<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: 路径规划 - SUNX的记录</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SUNX的记录"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SUNX的记录"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天的天气不错"><meta property="og:type" content="blog"><meta property="og:title" content="SUNX的记录"><meta property="og:url" content="https://duohangsun.gitee.io/"><meta property="og:site_name" content="SUNX的记录"><meta property="og:description" content="今天的天气不错"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duohangsun.gitee.io/img/og_image.png"><meta property="article:author" content="SUNX"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://duohangsun.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://duohangsun.gitee.io"},"headline":"SUNX的记录","image":["https://duohangsun.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"SUNX"},"publisher":{"@type":"Organization","name":"SUNX的记录","logo":{"@type":"ImageObject","url":"https://duohangsun.gitee.io/img/logo.svg"}},"description":"今天的天气不错"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?69225dadb01d44aae3f8c4f29649a59d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">路径规划</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-03T10:45:41.000Z" title="2024/3/3 18:45:41">2024-03-03</time>发表</span><span class="level-item"><time dateTime="2024-03-03T12:21:14.207Z" title="2024/3/3 20:21:14">2024-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约7695个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><div class="content"><h1><span id="hierarchical-a-searching-abstraction-hierarchies-efficiently">Hierarchical A*： Searching Abstraction Hierarchies Efficiently</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403031849761.png" alt="image-20240303184926771"></p>
<h1><span id="abstract">Abstract</span></h1><p>在搜索、问题求解和规划中，抽象的作用是用另一个更容易搜索的状态空间（”抽象 “空间）来替代一个状态空间。抽象空间的搜索结果用于指导原始空间的搜索。例如，抽象解的长度可以作为 A* 在原始空间中搜索的启发式。然而，要有效地实现这一点有两个障碍。第一个障碍是一个定理（Valtorta，1984 年），该定理指出，对于一大类抽象，即 “嵌入抽象”，在用这种方法计算 A* 的启发式时，盲搜索扩展的每个状态也必须被 A* 扩展。第二个障碍产生的原因是，A* 在计算启发式时，需要反复对抽象空间进行全面搜索。本文介绍了一种新的由抽象引起的搜索技术–”分层 A* “，它能同时解决这两个难题：首先，它从不同的抽象类别–”同态抽象”–中汲取灵感；其次，它使用新颖的缓存技术，避免在抽象空间的连续搜索中重复扩展相同的状态。在所研究的所有搜索空间中，分层 A* 均优于盲搜索。</p>
<h1><span id="introduction">Introduction</span></h1><p>有几位研究者将抽象作为自动创建可接受的启发式A*搜索的一种手段进行了研究（Gaschnig, 1979; Pearl, 1984; Prieditis, 1993; Guida &amp; Somalvico, 1979）。总体思路是将状态空间 SS 中从状态 S 到目标 G 的距离估计值 h(S)，等同于另一个状态空间 SS’ 中从 SS’ 中对应于 S 的状态到对应于 6 的状态的精确距离，SS’是 SS 的 “抽象”。只要 SS 中每对状态之间的距离都大于或等于 SS’ 中相应状态之间的距离，以这种方式定义的 h(S) 就是一种可接受的启发式。普里迪蒂斯（Prieditis,1993）在 “抽象变换 “的定义中正式提出了这一观点，具体如下。</p>
<p>状态空间 “是一对 &lt;States,d&gt;，其中 States 是一组状态，d(S,,S,) 是两个状态之间的距离（最短路径的长度）（如果从 S, 到 S, 之间没有路径，则 d(S,,S,) &#x3D; 00）；”问题 “是一对 &lt;Start,Goal&gt;，其中 Start 是一个状态，Goal 是一个（组）状态’。给定状态空间 SS &#x3D; &lt;States&amp; 和 SS’&#x3D; &lt;States’,d’&gt;, 一个映射 @： 如果 SS 中的每个距离都小于或等于 SS’ 中相应的（根据 @）距离，那么（SS 的）States + States’ 映射就是抽象变换。形式上：d’（#（S,）,#（S,）) I d(S,,S,) for all S,, S, E States. 给定 SS 的问题 &lt;Start,Goal&gt;，SS’的相应问题为 &lt;@tart),Goal’&gt;，其中 Goal’ 2 {H(g) I g E Goal}。通常我们会提及 @(SS)，而不指定 SS’。在这种情况下，SS’ 被隐含为 cimage#,d#&gt;，其中 image@&#x3D; {K(s) I s E States} 和 d#(S;,S;) &#x3D; min { d(s, ,s.J I #(st) &#x3D; S; and @(sZ)&#x3D; S;} 。</p>
<p>最早也是最常研究的抽象变换类型是 “嵌入”。非正式地讲，如果 @ 为 SS “添加了边”，那么它就是一种嵌入变换。例如，在状态空间定义中添加宏运算符或删除先决条件的技术就是嵌入。从形式上看，如果 SS’ 是 SS 的超图，即 States’ 2 States，且 g(s)&#x3D; S 适用于所有 S E States，那么 @ 就是一种嵌入。因为 SS 中的所有状态和边（代价相同）都存在于 SS’ 中，所以 SS’ 中的距离不可能比 SS 中的相应距离长。因此，任何嵌入都是一种抽象变换。嵌入是（Gaschnig，1979；Pearl，1984；以及 Guida &amp; Somalvico，1979）中研究的一种转换类型。</p>
<p>抽象转换的另一种主要类型是 “同态”（”自然转换 “的同态）（Kibler，1982）。非正式地讲，同态 4 是将 SS 中的几个状态组合在一起，形成一个抽象状态。例如，从状态空间描述中完全删除谓词的技术（Knoblock, 1994）就是同构。从形式上看，如果 @ 是 SS 状态的多对一映射，那么如上定义的 $(SS) 就是 SS 的同构。</p>
<p>创建启发式的目的是加快搜索速度。如果没有启发式，A* 就会盲目地在原始空间中搜索。有了启发式，A* 的搜索就会更有针对性，在原始空间的搜索努力就会减少一些（”节省”）。使用通过抽象创建的启发式的主要风险在于，在搜索过程中计算 h(-) 的总成本可能会超过节省的成本。如果出现这种情况，启发式的使用就是有害的：计算启发式的成本超过了使用启发式的收益。</p>
<p>Valtorta, l984）中对通过嵌入变换自动生成的启发式方法进行了成本效益分析。 (Valtorta，l984）。结果证明，如果 SS 嵌入 SS’，而 h(-) 是通过在 SS’ 中盲目搜索计算出来的，那么使用 h(-) 的 A* 将扩展直接在 SS 中盲目搜索所扩展的每一个状态。换句话说，这种定义启发式的方法不可能加快搜索速度–使用启发式扩展的节点（状态）总数（包括在抽象空间中扩展的节点）必须等于或超过在原始空间中盲目搜索时扩展的节点（状态）总数。根据这一定理，我们将 “瓦尔托尔塔障碍 “定义为在空间中盲目搜索时扩展的节点数。瓦尔托尔塔定理指出，使用任何嵌入变换都无法 “打破 “这一障碍。</p>
<p>瓦尔托塔定理并不排除使用其他类型的变换来打破瓦尔托塔障碍的可能性。不过，迄今为止，瓦尔托塔障碍只被突破过两次。Absolver II（普里迪蒂斯，1993年）通过使用同态变换，为与 “傻瓜磁盘 “和 “瞬间精神错乱 “谜题相关的状态空间（和特定目标）创建了具有成本效益的启发式方法。在 Absolver II 应用的其他 11 个问题中，抽象本身无法创造出具有成本效益的启发式（其中 5 个问题的成本效益启发式是在抽象与其他类型的状态空间变换一起使用时创造出来的）。</p>
<p>在本文中，我们展示了利用通用同态抽象技术可以在多种搜索空间上打破 Valtorta 障碍。首先，我们提出了适用于所有类型抽象转换的 Valtorta 定理的广义版本。该定理提供了使用任何抽象变换必须扩展的节点数量的下限。对于同态变换，该界限低于在原始空间中盲目搜索所扩展的节点数。这表明，同态抽象至少在原则上有可能打破瓦尔托尔塔的障碍。不过，我们的初步实验结果表明，仅仅抽象是同态的这一事实，并不能保证能创造出具有成本效益的启发式方法。我们发现，使用同态抽象层次结构进行搜索所扩展的状态比盲目搜索多得多，在一个测试平台的搜索空间中，盲目搜索扩展的状态是盲目搜索的 17 倍。我们找出了造成这些负面结果的原因，并提出了两种缓解问题的互补方法。第一种是算法方法。对 A* 算法进行了定制，以便在抽象层级中进行搜索。定制版本称为分层 A<em>，扩展的状态比原始 A</em> 少大约 6 倍，并在大约一半的测试平台搜索空间中突破了 Valtorta 的障碍。第二种方法是创建精细度较低的抽象。这也打破了 Valtorta 在部分测试平台搜索空间的障碍。当两种方法结合使用时，所有测试平台搜索空间的瓦尔托塔障碍都会被打破。</p>
<h2><span id="valtortas-theorem-generalized">Valtorta’s Theorem Generalized</span></h2><p>Valtorta, l984）中的主要定理是针对嵌入的，但很容易推广到任何抽象变换。广义的定理是（正式的陈述和证明见 (Holte et al., 1995)）：</p>
<p>让 $\phi$ 是状态空间 SS 到 SS’ 的任意抽象映射，$h_{\phi}(S)$ 是 SS’ 中从 $\phi(s)$到 $\phi(goal)$ 的最短路径长度（通过在 SS’ 中盲查计算）。如果 S 是直接在状态空间 SS 中通过盲搜索求解给定问题时必然扩展的任何状态，那么在 SS 中使用带有 $h_{\phi}(-)$ 的 A* 搜索求解问题时，要么 S 本身被扩展，要么 $\phi(s)$ 被扩展。</p>
<p>当 $\phi$ 是一个嵌入时，$\phi(S)&#x3D;S$，我们就得到了瓦尔托尔塔定理：盲搜索必然扩展的每个状态也必然被使用 h 的 A* 扩展，但如果 $\phi$ 是一个同态，加速是可能的，因为抽象空间中一个状态的扩展等同于原始空间中许多状态的扩展。</p>
<p>一个简单的例子说明，基于同态抽象的启发式方法确实可以大大减少扩展节点的数量。假设状态空间 SS 是一个 n x n 网格，要解决的问题是从左下角 (1 ,l) 到右下角 (n,l)。要通过盲搜索解决这个问题，必须扩展距离 (n-l) 或更小的所有状态，因此要扩展 $O(n^2)$ 个状态。假设 $\phi$ 是忽略第二个坐标的映射。那么，$\phi(SS)$ 是一个线性空间，包含 (l)、(2)、……(n)个状态。 计算 $h_{\phi}(Start)$ 需要在 $\phi(SS)$ 中找到一条从（1）到（n）的路径。在这一搜索过程中会扩展 O(n) 个状态，但注意这一搜索会生成所有 S 的 $h_{\phi}(s)$ 值，因此无需在抽象空间中做进一步搜索。此外，这个特定抽象定义的 $h_{\phi}(-)$ 是一个完美的启发式，因此在 SS 中的搜索只会扩展解路径上的那些状态。因此，A* 使用 $h_{\phi}(-)$ 扩展的节点总数为 O(n)，远远少于盲搜索扩展的 $O(n^2) $个节点。</p>
<h2><span id="hierarchical-search-using-a">Hierarchical Search using A*</span></h2><p>在当前的系统中，抽象状态是通过（Holte et al.，1996）中描述的 “最大度 “STAR 抽象技术创建的。这种技术非常简单：将度数最大的状态与一定距离（”抽象半径”）内的相邻状态组合在一起，形成一个抽象状态。如此反复，直到所有状态都被分配到某个抽象状态。这样就建立了一个抽象层级，这个过程不断重复，直到建立了一个只包含一个状态的层级。这就形成了一个抽象层级，其顶层就是三维搜索空间。层次结构的底层或 “基础 “层就是原始的搜索空间。这种创建抽象的方法最初是为被称为 “细化 “的搜索技术而设计的，并被证明是非常成功的（Holte 等，1996；Holte 等，1994）。在目前的工作开始时，还不完全清楚它是否能创建适合 A* 搜索的抽象层次。它当然不适合抽象出不同算子具有不同代价的搜索空间，但在本文的实验中并没有出现这种考虑。</p>
<p>A* 的实现是标准的，只是在估算从非目标状态 S 到目标的距离时，除了使用其他可能可用的启发式估算之外，还使用了适用于 S 的算子的最小成本。当有多个启发式信息来源时，会通过取最大值的方式将它们结合起来。如果单个启发式信息是可接受的，那么这种组合多个启发式信息的方法就保证是可接受的，但即使单个启发式信息是可接受的，这种方法也可能不是单调的（相反的例子见下一节）。然而，我们不难发现，如果每个算子都有相同代价的倒数，那么将最小算子代价与任何单调启发式相结合就会产生单调启发式，我们实验中的搜索空间就是这种情况。</p>
<p>当没有其他启发式估计时，”最廉价算子 “信息最为有用（盲探： 对于所有 S，A* 的 h(S)&#x3D;0）。在这种情况下，使用 “最廉价算子 “可以大大减少扩展节点的数量。当有其他启发式估计时，”最廉价算子 “信息只对其他方法估计的非常接近目标的状态有用。</p>
<p>使用 A* 进行分层搜索非常简单。像往常一样，在 A* 搜索的每一步，一个状态都会从 OPEN 列表中移除，而它的每个后继状态都会被添加到 OPEN 列表中（如果它之前没有被打开过）。要将一个状态 S 加入 OPEN 列表，必须知道 h(S)。h(S) 的计算方法是在下一个更高的抽象层次进行搜索，使用与 S 对应的抽象状态 KS) 作为抽象起始状态，$\phi(goal) $作为抽象目标。找到抽象解路径后，就知道了从 $g(s)$ 到 $\phi(goal)$的确切抽象距离。如前文所述，这将与其他估计值（如适用于 S 的最便宜算子的成本）相结合，得出最终的 $h(S)$ 值。</p>
<p>当找到从 $\phi(s) $到 $\phi(goal)$ 的抽象路径时，这条路径上所有抽象状态的精确抽象距离到目标信息都是已知的。一般来说，每个抽象状态都对应着 “下一层”（包含 S 的状态空间）中的许多状态。因此，一次抽象搜索会对许多状态产生启发式估计。所有这些信息都被缓存起来。如果需要这些状态中任何一个状态的 h 值，只需简单查找即可，无需在抽象层进行任何搜索。尽管有这种缓存技术，但一般来说，要解决一个基础层问题，分层搜索技术需要解决许多抽象层问题。而这些抽象问题中的每一个都需要解决下一个抽象层次的许多问题，等等。解决单个基础层问题所扩展的节点数是在所有抽象层次（包括基础层本身）与该基础层问题相关的所有搜索过程中扩展的状态总数。</p>
<p>刚刚描述的分层搜索技术将被称为原始分层 A* (navie hierarchical A* )，以与下一节介绍的版本形成对比。我们在 8 个状态空间上对各种分层 A* 技术进行了经验评估（见 Holte 等人，1995 年）。所有算子都是可逆算子，应用所有算子的代价都是相同的 (1)。每个状态空间的测试问题都是随机选择 100 对状态生成的。每对状态 &lt;Sl,S2&gt; 都定义了两个要解决的问题： $&lt;start&#x3D;S1,goal&#x3D;S2&gt;$ 和 $&lt;start&#x3D;S2,goal&#x3D;Sl&gt;$。为了便于详细比较，每次实验都使用了相同的 200 个问题。显示的 “节点扩展 “结果是这 200 个问题的平均值。</p>
<p>在每个测试平台搜索空间中，天真分层 A* 扩展的状态都比盲法搜索多得多（见表 1）。要理解为什么会出现这种情况，关键在于天真分层 A* 扩展的状态比整个抽象分层中的状态多得多（表 1，第二列）。这意味着在解决单个基础层问题的过程中，某些状态被扩展了很多次。由于采用单调启发式的 A* 不会在一次搜索中重复扩展相同的状态，因此重复扩展一定是由于在与同一基础层搜索相关的多次不同搜索中扩展了相同的状态。下一节将介绍大大减少这种重复的方法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403032015234.png" alt="image-20240303201523037"></p>
<p>分层 A* 在基础层中扩展的节点数是 A* 在给定抽象层级下所能达到的提速的基本限制。这个数字表示启发式的质量，即启发式能在多大程度上减少原始空间的搜索工作量。例如，在 Permute-6 搜索空间中，分层 A* 在基础层中扩展了 77 个状态，比盲目搜索扩展的数量减少了 75%。这只是微不足道的节省。但这是表 1 中最好的启发式方法。另一个极端是为 “传教士与食人族 “搜索空间创建的启发式（MC 60-40-7），它只节省了 25%。启发式搜索的质量是抽象技术的属性，只能通过使用不同的抽象技术来提高。除了改变抽象的粒度外，这一主题超出了本文的范围。</p>
<p>目前的抽象技术所产生的启发式搜索只能适度减少在基础层上扩展的节点数，这使得打破瓦尔塔障碍变得尤为困难。为了突破这一障碍，所有抽象搜索所扩展的节点总数必须少于启发式搜索所节省的数量。例如，考虑 5 字谜。通过抽象产生的启发式结果是 A* 在底层扩展了 224 个状态，比盲目搜索节省了 124 个状态。为了打破瓦尔托塔的障碍，为所有这 224 个状态（以及被打开但从未关闭的额外状态）计算启发式的成本（以在所有抽象层次扩展的节点计）不得超过 124。这并非不可能：如上例所示，在抽象层次扩展几个状态，就能为基础层的许多状态提供启发式值。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403032016184.png" alt="image-20240303201609899"></p>
<h2><span id="customizing-a-for-hierarchical-search">Customizing A* for Hierarchical Search</span></h2><p>在分层搜索中，一个基础层级的搜索可能会产生大量抽象层级的搜索。如前面的结果所示，这些搜索通常会扩展许多相同的状态。减少这种重复的关键在于观察到与同一基础层搜索相关的所有搜索都具有相同的目标。天真分层 A* 的简单缓存策略在很小程度上利用了这一观察结果，因为它在特定抽象层次的缓存直到该层次的目标发生变化时才会被清除。表 1 中的结果表明，如果要使分层 A* 有效，还需要更多利用这一观察结果的方法。</p>
<p>当抽象层次的搜索结束时，已知求解路径上每个抽象状态 S 到目标的确切距离 h* (S)。这一信息可以被缓存起来，并在后续相同目标的搜索中代替 h(S)。这样可以提高启发式在这一抽象层次的质量，从而减少后续搜索所扩展的节点数量。这种技术被称为 h* 缓存。从表 2（第 Vl 列）中可以看出，这大约将扩展节点的数量减少了一半。</p>
<p>由 h* 缓存产生的启发式并不是单调的。例如，假设所有算子的代价都是 1，并且所有非目标状态的 h(S)&#x3D;1 。在解决了一个问题并缓存了 h*(-) 值后，求解路径上的状态可能会有相当大的 h(-) 值，而它们在求解路径之外的相邻状态仍会有 h(-)&#x3D;1 值。因此，相邻 h(-) 值之差将大于 1，即两个状态之间的 “距离”。因此，新的 h(-) 函数不符合单调性的定义。</p>
<p>由于 h(-) 函数不是单调的，因此有可能过早地关闭一个状态，即在找到从起始状态到该状态的最短路径之前就关闭了。一般来说，使用非单调启发式算法时，为了保证找到最短路径，有必要重新打开此类状态。然而，对于 h* 缓存所产生的非单调启发式来说，这并不是必须的，事实上，我们的 A* 实现并没有重新打开封闭状态的规定。为了说明这一点，让 S 作为起始状态，P 作为过早关闭的状态。要使 P 提前关闭，必须是 h* (P)是未知的，而且从 S 到 P 的每条最短路径都要经过某个状态 X，而 h* (-)是已知的。如果在任何从 S 到目标的最短路径上都没有这样的 X，那么 P 也不存在，所以 P 的过早关闭就无关紧要了。另一方面，假设从 S 到目标的最短路径经过这样一个 X。h* (X) 已知这一事实意味着在之前的搜索中 X 在解路径上，因此之前发现了一条从 X 到目标的最短路径。这条路径上的每个状态 h*(-) 都是已知的。因此，在当前搜索中，这些状态都没有被扩展，所以从 S 到目标的这段最短路径将被找到，而无需重新打开任何封闭状态。</p>
<p>如前所述，对于已知 h*(X)的每个状态 X，从 X 到目标的最短路径也是已知的。如果除了 h* (X)之外还缓存了这条路径，就没有必要再扩展 X 了。这是因为知道了一条长度为 g(X)到 X 的路径，就等于知道了一条长度为 g(X)+h* (X) 到目标的路径。因此，我们可以将目标添加到 OPEN 列表中，而不是将 X 添加到 OPEN 列表中，然后像往常一样，当目标位于 OPEN 列表顶端时终止搜索。这种技术称为最优路径缓存。表 2 中第 V2 列显示了在天真分层 A* 中添加最优路径缓存时扩展的节点数。最优路径缓存比 h* 缓存节省了大约一倍的时间，并打破了 Valtorta 在 Permute-6 搜索空间中的障碍。</p>
<p>最后一项技术与搜索过程中打开（或关闭）但不在求解路径上的状态有关。对于每个这样的状态 S，我们都知道它与起点的距离 g(S)。如果求解路径的长度为 P，那么根据其最优性，必须是 P I g(S) + h* (S)。将其重排为 P-g(S) I h* (S)，我们可以看到 P-g(S)是一个可接受的启发式，我们称之为 P-g 启发式。当所有算子都有反函数时，可以证明（Holte 等人，1995 年）P-g 启发式与任何单调启发式结合都会产生一个单调启发式。P-g 缓存包含 h* 缓存，因为当 S 在求解路径上时，P-g(S) &#x3D; h*(S)。最后，如果搜索终止时 S 是开放的，则无需计算 P-g(S)，因为在这种情况下 P 5 g(S)+h(S) 因此 P-g(S) I h(S)。</p>
<p>情况 P 5 g(S)+h(S)，因此 P-g(S) I h(S)。系统 V3 包括最优路径缓存和 P-g 缓存。在用于测试的 8 个搜索空间中，它有 5 个突破了 Valtorta 的障碍（表 2 中的粗体数字）。这表明，通过同态抽象，可以在实践中实现</p>
<h2><span id="varying-the-granularity-of-abstraction">Varying the Granularity of Abstraction</span></h2><p>我们的抽象技术允许我们通过设置抽象半径来控制所创建抽象的粒度。前面的结果是在抽象半径为 2 的情况下得出的，这意味着一个状态与其近邻状态分组。增加抽象半径对 “节点扩展 “的净影响并不明显，因为有两种相互对立的影响。一方面，半径越大，意味着抽象空间中包含的状态越少；另一方面，单次抽象搜索会产生更多状态的启发值。这些因素将减少分层 A* 扩展的抽象节点数量。另一方面，半径越大，启发式的区分度就越低：这往往会增加扩展节点的数量（如果启发式完全没有区分度，A* 就会退化为盲目搜索）。(Prieditis &amp; Davis, 1995）对 “抽象性”（即粒度）与启发式搜索结果的准确性之间的关系进行了初步的定量分析。</p>
<p>实验中，抽象半径设置为 2 到 5，某些搜索空间的抽象半径设置为更大。分层 A* 扩展的节点数随着半径的增大而减少，直到达到最小值；半径超过该值后，扩展的节点数会增加。表 3 显示了 V3 为每个搜索空间找到的最佳半径结果（天真分层 A* 的最佳半径有时更大）。现在，在每个搜索空间中，V3 在一半以上的问题上都突破了 Valtorta 的障碍（在其中两个搜索空间中，V3 在 95% 以上的问题上都突破了 Valtorta 的障碍）。</p>
<p>虽然最佳半径相当小，但在每种情况下，它们都占搜索空间直径的很大一部分。由此创建的抽象层次结构只有一个非三维抽象层，而且只包含少量状态。令人惊讶的是，如此粗略的启发式竟然能够减少扩展节点的数量。</p>
<p>只有一个小的非难抽象层次的后果是，上述算法改进的效果大打折扣：在几个空间中，天真的分层 A* 扩展的状态只比 V3 稍多一些。然而，算法改进之所以重要，是因为大多数创建抽象的技术都无法轻松控制所生成抽象的粒度。与天真层次 A* 不同的是，V3 具有很强的鲁棒性：它在任何粒度的抽象上都有很好的表现，因此是粒度无法控制时的首选搜索算法。</p>
<p>“节点扩展 “是一种方便的理论测量方法，但它并不能完全反映搜索系统所做的所有 “工作”，尤其是分层系统，因为它必须在抽象层级上反复初始化搜索，并将信息从一个层级传递到下一个层级。搜索系统的实际速度取决于所有这些操作。表 3 列出了盲搜索和 V3 解决所有 200 个问题所需的 CPU 时间。当然，在解释 CPU 时间结果时必须非常谨慎，因为它们可能会受到底层实现细节的严重影响。在目前的实现中，许多底层细节都相当笨拙，但 V3 所减少的节点扩展量似乎几乎完全抵消了分层搜索所带来的额外开销。</p>
<p>为了最大限度地减少分层搜索的开销，并在更大的状态空间和不同的同态抽象方法上评估分层 A* ，我们最近重新实施了分层搜索和缓存技术。该系统中的抽象是由用户提供的，而不是自动创建的，但到目前为止，我们还没有尝试对抽象进行优化，因为我们的目标是在 “典型 “抽象上评估 Hierarchical A* 。新实施的初步结果证实了表 3 所示的节点扩展结果的一般模式：在某些空间中，扩展的节点数量显著减少，而在其他空间（如河内塔）中，V3 扩展的节点数量则略有减少。不过，CPU 时间的结果却有很大改进。例如，在 &amp;puzzle 中，V3 将 CPU 时间减少了 10 倍（将扩展的节点数减少了 6.5 倍）。</p>
<h2><span id="conclusion">Conclusion</span></h2><p>在本文中，我们证明了使用同态抽象自动创建的启发式 A* 搜索可以 “打破瓦尔托尔塔的障碍”，即在扩展节点数量方面优于盲搜索。这一点在实验中使用的所有状态空间中都得以实现。为了实现这一目标，有必要在 A* 中添加两种新的缓存技术，即最优路径缓存和 P-g 缓存，在某些情况下，还需要选择适当粒度的抽象。所扩展的节点数量减少不多，但这是由于抽象技术的限制，而不是由于算法开销过大。开发一种非常适合分层 A* 搜索的抽象技术是今后研究的一个重要课题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T06:17:52.000Z" title="2024/3/1 14:17:52">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2024-03-03T13:17:35.165Z" title="2024/3/3 21:17:35">2024-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约13349个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><div class="content"><h1><span id="the-grid-based-path-planning-competition-2014-entries-and-results">The Grid-Based Path Planning Competition: 2014 Entries and Results</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011423266.png" alt="image-20240301141900391"></p>
<h2><span id="abstract">Abstract</span></h2><p>基于网格的路径规划竞赛刚刚完成了第三次迭代。在此期间，竞赛中使用的参赛作品有了显著改进，改变了人们对网格寻路技术现状的看法。此外，大赛的参赛作品已经公开，提高了研究人员比较其工作的能力。本文总结了 2014 年竞赛的参赛作品，介绍了 2014 年的竞赛结果，并讨论了所学到的知识和有待改进的地方。</p>
<h2><span id="introduction-and-background">Introduction and Background</span></h2><p>基于网格的路径规划是一个被广泛研究的课题，在许多应用领域都有大量已发布的方法。多年来，该领域的工作缺乏广泛分布的标准基准问题来比较工作，也缺乏标准实现来比较工作质量。本文的第一作者致力于解决这两种情况：（1）引入各种标准基准问题，用于测试在基于网格的地图上运行的程序；（2）发起基于网格的路径规划竞赛（GPPC）。</p>
<p>引用次数表明，寻路基准已被广泛采用。(关于基准集中每张地图的来源，请参见（Sturtevant 2012）。GPPC 竞赛已举办过三次，分别在 2012 年、2013 年和 2014 年。在此期间，参赛作品的性能有了显著提高，对基于网格的地图结构的理解也有了改进。</p>
<p>本文详细介绍了竞赛采用的方法以及 2014 年竞赛的结果。随后，2014 年参赛作品的作者分别介绍了他们的参赛作品。论文最后讨论了竞赛和基于网格的寻路研究的未来方向。</p>
<h2><span id="competition-setup">Competition Setup</span></h2><p>竞赛的目的是对各种问题实例和各种地图大小进行实验。</p>
<p>GPPC 在一组 132 幅地图上运行，这些地图来自多个地图来源。表 1 列出了每组地图的来源以及每组地图的数量。竞赛中的地图样本如图 1 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011424610.png" alt="image-20240301142434375"></p>
<p>在 2012 年比赛之前，《龙腾世纪 2》中的地图尚未公开。这些地图已在 GPPC 竞赛中使用，但尚未作为通用在线寻路地图库的一部分发布，尽管今后有计划这样做。《星际争霸》和《龙腾世纪：起源》中的地图是寻路地图库的一部分；并使用了为这些地图创建的标准问题，尽管这些只是全部可用地图中的一小部分。随机地图、房间地图和迷宫地图都是人造的。这些地图的大小从 100 × 100 到 1550 × 1550 不等。随机地图中正好有 33% 的单元格被屏蔽，然后除了地图中最大的连接部分外，其他所有单元格都被移除，每张地图中大约又有 5% 的单元格被移除。房间地图包含的房间面积为地图面积的 10%。最初，所有房间都是封闭的，但房间之间的门会随机打开。当墙壁被打开时，墙壁中 1&#x2F;8 的单元格会被随机解封。图 1 显示了 (a) 100 × 100 地图中的 10 × 10 房间和 (b) 400 × 400 地图中的 40 × 40 房间。迷宫地图的走廊尺寸是地图一维尺寸的 1%。因此，100 × 100 地图上的走廊尺寸为 1，800 × 800 地图上的走廊尺寸为 8。图 1 显示了（c）100 × 100 迷宫的一部分和（d）400 × 400 迷宫的一部分。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011426604.png" alt="image-20240301142640786"></p>
<p>测试问题是随机选择的。问题按照最优解的长度除以 4 分成若干个桶。 因此，所有最优解长度为 [4, 8) 的问题都在同一个桶中。每个桶选出 10 个问题，每个地图的桶数由特定地图的路径长度决定。迷宫地图上的问题较多，因为迷宫中的路径非常长。《龙腾世纪 2》中的一些地图相对较小，因此即使地图数量较多，每张地图的问题数量也比其他地图少。</p>
<p>每个地图源的地图尺寸分布见图 2。从最大到最小，地图大小在 4 个数量级以上。较小的地图来自《龙腾世纪》游戏，而较大的地图则来自《星际争霸》和人造地图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011426954.png" alt="image-20240301142615062"></p>
<h2><span id="experimental-setup">Experimental Setup</span></h2><p>为确保比赛结果不会受到 CPU 时序变化的过度影响，我们在每个参赛作品上运行问题集 5 次。参赛项目必须实现一个简单的接口，用于预计算地图数据、加载预计算数据以及在地图上进行路径计算。所有条目在运行前都要进行预计算。重复运行并不是连续的，因此前一次运行的数据不会在随后的运行中进入缓存。条目可以选择一步返回整个路径，也可以逐步返回，从而创建一个可以交错规划和移动的实时智能体。</p>
<p>在历年的比赛中，实验都是在同一台机器上进行的，这台服务器配备了双处理器四核至强 E5620，主频为 2.4Ghz，内存为 12GB。求解过程使用顺序 API，但预处理可以并行进行。</p>
<p>根据不同的领域，有大量有趣的指标可以确定最佳入口。我们并不设定特定的效用函数来确定最佳入口，而是寻找非优势入口的帕累托最优前沿。这样，实践者就可以自己分析数据，选择最适合自己应用的方法。</p>
<p>衡量标准包括：</p>
<ul>
<li><p><strong>总时间（秒）</strong>： 这是找到所有问题的解决方案所需的总时间。</p>
</li>
<li><p><strong>平均时间（毫秒）</strong>： 这是查找单条路径的平均时间（毫秒）。</p>
</li>
<li><p><strong>20 步（毫秒）</strong>： 这是找到路径前 20 步的平均时间（毫秒）。这可以衡量可跟踪路径的速度，在游戏或机器人等实时应用中非常重要。</p>
</li>
<li><p><strong>最大线段（毫秒）</strong>： 这是生成路径中任何单独网段所需的最长时间的平均值。这衡量的是最差情况下的实时性能。</p>
</li>
<li><p><strong>平均长度</strong>： 这是返回路径的平均长度。如果一个条目在长路径上是最优的，而在短路径上是次优的，那么它将接近平均长度，因为大部分长度来自最长的路径。</p>
</li>
<li><p><strong>次优化</strong>： 这是每条路径的平均次优度。如果一个条目在长路径上是最优的，而在短路径上是高度次优的，那么由于大多数路径都是短路径，因此这个指标会很大。</p>
</li>
<li><p><strong>解决数量</strong>： 这是 347，868 ∗ 5 &#x3D; 1，739，340 个问题中已解决的问题总数。</p>
</li>
<li><p><strong>无效</strong>： 这是返回的无效解决方案的数量，这些解决方案的路径并不完整（例如，返回路径中的相邻位置在地图上并不相邻）。</p>
</li>
<li><p><strong>未解</strong>： 这是未解决、无解决方案的问题数量。</p>
</li>
<li><p><strong>内存（之前）</strong>： 这是加载预计算数据后的内存使用量（以 MB 为单位）。</p>
</li>
<li><p><strong>内存（后）</strong>： 这是运行全部问题集后的内存使用量（以 MB 为单位）。这包括用于存储结果的内存，因此所有条目的内存使用量都被人为夸大了。</p>
</li>
<li><p><strong>存储空间</strong>： 这是用于所有预计算存储的磁盘空间。</p>
</li>
<li><p><strong>预计算时间</strong>： 这是全部预计算所需的时间（分钟）。执行并行预计算的条目会在下一节的结果表中用 † 标记。</p>
</li>
</ul>
<p>最初的 GPPC 竞赛限制了 RAM 和预计算时间，但后来取消了这些限制，使参赛作品更加多样化，但代价是在竞赛期间需要更多的计算。</p>
<p>2014 年共有 6 个团队的 14 个程序参赛1 。下文将对这些参赛项目进行详细介绍，但参赛项目有几个高层次的趋势。首先，我们看到新参赛者大量重复使用代码。这降低了参赛门槛，使参赛者可以从以前最好的作品开始。以往参赛作品的可用性也有助于在比赛之外进行实验比较。接下来，我们可以将参赛作品分为几种高级方法。这些方法包括</p>
<ul>
<li><em><em>Faster A</em> implementations</em><em><em>。过去，这包括伪优先队列等工作。今年该类别有两个参赛作品，分别是 Relaxed A</em> (RA</em> ) 和桶式开放列表版 A* （ bucketed open list version of A*） 。</li>
<li><strong>Grid Exploitation.</strong> 有几个项目专门致力于利用网格中存在的结构。其中包括基于跳点搜索（Harabor 和 Grastien，2011 年）和子目标图（Uras 和 Koenig，2014 年）的条目。这些技术密切相关，但全面描述它们之间的关系超出了本文的范围。</li>
<li><strong>Compressed All Pairs Shortest Paths.</strong>  压缩路径数据库是压缩全对最短路径数据的第一种方法（Botea，2012 年）。今年有两个基于单行压缩（SRC）的新条目。</li>
<li><strong>Other approaches</strong>。子目标方法包含了收缩层次法（Geisberger 等人，2008 年）的一些理念；今年我们也有一个收缩层次法参赛。在往年的比赛中，也出现了一些次优方法。</li>
</ul>
<h2><span id="2014-competition-results">2014 Competition Results</span></h2><p>竞赛的全部结果见表 2。用粗体字标出的参赛作品是那些不被其他参赛作品所支配，形成帕累托最优边界的作品。也就是说，它们至少在一项指标上的表现优于所有其他参赛作品。这些条目的粗体指标是它们不占优势的指标。看完总体趋势后，我们再来研究被支配的条目。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011441487.png" alt="image-20240301144139572"></p>
<p>我们注意到以下数据趋势：</p>
<ul>
<li><p>很难设计出更好的开放式列表结构并保证其正确性。RA* 成功地做到了这一点。2012 年的伪优先队列（PPQ）方法无法解决的问题数量很少（23 个）。除此之外，它的速度明显快于 RA* ，次优性也较低。A* Bucket 作品也有类似的问题，但该作品是在较晚的时候才从组织者那里征集到的，因此参赛者在提交作品之前测试作品的时间相对较少。我们希望明年的参赛作品能有明显改善。</p>
</li>
<li><p>自 2012 年以来，子目标方法不断改进，使用的 RAM 相对较少。</p>
</li>
<li><p>在整个比赛期间，JPS 参赛作品的性能提高了 10 倍以上，如果考虑到算法的非预处理版本，提高的幅度甚至更大。</p>
</li>
<li><p>在道路网络中取得成功的收缩层次法（CH），现在在游戏地图上也有非常出色的表现。</p>
</li>
<li><p>预计算方向启发法（PDH）（Parra、de Reyna 和 Linares L ́ opez，2012 年）是之前少数几个利用增量计算的参赛项目之一。今年的单行压缩（SRC）参赛作品速度更快，性能更优，但占用内存更大。</p>
</li>
<li><p>查找完整路径最快的条目仍然是 Ken Anderson 在 2013 年发布的 “树缓存 “条目；新条目主要侧重于最优路径。</p>
</li>
<li><p>虽然严格来说 BLJPS 和 NSubgoal 条目使用的 RAM 最少，但许多条目使用的 RAM 量相差无几，因此在实际使用中这种差异并不一定有意义。</p>
</li>
</ul>
<p>出于篇幅考虑，我们在此不对这些数据作进一步细分（如按地图类型或路径长度）。有兴趣的读者可以查阅完整数据。不过，我们在此从过去的条目开始，说明每个条目被支配或不被支配的原因。</p>
<p><strong>过往作品</strong></p>
<ul>
<li><p>2012 年的 JPS 条目是非主导条目，因为没有其他最优条目不使用预计算。</p>
</li>
<li><p>2012 年的 “JPS+”项目被 2014 年的 “JPS+”项目弱支配。(这两个条目都是最优的，因此它们永远不会被完全支配）。</p>
</li>
<li><p>PPQ 条目（Guivant、Seton 和 Whitty，2012 年）将是非主导条目，但它并没有解决 23 个问题。</p>
</li>
<li><p>块 A* （Block）（Yap 等人，2011 年）除存储外，都被 BLJPS 所支配。但是，从 RAM 使用情况可以看出，Block A* 在运行时会计算一个 60MB 的表，而不会将其保存，因此我们仍然认为这个条目是被支配的。</p>
</li>
<li><p>2012 年和 2013 年的子目标条目被 2014 年的 NLevelSubgoal 条目所占据。</p>
</li>
<li><p>PDH 条目不占优势，因为只有一个条目的 20 步时间更快，但它使用的存储空间更大。</p>
</li>
<li><p>树 条目是非主导条目，因为没有任何条目能比该条目更快地找到完整路径。</p>
</li>
</ul>
<p><strong>2014 Entries</strong></p>
<ul>
<li>在所有不执行预计算的条目中，RA* 条目占用的内存最少，因此不占主导地位。</li>
<li>除了预计算存储空间外，BLJPS2 在 BLJPS2 中占主导地位。它是使用 20MB 或更少的存储空间速度最快的最佳条目。</li>
<li>JPS+ 以 BLJPS2 为主，尽管其差异在下文所述的 99% 置信度范围内。</li>
<li>BLJPS2 不占优势，因为它是使用 47MB 或更少的存储空间速度最快的最佳条目。</li>
<li>RA-Subgoal 不占优势，因为它是使用 264MB 或更少的存储空间的最快条目。</li>
<li>除预处理时间外，JPS+ Bucket 与 NSubgoal 相比优势微弱。但是，这些差异并不一定有意义。</li>
<li>除预处理时间外，BLJPS Sub 在 NSubgoal 中的优势较弱。但是，这些差异并不一定有意义。</li>
<li>NSubgoal 不占主导地位，因为它是使用 293MB 或更少的存储空间的最快最优算法。</li>
<li>CH 是非主导算法，因为它是使用 2.4GB 或更少的存储空间速度最快的最优算法。</li>
<li>由于 SRC-dfs-i 是最快的增量算法（20 步和最大分段时间），因此不占优势。</li>
<li>SRC-dfs 是非主导算法，因为它是返回完整最优路径的最快算法。</li>
<li>如果 A* Bucket 解决所有问题的次优性或速度都优于其他所有不进行预计算的参赛作品，那么它就不占优势。(由于是比赛组织者在最后一刻征集的作品，因此没有足够的时间进行测试）。</li>
<li>SRC-cut 条目由 SRC-dfs 条目主导。</li>
</ul>
<p>这些结果表明，帕累托前沿有许多算法。</p>
<p>表 3 显示了 2014 年每个条目的时间的 95% 置信区间。这些值基于每个参赛作品在每个问题上运行 5 次这一事实。因此，我们使用 5 个样本的 t 检验来计算置信区间。虽然样本数很少，但置信区间也很小，因为我们在五个样本中的每个样本中都运行了如此多的问题（347 868 个）。所有条目都能以 95% 的置信度区分。最接近的结果是 JPS+ 和 BLJPS2 条目；这些条目无法以 99% 的置信度区分。</p>
<h2><span id="2014-competition-entries">2014 Competition Entries</span></h2><p>在下面的文字中，每个条目的作者都详细介绍了自己的方法。各部分根据各部分内容的重叠程度排序。</p>
<h3><span id="subgoal-graph-子目标图">subgoal graph 子目标图</span></h3><p>该词条的作者是来自南加州大学的 Tansel Uras 和 Sven Koenig。他们提交了表 2 中的条目 NSubgoal。</p>
<p>本节介绍子目标图的两种变体。简单子目标图是通过在障碍物的凸角处放置子目标并将它们连接起来而构建的网格。它们类似于连续地形的可见度图，但边缘较少，可用于快速查找网格上的最短路径。简单子目标图的顶点可以划分为不同的级别，从而创建 N 级子目标图（今年的参赛作品），通过忽略与搜索无关的子目标，可以更快地找到网格上的最短路径，从而显著减少搜索图的大小。</p>
<p><strong>简单子目标图 (SSG）</strong>简单子目标图（Uras、Koenig 和 Hern ́ andez，2013 年）是通过在障碍物的凸角处放置子目标，并连接可直接到达的子目标对，从而从网格中构建出来的。定义 1 正式定义了这些概念。顶点位于无障碍单元的中心。边的长度等于它所连接的顶点之间的八分距离。图 3 显示了 SSG 的一个示例。请注意，子目标 C 和 E 是 h 可达的，但不是直接 h 可达的（由于子目标 D 的存在），因此没有连接它们的边。</p>
<p><strong>定义 1</strong>. 一个单元格 s 是一个子目标，当且仅当 s 是无阻塞的，s 有一个阻塞的对角线邻居 t，并且 s 和 t 的两个邻居单元格都是无阻塞的。&#x3D;&#x3D;当且仅当两个单元格 s 和 t 之间的最短网格路径长度等于它们之间的octile距离时，这两个单元格才是 h 可到达的。当且仅当两个单元格之间的最短路径都不经过子目标时，它们才是可直接到达的。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011454789.png" alt="image-20240301145422878"></p>
<p>使用 SSG 寻找最短网格路径时，需要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后用 A* 搜索此图，找到连接 s 和 g 的可直接到达子目标序列，即最短高层路径。例如，如果我们要使用图 3 中的 SSG 寻找 B1 和 H3 之间的最短网格路径，我们会将 B1 连接到子目标 A 和 B，将 H3 连接到子目标 F，然后搜索该图，找到最短高层路径 B1-D1-D3-F5-H5-H3。沿着网格上的这条高层路径，我们可以得到最短的网格路径 B1C1-D1-D2-D3-E4-F5-G5-H5-H4-H3。</p>
<p>通过使用预先计算出的间隙值的动态编程算法，可以高效地确定从给定单元可直接到达的子目标。使用这种算法，可以在几毫秒内构建 SSG，并在搜索前迅速将起始顶点和目标顶点连接到 SSG。</p>
<p><strong>N-Level Subgoal Graphs</strong></p>
<p>N 层子目标图（Uras 和 Koenig，2014 年）是通过在 SSG 的顶点之间创建层次结构来构建的。这种层次结构与本文后面描述的收缩层次结构（Geisberger 等人，2008 年；Dibbelt、Strasser 和 Wagner，2014 年 a）非常相似，只是 N 层子目标图可以将多个顶点置于层次结构的同一层次，并且只在 h 个可达到的子目标之间添加新的边。构建过程中，每个子目标的级别都是 1，然后重复将最高级别的子目标划分为全局子目标和局部子目标，并将全局子目标的级别增加一级（任何在划分之初不在最高级别的子目标在划分过程中都会被忽略）。这个过程一直持续到最高级别的子目标无法再被分割，或者图中的级别数达到用户定义的限制为止。在将最高层子目标划分为全局和局部子目标时，划分必须满足以下属性： 如果从图中移除任何一个本地子目标子集，剩余的本地子目标和全局子目标之间的最短路径长度必须保持不变。图 4 显示了由图 3 中的 SSG 构建的两级子目标图（在子目标 D 和 F 之间添加了一条边）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011455423.png" alt="image-20240301145531509"></p>
<p>要使用 N 级子目标图查找最短路径，首先要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后通过递增边（从子目标到更高级子目标的边，如果 s 和 g 不是子目标，则假定它们的级别为 0）确定所有可从 s 和 g 到达的子目标，并搜索由这些子目标和所有最高级子目标（以及它们之间的边）组成的图，从而在搜索过程中忽略其他子目标。例如，如果使用图 4 中的两级子目标图来查找 B2 和 H3 之间的路径，那么搜索到的图将包括子目标 A、B、D 和 F，但不包括 C 和 E。</p>
<p>在构建过程中考虑顶点的顺序决定了所得到的层次结构。正如收缩层次结构所显示的，良好的节点收缩排序可以大大加快路径规划的速度，这也是收缩层次结构方法经常花费大量预处理时间来寻找良好节点收缩排序的原因。未来的工作是在子目标层次结构的背景下考虑这种效果，因为子目标层次结构的 GPPC 条目使用任意节点排序。</p>
<h3><span id="jump-point-search-jps">Jump Point Search (JPS)</span></h3><p>由于多个条目都建立在跳点搜索（JPS）（Harabor 和 Grastien，2011 年；2014 年）的基础上，我们提供了算法的基本描述，作为这些条目的介绍。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011457933.png" alt="image-20240301145723064"></p>
<p>JPS 利用网格结构避免通过交替&#x2F;冗余路径到达许多状态。JPS 的核心理念是对路径进行排序，使所有对角线移动优先，然后是水平&#x2F;垂直移动。这就为所有路径创建了一个规范排序，确保每个目标只有一条路径。然而，仅有这一想法是不够的，因为障碍物可能会阻挡通往特定目标的自然典型路径。因此，我们引入了跳跃点。跳转点是地图中部分重置典型排序的位置，以便让搜索绕过障碍物。我们在图 5 中对此进行了说明。在图 5（a）中，我们展示了根据从 S 开始的规范排序可到达的状态。在图 5（b）中，我们添加了一个标为 J 的跳转点，在这里规范排序被重置，允许搜索向下、向右进行，从而到达目标。J 的新邻居称为强制邻居。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011458480.png" alt="image-20240301145822139"></p>
<p>跳跃点取决于地图上的障碍物，可以在运行时使用，也可以事先计算。JPS 的高效不仅在于它限制了对称路径的数量，&#x3D;&#x3D;还在于它减少了开放列表中存储的节点数量。我们不需要把节点的每个后继节点都放在开放列表中，而只需要把跳转点放在开放列表中。&#x3D;&#x3D;下面两个条目是在 JPS 的基础上改进其性能的。</p>
<h3><span id="bljps">BLJPS</span></h3><p>本条目作者是查尔斯特大学的杰森-特雷什（Jason Traish）和詹姆斯-图利普（James Tulip）。他们提交了表 2 中的参赛作品 BLJPS、BLJPS2 和 BLJPS Sub。</p>
<p>边界查找跳点搜索（BLJPS）是跳点搜索（JPS）的扩展。BLJPS 对地图上的边界进行预处理，以加快跳跃点检测速度。边界用于识别沿水平轴或垂直轴存在的跳转点，而无需反复检查大量单元格。</p>
<p>正常的 JPS 行为允许在相关主方向被阻挡时进行对角移动。但在本次比赛中，此类移动是被禁止的。在提交的代码中，这些行为之间的切换由标志变量 DIAG UNBLOCKED 控制。</p>
<p>下面的示例使用图 6 演示 JPS 如何从 P1 移动到 P4。每个基本方向的检查都以虚线显示。搜索从 P1 开始，检查所有 8 个方向（主方向和对角线方向）的跳转点。在本例中，只有东、北和东北三个方向可以访问。JPS 沿着一个基本方向遍历开放位置，直到到达一个受阻位置，然后终止搜索，不返回跳转点。在这种情况下，东面和北面都无法返回跳转点。然后，算法沿东北方向对角扩展到位置 (B8)。然后重复迭代检查相对于东北方向（北和东）的红心方向跳转点。同样，沿任一轴线都找不到跳转点，该过程重复进行，直到对角线扩展到达边界或在任一相对主轴方向上找到跳转点。在这种情况下，NE 扩展会继续到 P2 位置，此时东心轴方向检查会在 P3 位置返回一个潜在的跳转点，该跳转点由一个强制邻接点的存在而确定。然后，P2 就会被添加到开放列表（openlist）中，方向为 NE。无论是否发现东北方向的跳转点，都会终止从 P1 开始的搜索，因为只有北、东和东北方向可以访问。</p>
<p>然后弹出开放列表中的顶层节点，返回 P2。然后搜索 NE 扩展的自然邻接方向（N、E、NE）。在北向和东北向的搜索中没有发现其他跳转点，但在东向有 P3 作为潜在跳转点。P3 作为实际跳转点的评估方式与 P2 类似。然而，由于 P4 的强迫相邻点，东南方向也进行了搜索。在 SE 方向上的步进确定了目标 P4 已经到达。这就确认了 P3 为跳转点，并完成了路径（P1、P2、P3、P4）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011459012.png" alt="image-20240301145953935"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011501166.png" alt="image-20240301150103119"></p>
<p>表 4 显示了与图 6 相对应的边界查找表。表 4 中的数值记录了从西部（或北部）边界开始，单元格在阻塞和开放状态之间切换的边界。第 1 行至第 5 行没有障碍物，因此水平边界查询记录的是地图宽度（N）。但第 6 行至第 9 行在 K 处有边界，因此将其记录为第一个条目。然后，边界在 L 单元重新打开，并再次被地图宽度（N）阻挡。</p>
<p>当 BLJPS 的边界在给定方向上比其上下两行的重开值更远时，BLJPS 就会识别出东&#x2F;西方向的跳转点。例如，东面（A5）的边界为 N，小于其下面行（第 6 行）的重开值。第 6 行的边界为 K，向东重新打开的边界为 L，小于 N，因此跳转点为（L-1&#x3D;K 第 5 行，K5）或 P3。如果从（M5）开始向西移动，边界会在-A 处离开地图。5 下方的第 6 行以 K 为西部边界，并在（K-1&#x3D;L）上重新打开，该边界在西部方向上没有 -A 边界那么远。</p>
<p>BLJPS2 优化了这种方法，将四个主要方向的跳转点分别存储在不同的列表中。这样，每次检查轴的查表次数就从三次减少到一次。</p>
<p>BLJPS SubGoal 是一种介于 BLJPS 和 SubGoal 之间的混合方法。它使用与 SubGoal 相同的高层图剪枝方法，但用跳跃点代替低层子目标，以利用 JPS 的方向性。不过，将目标节点附加到低层 SubGoal 图上的计算成本很高，而且与基本的 SubGoal 算法相比没有任何改进。SubGoal 是从 2013 年基于网格的路径规划竞赛的参赛作品中提取的。</p>
<h3><span id="optimized-jps">Optimized JPS+</span></h3><p>本条目作者是史蒂夫-拉宾。提交的作品包括 JPS+、JPS+Bucket 和 A* Bucket。</p>
<p>JPS+ 为每个节点（每条边一个）预先计算 8 个值，这有助于在运行时引导搜索到预先确定的跳转点节点。通过典型排序搜索和在前往关键跳转点节点的途中跳过节点的组合，实现了显著的节点剪枝。这样做的效果是，通过检查更少的节点来加快搜索速度，从而减少开放列表中的节点数量。</p>
<p>优化后的 JPS+ 在编程时采用了多种最佳实践，每种实践对整体速度的贡献都很小。搜索所需的节点数据预先分配在一个二维数组中，每个节点中存储的搜索迭代计数避免了在每次搜索前重置节点数据的需要。所有成本均使用定点数学计算，启发式则使用八分启发式计算：我们计算两点之间在每个基本方向上的最大和最小距离。八分位距即为（minDiff ∗ (√2 - 1.0) + maxDiff）。此外，如果某个节点已经在开放列表中，而其成本需要更新，则会提取启发式，从而避免重新计算。最后，开放列表使用了堆优先级队列和哈希表，以加快 A* 在搜索中找到通往现有节点的更短路径时进行的 DecreaseKey 操作。</p>
<p>经过优化的 JPS+ 的 “桶 “版本将堆优先级队列换成了使用桶实现的优先级队列，桶以成本为索引，每个桶内包含一个堆栈。所需的桶数是最大搜索成本的 10 倍，节点的桶索引等于最终成本的 10 倍，因此每个桶内的成本差异为 0.1。一个指针记录着最便宜的非空桶，并根据需要在添加和删除时进行更新。每个水桶内都使用了搜索迭代计数，以实现每次新搜索时的懒重置。</p>
<p>有两项重要的优化未能在比赛中及时实施，但已证明它们都能进一步加快 JPS+ 的搜索速度。使用快速堆栈优化非常有帮助，2013 年的参赛作品 Subgoal 就实现了这一点。如果节点的成本等于父节点的成本，该优化就会将节点放在堆栈中，而不是开放列表中。&#x3D;&#x3D;然后，在检查开放列表之前，节点会从快速堆栈中移除。需要注意的是，这种优化方法只适用于使用 octile 启发式的网格搜索空间&#x3D;&#x3D;。此外，基于墙模式和父节点方向的函数指针查找表已经证明可以通过消除条件来加快搜索速度（2,048 个条目指向 48 个独特的函数）。最后，作为一种内存优化方法，通过对所有搜索成本进行重定向，以起始节点的原始八叉启发式成本为基准，可以减少桶的数量。</p>
<p>为了便于比较，A* Bucket 是一个基于 A* 的条目，它采用与 JPS+ 类似的方式，为开放式名单设置分桶。</p>
<h3><span id="relaxed-a">Relaxed A*</span></h3><p>本作品由 <a target="_blank" rel="noopener" href="http://www.iroboapp.org/">http://www.iroboapp.org/</a> 网站的一个研究小组撰写。由于非科学方面的原因，该作品的作者无法参与本论文；本说明由竞赛组织者撰写。</p>
<p>该小组的研究人员提交了表 2 中标有 RA* 和 RA-Subgoal 的条目。他们的条目在三个方面放宽了 A* 的行为。&#x3D;&#x3D;首先，它不允许节点的 g-cost 在首次设定后被更改。&#x3D;&#x3D;其次，由于节点的 g-cost 只更新一次，因此在使用 A* 打开节点时，无需明确检查打开列表中的成员。所有开放节点的 g-cost 都是无限的。最后，该条目不维护父节点指针，而是假设节点的父节点是 g 成本最低的节点。</p>
<p>这种方法首先应用于常规 A* 搜索，然后应用于作为子目标图一部分的 A* 搜索（Uras、Koenig 和 Hern ́ andez，2013 年）。子目标代码由 2013 年 GPPC 竞赛中的 SubgoalGraph-Fast 代码构建而成。</p>
<h3><span id="contraction-hierarchies-ch">Contraction Hierarchies (CH)</span></h3><p>本条目的作者是卡尔斯鲁厄理工学院的 Ben Strasser，在表 2 中标注为 CH。</p>
<p>CH 是一种在一般加权图中计算最短路径的加速技术。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以利用辅助数据，运行速度应该非常快。该技术在（Geisberger 等人，2012 年）中提出，此后成为许多研究论文的焦点。在各种独立研究中，该技术在道路图上得到了广泛的评估。然而，人们一直在质疑该技术在源自游戏网格的图上是否可行，或者该技术是否需要调整。本论文的唯一目标就是确定这一点。我们没有针对游戏地图对提交的代码进行优化。事实上，我们的代码取自（Dibbelt、Strasser 和 Wagner，2014b）的实现，并进行了大部分封装。应该可以对代码进行调整。例如，预处理代码并没有利用游戏图是无向的这一特点。这样做应该很简单，并能将预处理运行时间缩短 2 倍。</p>
<p>算法的核心思想很简单，但需要一些符号。用 G 表示输入图，在本次竞赛中，输入图是无向的。辅助数据包括一个有向无循环搜索图 G′，其节点集与 G 相同，且满足覆盖属性： 对于每一对源节点 s 和目标节点 t，都存在一个节点 m，这样对于 G 中的每一条最短 st 路径 P，G′ 中都存在一条 sm 路径 P ′ u 和一条 tm 路径 P ′ d，使得 P 的长度与 P ′ u 和 P ′ d 的长度之和相同。我们把 P′ u 称为向上路径，把 P ′ d 称为向下路径。我们把 P ′ u 和 P ′ d 称为上下路径。</p>
<p>将顶部节点视为覆盖许多最短路径的重要节点。例如，道路图中的桥梁。底部节点则非常不重要。将它们视为死胡同。你可以把上-下路径看作是 G 中最短路径的粗略化版本。粗略化意味着两个顶部节点（即桥梁）之间的所有边都不见了。该算法的思路是搜索 P′ u 和 P ′ d，即一条向上向下的路径，而不是 P。 该算法使用两个在 G′ 上运行的 Dijkstra 算法实例。第一个实例从 s 开始搜索，第二个实例从 t 开始搜索。第一个实例找到 P ′ u，第二个实例找到 P ′ d，由此可以重建 G 中的路径。我们将节点 x 可到达的 G′ 子图称为 x 的搜索空间。</p>
<p>要构建 G′，我们需要（加权）节点收缩的概念。这就是为 CH 命名的操作。节点收缩包括从图 H 中移除节点 x，并在两个相邻节点 y 和 z 之间插入一条边，条件是 y→x→z 路径是唯一最短的 yz 路径。检验 y→x→z 是否具有这一特性的方法是在 H{x} 上运行迪克斯特拉算法，检查 H{x} 中最短的 yz 路径是否比 y→x→z 长。这一操作称为见证搜索。我们的想法是从 H 中删除 x，同时保持 H{x} 中所有最短路径的距离。G′ 是通过沿着收缩阶 o1 … on 迭代收缩不重要节点从 G 中构造出来的。用 Gi 表示前 i - 1 个节点收缩后剩下的图，即 G1 &#x3D; G，Gi 是通过在 Gi-1 中收缩 oi-1 得到的。在枚举这些 Gi 的同时，算法按如下方式构建 G′： oi 的出弧指向 Gi 中 oi 的邻弧。正如（Geisberger 等人，2012 年）所述，这种构造符合覆盖属性。</p>
<p>剩下的关键问题是如何确定良好的节点收缩顺序。这是目前预处理中最慢的部分。文献中存在几种方法。最初的 CH 论文（Geisberger 等人，2012 年）采用了一种自下而上的方法，在 CH 收缩过程中贪婪地确定最不重要的节点。在（Abraham 等人，2012 年）中，引入了一种自上而下的方法。这种方法的理念是，最重要的节点是位于最多非覆盖最短路径上的节点。(自下而上的方法在类似道路的图中实际效果非常好，但却像烹饪食谱一样优雅： 你将各种启发式方法混合使用，最后问题就会迎刃而解。据我们所知，没有人真正知道为什么一种配方优于其他配方。自上而下的方法更为优雅，但其基本变体速度较慢。在（Delling 等人，2014 年）一书中，介绍了一种基于快速采样的自顶向下方法。自下而上和自上而下的方法计算的阶数都取决于 G 的边权重。在（Dibbelt、Strasser 和 Wagner，2014b；Bauer 等人，2013 年）中，引入了第三种基于平衡图分离器的与权重无关的构造，并证明其查询性能非常接近与权重有关的阶次。这种与权重无关的构造与树分解理论紧密结合在一起。</p>
<p>GPPC 提交的论文采用了一种相对缓慢但高质量的自下而上排序方法。其核心思想是将 G′的构建与收缩排序交织在一起。该算法为 Gi 中的每个节点 x 确定一个重要性值 Ii(x)。然后设置 oi &#x3D; min arg Ii(x)。在下文中，我们将去掉 Ii 中的 i 索引和，以避免不必要的符号杂乱。为了避免在每次迭代中重新计算所有 I(x)，我们使用了一个优先级队列，按照节点当前的重要性对所有节点进行排序。收缩节点只会修改相邻节点的重要性。这些值在每次迭代中都会更新，然后算法会继续收缩 I(x) 最小的节点。I(x) 的定义就像一份烹饪食谱。我们首先定义所有配料。我们用 L(x) 表示近似顶点 x 在 G′ 中的水平值。最初所有 L(x) 都是 0。如果 x 是收缩的，那么对于每一条入射边 {x, y}，我们都要执行 <code>(y) ← max&#123;</code>(y), &#96;(x) + 1}。我们进一步为每条弧 a 存储一个跳长 h(a)。这是该快捷方式完全解包后所代表的弧的数量。用 D(x) 表示如果 x 被收缩则删除的弧集，用 A(x) 表示将插入的弧集。集合 A(x) 和 D(x) 是通过模拟节点收缩计算得出的。我们设定:<br>$$<br>I(x) &#x3D; L(x) + \frac{|A(x)|}{|D(x)|} + \frac {\sum_{a \in A(x)} h(a)}{\sum_{a \in D(x)} h(a)}<br>$$<br>该公式源自（Abraham 等人，2012 年）。请注意，原始的 CH 变体（Geisberger 等人，2012 年）包含了更多旨在减少预处理时间的启发式。例如，如果 Dijkstra 算法运行时间过长，他们的变体就会中止见证搜索，而且不会更新所有 I(x)，而是使用一种称为 lazy-pop 的技术。而我们提交的 GPPC 没有做这些工作。</p>
<p>为了说明 CHs 的性能，我们在星际争霸 IceFloes 地图上进行了一次实验。该地图有 91,123 个单元，将其转化为一个有 91,123 个节点和 347,624 条边（权重为 1 或 √2）的图 G。确定顺序只需不到 2 分钟的时间。搜索图 G′包含 733 114 条弧。随机均匀节点的搜索空间平均包含 680 个节点和 6,677 条弧。搜索图 G′有 48 层。这个 CH 性能非常好。只有在极少数情况下，才能在保持合理搜索空间大小的同时，使每条输入边的搜索图弧少于两条。不过，我们相信，通过利用输入实例的映射结构，仍然可以取得显著的改进。例如，将输入图编码为二维位图的内存效率要远远高于任何等效的通用图表示法。利用这一观察结果可以大大降低内存占用。</p>
<h3><span id="single-row-compression-src">Single Row Compression (SRC)</span></h3><p>本条目作者为 Ben Strasser、Adi Botea 和 Daniel Harabor，对应表 2 中的条目 SRC-dfs、SRCdfs-i、SRC-cut、SRC-cut-i。</p>
<p>SRC 是一种在有界度的一般加权图中计算最短路径的加速技术。该技术在（Strasser、Harabor 和 Botea，2014 年）中提出，其理论复杂性在（Botea、Strasser 和 Harabor，2015 年）中进行了研究。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图形进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以使用辅助数据，运行速度必须非常快。</p>
<p>使用这种设置的一个非常基本的技术是计算一个大型的首步矩阵 A。从源节点 s 到目标节点 t 的第一次移动是从 s 到 t 的最短路径的第一条边。矩阵 A 的每个条目 aij 对应于从第 i 个节点到第 j 个节点的最短路径的第一条边。按照惯例，我们认为第 i 行包含了从第 i 节点到所有其他节点的所有首条路径。同样，第 j 列包含了所有向第 j 节点的第一次移动。这种设置的查询阶段速度极快，大部分时间只需一次随机存储器访问。这种方法的缺点是矩阵需要的空间是节点数的二次方，这对于大型图来说是无法承受的。</p>
<p>SRC 通过利用一个非常简单的观察结果来缓解这一空间问题： 一行中的所有边都必须是单个节点的出边。如果我们假设图的度数是有界的，那么许多边必须重复。SRC 利用这一事实，使用运行长度编码 (RLE) 对每一行进行单独压缩。如果处理得当，查询的运行时间可按压缩行长度的对数计算。遗憾的是，使用 RLE 可能无法很好地压缩行。因此，SRC 首先会对节点进行排列，使相似的首移在一行中倾向于出现在相邻位置。不幸的是，正如（Botea、Strasser 和 Harabor，2015 年）中所示，计算一个能使运行次数最小化的节点顺序是 NP 难的。幸运的是，启发式方法在实践中运行良好： Strasser、Harabor 和 Botea 2014）提出了 dfs 排序和 cut 排序。dfs-order 非常简单，只需从随机根节点开始使用深度优先预排序对节点重新排序。剪切阶更为复杂，对图形进行递归分割。在大多数测试过的图形上，剪切排序的效果略好于 dfs 排序。但在某些图上，由于不明原因，剪切阶数远不如 dfs 阶数。这导致了糟糕的压缩率。这就导致了整数溢出，这也解释了为什么剪切阶提交会在一些图形上失败。为了直观了解好的阶次是怎样的，请看美国道路图。考虑东南部某个节点的行 R。如果目的地在西北部，路径很可能总是从相同的第一步开始。成功的关键在于找到一种节点顺序，为西北部的所有节点分配连续的节点 ID。这样的顺序可以确保美国西北部的所有节点都在 R 中折叠成一个单一的运行。</p>
<p>SRC 的优势在于能快速计算先手。其主要缺点在于预处理时间，由于必须计算 A，预处理时间与节点数呈二次方关系。请注意，快速计算首步并不会自动转化为快速计算完整路径的最快算法。原因在于所有每次计算一条边的技术。这甚至包括基本的二次矩阵方法。这种算法需要对每条边进行一次随机内存访问。而将大部分路径预装在内存中的算法，只需对每个部分进行一次随机内存访问。由于缓存效应，速度会明显加快。(在当前的硬件上，顺序内存访问比随机内存访问快约 70 倍）。然而，在许多重要的应用场景中，对缓存更友好的路径计算最终并不会带来任何好处。考虑一个需要导航到某个位置的游戏单元。有两种不同的设置：(1) 在开始旅程时，单元会计算整个路径并将其存储在某处。每当单元到达一条边的终点时，它就会查找下一条边，即需要随机存取内存。(2) 每次单元到达一条边的终点时，它只计算下一条边。在实验室条件下，设置（1）可能比设置（2）更好，因为测得的运行时间通常只包括计算路径所需的时间。单元查找单条边所花费的时间往往被忽略。此外，(1) 方法需要在内存中存储长度可变的路径。这就增加了内存管理所需的时间，更重要的是，每个单元的内存消耗是不恒定的。考虑一种极端情况，即有ω(n) 个单元，其存储的路径有 Θ(n) 条边（n 为节点数）。这将导致 ω(n2) 的内存消耗。即使是采用二次矩阵方法的设置 2，在这种情况下也只需要 Θ(n2) 内存。</p>
<p>表 2 包含我们算法的 4 个变体。cut&#x2F;dfs 部分指的是所使用的节点顺序。-i “表示是在一次函数调用中提取完整路径，还是逐边提取路径。理论上，这应该没有什么区别。但在实际操作中，它会影响时序代码的调用频率。如果路径是在一次函数调用中提取的，那么定时代码只会在每次路径查询前后运行。然而，如果路径是逐边提取的，则定时代码会在每条边上运行一次。这种略有不同的实验设置导致 “dfs-i “和 “dfs “的路径提取平均运行时间相差 0.044ms。</p>
<h2><span id="looking-ahead-and-conclusions">Looking Ahead and Conclusions</span></h2><p>GPPC 涵盖各种基于网格的寻路问题。目前已开发出几种主要的竞争方法，它们利用网格结构的优势，显著提高了基本 A* 实现的性能。因此，该竞赛成功地记录了网格寻路的显著改进，并为实验和测试提供了高质量的寻路实现。</p>
<p>从作品的应用来看，比赛涵盖了游戏行业感兴趣的问题的一个子集，但并没有解决一些现实世界的问题，而这些问题有时是在使用网格时必须解决的。特别是，网格通常用于动态环境中，在这种环境中，世界和&#x2F;或在世界中移动的成本会定期发生变化（Sturtevant，2013 年）。这是因为当世界发生变化时，网格表示法易于更新且成本低廉。</p>
<p>目前的竞赛不允许在地图或动态地图中使用动态权重，而旨在促进此类比较的新赛道没有收到任何参赛作品。从某种意义上说，这并不完全令人惊讶，因为网格方法的研究已经有很多年了，所以有大量的作品可以参赛。此外，测试动态地图的方法有很多种，对于类似机器人的环境和游戏环境，可能需要进行不同的测试。</p>
<p>但是，经过几年的竞赛，我们可以看到用于提高性能的主要核心思想，以及一系列内存和预计算要求。随着这些方法的不断改进，我们期待看到更多技术填补这些参赛项目之间的空白。特别是，实时和次优条目还有很大的创新空间。</p>
<p>展望未来，重要的是要解决如何挑战研究界的难题，使其超越统一成本网格寻路问题，进而解决更能代表实践者所面临的真实世界问题。例如，本文第一作者正在与游戏行业合作，以获得更多地图和地图类型，从而为研究人员提供有意义的研究数据。我们将认真考虑如何利用竞赛来鼓励对不同问题类型的研究，这些问题类型在更广泛的领域中有着更广泛的应用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-17T15:16:04.000Z" title="2024/1/17 23:16:04">2024-01-17</time>发表</span><span class="level-item"><time dateTime="2024-01-19T17:01:08.987Z" title="2024/1/20 01:01:08">2024-01-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/">路径规划启发式</a></span><span class="level-item">2 小时读完 (大约14302个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/17/An-improved-heuristic-mechanism-ant-colony-optimization-algorithm-for-solving-path-planning/">An improved heuristic mechanism ant colony optimization algorithm for solving path planning</a></p><div class="content"><h1><span id="an-improved-heuristic-mechanism-ant-colony-optimization-algorithm-for-solving-path-planning">An improved heuristic mechanism ant colony optimization algorithm for solving path planning</span></h1><h2><span id="abstract">abstract</span></h2><p>随着人工智能算法的发展，智能路径规划因其广阔的应用前景和发展潜力吸引着研究人员的目光。蚁群优化（ACO）算法是目前应用最广泛的路径规划求解方法之一。然而，传统的 ACO 算法存在搜索效率低、容易停滞等缺点。本研究提出了一种新的 ACO 变体，名为改进的启发式机制 ACO（IHMACO）。IHMACO 包含四种改进机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整。具体而言，&#x3D;&#x3D;自适应信息素浓度设置和带有方向判断的启发式机制可提高规划路径的目的性并减少转弯时间。改进的伪随机转移策略和信息素蒸发率的动态调整提高了搜索效率和全局搜索能力，进一步避免了陷入局部最优。&#x3D;&#x3D;随后，通过一系列实验检验了四种机制的有效性，并验证了所提出的 IHMACO 的性能。与现有的 15 种求解路径规划的方法进行比较，包括 ACO 的 9 种变体和 6 种常用的确定性搜索算法。实验结果表明，所提出的 IHMACO 在路径转弯时间方面的相对改进率分别为 33.33%、83.33%、35.29%、38.46% 和 38.46%，证明了 IHMACO 在可用性和高效率方面的优越性。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>全局路径规划是在已知障碍环境下，建立一条从起点节点到目标节点的有序可行路径，且必须保证规划路径不与任何障碍物发生碰撞。智能路径规划是许多领域的重要工具，如机器人路径规划[1]、无人战车（UCV）[2]、车辆路由问题（VRP）[3,4]、交通系统导航[5]、军事指挥系统[6]、巡航导弹轨迹规划[7]、无人机（UAV）轨迹规划[8,9]、火险逃生[10]、自动导引车（AGV）[11]等。由于应用广泛，路径规划问题得到了众多研究者的关注，大量优化算法被用于解决路径规划问题。</p>
<p>传统的路径规划算法主要包括最佳第一搜索算法[12]、Dijkstra算法[13]、A* 算法[14]、跳点搜索算法[15]、广度第一搜索算法[16]、跟踪算法[17]、快速探索随机树（RRT）算法[18]、概率路线图（PRM）算法[19]等。Kurdi 等人将 Dijkstra 算法应用于自动驾驶车辆问题[20]。然而，由于需要遍历大量节点，Dijkstra 算法效率较低，而且无法处理负边问题。&#x3D;&#x3D;Luo 等人提出了一种扩展的 Dijkstra 算法，利用 Delaunay 三角剖分法解决曲面最优路径规划问题[21]。&#x3D;&#x3D;Best-First Search 算法与 Dijkstra 算法的过程类似，不同之处在于它使用启发式函数快速引导目标节点[22]。El Baz 等人提出了一种改进的并行 Best-First Search 算法来解决多核处理器规划问题[23]。Breuker 等人将双基算法与 Best-First Search 算法相结合，解决了图历史交互（GHI）问题 [24]。A * 算法在路径规划问题中具有良好的鲁棒性、对环境信息响应快等优异性能[25]。Sang 等人引入了人工势场来改进无人水面飞行器编队的 A* 算法 [26]。Li 等人将双向 A* 应用于机器人路径规划 [27]。然而，&#x3D;&#x3D;A* 算法并不适合高维空间，而且在复杂环境中会导致计算量骤增。 通过改进 A* 算法，引入了 JPS 算法，以避免扩展许多无用节点 [28,29]。&#x3D;&#x3D; 广度优先搜索算法采用基于地毯的级联搜索策略，沿着树的宽度遍历节点。Li 等人采用 Breadth-First Search 提出了一种快速路径规划算法 [30]。&#x3D;&#x3D;RRT 和 PRM 是基于图搜索的动态路径规划求解方法[31,32]。&#x3D;&#x3D;广度优先搜索算法是一种盲搜索方法，无法确保找到最优路径 [33]。因此，Tripathy 等人提出了一种改进的基于广度优先搜索的识别方法，用于解决移动机器人导航问题 [34]。</p>
<p>近年来，许多启发式仿生算法被广泛应用于解决路径规划问题，如粒子群优化（PSO）[35]、遗传算法（GA）[36]、蚁群优化（ACO）[37]等。然而，传统的启发式算法在解决路径规划问题时存在局限性。为克服 GA 算法运行效率低的缺点[38]，Flores-Caballero 等人提出了一种改进的遗传算法来解决无人机的路径规划问题[39]。Cheng 等人提出了一种适用于可重构平铺机器人的新型遗传算法[40]。Chong 等人提出了一种改进的自适应遗传算法（IAGA）来解决自主水下航行器的路径规划问题[41]。此外，PSO 容易进入局部最优[42]。根据提出的 PSO 变体，Wang 等人介绍了一种用于 AUV 离线路径规划的量子 PSO 方法[43]。为了获得较高的最优精度，Zhao 等人提出了一种混合 PSO，用于求解串行机械手时空最优轨迹规划[44]。Kathen 等人提出了一种改进的 PSO 来解决高级安全飞行器的路径规划问题[45]。此外，随着路径规划问题复杂度的不断提高，许多学者提出了各种改进的优化算法。&#x3D;&#x3D;Wu 等人引入了一种名为自主导航和避障（ANOA）的深度强化学习技术，以解决无人水面飞行器（USV）的自主导航和避障问题[46]。&#x3D;&#x3D; SA 是一种基于概率的算法，源自固体退火原理。Xiao 等人提出了一种改进的 SA 来实现无人机覆盖路径规划，结果验证了改进 SA 的高质量效果[47]。&#x3D;&#x3D;Xiong 等人从快速探索随机树星（RRT*）中汲取灵感，结合锦标赛选择方法和信息启发式算法，提出了一种独特的基于样本的路径规划算法[48]。&#x3D;&#x3D;与其他启发式仿生算法相比，ACO 具有并行性、自组织性、正反馈能力等优点。然而，传统的 ACO 算法也存在一些缺点，如效率低、收敛慢、易停滞等。因此，许多研究人员提出了许多改进措施，以解决路径搜索策略和信息素更新方面的问题。Ma 等人提出了一种烟花蚁群混合算法，并通过考虑导航距离成本和能耗成本建立了新的数学模型[49]。Ajeil 等人提出了一种基于老化的 ACO，通过与栅格法相结合实现了路径规划的求解[50]。Liu 等人提出了一种改进的 ACO，它集成了信息素扩散和几何局部优化，用于移动机器人路径规划[51]。</p>
<p>&#x3D;&#x3D;Zhu 等人提出了一种用于月球机器人路径规划的自适应势场 ACO[52]&#x3D;&#x3D;，引入了启发式因子和自适应状态转换来提高搜索能力和收敛速度。Yi 等人通过引入多目标编程模型对 ACO 进行了改进，以优化多自动制导车辆的信息素矩阵[53]。为了解决室内移动机器人路径规划问题，Miao 等人通过增强信息素更新策略和状态转换概率，提出了一种改进的 ACO（IACO）[54]。Jiao 等人提出了一种自适应多态 ACO，用于解决智能轮椅的路径规划问题，它主要改进了信息素更新策略[55]。Tao 等人提出了一种改进的 ACO，它结合了初始信息素的分布、修正的启发式函数和信息素更新规则来解决移动服务机器人的路径规划问题[56]。&#x3D;&#x3D;为了改善 ACO 计算量大的缺点，Wang 等人提出了一种新的加权邻接矩阵用于路径规划[57]&#x3D;&#x3D;。Zhao 等人通过引入信息素更新策略和路径选择策略，提出了一种改进的 ACO，用于解决全向移动车辆路径规划问题[58]。尽管 ACO 及其变体在解决路径规划问题时能产生令人满意的解，但就有效性和效率而言，ACO 的性能仍有进一步提高的空间。</p>
<p>本研究提出了一种改进的 ACO 来解决路径规划问题。为了克服经典 ACO 的缺点，&#x3D;&#x3D;本文提出了四种新的机制，分别是自适应信息素浓度设置、具有方向判断能力的启发式机制、改进的伪随机转移策略以及信息素蒸发率的动态调整。&#x3D;&#x3D;自适应信息素浓度设置是为了加强在初始搜索过程中优先选择可选区域的引导能力。提出了具有方向判断能力的启发式机制，以增强算法的搜索目的性和规划路径的平滑性。引入了改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。提出了一种动态调整信息素蒸发率的方法，以增加蜂群多样性和提高全局搜索能力。将上述四种机制与传统的蚁群优化算法相结合，提出了一种新的蚁群优化算法变体，即 IHMACO（改进的启发式机制蚁群优化）算法。为了验证 IHMACO 的有效性和优越性，我们进行了一组实验，将其与其他路径规划算法在不同实例中进行了比较。结果验证了 IHMACO 在收敛速度和最优解搜索能力方面的优势。</p>
<p>其余部分的结构如下： 第 2 节给出了建立全局路径规划数学模型的说明。然后，第 3 节介绍了传统 ACO 和 IHMACO 中的四种新型机制。第 4 节进行了实验和分析。最后，第 5 节给出结论。</p>
<h2><span id="2-mathematical-model-of-global-path-planning">2. Mathematical model of global path planning</span></h2><h3><span id="21-grid-environment-model">2.1. Grid environment model</span></h3><p>全局路径规划的环境模型是为了模拟实际应用场景，为算法实现提供仿真环境。&#x3D;&#x3D;栅格法是路径规划中应用最为广泛的方式，可以降低环境模型的复杂度。&#x3D;&#x3D;因此，本研究选择栅格法来构建全局路径规划的环境模型。一般来说，环境模型由自由栅格和障碍物栅格组成，自由栅格用白色栅格表示，也可以用数值 0 表示。障碍物栅格用黑色栅格表示，也可以用数值 1 表示。为方便起见，每个栅格都有唯一的序列号和坐标值。图 1 显示了一个带有 (20 × 20) 个栅格的环境模型示例。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172338680.png" alt="image-20240117233843703"></p>
<p>如图 1 所示，起点节点和目标节点分别用 S 和 T 表示。黑色栅格代表障碍区域，白色栅格代表可行区域。相应坐标与栅格序列号之间的变换规则如式（1）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172347491.png" alt="image-20240117234705986"></p>
<p>其中，(xn, yn) 表示第 n 个栅格的坐标位置；n 是其序列对应的编号；mod () 表示余数函数；Rx 和 Ry 是环境模型的行列总和；ceil () 表示四舍五入函数。环境模型建立后，转而寻找一组连续的栅格来连接 S 和 T，任意栅格的可能方向如图 2 所示。在图 2 中，任何栅格都可以选择 8 个可能的方向，障碍物栅格为禁止栅格。</p>
<h2><span id="22-mathematical-model-of-path-planning">2.2. Mathematical model of path planning</span></h2><p>传统 ACO 的目标函数只考虑路径长度，但转弯次数对优化过程也有重要影响 [59]。我们知道，一条令人满意的路径应该具有最短的长度和最少的转弯次数。在本研究中，引入了多目标函数来建立路径规划的数学模型，该模型考虑了路径长度和转弯次数[60]。同时还采用了加权法来维持两个目标，如式（2）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172348715.png" alt="image-20240117234816200"></p>
<p>其中，L(p) 表示路径长度；T (p) 表示转弯时间；w1、w2 表示权重系数。实际上，w1 和 w2 与 L（p）和 T（p）的最小值有关。 &#x3D;&#x3D;w1 和 w2 应保证（w1×L(p)）和（w2×T (p)）的值处于同一振幅，以平衡路径长度和转弯时间的影响。&#x3D;&#x3D;</p>
<h2><span id="3-improved-mechanisms-and-the-proposed-variant-of-aco">3. Improved mechanisms and the proposed variant of ACO</span></h2><h3><span id="31-aco-algorithm">3.1. ACO algorithm</span></h3><p>ACO 算法的灵感来源于蚂蚁的觅食行为。在蚁群中，每只蚂蚁都是独立的合作个体，觅食行为是通过蚁群内个体间的交流来实现的。</p>
<p>(1) 初始化参数设置 ACO 的基本参数可根据实验经验进行分配，主要包括蚂蚁数量 M、最大迭代次数 K、信息素启发因子 α、期望启发因子 β、信息素挥发因子 ρ 和信息素强度值 Q。</p>
<p>(2) 状态转换概率 在环境模型中，位于节点 i 上的蚂蚁 m 利用状态转换概率选择下一个节点 j，如公式 (3) 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172351111.png" alt="image-20240117235138596"></p>
<p>其中，$p_{ij}^{m}$ 节点 $i$ 和节点 $j$ 之间的转换概率；$$\tau (i, j)$$ 代表信息素浓度值；$η(i, j)$ 代表能见度启发式信息，$η(i, j) &#x3D; 1&#x2F;d_{ij} * J{m}$ 代表可选节点集。</p>
<p>(3) 信息素更新规则 信息素更新规则复制了 ACO 中信息素的积累和蒸发，用公式 (4) 和 (5) 表示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172352893.png" alt="image-20240117235240675"></p>
<p>其中，ρ 的值在 [0, 1] 范围内；$\tau^{m}<em>{t}(i, j)$ 表示第 m 只蚂蚁从节点 i 到节点 j 的信息素；$\Delta \tau^{m}</em>{t}(i, j)$ 表示当前迭代中从节点 i 到节点 j 的信息素增量；$L_m$ 表示路径长度。</p>
<h3><span id="32-a-proposed-variant-of-aco">3.2. A proposed variant of ACO</span></h3><p>本节提出了四种新的机制来改善传统 ACO 的缺点。首先，提出了一种自适应信息素浓度设置，以加强在初始搜索过程中选择先行可选区域的引导能力。然后，提出了一种具有方向判断能力的新型启发式机制，以提高规划路径的目的性和平稳性。随后，引入了一种改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。最后，提出了信息素蒸发率的动态调整机制，以增加蚁群的多样性，提高全局搜索能力。然后，结合上述四种机制，形成了一种新的 ACO 变种，即改进的启发式机制 ACO（IHMACO）。IHMACO 的流程图如图 3 所示。图 4 给出了 IHMACO 的伪代码。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172355363.png" alt="image-20240117235534260"></p>
<h3><span id="33-adaptive-pheromone-concentration-setting">3.3. Adaptive pheromone concentration setting</span></h3><p>在传统的 ACO 中，初始信息素值的设置是均匀分布的，如图 5（a）所示。这种方式会导致算法在早期阶段出现搜索盲区，收敛速度较慢。为了克服这一缺点，&#x3D;&#x3D;引入了自适应信息素浓度设置来增强引导功能，即在初始搜索过程中优先选择优势可选区域，如式（6）所示。改进后的初始信息素分布如图 5(b) 所示。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172356023.png" alt="image-20240117235634863"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401181119688.png" alt="image-20240118111949767"></p>
<p>其中，$\tau_{ij}(0)$ 是 $i$ 到 $j$ 的初始信息素浓度，存在  $\tau_{ij}(0) \neq \tau_{ji}(0)$；$τ_0$ 是传统 ACO 中的初始信息素，取一常数；a 被定义为初始信息素奖惩因子。$d_{Si}$ 是节点 $i$ 到 $S$ 的欧拉距离，$d_{iT}$ 是节点 $i$ 到目标节点 $T$ 的欧拉距离，$d_{Sj}$ 是节点 $j$ 到节点 $S$ 的欧拉距离，$d_{jT}$ 是节点 $j$ 到节点 $T$ 的欧拉距离，$d_{ST}$ 表示 $S$ 到 $T$ 的距离。假设 $S$ 的坐标为（xS , yS ），T 的坐标为（xT , yT ），欧拉距离计算公式如式（7）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172357036.png" alt="image-20240117235711148"></p>
<p>对于特殊情况，&#x3D;&#x3D;引入的欧拉距离 $d_{Si}$、$d_{iT}$、$d_{Sj}$、$d_{jT}$ 和 $d_{ST}$ 如图 6 所示。显然，dSi 和 diT、dSj 和 djT 之和的最小值就是 $d_{ST}$ 的值。当前节点 i 与直线 “ST “之间的距离越远，初始信息素浓度就越小。&#x3D;&#x3D;</p>
<p>此外，在信息素浓度自适应设置方程中，a 是用来控制一般可选节点和优势区域可选节点的初始信息素浓度。如果 diT &gt; djT，则下一个节点 j 离目标节点位置更近，被视为优势区域节点。为确保当前节点尽可能选择优势区域的下一个节点，a 取其最大奖励值 1。另一方面，如果 diT &lt; djT，则需要进行综合统计实验以找出 a 的合适惩罚值。</p>
<p>具体而言，a 的惩罚值分别设置为 0.1、0.3、0.5、0.7 和 0.9。IHMACO 的其他主要参数设定为 K &#x3D; 100、M &#x3D; 50、α &#x3D; 1、β &#x3D; 7、Q &#x3D; 1、ρ &#x3D; 0.2。每组选定的参数组合模拟运行 20 次。不同 a 值的实验结果如图 8 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004175.png" alt="image-20240118000412109"></p>
<p>从图 8 中可以看出，当 a 的惩罚值设置为 1&#x2F;2 时，算法的性能在路径长度和转弯时间方面都有优势。总之，当 diT &gt; djT 时，a 的最大奖励值为 1，而当 diT &lt; djT 时，a 的惩罚奖励值为 1&#x2F;2。在自适应信息素浓度设置功能的作用下，ACO 的初始搜索过程更有目的性，效率更高。</p>
<h3><span id="34-heuristic-mechanism-with-directional-judgment">3.4. Heuristic mechanism with directional judgment</span></h3><p>对于当前节点 i，如果在传统 ACO 中没有障碍物包围，则它有八个可选节点。如图 9 所示，节点 i 及其八个可选节点分别用 j1、j2、j3、j4、j5、j6、j7 和 j8 表示。在路径规划中，&#x3D;&#x3D;启发式函数 η(i, j) &#x3D; 1&#x2F;dij 只与当前节点 i 和下一个可选节点之间的距离有关，而欧拉距离 dij 是环境模型中的已知值，为 1 或 $\sqrt{2} $。&#x3D;&#x3D; 因此，&#x3D;&#x3D;传统的启发式函数缺乏指导性和启发性。&#x3D;&#x3D;这会导致蚂蚁随机选择搜索路径，进一步减慢 ACO 的收敛速度，尤其是在迭代初期。显然，为了保持搜索过程的效率，&#x3D;&#x3D;希望节点 i 所选择的下一个节点 j 也是沿着从 S 到 T 的箭头方向&#x3D;&#x3D;，&#x3D;&#x3D;如图 9 所示。本节通过考虑 S 和 T 的位置信息，提出了一种新颖的带有方向判断的启发式机制&#x3D;&#x3D;，从而使路径搜索过程变得有目的性和流畅性，进一步有效避免了搜索的盲目性。带有方向判断的启发式机制基于 S 和 T 的相对位置，与 S 和 T 的绝对位置无关。具体如图 9（a）所示，当前节点的八个可选节点被赋予不同的权重值。假设节点 i 的坐标为 (xi，yi)，下一个选定节点 j 的坐标为 (xj，yj)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172359652.png" alt="image-20240117235945622"></p>
<p>基于新颖的启发式方向判断机制，从 i 到 j 的向量应尽可能指向从 S 到 T 的箭头方向。这意味着（x &#x3D; xj-xi ）-（X &#x3D; xT -xS ）和（y &#x3D; yj-yi ）-（Y &#x3D; yT -yS ）的值应尽可能不小于 0。如果 x-X &gt; 0 或 y-Y &gt; 0，则表示下一个节点的 x 或 y 方向为正，可标记为 “+”；相反，如果 x - X &lt; 0 或 y - Y &lt; 0，则标记为”-“。如图 9（a）所示，八个可选节点的值分别为 j1（+，+）、j2（0，+）、j3（+，0）、j4（-，+）、j5（+，-）、j6（-，0）、j7（0，-）、j8（-，-）。共有五种情况：j1 有两个 “+”；j2 和 j3 有一个 “+”和一个 “0”；j4 和 j5 有一个 “+”和一个”-“；j6 和 j7 有一个”-“和一个 “0”；j8 有两个”-“。根据方向判断规则，对于当前节点 i 来说，选择 “+”符号较多的可选节点是更好的选择。因此，将八个可选节点的优先级顺序分为五组，分别为 j1&gt;j2 &#x3D; j3&gt;j4 &#x3D; j5&gt;j6 &#x3D; j7&gt;j8，并赋予它们 5:4:3:2:1 的不同权重系数。经过归一化处理后，8 个可选节点的权重值 $\pi$ 依次为 5&#x2F;15、4&#x2F;15、3&#x2F;15、2&#x2F;15、1&#x2F;15，如表 1 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004642.png" alt="image-20240118000432302"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180000297.png" alt="image-20240118000039249"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180000770.png" alt="image-20240118000057789"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180001369.png" alt="image-20240118000117392"></p>
<p>如果起始位置（S）位于（n，n），目标位置（T）位于（0，0），则方向最一致的指向 S -→T 的下一个节点变为 j8，而方向相反的指向 S -→T 的 j1 变为（-，-），如图 9（b）所示。因此，带有方向判断的启发式机制只与 S 和 T 的相对位置有关，而与它们的绝对位置无关。此外，传统的 ACO 只考虑距离函数的影响，启发式函数中还应考虑转弯因素的影响，以提高路径的平滑度。带有方向判断的启发式机制在路径规划中考虑了下一节点、目标节点和转弯时间之间位置信息的联系。改进后的启发式函数详见公式 (8)-(10)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180002174.png" alt="image-20240118000222169"></p>
<p>其中，η（i，j）′为改进启发式函数；π为方向判断权重值；T（i，j）为上一节点（i-1）与下一节点 j 之间的转弯时间；T0 为初始转弯系数常数。改进后的启发式函数综合考虑了节点方向判断、距离信息和转弯时间。&#x3D;&#x3D;选择正方向的节点，距离和转弯次数越小，启发式函数越好。如此一来，使得算法具有更好的方向引导性，有效提升规划路径的平滑度。&#x3D;&#x3D;</p>
<h3><span id="35-improved-pseudo-random-transfer-strategy">3.5. Improved pseudo-random transfer strategy</span></h3><p>为了提高搜索效率，避免陷入局部最优，我们提出了一种改进的伪随机转移策略，如式（11）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180003093.png" alt="image-20240118000329200"></p>
<p>其中，$S_{ij}^{m}$ 是蚂蚁 $m$ 从节点 $i$ 转移到节点 $j$ 的概率；随机变量 q 在 [0, 1] 之间平均分布；argmax () 是函数达到最大值时的变量位置；$q_0$ 决定了选择确定性转移和随机性转移的概率。因此，如式（12）和图 10 所示，引入了 $q_0$ 的自适应调整机制，以实现确定性转移和随机转移的合理组合。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004298.png" alt="image-20240118000451322"></p>
<p>其中，$εq$ 表示 $q_0$ 的调整系数，$εq$ 取 0.1 较好。在&#x3D;&#x3D;早期阶段，$q_0$ 取较大的值，选择确定性转移的概率较大，可以加快局部最优路径的搜索速度。在算法执行的中期，$q_0$ 取较小值，可以增加选择随机转移的概率，防止局部最优的出现。&#x3D;&#x3D;当算法迭代到后期，其进化方向已基本确定，可逐渐增大 $q_0$ 值，加快收敛速度。如果某次迭代中有一半以上的蚂蚁获得了相同的路径，取 $q_0$ 的值为$(εq - q_0)$，可以增加选择其他路径的概率。改进后的伪随机转移策略在全局搜索能力和收敛速度之间取得了良好的平衡。</p>
<h3><span id="36-dynamic-adjustment-of-the-pheromone-evaporation-rate">3.6. Dynamic adjustment of the pheromone evaporation rate</span></h3><p>当蚂蚁因信息素干扰次优路径而无法选择最优路径时，就会出现局部最优。当经过多次迭代仍未找到最优解时，算法就会停止搜索。传统的 ACO 在迭代后期很容易陷入局部最优解的困境。为了加强算法后期的全局搜索能力，&#x3D;&#x3D;增加路径搜索的多样性，引入了信息素蒸发率的动态调整&#x3D;&#x3D;。此外，还引入了多目标函数 $Fitness$ 来替代全局信息素更新中的路径长度 $L_m$，如式（13）和式（14）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180006352.png" alt="image-20240118000641343"></p>
<p>其中，$\rho_0$ 是 $\rho$ 的初始值，$\rho$ 随迭代次数的增加而变大。在迭代初期，$\rho$ 设置得较小，以增强蚂蚁的方向性，进一步加快收敛速度。随着迭代次数的增加，$\rho$ 逐渐增大，以扩大蚁群的搜索空间，进一步增强全局搜索能力，避免陷入局部最优。</p>
<h3><span id="37-parameter-optimization-of-ihmaco">3.7. Parameter optimization of IHMACO</span></h3><p>&#x3D;&#x3D;众所周知，ACO 参数的选择直接影响其性能。&#x3D;&#x3D;迄今为止，还没有一种成熟的理论分析方法可以直接确定参数的最佳组合。因此，为了找到 IHMACO 的合适参数 $q_0$，我们进行了一次全面的统计实验。在每段测试实验中，只改变其中一个参数，其他参数设置为常数，以分析单一参数的影响。为减少偶然因素造成的误差，每组选定的参数组合都要模拟运行 10 次。测试实验的环境模型设置如图 11 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180006723.png" alt="image-20240118000616637"></p>
<p>q0 的值分别设置为 0.1、0.2、……、0.9。, 0.9。IHMACO 的其他主要参数设定为 K &#x3D; 100、M &#x3D; 50、α &#x3D; 1、β &#x3D; 7、Q &#x3D; 1、ρ &#x3D; 0.2。不同 q0 值的实验结果如图 12 所示。<br>如图 12 所示，当 q0 的取值范围在 [0.5, 0.6] 之间时，算法的转向时间和平均收敛生成量的性能都较好。考虑到图 12 所给出的结果，在仿真实验中将 $q_0$ 的初始值设为 0.5。</p>
<p>为了证明 q0 的大小对全局搜索能力和收敛速度有显著影响，我们又进行了一次综合统计实验。环境模型（20 × 20）设置为相同，如图 11 所示。起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。图 13 显示了不同 q0 值下最优解的演化曲线。<br>从图 13(a) 可以看出，当 q0 值较小时，ACO 具有很好的全局搜索能力，但收敛速度较慢。相反，随着 q0 值的增大，ACO 的收敛速度较快，且容易陷入局部最优解。同时，当 q0 取中间值 0.5 时，最优解在算法初期具有良好的离散性。此外，在迭代的中后期，算法的全局搜索能力减弱，容易达到局部最优。从图 13（b）可以看出，当 q0 采用自适应调整机制时，算法在迭代初期能有效地搜索到最优路径，收敛速度较快。随着迭代次数的增加，蜂群多样性得到提高，算法的全局搜索能力得到加强，有效避免了算法陷入局部最优。因此，可以得出结论：q0 的自适应调整机制能够很好地平衡全局搜索能力和收敛速度。</p>
<h3><span id="38-time-complexity-of-ihmaco-algorithm">3.8. Time complexity of IHMACO algorithm</span></h3><p>时间复杂度是判断算法运行效率的重要因素，也是反映算法性能的重要工具。一般来说，算法的时间复杂度由种群数量、实验环境空间维数和模型目标函数决定。假设参数初始化时间为 t0，信息素矩阵初始化时间为 G2-t1，其中 t1 为矩阵各节点初始化时间。初始化每只蚂蚁的时间为 t2。因此，初始化阶段的时间复杂度如式（15）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180009310.png" alt="image-20240118000931313"></p>
<p>在迭代过程中，最大迭代次数为 K，f (G) 是计算最优个体适应度值的时间。此外，从种群中选择最优个体的时间为 t3，替换最后一次迭代个体的时间为 t4。边界初始化阶段的时间复杂度如式（16）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180010105.png" alt="image-20240118001004100"></p>
<p>在单个位置更新阶段，假设计算权重的时间为 t5，则执行带有方向判断策略的启发式机制的时间为 8-t5。假设更新参数的时间为 t6，则通过式（12）和式（14）计算改进的伪随机转移策略和动态调整信息素蒸发率的时间为 2-t6，生成随机数的时间为 t7。然后，根据公式（8）选择下一个节点位置的时间为 M-t8。此外，信息素矩阵重新初始化的时间为 G2-t1。因此，单个位置更新阶段的时间复杂度可用公式（17）表示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180010394.png" alt="image-20240118001050315"></p>
<p>总之，IHMACO 的时间复杂度可以通过公式 (18) 计算出来。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011255.png" alt="image-20240118001109463"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011506.png" alt="image-20240118001131348"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011905.png" alt="image-20240118001150685"></p>
<h2><span id="4-experiments-and-numerical-analysis">4. Experiments and numerical analysis</span></h2><p>为了验证 IHMACO 在解决路径规划问题中的性能，本部分操作了一组实验。首先，第一组实验用于测试四种机制的改进效果。然后，第二组实验用于评估建议算法在四种不同实验环境中的适应性。此外，还比较了 ACO 的几个变体和六种广泛使用的算法（Dijkstra 算法、Bes-First Search 算法、A* 算法、Trace 算法、JPS 算法和 Breath-First Search 算法），以验证 IHMACO 在路径规划问题中的实用性和效率。所有算法均由 Matlab 2020a 进行编码，并在英特尔® 酷睿 i5-2400 <a href="mailto:&#67;&#x50;&#x55;&#64;&#51;&#46;&#48;">&#67;&#x50;&#x55;&#64;&#51;&#46;&#48;</a> GHz、2 GB 内存和 Windows 10 计算机上运行。</p>
<h3><span id="41-performance-verification-of-the-four-proposed-mechanisms">4.1. Performance verification of the four proposed mechanisms</span></h3><p>为了区分和检验四种机制的有效性，将每种机制与传统ACO有序结合，形成ACO的几种过渡变体，分别命名为ACO-1、ACO-2、ACO-3和IHMACO，如表2所示，并建立了一个空间环境模型（20×20）的实例，其中有几个凹陷的栅格陷阱，如图14所示。起始节点 S 和目标节点 T 用红点表示，它们的坐标分别为（0.5，19.5）和（19.5，0.5）。ACO 变体的初始参数设置如表 3 所示。由于智能算法的随机性，这些算法产生的解可能比新搜索过程中产生的解更好，也可能更差。因此，为了比较模拟结果，使用统计量是一个不错的选择。在本节中，每种算法独立运行 20 次来求解路径规划实例。这些算法得到的最优路径和收敛曲线如图 14 和图 15 所示，五种算法的结果如表 4 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180013660.png" alt="image-20240118001317762"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180013697.png" alt="image-20240118001338571"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180014130.png" alt="image-20240118001404098"></p>
<p>与 ACO 相比，增加了初始信息素浓度设置改进的 ACO-1 在最优路径长度（32.384&lt;34.042）、平均路径长度（33.213&lt;35.758）、转弯次数（8&lt;9）和收敛代数（68&lt;81）等方面都有更好的表现。特别是在收敛代数方面，表明这种改进能有效提高搜索效率，降低蚂蚁陷入僵局的概率。</p>
<p>然后，将 ACO-1 与进一步引入方向判断启发式机制的 ACO-2 进行比较。如表 4 所示，可以发现 ACO-2 在最优路径长度和平均路径长度方面都有明显更好的表现。ACO-2 的较好性能表明了所提出的带有方向判断的启发式机制的可用性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016673.png" alt="image-20240118001622336"></p>
<p>将 ACO-2 与 ACO-3 进行比较，可以发现 ACO-3 在转弯时间（6&lt;8）方面表现出色。但是，ACO-3 产生的收敛生成次数更多（38&gt;32）。这说明改进后的伪随机转移策略减慢了收敛速度。<br>将 ACO-3 与 IHMACO 比较，IHMACO 在所有指标上都有显著的表现。具体而言，IHMACO 可以获得最小的最优路径长度（31.556）、最小的转弯次数（4）和最少的收敛代数（19）。因此，所提出的信息素蒸发率动态调整方法可以很好地平衡全局搜索能力和收敛速度。</p>
<p>此外，图 14 和图 15 也显示了 IHMACO 更好的结果。对于这五种算法生成的最优路径，可以发现 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序有明显改善。同时，收敛曲线进一步验证了所提出的四种机制的有效性。总之，所提出的四种机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整，都具有提高 ACO 性能的作用。</p>
<h3><span id="42-performance-verification-in-different-environments">4.2. Performance verification in different environments</span></h3><p>为了评估所提出的 IHMACO 的适应性，本实验设计了四种不同的环境模型。表 5 总结了每个环境模型的特征和设计目标。同时，还使用了传统 ACO 进行比较。环境模型的设置如图 16 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。平心而论，IHMACO 的常用参数设置与传统 ACO 相同。具体来说，ACO 设置为 K &#x3D; 100、M &#x3D; 50、ρ &#x3D; 0.3、Q &#x3D; 1、α &#x3D; 1、β &#x3D; 4，IHMACO 设置为 K &#x3D; 100、M &#x3D; 50、ρ0 &#x3D; 0.3、Q &#x3D; 1、α &#x3D; 1、β &#x3D; 4、T0 &#x3D; 1、τ0 &#x3D; 1、εq &#x3D; 0.1、w1 &#x3D; 0.5、w2 &#x3D; 1。然后，每种算法独立运行 20 次，求解路径规划实例。实验结果如表 6 所示，两种算法得到的最优路径如图 16 所示。表 6 说明了与传统 ACO 相比，路径长度和转弯时间都有所改善。此外，Path_L_Improve 表示与其他算法相比改进路径长度的百分比，Differ_Length 表示 IHMACO 与其他算法在路径长度上的差异，其他算法的路径长度用 Path_Length 表示。转弯时间也可以用同样的方法得到，如公式 (19) 和 (20) 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016957.png" alt="image-20240118001638132"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016637.png" alt="image-20240118001652610"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180017443.png" alt="image-20240118001713449"></p>
<p>如表 6 所示，可以看出在这四种不同环境下，IHMACO 的效率均高于传统 ACO。特别是转弯时间，IHMACO 产生的转弯时间更少（环境 1，5&lt;13；环境 2，6&lt;17；环境 3，4&lt;9；环境 4，4&lt;9；）。在四种不同环境下，转弯时间的改善百分比分别为 61.54%、64.71%、55.56% 和 55.56%。在其他性能指标方面，IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（’’Std’’. 具体而言，IHMACO 得到的 “最佳 “路径长度分别为 29.213、29.799、31.556 和 30.384，小于 ACO。其中，环境 3 中最佳路径长度的改进百分比最多可提高 7.31%。IHMACO 所获得的路径长度 “平均值 “分别为 29.213、29.799、31.556 和 30.384，也小于 ACO。在环境 3 中，改进后的平均路径长度最多可增加 11.75%。 图 16 也显示了 IHMACO 的性能，IHMACO 的结果进一步验证了其优越性。总之，实验结果证明了改进算法在不同环境模型下求解路径规划实例的优越性和适应性。</p>
<h3><span id="43-comparison-experiments-with-other-variants-of-aco">4.3. Comparison experiments with other variants of ACO</span></h3><h4><span id="431-simulation-experiment-i">4.3.1. Simulation Experiment I</span></h4><p>在这一部分中，采用了 ACO 和文献[54]中提出的 ACO 的另一种变体，即改进型自适应蚁群优化（IAACO），与 IHMACO 进行比较，以验证其优越性。此外，还采用了六种常用的路径规划算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。环境模型与文献 [54] 一致，如图 17 所示。本实例的起始节点 S 用红点表示，其坐标为（0.5，19.5），位于环境模型的左上角。目标节点 T 也用红点表示，其坐标为（19.5, 0.5），位于环境模型的右下角。为公平起见，ACO 变体（ACO、IAACO、IHMACO）的共同参数设置为相同值。具体来说，ACO 和 IAACO 的参数设置为 K &#x3D; 100，M &#x3D; 50，λ &#x3D; 7，k &#x3D; 0.9，Q &#x3D; 2.5，α &#x3D; 1，β &#x3D; 7，σ1 &#x3D; 0.1，σ2 &#x3D; 0.9，Rs &#x3D; 0.5，δ0 &#x3D; 0.15，kL &#x3D; 0.7，kS &#x3D; 0.1，kE &#x3D; 0.2。IAACO 的具体参数可参见文献[54]，如 σ1 和 σ2（距离权系数，σ1 + σ2 &#x3D; 1）、λ（角度引导系数的权系数）、k（调整系数）。建议的 IHMACO 参数设置为 K &#x3D; 100，M &#x3D; 50，ρ0 &#x3D; 0.2，Q &#x3D; 2.5，α &#x3D; 1，β &#x3D; 7，T0 &#x3D; 1，τ0 &#x3D; 1，εq &#x3D; 0.1。这些算法的详细参数见表 7。ACO 及其变体算法独立运行 20 次。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019918.png" alt="image-20240118001900010"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019920.png" alt="image-20240118001917839"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019661.png" alt="image-20240118001936666"></p>
<p>此外，还采用了六种常用的路径规划算法，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法，与 IHMACO 进行比较。由于这六种常用算法都是确定性搜索算法，它们可以在多次运行中产生相同的解。因此，这六种确定性搜索算法得到的最优路径的最佳值和平均值总是相等的，而且它们只进行一次迭代搜索。表 8 记录并列出了每种算法在 20 次实验中的最佳值、平均值和标准偏差（Std.），产生的最优路径详见图 17-19。此外，收敛速度也是衡量算法效率的一个重要指标，四种改进 ACO 算法的收敛迭代曲线见图 20。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180020868.png" alt="image-20240118002017816"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180020208.png" alt="image-20240118002035030"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180021171.png" alt="image-20240118002106961"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180021865.png" alt="image-20240118002134667"></p>
<p>如表 8 所示，与 ACO 的其他变体相比，IHMACO 的性能最好。具体而言，虽然 IHMACO 的最优路径长度（29.79）与 IAACO 相同，小于 ACO（29.79 &#x3D; 29.79&lt;33.56），但从 “平均值”（29.79&lt;30.12&lt;36.61）和 “标准值”（0&lt;0.3953&lt;3.4189）来看，IHMACO 的性能更稳定。(0&lt;0.3953&lt;3.4189). 众所周知，”平均值 “和 “标准差 “是衡量智能算法总体性能的两个重要指标。IHMACO 产生的”‘Std’’. “值为 0，这意味着 IHMACO 总是能在 20 次独立操作中获得最佳路径长度（29.79）。上述 “平均值 “和 “标准值 “的统计结果证明，IHMACO 在稳定性能和收敛精度方面具有明显的优势。图 20 中的收敛迭代曲线也证明了 IHMACO 的出色稳定性。可以发现，IHMACO 不仅在收敛速度上占优势，而且在 ACO 陷入局部优化的情况下，IHMACO 的 “Std”.代找到了更精确的解，具有明显的优越性。因此，与 ACO 和 IAACO 相比，IHMACO 可以综合考虑长度和转弯次数等因素，在路径规划中取得更好的效果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180023951.png" alt="image-20240118002332815"></p>
<p>与六种常用算法相比，虽然IHMACO的最优路径长度（29.79）与Dijkstra算法、A* 算法、JPS算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和Trace算法（29.79&lt;31.56&lt;32.73）。在其他性能指标方面，IHMACO产生的最优路径的转弯次数均少于Dijkstra算法、A *  算法、Best-First Search算法、Trace算法和Breath-First Search算法。考虑到最优路径的路径长度、收敛生成和转弯时间的综合性能，表 8 中的结果验证了在本实例中，IHMACO 与 ACO、IAACO、Dijkstra 算法、A * 算法、最佳第一搜索算法、跟踪算法和呼吸第一搜索算法相比具有更优的性能。图 17-19 也证明了 IHMACO 更好的性能。事实上，IHMACO 所获得的最优路径的高质量得益于所提出的具有方向判断能力的启发式机制、信息素蒸发率的动态调整，而寻找最优路径的高效率则得益于所提出的改进的伪随机转移策略、自适应信息素浓度设置。</p>
<p>此外，如图 20 所示，考虑到收敛速度和求解精度，IHMACO 的优势更加明显，远远领先于 ACO 的其他变体。IHMACO 的平均收敛代小于 ACO 和 IAACO（5.8&lt;6.4&lt;23.1）。总之，与 ACO、IAACO、Dijkstra 算法、A* 算法、Best-First Search 算法、Trace 算法和 Breath-First Search 算法相比，IHMACO 能以更高的效率获得更好的最优解。为了进一步证明 IHMACO 的优越性，应使用更多的实例和采用更多的方法进行比较。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180023388.png" alt="image-20240118002351376"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180024202.png" alt="image-20240118002411119"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180024160.png" alt="image-20240118002426125"></p>
<h3><span id="432-simulation-experiment-ii">4.3.2. Simulation experiment II</span></h3><p>在这一部分，通过文献[55]中给出的一个智能轮椅的简单路径规划示例来测试 IHMACO 的性能。此外，文献[55]中提出的三种改进型 ACO（IACA、GPACA 和 APACA）、Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法也被用来进行比较。为公平起见，环境模型（20 × 20）的设置与文献[55]相同，如图 21 所示。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。此外，IHMACO、IACA、APACA 和 GPACA 的详细参数见表 9。十种算法的计算结果见表 10，其生成的最优路径见图 2123。图 24 给出了四种 ACO 算法的收敛迭代曲线。如图 21 所示，可以发现 IHMACO 的性能优于 IACA、GPACA 和 APAC。具体而言，在 “最佳 “结果中，IHMACO 获得了最佳路径长度（28.038 &#x3D; 28.038&lt;29.210&lt;30.380）。就 “平均值 “而言，拟议的 IHMACO 得出的结果最佳（28.038&lt;29.184&lt;32.708&lt;35.357）。在 “标准值 “方面，IHMACO 的值为 0，表明在所有比较算法中，IHMACO 的偏差最小，稳定性最好（0&lt;1.0020&lt;4.2827&lt;4.3764）。图 24 中 IACA、GPACA、APAC 和 IHMACO 的收敛曲线也证明了所提出的 IHMACO 具有极佳的稳定性和鲁棒性，其他 ACO 变体在迭代后期缓慢收敛到某个最优解，而 IHMACO 在迭代过程中迅速接近最优解。IHMACO 的迭代次数为 4 次，少于 24 次（IACA）、12 次（GPACA）和 9 次（APACA）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180025380.png" alt="image-20240118002548325"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180026654.png" alt="image-20240118002611565"></p>
<p>与六种确定性搜索算法相比，虽然 IHMACO、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法获得的最优路径长度相同（28.038），但 IHMACO 产生的转弯次数比 Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法最少，如表 10 所示。IHMACO 性能较好的原因在于所提出的机制，包括自适应信息素浓度设置和带有方向判断的启发式机制。图 22-23 也证明了 IHMACO 的优异性能。综上所述，与 IACA 算法、GPACA 算法、APACA 算法、Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法相比，IHMACO 可以获得智能轮椅路径规划实例的最优解。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180026370.png" alt="image-20240118002638036"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180027494.png" alt="image-20240118002700582"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180027786.png" alt="image-20240118002720808"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180028133.png" alt="image-20240118002805119"></p>
<p>如表 11 所示，可以看出 IHMACO 的效率高于 ACO 和 IACO [56]。特别是在路径长度方面，IHMACO产生的最短路径长度为30.9706，小于ACO的39.6985和IACO的31.7990。在其他性能指标方面，IHMACO 产生的转弯次数为 11，是最小的（11&lt;13&lt;17）。图 25 也可以证明 IHMACO 的显著改进性能，可以看出 ACO 和 IACO 都陷入了死锁栅格，导致算法进入局部最优。此外，IHMACO 的最佳收敛代小于 IACO 和 ACO（8&lt;13&lt;62）。IHMACO 的较好结果进一步验证了其在提高全局搜索能力方面的优势，从而提高了 ACO 的收敛精度。与其他六种确定性搜索算法相比，所提出的 IHMACO 比 Best-First Search 算法和 Trace 算法性能更优。最佳第一搜索算法和跟踪算法生成的路径长度较长，且有很多多余的转弯时间。IHMACO 的出色表现表明了所介绍的四种机制的效率。IHMACO 和其他六种确定性搜索算法获得的最优路径如图 26-27 所示，IHMACO 的出色表现进一步证明了其优越性。</p>
<h3><span id="434-simulation-experiment-iv">4.3.4. Simulation experiment IV</span></h3><p>在本节中，文献[57]中提出的一种方法与所提出的 IHMACO 在相同的模拟实验中进行了比较。此外，还采用了另外六种算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。为公平起见，IHMACO 与文献[57]中算法的公共参数设置相同。文献[57]中的算法参数设置为 M &#x3D; 30，K &#x3D; 200，ρ &#x3D; 0.43，Q &#x3D; 100，α &#x3D; 1，β &#x3D; 7，γ &#x3D; 3，γ 表示导向系数。IHMACO 设为 M &#x3D; 30，K &#x3D; 200，ρ0 &#x3D; 0.43，α &#x3D; 1，β &#x3D; 7，T0 &#x3D; 1，Q &#x3D; 100，w1 &#x3D; 0.3，w2 &#x3D; 1。随后，每种算法独立运行 20 次。这八种算法的模拟结果见表 12，其生成的最优路径见图 28-30。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180028301.png" alt="image-20240118002836381"></p>
<p>从表 12 可以看出，虽然 IMHACO 的最优路径长度（29.79）与文献[57]中提出的 Dijkstra 算法、A* 算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和跟踪算法（29.79&lt;31.56 &#x3D; 31.56）。特别是在这些不同算法得到的转弯时间中，IHMACO 可以得到最平滑的路径，转弯时间最少（8），其较好的性能也可以从图 2830 中得到证明。实际上，IHMACO 的主要性能得益于自适应信息素浓度设置的启发式机制、方向判断的启发式机制、改进的伪随机转移策略、信息素蒸发率的动态调整。这四种机制兼顾了 ACO 的全局探索和局部利用能力。总之，考虑到路径长度、收敛生成和转弯时间等综合性能，实验结果表明，在本实例中，IHMACO与文献[57]中提出的算法、最佳第一搜索算法、Dijkstra算法、A*算法、Trace算法和呼吸第一搜索算法相比具有更优越的性能。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180030199.png" alt="image-20240118003025298"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180030336.png" alt="image-20240118003040388"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031122.png" alt="image-20240118003121995"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031525.png" alt="image-20240118003135479"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031777.png" alt="image-20240118003158787"></p>
<h3><span id="435-simulation-experiment-v">4.3.5. Simulation experiment V</span></h3><p>本节使用文献[58]中提出的一个更复杂的路径规划实例进行比较。此外，还采用了 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法进行比较。在这个 30 × 30 空间环境模型中，S 和 T 的坐标分别为（0.5，8.5）和（25.5，28.5）。为了公平起见，文献[58]和 IHMACO 算法的常用参数设置相同。这八种算法的仿真结果见表 13，其生成的最优路径见图 31-33。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031019.png" alt="image-20240118003105148"></p>
<p>从表 13 中可以看出，与文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法相比，IHMACO 的性能更优。尽管文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、跟踪算法和呼吸优先搜索算法获得的最优路径长度相同，但 IHMACO 能产生较小的转弯时间。JPS 算法的转弯次数略少于 IHMACO，但 IHMACO 无法保证最短路径长度。此外，IHMACO 生成的最优路径长度的 “平均值 “和 “最佳值 “均为 35.63，这表明了 IHMACO 的稳定性。图 31-33 也证明了 IHMACO 的出色性能。总之，IHMACO 的综合结果进一步证明了它在这一复杂环境模型中的优势。事实上，IHMACO 的优异结果得益于所提出的四种机制。</p>
<h2><span id="44-summarization-of-case-study">4.4. Summarization of case study</span></h2><p>在这一部分中，通过一系列实验将 IHMACO 应用于解决路径规划问题。在第一组实验中，采用了几种 ACO 的过渡变体，分别命名为 ACO-1、ACO-2、ACO-3 和 IHMACO，以区分四种机制的有效性。五种算法得到的最优路径和收敛曲线按照 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序逐渐变好，可以得出结论：四种机制对提高 ACO 的性能有一定的作用。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180034599.png" alt="image-20240118003447101"></p>
<p>在第二组实验中，设计了四种不同的环境模型来评估所提出的 IHMACO 的适应性。与传统 ACO 相比，IHMACO 在路径长度和转弯时间方面更胜一筹。具体而言，IHMACO 在路径转弯时间方面的相对改进率分别为 61.54%、64.71%、55.56% 和 55.56%。而 IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（”Std”. 总之，本实验证明了 IHMACO 在不同环境模型中解决路径规划实例的有效性和适应性。</p>
<p>在第三组实验中，采用了五个实验来比较 IHMACO 与 ACO 的其他变体以及六种常用路径规划算法。具体而言，在所有实验中，IHMACO 的整体性能普遍优于 ACO 的九种变体。在 IHMACO 与六种常用路径规划算法的比较中，就路径长度和转弯时间的综合结果而言，IHMACO 在全部五组仿真实验中普遍优于 Best-First Search 算法和 Trace 算法，在三组实验中优于 Dijkstra 算法，在四组实验中优于 A* 算法，在三组实验中优于 JPS 算法，在三组实验中优于 Breath-First Search 算法。总之，实验结果验证了所提出的 IHMACO 算法的高效性和优越性。</p>
<h2><span id="5-conclusion">5. Conclusion</span></h2><p>本研究提出了一种改进的启发式机制 ACO（IHMACO），以克服传统 ACO 在解决路径规划问题时的不足。首先，提出了一种自适应信息素浓度设置方法，以加强引导能力，避免早期阶段的过度发散。其次，提出了一种新颖的带有方向判断的启发式机制方法，有效增强了搜索目的性和规划路径的平滑性。第三，引入改进的伪随机转移策略，以最大限度地保持全局搜索能力和收敛速度。然后，提出了一种动态调整信息素蒸发率的方法，以增加蜂群的多样性，避免陷入局部最优。随后，进行了一组路径规划的仿真实验，验证了所提算法的适应性和优势。此外，IHMACO 还与现有的九种 ACO 变体和六种常用算法（包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法）进行了比较。由路径长度的’’最佳’’、’’平均’’、’’标准’’组成的实验结果验证了 IHMACO 在最优解搜索能力上的优势，尤其是在转弯次数上明显优于其他算法。总之，所提出的四种机制能有效提高 ACO 的性能，IHMACO 与其他算法相比，具有实用性和高效率的能力，能获得相应路径规划实例的最优解。</p>
<p>然而，IHMACO 的研究和应用仍处于起步阶段，存在一些不足之处，有待进一步研究。例如，与确定性搜索算法相比，IHMACO 的执行时间不具有竞争力，这主要是由算法机制造成的。下一步工作中，将着重提升算法的效率和精度，将其应用于动态空间环境和三维路径规划中求解。此外，还可以建议将 IHMACO 用于其他实际应用中，如管道路由设计，以进一步提高其在实际工程问题中的应用能力。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-10T16:53:51.000Z" title="2024/1/11 00:53:51">2024-01-11</time>发表</span><span class="level-item"><time dateTime="2024-01-16T13:49:43.746Z" title="2024/1/16 21:49:43">2024-01-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约10053个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/11/Classical-and-Heuristic-Approaches-for-Mobile-Robot-Path-Planning-A-Survey/">Classical and Heuristic Approaches for Mobile Robot Path Planning A Survey</a></p><div class="content"><h1><span id="classical-and-heuristic-approaches-for-mobile-robot-path-planning-a-survey">Classical and Heuristic Approaches for Mobile Robot Path Planning: A Survey</span></h1><p>作者：Jaafar Ahmed Abdulsaheb and Dheyaa Jasim Kadhim *</p>
<p>摘要： 机器人学最重要的研究领域是导航算法。机器人路径规划（RPP）是指在移动机器人移动前为其选择最佳路径的过程。寻找理想或接近理想的路径被称为 “路径规划优化”。其目标是找到满足单个或多个目标（如最短、最平滑和最安全的路径）的最佳解决方案值。本研究旨在概述移动机器人的导航策略，这些策略采用了三种经典方法，即 路线图方法（RM）、单元分解（CD）和人工势场（APF），以及十一种启发式方法，包括遗传算法（GA）、蚁群优化（ACO）、人工蜂群（ABC）和灰狼优化（GWO）、 蛙跳算法 (SFLA)、鲸鱼优化算法 (WOA)、细菌觅食优化 (BFO)、萤火虫算法 (FF)、布谷鸟搜索 (CS) 和蝙蝠算法 (BA)。本研究中介绍的不同文章涉及多个问题，包括动态目标、静态和动态环境、多机器人、实时模拟、运动学分析和混合算法。在本作品的最后将进行讨论，并提供详尽的表格和图表，以帮助读者了解开发了哪些类型的路径规划策略，可用于各种生态环境。因此，本作品的主要贡献在于，它为机器人路径规划提供了一个广阔的视角，这将为科学家们在不久的将来研究这一课题提供更多便利。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>机器人是一种能够对周围环境做出反应，并（通过传感器）收集环境信息，从而安全执行各类任务的机器。自主机器人可以在没有人类直接控制的情况下自行操作和移动。与制造工厂中使用的机器人不同，在制造工厂中，机器人所处的环境受到严格控制且完全已知，而自主机器人则不可能总是通过编程来执行预定义的动作，因为机器人不可能预测可能遇到的各种情况。此外，环境可能是不可预测的，也可能随着时间的推移而发生变化，这就意味着机器人的动作必须在线快速改变[1]。自主机器人的应用包括医院的快递员、保安、军事监控、航空航天研究、环境监测、清洁工和割草机。一般来说，最重要的应用之一是在危险领域（如雷区或核电站内部）使用自主移动机器人。由于移动机器人与生俱来的自主性，必须克服一系列挑战，包括不确定性、感知误差、规划、学习、可靠性和实时响应[2]。机器人需要动态响应变化并适应环境。</p>
<p>机器人路径规划学科的雏形可以追溯到 20 世纪 60 年代中期。机器人路径规划问题，通常称为机器人路径规划（RPP），是移动机器人导航领域的一个重要问题。&#x3D;&#x3D;其目标是确定在指定环境中，从预定位置出发，以目标目的地为终点，没有任何碰撞的最佳路径。&#x3D;&#x3D;一般来说，机器人有无数条路线可以到达目的地，但最佳路线实际上是根据一系列规则来选择的。最广泛使用的标准是距离最短、耗能最少或时间最短、距离最短。由于路径规划的目标是找到最短路径，同时牢记给定环境和无碰撞运动等约束条件，&#x3D;&#x3D;因此可以将其视为一个优化问题[3]&#x3D;&#x3D;。移动机器人的地图、定位和导航可以通过环境模型来实现。然而，这些模型中的数据量必须易于管理，并能满足实时计算的要求。机器人领域一个非常棘手的问题是机器人路径的规划。主要目标是在不撞到任何东西的情况下，找到一条从起点到终点的路线。&#x3D;&#x3D;在解决机器人导航问题时，必须考虑三个关键问题：效率、安全性和准确性。效率要求算法避免让机器人多走几步或反复停下来转弯，这样会浪费时间和精力，以便在最短的时间内确定最短的距离。安全性和准确性取决于找到一条不会撞到任何东西的路径，同时保持在该路径附近[4]。&#x3D;&#x3D;机器人导航问题可分为定位、路径规划、运动控制和认知映射，如图 1 所示。路径规划可能是机器人导航最重要的方面 [5]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401110955430.png" alt="image-20240111013711561"></p>
<p>根据其所在位置[6]，区域淘汰计划可分为两类：</p>
<p>(a) 在静态环境中遇到固定障碍物时的 RPP。<br>(b) 在动态环境中面对静止和移动障碍物时的 RPP。</p>
<p>这两类中的每一类又可细分为一个子群。&#x3D;&#x3D;全局路径规划&#x3D;&#x3D;，即环境中的机器人可以在开始移动之前（离线）规划好整体路径，因为它们掌握了静止障碍物的完整信息，而移动障碍物的轨迹也是事先已知的。由于设置新地图具有挑战性，因此全局导航中环境变化的成本非常高，尤其是在动态环境中。无法利用完整的环境知识规划本地路线是本地路径规划的一个局限。移动机器人在环境中移动时，会使用传感器收集信息（在线）。机器人必须反复移动到新的位置，感知周围环境，更新地图，规划下一步行动路线，从而绘制出周围环境的地图。局部路径规划面临着一系列挑战，包括传感器读数误差、传感器约束、多变的环境条件、机器人动力学、位置估计和机器人运动限制等[6]。在极其复杂和广阔的环境中，本地路径规划可能无法确定通往目标的路径。出现这种情况的主要原因是传感器无法提供足够的数据，将机器人送至理想位置[7]。机器人的基本位置、旋转以及整个链路的旋转或平移称为机器人的配置。所有可能配置的集合构成了配置空间或 c 空间，它需要几个元素：</p>
<ol>
<li><p>描述机器人的形状，如是否有腿、轮子或没有四肢（运动）。</p>
</li>
<li><p>解释机器人所处的环境，包括其几何形状（二维或三维工作空间）。</p>
</li>
<li><p>环境必须有一个起点和目标配置，必须在这两个配置之间规划机器人的路径。</p>
</li>
</ol>
<p>一些参数用于描述机器人的工作空间配置。例如，两个参数（通常称为 x 和 y）可用于描述机器人的配置，将其转换为二维工作空间。机器人工作区内的障碍物会阻止某些配置的使用。例如，配置为 C 的机器人如果与工作区的任何障碍物发生碰撞，就会被禁止使用。由此，配置空间 C 被划分为一组禁止配置 C forbited 和一组允许配置 C free。一般来说，路径被定义为一个连续函数 π : [ 0, L ] → C，以路径的长度 L 为参数。路径规划问题是在给定的起点配置 s∈C 和目标配置 g∈C 之间找到一条无（碰撞）路径。就配置空间 C 而言，通过找到一条路径 π，使 π ( 0 ) &#x3D; s 和 π ( L ) &#x3D; g，并且 ∀(t∈ [ 0, L ] :π ( t )∈C f ree ) [8]。绘制地图是构建环境模型的过程。为了绘制出足够精确的地图，显示机器人沿途所见，必须准确显示地形。有不同类型的地图可用于表示环境。其中一些使用栅格，栅格中的单元格要么是空的，机器人可以在其中自由行进，要么是被占满的，以表示障碍物，如图 2 所示。如图 3 所示，其他人使用二维（或三维）矩形或正方形工作空间，障碍物为多边形。</p>
<p>许多研究人员都提交了有关移动机器人导航的调查论文[9-11]；然而，这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在发现特定领域的研究空白和创新范围。它深入分析了静态环境中的单个算法、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合，以及在三维（3D）环境中的应用。</p>
<p>调查还强调了传统方法和反应式方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。在参考文献[9]中，该方法仅限于路径计算。[9]中，该方法仅限于三维路径规划，而参考文献 [10]综述了适用于各种机器人类型（包括空中、地面和水下机器人）的多机器人路径规划方法和决策策略。参考文献 [11 [11]主要研究了移动机器人路径规划的多目标优化算法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001404.png" alt="image-20240111100109345"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001670.png" alt="image-20240111100135547"></p>
<p>本综述编排如下： 第 2 节讨论机器人路径规划技术，第 3 节讨论移动机器人导航建模，第 4 节是讨论。</p>
<h2><span id="2-robot-path-planning-techniques">2. Robot Path Planning Techniques</span></h2><p>机器人的路径需要优化以满足某些标准，因此路径规划问题是一种优化问题。过去几十年来，优化算法的研究吸引了众多研究人员的关注。优化方法和算法分为确定性和随机性两类 (12]。&#x3D;&#x3D;随机方法更善于发现各种目标函数的全局最优解，而确定性方法则依赖于问题的数学属性。&#x3D;&#x3D;相反，随机方法并不依赖于特定函数的数学属性，如参考文献[13]所述。然而，最初的方法也存在一些局限性，包括依赖梯度、容易出现局部最优、在&#x3D;&#x3D;搜索大规模空间时效率低下&#x3D;&#x3D;，以及无法处理离散函数。基于随机过程的技术被认为具有更高的用户友好性。由于现实世界中许多优化问题的复杂性，特别是在优化无差别、多模态和离散复杂函数时，随机方法是必要的–这些算法已被发现优于基于梯度的经典方法。这些受自然启发的范式目前正被广泛应用于众多工程领域 [14]。这些技术已被证明是可靠而强大的搜索方法。</p>
<p>多年来，众多科学家和研究人员提出了各种导航方法。移动机器人的导航方法大致可分为两类：经典方法和启发式方法（图 4）。&#x3D;&#x3D;经典方法存在一些缺陷，导致其在实际应用中效果不佳，包括高维度下的高时间复杂性问题和陷入局部极小值的现象，这些都是该领域的重大问题。&#x3D;&#x3D;启发式方法优于传统方法，并因 PP 问题的 NP 难度而广受欢迎。启发式技术在解决涉及多维度、复杂工作空间和局部极小值的问题方面也取得了成功，因此越来越受欢迎[15]。在下面的研究小节中，我们将考察一组使用经典方法和启发式方法寻找最佳单目标或多目标路径规划的科研成果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160852835.png" alt="image-20240116085249597"></p>
<h2><span id="21-classical-approaches">2.1. Classical Approaches</span></h2><p>我们将在下文中讨论用于寻找最佳单目标或多目标路径的三种经典方法：</p>
<ol>
<li>路线图（可视图 [16]；沃罗诺图 [17]）： 如图 5 所示，路线图方法（RM）涉及将自由 C 空间重新制定、缩小或映射到一维工作空间。Salzman 研究了 RM 在自主移动机器人导航中的应用[18]。在规划阶段，机器人的配置空间是随机生成的，会产生特定数量的节点。然后，在确保路径不与任何障碍物相交的前提下，通过直线连接节点对来构建路线图。根据规划阶段获得的结果，查询阶段设计出一条连接初始配置和目标配置的路径。如参考文献[19]所述，对 Voronoi 图的有效路径规划进行了改进，以优化其性能并减少突然转向和扩展环路等问题。如参考文献[20]所述，通过采用一种混合方法，将可视图、沃罗诺伊图和势场技术相结合，确定最佳路径。学者们强调，这种方法无法确定最佳路径，在实施过程中也面临挑战。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160857115.png" alt="image-20240116085749819"></p>
<p>Yang 等人（21）采用骨架图和维诺图等技术，有效地制定了路线战略。Wein 等人[22]提出了一种新方法，它将可视图和维诺图整合在一起，以确定最佳路线。&#x3D;&#x3D;Kavraki 等人在他们的工作（23）中展示了概率在机器人运动中的应用，目的是理解和产生路径规划解决方案。然而，该方法在获得理想路径长度方面效果不佳。Sanchez 等人（24）利用概率路线图方法对概率路径规划稍作修改，改进了最短路径确定方法（PRM），提出了懒碰撞检查策略作为实际路径规划问题的解决方案。&#x3D;&#x3D;Yan 等人（25）成功测试了无人飞行器在三维环境中的导航能力。这种方法同时使用概率公式和路线图来确定飞行路径。一种在动态环境中避开障碍物的创新路径规划算法被称为 “时间-PRM”（26）。通过在原始概率路线图（PRM）中加入时间概念，该算法创建了一个可有效查询的增强结构。</p>
<p>Huang 等人在（27）中介绍了利用启发式机器人在线路径规划（HIRO）的方法，与传统方法相比，无论机器人是否事先了解环境，该方法都能显著加快发现无碰撞路径的速度。为了快速寻找路径，HIRO 同时采用了知情启发式和确定性路线图。概率路线图（PRM）因其简单易行而被广泛应用于移动机器人导航。&#x3D;&#x3D;当环境中存在狭窄通道时，概率路线图的效率就会大大降低。&#x3D;&#x3D;Zhang 等人 [28] 提出了一种改进的基于势场的概率路线图算法。在具有大量复杂约束和高维度的环境中，概率路线图（PRM）可以成功地解决路径规划问题。其缺点是在狭窄空间和动态环境中的路径规划质量和效率较差。最后，You 等人[29] 建议使用动态 PRM 混合势场来规划移动机器人在多维环境中的路径。</p>
<ol start="2">
<li>单元分解（Cell decomposition CD）[30]： 为了确定连接初始配置和目标配置的路径，无障碍配置空间被划分为一系列单元格。如图 6 所示，在开始单元和终止单元之间建立连接以及随后通过一系列中间单元建立连接决定了单元关系。Samet [31] 和 Noborio [32] 提出了利用四叉树进行分解的方法。大的栅格单元分割环境；然而，当一个栅格单元只填满一部分时，它就会被分解成四个相同大小的小部分，直到填满为止。该系统的缺陷在于，当有新信息（如障碍物的位置）出现时，它无法更新程序，因此在动态环境中效果不佳。&#x3D;&#x3D;Lingelbach [33] 证明了路径规划的高维静态配置问题是存在的&#x3D;&#x3D;。他为类似链条和迷宫的机器人平台找到了路径规划问题的解决方案。利用基于 CAD 的数据，Sleumer 等人[34]提出了一种移动机器人的路径规划策略。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161004274.png" alt="image-20240116100419776"></p>
<p>Cai 等人 [35]的研究表明，使用传感器的粗糙 cell decomposition 可以将复杂环境中的许多固定目标分成不同的组。在静态环境中，所开发的方法效果最佳，因为它能选择最短的路线并覆盖整个环境。Dugarjav 等人（36）利用基于传感器的 CD 模型仍然适用于处理移动机器人不熟悉的直线工作空间。他们利用 CD 策略和激光扫描机制绕过了不熟悉的位置和物体。&#x3D;&#x3D;Glavaski 等人[37]提出了一种混合方法，以解决路径规划问题中理论进展与实际考虑之间的差异。为了减少计算费用，他们开发了一种基于 APF 方法的精确 CD 路径规划器。&#x3D;&#x3D;Tunggal 等人 [38] 介绍了如何利用 CD 和模糊逻辑来实现不确定性环境中的实时运行。</p>
<p>Mark 等人[39]的论文旨在阐明贪婪深度优先搜索算法和利用遗传算法 (GA) 的 CD 技术的机理，目的是规划机械手系统的三维路径。Gonzalez 等人[40] 通过改变图权重、航点计算方法和 CD，对路径进行了定量分析。Wahyunggoro 等人[41]介绍了利用 CD 方法探索三维环境在空中导航问题上的应用。在该方法中，CD 方法和模糊逻辑一起用于引导和控制航空飞行器。[42] 与垂直（VCD）算法相比，径向 CD（RCD）算法能产生更短的路径。&#x3D;&#x3D;杂乱环境和走廊环境都能从 RCD 算法中受益。RCD 在路径长度和处理时间方面的有效性得到了仿真结果的支持。&#x3D;&#x3D;</p>
<ol start="3">
<li>人工势场（APF）： 如图 7 所示，本方法涉及一个配置空间，该空间由两种不同的力组成，一种是排斥力，其作用方式是将机器人从障碍物中驱逐出去；另一种是吸引力，其作用方式是将机器人引向所需的目标配置。Khatib (43) 是 1986 年将 APF 方法引入移动机器人导航的先驱。按照他的说法，目标和障碍物就像通电的表面，机器人受到由它们的势能总和产生的假想力的作用。这个假想力（如图 7 所示）将机器人推向所需的方向，使其不会冲向障碍物。在这里，机器人沿着负梯度绕过障碍物，到达理想位置。Garibotto 等人[44]介绍了这种方法在移动机器人导航中的应用。Kim 等人（45）讨论了一种利用 APF 在未开发环境中避开障碍物的新技术。为了绕过局部最小值的问题，他们使用了谐函数。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161017039.png" alt="image-20240116101702985"></p>
<p>Borenstein 等人[46] 提供了另一种解决局部最小条件问题的方法。他们在研究中考虑了机器人的动态导航特性。在参考文献[47,48]中，对动态避障背景下的 APF 进行了研究。通过利用静电定律，APF 方法在某些方面得到了改进[49]，利用静电可以产生势函数并即时确定无碰撞路径。在实时环境中，移动时避开障碍物是一项艰巨的任务；因此，Huang [50] 开发了一种控制速度的方法，以确定障碍物的位置和移动方式。&#x3D;&#x3D;Shi 等人[51] 提出的 “超强势能 “和 “超强排斥势能 “指的就是这两种功能，以防止局部最小值并达到全局最大值。&#x3D;&#x3D;Sfeir 等人[52]研究了移动机器人的导航问题，该问题可通过采用振荡和冲突等 APF 技术来解决。他们改变了 APF，使其在目标靠近障碍物时不易发生振荡和产生问题。</p>
<p>Pradhan 等人[53]使用 ROBOPATH 仿真工具测试了人工势场的适用性。人工势场法被认为是最流行的路径规划技术之一。为了解决无法到达目标的问题，文章[54]增强了斥力场函数。当它陷入陷阱时，它会选择一个虚拟目标点来帮助它解脱。文章[55]的主题是将人工势场方法应用于环境数据不可知的静态障碍物。通过 MATLAB 仿真证明，改进后的人工势场方法偶尔可以绕过局部极小值，顺利到达目的地。Shi 等人[56]涉及多智能体编队避障控制，研究了步长对路径规划的影响，并提出了两种使路径更高效的方法。&#x3D;&#x3D;知情快速探索随机树星（RRT*）算法会进行质量检查，并重新优化采样路径&#x3D;&#x3D;。Liu 等人提出了一种更有效的 APF 局部避障路径规划算法[57]。根据仿真结果，该算法提高了动态避障的稳定性，改进后的势场法得到的航向角变化减少了 84%。该算法可应用于车辆的实时避障。</p>
<p>随后，又有人尝试改进这些经典方法，如概率路线图（PRM）和快速探索随机树（RRT*）。此外，还出现了结合经典方法和启发式方法的混合方法，以利用两种技术的优势（模拟退火（SA）与人工势场（APF）[58]）。&#x3D;&#x3D;启发式方法旨在克服传统方法的局限性，如陷入局部最小值的问题。&#x3D;&#x3D;以下各小节列出了其中一些启发式方法：</p>
<h2><span id="22-heuristic-approaches">2.2. Heuristic Approaches</span></h2><p>我们将在下文中讨论十一种用于寻找最佳单目标或多目标路径的启发式方法：</p>
<ol>
<li>遗传算法（GA）： 这是一种著名的基于搜索的优化工具，秉承了 1958 年布雷默曼[59]对遗传学和自然选择的发现。1975 年，Holland [60] 首次将其引入计算机科学领域。机器人导航只是目前广泛应用的众多科技领域之一。机器人导航是科学和技术领域的一项普遍应用。该主题涉及复杂问题的优化，这些问题要求在遵守预先设定的约束条件的同时，实现目标函数的最大化或最小化。这种方法涉及将由具有独特遗传特征的个体组成的群体分配到特定问题中。随后，种群中的每个成员都会被分配一个由目标函数决定的适应度分数。根据个体的适应度值选择个体，并允许个体与后代进行交叉，以确保遗传物质的传递。变异可防止过早趋同，并保持群体的多样性。</li>
</ol>
<p>如果种群已经收敛，则算法结束。&#x3D;&#x3D;遗传算法具有一定的随机性，但由于它也可以使用历史数据，因此其性能优于随机局部搜索。&#x3D;&#x3D;GA 的一般流程图如图 8 所示。机器人技术的难点之一是多机器人路径规划。&#x3D;&#x3D;Kala [61] 借助 GA 探讨了多移动机器人的路径规划策略。通过他的研究，研究人员开发出一种有效的方法来协调多个机器人，以避免在静止环境中发生碰撞。参考文献[62]对静态环境下的多目标策略进行了说明。&#x3D;&#x3D;[62] 针对静态环境，类似于多机器人路径规划。Yang 等人[63] 解决了动态环境中多移动机器人系统导航的问题。他们展示了在存在静态和移动障碍物时的结果。一些研究表明，&#x3D;&#x3D;GA 具有一定的局限性，如收敛速度慢、无法保证获得最优解、选择突变率和种群规模参数的方法繁琐等。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161034489.png" alt="image-20240116103439016"></p>
<p>Hong 等人[64]提出了改进的遗传算法路径规划器，其中包含了基于种群的机器人导航协同评估机制。通过应用改进的遗传算法，作者证明了在陌生环境中运行的多机器人系统在避障和路径优化方面的仿真结果得到了增强。建军等人[65] 提出了一种不同的用于路径优化的改进型遗传算法，为了达到最佳效果，他们的方法修改了染色体的长度。GA 方法被用于仿人机器人（66）的二维路径规划以及水下机器人（67）和空中机器人（68）的三维路径规划问题，因为它能有效地适应环境（包括已知环境和未知环境）。&#x3D;&#x3D;Patle 等人 [69] 针对单机器人和多机器人系统，开发了一种利用二进制代码的基于矩阵的 GA（MGA）来解决移动目标问题。&#x3D;&#x3D;在这种方法中，机器人可以快速、轻松地跟随移动目标和障碍物到达目的地。</p>
<p>Creaser 等人（70）展示了一个结合了模糊逻辑和 GA 方法的导弹控制演示。在为导弹创建制导法则的过程中，GA 起着至关重要的作用。Lin 等人（71）介绍了一种基于 GA 的军事和海洋监测创新方法。在 GA 的帮助下，他们能够确保关键军事资产的安全，并确定水下传感器网络的最佳定位策略。[72]的作者试图找到一种机器人路径规划问题的解决方案，以解决收敛速度慢和局部最优容易衰减的问题，并提出了一种基于种群多样性水平评估的自适应选择技术。为了证明该算法的可行性和有效性，我们在栅格环境中进行了多次仿真。在改进种群初始化方法后，(73) 采用双向 RRT 算法替换部分种群，以创建精英种群。结果表明，本文提出的精英种群遗传算法弥补了传统遗传算法的缺陷。</p>
<ol start="2">
<li>蚁群优化（ACO）： 1992 年，马可-多里戈（Marco Dorigo）在论文中提出了这一群体智能算法（74]。为了解决组合优化问题，该算法采用了基于种群的方法。蚂蚁群从巢穴到食物来源的有效导航是 ACO 算法的灵感来源（图 9）。ACO 算法已在许多科学和工程领域得到应用，包括图着色、二次赋值问题、车辆路由、旅行推销员问题、作业车间调度等。关正等人[75]将 ACO 应用于移动机器人的实时路径规划。与 GA 等其他算法相比，ACC 算法在动态收敛行为、解的变化、收敛速度和计算效率等方面都有所提高。Liu 等人（76）介绍了 ACO 在多移动机器人导航中的应用。他们为静止环境中的不同机器人系统提供了一种避免碰撞的方法。为了增强选择性策略，他们使用了一个特殊函数。当蚂蚁遇到死角时，会对轨迹强度施加惩罚函数，以防止机器人的路径无法移动。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161039669.png" alt="image-20240116103909463"></p>
<p>Castillo 等人[77] 提出了一种基于 ACO-模糊的混合方法，用于移动机器人在静态环境中的导航。Kumar 等人(78) 提出了一种基于 RA-ACO 的方法，用于仿人机器人在杂乱环境中的导航。他们使用 Petri 网测试了所提出的用于多个仿人机器人实时导航的方法，发现仿真结果与实时结果之间具有良好的一致性。Liu 等人[79]就如何调整当前的 ACO 方法以便在静态环境中更好地工作提出了建议。当蚂蚁趋向于更高的效率子空间时，模式的搜索空间会缩小，沿当前路径的信息素会向势场力的方向扩散。他们结合信息素扩散和几何局部优化找到了最佳路径。Rajput 等人（80）针对动态环境提出了另一种修改方法。为了防止无意义的循环并实现更快的收敛，他们还提出了一种新颖的信息素更新技术。Purian 等人（81）将 ACO 算法应用于未知动态环境中的移动机器人导航。在模糊规则的选择和优化方面，他们使用了 ACO。</p>
<p>Brand 等人在（82）中比较了模拟和真实世界中移动机器人在相同环境下的运行情况。Liu 等（83）提出的水下机器人三维路径规划方案使用了一种基于 ACO 的搜索算法来寻找从一个位置到另一个位置的无碰撞路径。Chen 等人也提出了 ACO 算法（84）。利用强化学习可以解决无人驾驶飞行器在战场上确定最佳路径的问题，从而解决原始蚁群算法搜索速度慢和停滞不前的问题。蚁群算法还被应用于军事硬件。Gao 等人[85]将蚁群算法用于导弹路线规划时，发现其性能有所提高，包括最优路线长度和更快的收敛速度。Zong 等人(86) 建议使用改进的蚁群算法为移动机器人规划路径。该算法的信息素更新机制具有加速收敛的能力。大量模拟实验的结果表明。 </p>
<p>通过修改通往目标点的路径，可以显著提高蚁群算法的收敛性 [87]。节点数量减少，更能满足机器人运动的需要。焊接路径的长度直接影响自动线的工作时间和生产效率 [87]。针对传统路径规划方法不适合多目标点的问题，提出了一种基于（ACO）算法的路径规划方法。虽然路径太长，转弯太多 [88]，但基本的蚁群算法（ACO）很容易进入局部最优。改进后的 ACO 会在地图上没有障碍物的区域随机设置可行走的位置点。对于移动机器人，提出了一种基于进化优化的自主路径规划方法。</p>
<ol start="3">
<li>粒子群优化（PSO）： 这种元优化方法从野生动物（如鱼群和鸟群）中获取群体动力学的线索。它是由 Eberhart 和 Kennedy 于 1995 年开发的[89]，是一种用户群迅速增长的优化工具，用于解决各种工程和科学问题。PSO 模仿社会性动物行为，但不需要群体领导者来完成工作。鸟群在寻找食物时不需要领导者，而是跟随离食物最近的成员（图 10）。通过这种方式，鸟群成功地与种群中的其他成员沟通，从而找到所需的解决方案。PSO 算法由一系列粒子组成，每个粒子都代表一个潜在的解决方案。PSO 现已成为移动机器人导航领域广泛使用的工具。Tang 等人[90]利用多智能体粒子过滤器，处理了移动机器人在未知环境中导航的测绘和定位问题。之所以使用 PSO，是因为它具有更稳定的收敛特性，有助于减少计算量。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161059605.png" alt="image-20240116105911079"></p>
<p>为了获得精确的轨迹并防止陷入局部最优，Xuan 等人[91]采用了 PSO 算法与 MADS（网格自适应直接搜索）算法相结合的方法。PSO-MADS 算法与 GA 算法和 EKF 算法相结合，产生了有效的结果（扩展卡尔曼滤波器）。Atyabi 等人[92]创建了区域扩展 PSO（AEPSO）。此外，受时间和变化限制的移动机器人导航问题也可以用 PSO 来解决，该算法结合了基本 PSO 算法和其他优化技术。AEPSO 策略已成功应用于炸弹拆除和幸存者搜救。Tang 等人的[93]挑战环境下的合作运动路径规划解决了多移动机器人系统导航问题。在将 PSO 和多体系统动力学（由加速度、质量、力和惯性等机器人属性组成）都考虑在内的情况下，对所提出方法的容错性进行了研究。对于现实世界中众多移动机器人的导航，Couceiro 等人[94]做了一些修改。他们改变了 PSO 和达尔文 PSO（DPSO）系统，以解决通信和避障问题。他们发现，由 12 个物理机器人组成的系统可将最佳总体性能和最大通信距离提高 90%。</p>
<p>Chen 等人[95]利用多类别分类器为不确定环境制定了可学习的人类专家控制策略。在此背景下，粒子群优化（PSO）算法被用于及时有效地提高精度。与传统的栅格搜索法相比，它具有更高的精度。Li 等人提出的自适应学习粒子群优化（SLPSO）技术，旨在解决复杂环境中机器人路径规划的难题，同时满足各种约束条件。作者最初将路径规划问题转化为多目标优化问题，目的是满足路径长度和碰撞风险最小化以及平稳性最大化的导航目标。在实现这些目标之后，他们又加入了自适应学习机制，以增强粒子群优化（PSO）探索具有众多约束条件的环境的能力。Das 等人[96]为创建有效的路径规划提供了一种混合方法。他们提出了一种使用改进引力搜索算法（IGSA）和 PSO 的混合方法，用于评估杂乱环境中众多移动机器人的最佳行动路线。He 等人的研究[97]探讨了如何利用粒子群优化（PSO）来应对在多元、三维环境中水下环境导航的挑战。该研究采用了 PSO-UFastSLAM 组合方法来提高估计精度和限制粒子大小，从而取得了更好的结果。</p>
<p>粒子群优化（PSO）方法已被用于各类机器人的导航，包括水下机器人、三维未知环境中的空中机器人[98]、仿人机器人[99]和工业机器人[100]。值得注意的是，这些机器人都取得了成功的导航结果。Algabri M 等人[101] 对 GA、PSO、NN 和 FL 等各种导航控制技术进行了比较分析，以确定最佳方法。研究人员得出的结论是，FL 和 PSO 的融合产生了与穿越距离相关的最佳结果。&#x3D;&#x3D;粒子群优化（PSO）在移动机器人导航领域之外也有潜在的应用，特别是在国防领域。Banks 等人[102]研究了 PSO 在非确定性无人机导航中的应用及其促进无人机间协作的潜力，以保护广大地区免受空中威胁。&#x3D;&#x3D;文献[103]采用栅格法对环境进行划分，以实现粒子群优化。路径的距离由目标函数来衡量，避开途中的障碍物会受到惩罚。利用粒子群优化解决了涉及紧急车辆和普通车辆的两个路径规划问题。路径规划是当前机器人领域最活跃的研究领域之一。Chen 等人[104]提到了粒子群的局部搜索性能不达标这一问题；因此，可以更快地规划出理想路径，该算法可以在前期和后期提高粒子搜索的质量。Sarkar 等人[105]开发了一种自适应适配函数，解决了三个重要问题，包括避开障碍物和选择更短、更平滑的路径。该适应度函数通过使用粒子群优化（PSO）算法进行优化。</p>
<p>[103] Yuan, D. Research on path-planning of particle swarm optimization based on distance penalty. In Proceedings of the 2021 2nd International Conference on Computing and Data Science (CDS), Stanford, CA, USA, 28–29 January 2021; pp. 149–153.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T06:04:58.000Z" title="2023/11/27 14:04:58">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2023-11-30T15:23:45.962Z" title="2023/11/30 23:23:45">2023-11-30</time>更新</span><span class="level-item">5 分钟读完 (大约695个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/27/A-Conflict-Based-Search-Framework-for-Multiobjective-Multiagent-Path-Finding/">A Conflict-Based Search Framework for Multiobjective Multiagent Path Finding</a></p><div class="content"><h1><span id="a-conflict-based-search-framework-for-multiobjective-multiagent-path-finding">A Conflict-Based Search Framework for Multiobjective Multiagent Path Finding</span></h1><h2><span id="abstract">Abstract</span></h2><p>传统的多智能体路径规划器通常在优化单一目标（如路径长度）的同时计算路径集合。然而，许多应用可能需要在规划过程中同时优化多个目标，如燃料消耗和完工时间，而且这些标准可能不容易比较，有时还会相互竞争。因此，问题的目标是找到一组帕累托最优解（Pareto-optimal），而不是单一最优解。将现有的多目标搜索算法（如多目标 A* (MOA* )）简单地应用于多智能体路径搜索可能会被证明是低效的，因为搜索空间的维度会随着智能体数量的增加而呈指数增长。本文提出了一种名为 “基于冲突的多目标搜索（MO-CBS）”的方法，试图利用先前的基于冲突的搜索（CBS）（一种著名的单目标多智能体路径搜索算法）和多目标优化文献中的优势原则来解决这种所谓的 “维度诅咒”。我们还开发了 MO-CBS 的几个变体，以提高其性能。我们证明了 MO-CBS 及其变体可以计算整个帕累托最优集。数值结果表明，MO-CBS 的性能优于最近开发的最先进的多目标智能体规划器 MOM* 。</p>
<h2><span id="note-to-practitioners">Note to Practitioners</span></h2><p>本文的动机源于在仓库物流、监控、施工场地路线和危险品运输等应用中，为多个移动机器人规划无冲突路径时，需要优化多个路径标准。现有的多智能体规划方法通常只考虑优化单一路径标准。本文开发了一种新颖的多目标多智能体规划器及其变体，可保证找到问题的所有帕累托最优解。我们还提供了一个示例，用该算法为在建筑工地上运输材料的多个智能体规划路径，同时优化路径长度和风险。在这个例子中，通过计算和可视化一组帕累托最优解，实践者可以直观地了解相互冲突的目标之间的基本权衡，并根据自己的领域知识选择最理想的执行方案。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/A-Conflict-Based-Search-Framework-for-Multiobjective-Multiagent-Path-Finding.png" alt="image-20231130205846387"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311302104814.png" alt="image-20231130210418332"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311302104369.png" alt="image-20231130210441253"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311302233202.png" alt="image-20231130223342087"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T02:32:09.000Z" title="2023/11/27 10:32:09">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2023-11-27T06:03:27.191Z" title="2023/11/27 14:03:27">2023-11-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">11 分钟读完 (大约1581个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/27/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system/">Particle swarm optimization based co-operative task assignment and path planning for multi-agent system</a></p><div class="content"><h1><span id="particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system">Particle swarm optimization based co-operative task assignment and path   planning for multi-agent system</span></h1><blockquote>
<p>[!WARNING]+ <center>🐣 总结</center>  </p>
<p>🎯 研究问题::<br>🔎 研究背景::<br>🚀 研究方法::<br>🐔 研究思路::<br>📺 主要内容::  本文提出了一种多智能体系统的合作路径规划和任务分配框架。<br>🎉 研究结论::  本文的重点是开发一种将任务分配与路径规划问题相结合的三层框架。在任务完成和路径搜索期间，该优化算法具有安全导航能力，确保路径无碰撞。在多代理系统中，即使在非常复杂的动态环境中，代理也能通过访问所有目标位置来完成给定任务。分析表明，所提出的框架非常容易实现，而且它能通过完成任何类型的指定任务轻松找到最佳解决方案。今后，我们将在实时场景中应用该框架。<br>🗝️ 创新点::<br>💩 研究局限::<br>🐾 研究展望::<br>✏️ 备注::  </p>
</blockquote>
<h2><span id="conclusion">CONCLUSION</span></h2><p>文章重点是开发一种任务分配与路径规划问题相结合的框架。<br>该框架具有：</p>
<ul>
<li>安全导航能力</li>
<li>多路径无碰撞</li>
<li>能完成给定任务</li>
</ul>
<h2><span id="abstract">Abstract</span></h2><p>本文提出了一种多智能体系统的合作路径规划和任务分配框架。对于候选算法来说，要处理动态环境中的多个智能体是比较困难的，在这种情况下，需要重新规划一条新的路径，以在不发生任何碰撞的情况下执行给定的任务。为了解决这个问题，这里提出了一种基于粒子群优化的路径规划算法，为在某些规定任务下工作的多智能体系统寻找最优路径。结果表明，由于采用了反应式管理结构，所提出的框架非常有效，能够成功完成任务。仿真结果表明，它是解决合作路径规划问题的一种可靠而稳健的方法。</p>
<p>文章问题场景是：</p>
<ul>
<li>动态场景</li>
<li>多智能体</li>
<li>无碰撞合作式路径规划</li>
<li>完成给定任务</li>
</ul>
<p>文章使用的基础算法是：</p>
<ul>
<li><p>粒子群算法 Particle Swarm Optimization</p>
</li>
<li><p>环境运行空间是连续空间</p>
</li>
</ul>
<h2><span id="simulation-results-and-discussions">SIMULATION RESULTS AND DISCUSSIONS</span></h2><p>实验环境</p>
<ul>
<li>MATLAB R2015b</li>
</ul>
<p>预备的参数组合如下：</p>
<p>$\omega&#x3D; 1.0$, $c1 &#x3D; 0.5$, $c2 &#x3D; 2.0$, Population size of swarms (agents) &#x3D; 25 and Maximum iterations &#x3D; 50.</p>
<p>避免碰撞策略所考虑的参数如下：</p>
<p>$\omega&#x3D; 1.0$, $c1 &#x3D; 3.0$, $c2 &#x3D; 4.0$,</p>
<p>这些增加的参数值有助于被捕获的粒子恢复。</p>
<p>为了评估整个框架的性能，我们模拟了几种不同情况的测试。我们将一个二维环境视为搜索空间，并考虑了不同类型的工作环境、不同类型的障碍物和不同数量的任务分配。工作空间的大小为 120 × 120 平方单位的地图。为简化起见，考虑了双智能体系统。每种配置均模拟运行 20 次。</p>
<p>实心圆代表静态障碍物，空心圆代表动态障碍物（图 2-8）。空心圆的序列代表动态障碍物的运动轨迹。动态障碍物可以是速度恒定的物体，也可以是随机移动的物体。路径上的圆圈表示智能体。在这种 SRVPSO 算法中，目标位置和目的位置周围考虑了 5-8 % 的容差区。菱形代表智能体需要访问的目标位置</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system2.png" alt="image-20231127104050741"></p>
<p>图 2 显示了智能体没有任务分配且只考虑静态障碍物时的路径规划结果。两个智能体都规划了到达目标位置的路径，它们之间没有任何冲突。图 3 描述了在相同环境中分配任务后的无碰撞路径。这里，为智能体分配了四个目标位置 {(20,40)、(40,70)、(60,30) 和 (70,35)}，以便它们在目标点 (80,80) 完成任务。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311271403043.png" alt="image-20231127104755443"></p>
<p>如图3的相同任务分配，并增加动态障碍的路径规划序列截图如图 4 所示，动态环境由两个静态障碍物和一个动态障碍物组成。动态障碍物半径为 3 个单位，以固定速度从点（20，60）移动到点（43，22）。该规划的计算时间仅需 1.9 秒。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311271048542.png" alt="image-20231127104833402"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202311271049871.png" alt="image-20231127104908657"></p>
<p>图 5 和图 6 显示了在相同动态环境中不同目标数量下的规划情况。在图 5 中，智能体被分配了 6 个目标，而在图 6 中，智能体访问了 10 个目标并最终到达目标。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system6.png" alt="image-20231127104932345"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system7.png" alt="image-20231127105010685"></p>
<p>图 7 和图 8 所示的搜索空间是一个更加复杂的动态环境，由三个静态障碍物和两个动态障碍物组成。两个动态障碍物的移动方向不同。一个半径为 “3 “个单位的动态障碍物从位置（20，70）移动到（66，1），而另一个半径为 “2 “个单位的移动障碍物则从位置（10，30）移动到（60，30）。图 7 的目标位置与图 8 的目标位置不同。在这个工作区中，智能体需要覆盖 14 个目标位置。完成任务所需的计算时间约为 8.1 秒。在某些图中，我们发现智能体无法到达特定的目标位置。不过，它们能够在容差范围内到达非常接近这些地点的地方。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system8.png" alt="image-20231127105044091"></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SUNX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SUNX</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/null"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_43571647?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">C++学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MATLAB/"><span class="level-start"><span class="level-item">MATLAB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/excel%E6%93%8D%E4%BD%9C/"><span class="level-start"><span class="level-item">excel操作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E5%88%9B/"><span class="level-start"><span class="level-item">原创</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路径规划</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="level-start"><span class="level-item">路径规划启发式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">路径规划算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-03T10:45:41.000Z">2024-03-03</time></p><p class="title"><a href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T06:17:52.000Z">2024-03-01</time></p><p class="title"><a href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T08:06:51.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T07:45:43.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/">Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-28T15:35:45.000Z">2024-02-28</time></p><p class="title"><a href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%AD%A6%E4%B9%A0/"><span class="tag">C++学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLion%E5%AE%89%E8%A3%85/"><span class="tag">CLion安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GDAL/"><span class="tag">GDAL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hierachical/"><span class="tag">Hierachical</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MAPF/"><span class="tag">MAPF</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Q1/"><span class="tag">Q1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XTDrone/"><span class="tag">XTDrone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pandas/"><span class="tag">pandas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82/"><span class="tag">分层</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"><span class="tag">分层方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"><span class="tag">原文翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"><span class="tag">可视图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="tag">启发式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">图论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"><span class="tag">多智能体</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="tag">离散数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"><span class="tag">维诺图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%BC%E8%BF%B0/"><span class="tag">综述</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a><p class="is-size-7"><span>&copy; 2024 SUNX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>