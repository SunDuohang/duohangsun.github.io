<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 路径规划 - SUNX的记录</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SUNX的记录"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SUNX的记录"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天的天气不错"><meta property="og:type" content="blog"><meta property="og:title" content="SUNX的记录"><meta property="og:url" content="https://duohangsun.gitee.io/"><meta property="og:site_name" content="SUNX的记录"><meta property="og:description" content="今天的天气不错"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duohangsun.gitee.io/img/og_image.png"><meta property="article:author" content="SUNX"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://duohangsun.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://duohangsun.gitee.io"},"headline":"SUNX的记录","image":["https://duohangsun.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"SUNX"},"publisher":{"@type":"Organization","name":"SUNX的记录","logo":{"@type":"ImageObject","url":"https://duohangsun.gitee.io/img/logo.svg"}},"description":"今天的天气不错"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?69225dadb01d44aae3f8c4f29649a59d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">路径规划</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-03T10:45:41.000Z" title="2024/3/3 18:45:41">2024-03-03</time>发表</span><span class="level-item"><time dateTime="2024-03-03T12:21:14.207Z" title="2024/3/3 20:21:14">2024-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约7695个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><div class="content"><h1><span id="hierarchical-a-searching-abstraction-hierarchies-efficiently">Hierarchical A*： Searching Abstraction Hierarchies Efficiently</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403031849761.png" alt="image-20240303184926771"></p>
<h1><span id="abstract">Abstract</span></h1><p>在搜索、问题求解和规划中，抽象的作用是用另一个更容易搜索的状态空间（”抽象 “空间）来替代一个状态空间。抽象空间的搜索结果用于指导原始空间的搜索。例如，抽象解的长度可以作为 A* 在原始空间中搜索的启发式。然而，要有效地实现这一点有两个障碍。第一个障碍是一个定理（Valtorta，1984 年），该定理指出，对于一大类抽象，即 “嵌入抽象”，在用这种方法计算 A* 的启发式时，盲搜索扩展的每个状态也必须被 A* 扩展。第二个障碍产生的原因是，A* 在计算启发式时，需要反复对抽象空间进行全面搜索。本文介绍了一种新的由抽象引起的搜索技术–”分层 A* “，它能同时解决这两个难题：首先，它从不同的抽象类别–”同态抽象”–中汲取灵感；其次，它使用新颖的缓存技术，避免在抽象空间的连续搜索中重复扩展相同的状态。在所研究的所有搜索空间中，分层 A* 均优于盲搜索。</p>
<h1><span id="introduction">Introduction</span></h1><p>有几位研究者将抽象作为自动创建可接受的启发式A*搜索的一种手段进行了研究（Gaschnig, 1979; Pearl, 1984; Prieditis, 1993; Guida &amp; Somalvico, 1979）。总体思路是将状态空间 SS 中从状态 S 到目标 G 的距离估计值 h(S)，等同于另一个状态空间 SS’ 中从 SS’ 中对应于 S 的状态到对应于 6 的状态的精确距离，SS’是 SS 的 “抽象”。只要 SS 中每对状态之间的距离都大于或等于 SS’ 中相应状态之间的距离，以这种方式定义的 h(S) 就是一种可接受的启发式。普里迪蒂斯（Prieditis,1993）在 “抽象变换 “的定义中正式提出了这一观点，具体如下。</p>
<p>状态空间 “是一对 &lt;States,d&gt;，其中 States 是一组状态，d(S,,S,) 是两个状态之间的距离（最短路径的长度）（如果从 S, 到 S, 之间没有路径，则 d(S,,S,) &#x3D; 00）；”问题 “是一对 &lt;Start,Goal&gt;，其中 Start 是一个状态，Goal 是一个（组）状态’。给定状态空间 SS &#x3D; &lt;States&amp; 和 SS’&#x3D; &lt;States’,d’&gt;, 一个映射 @： 如果 SS 中的每个距离都小于或等于 SS’ 中相应的（根据 @）距离，那么（SS 的）States + States’ 映射就是抽象变换。形式上：d’（#（S,）,#（S,）) I d(S,,S,) for all S,, S, E States. 给定 SS 的问题 &lt;Start,Goal&gt;，SS’的相应问题为 &lt;@tart),Goal’&gt;，其中 Goal’ 2 {H(g) I g E Goal}。通常我们会提及 @(SS)，而不指定 SS’。在这种情况下，SS’ 被隐含为 cimage#,d#&gt;，其中 image@&#x3D; {K(s) I s E States} 和 d#(S;,S;) &#x3D; min { d(s, ,s.J I #(st) &#x3D; S; and @(sZ)&#x3D; S;} 。</p>
<p>最早也是最常研究的抽象变换类型是 “嵌入”。非正式地讲，如果 @ 为 SS “添加了边”，那么它就是一种嵌入变换。例如，在状态空间定义中添加宏运算符或删除先决条件的技术就是嵌入。从形式上看，如果 SS’ 是 SS 的超图，即 States’ 2 States，且 g(s)&#x3D; S 适用于所有 S E States，那么 @ 就是一种嵌入。因为 SS 中的所有状态和边（代价相同）都存在于 SS’ 中，所以 SS’ 中的距离不可能比 SS 中的相应距离长。因此，任何嵌入都是一种抽象变换。嵌入是（Gaschnig，1979；Pearl，1984；以及 Guida &amp; Somalvico，1979）中研究的一种转换类型。</p>
<p>抽象转换的另一种主要类型是 “同态”（”自然转换 “的同态）（Kibler，1982）。非正式地讲，同态 4 是将 SS 中的几个状态组合在一起，形成一个抽象状态。例如，从状态空间描述中完全删除谓词的技术（Knoblock, 1994）就是同构。从形式上看，如果 @ 是 SS 状态的多对一映射，那么如上定义的 $(SS) 就是 SS 的同构。</p>
<p>创建启发式的目的是加快搜索速度。如果没有启发式，A* 就会盲目地在原始空间中搜索。有了启发式，A* 的搜索就会更有针对性，在原始空间的搜索努力就会减少一些（”节省”）。使用通过抽象创建的启发式的主要风险在于，在搜索过程中计算 h(-) 的总成本可能会超过节省的成本。如果出现这种情况，启发式的使用就是有害的：计算启发式的成本超过了使用启发式的收益。</p>
<p>Valtorta, l984）中对通过嵌入变换自动生成的启发式方法进行了成本效益分析。 (Valtorta，l984）。结果证明，如果 SS 嵌入 SS’，而 h(-) 是通过在 SS’ 中盲目搜索计算出来的，那么使用 h(-) 的 A* 将扩展直接在 SS 中盲目搜索所扩展的每一个状态。换句话说，这种定义启发式的方法不可能加快搜索速度–使用启发式扩展的节点（状态）总数（包括在抽象空间中扩展的节点）必须等于或超过在原始空间中盲目搜索时扩展的节点（状态）总数。根据这一定理，我们将 “瓦尔托尔塔障碍 “定义为在空间中盲目搜索时扩展的节点数。瓦尔托尔塔定理指出，使用任何嵌入变换都无法 “打破 “这一障碍。</p>
<p>瓦尔托塔定理并不排除使用其他类型的变换来打破瓦尔托塔障碍的可能性。不过，迄今为止，瓦尔托塔障碍只被突破过两次。Absolver II（普里迪蒂斯，1993年）通过使用同态变换，为与 “傻瓜磁盘 “和 “瞬间精神错乱 “谜题相关的状态空间（和特定目标）创建了具有成本效益的启发式方法。在 Absolver II 应用的其他 11 个问题中，抽象本身无法创造出具有成本效益的启发式（其中 5 个问题的成本效益启发式是在抽象与其他类型的状态空间变换一起使用时创造出来的）。</p>
<p>在本文中，我们展示了利用通用同态抽象技术可以在多种搜索空间上打破 Valtorta 障碍。首先，我们提出了适用于所有类型抽象转换的 Valtorta 定理的广义版本。该定理提供了使用任何抽象变换必须扩展的节点数量的下限。对于同态变换，该界限低于在原始空间中盲目搜索所扩展的节点数。这表明，同态抽象至少在原则上有可能打破瓦尔托尔塔的障碍。不过，我们的初步实验结果表明，仅仅抽象是同态的这一事实，并不能保证能创造出具有成本效益的启发式方法。我们发现，使用同态抽象层次结构进行搜索所扩展的状态比盲目搜索多得多，在一个测试平台的搜索空间中，盲目搜索扩展的状态是盲目搜索的 17 倍。我们找出了造成这些负面结果的原因，并提出了两种缓解问题的互补方法。第一种是算法方法。对 A* 算法进行了定制，以便在抽象层级中进行搜索。定制版本称为分层 A<em>，扩展的状态比原始 A</em> 少大约 6 倍，并在大约一半的测试平台搜索空间中突破了 Valtorta 的障碍。第二种方法是创建精细度较低的抽象。这也打破了 Valtorta 在部分测试平台搜索空间的障碍。当两种方法结合使用时，所有测试平台搜索空间的瓦尔托塔障碍都会被打破。</p>
<h2><span id="valtortas-theorem-generalized">Valtorta’s Theorem Generalized</span></h2><p>Valtorta, l984）中的主要定理是针对嵌入的，但很容易推广到任何抽象变换。广义的定理是（正式的陈述和证明见 (Holte et al., 1995)）：</p>
<p>让 $\phi$ 是状态空间 SS 到 SS’ 的任意抽象映射，$h_{\phi}(S)$ 是 SS’ 中从 $\phi(s)$到 $\phi(goal)$ 的最短路径长度（通过在 SS’ 中盲查计算）。如果 S 是直接在状态空间 SS 中通过盲搜索求解给定问题时必然扩展的任何状态，那么在 SS 中使用带有 $h_{\phi}(-)$ 的 A* 搜索求解问题时，要么 S 本身被扩展，要么 $\phi(s)$ 被扩展。</p>
<p>当 $\phi$ 是一个嵌入时，$\phi(S)&#x3D;S$，我们就得到了瓦尔托尔塔定理：盲搜索必然扩展的每个状态也必然被使用 h 的 A* 扩展，但如果 $\phi$ 是一个同态，加速是可能的，因为抽象空间中一个状态的扩展等同于原始空间中许多状态的扩展。</p>
<p>一个简单的例子说明，基于同态抽象的启发式方法确实可以大大减少扩展节点的数量。假设状态空间 SS 是一个 n x n 网格，要解决的问题是从左下角 (1 ,l) 到右下角 (n,l)。要通过盲搜索解决这个问题，必须扩展距离 (n-l) 或更小的所有状态，因此要扩展 $O(n^2)$ 个状态。假设 $\phi$ 是忽略第二个坐标的映射。那么，$\phi(SS)$ 是一个线性空间，包含 (l)、(2)、……(n)个状态。 计算 $h_{\phi}(Start)$ 需要在 $\phi(SS)$ 中找到一条从（1）到（n）的路径。在这一搜索过程中会扩展 O(n) 个状态，但注意这一搜索会生成所有 S 的 $h_{\phi}(s)$ 值，因此无需在抽象空间中做进一步搜索。此外，这个特定抽象定义的 $h_{\phi}(-)$ 是一个完美的启发式，因此在 SS 中的搜索只会扩展解路径上的那些状态。因此，A* 使用 $h_{\phi}(-)$ 扩展的节点总数为 O(n)，远远少于盲搜索扩展的 $O(n^2) $个节点。</p>
<h2><span id="hierarchical-search-using-a">Hierarchical Search using A*</span></h2><p>在当前的系统中，抽象状态是通过（Holte et al.，1996）中描述的 “最大度 “STAR 抽象技术创建的。这种技术非常简单：将度数最大的状态与一定距离（”抽象半径”）内的相邻状态组合在一起，形成一个抽象状态。如此反复，直到所有状态都被分配到某个抽象状态。这样就建立了一个抽象层级，这个过程不断重复，直到建立了一个只包含一个状态的层级。这就形成了一个抽象层级，其顶层就是三维搜索空间。层次结构的底层或 “基础 “层就是原始的搜索空间。这种创建抽象的方法最初是为被称为 “细化 “的搜索技术而设计的，并被证明是非常成功的（Holte 等，1996；Holte 等，1994）。在目前的工作开始时，还不完全清楚它是否能创建适合 A* 搜索的抽象层次。它当然不适合抽象出不同算子具有不同代价的搜索空间，但在本文的实验中并没有出现这种考虑。</p>
<p>A* 的实现是标准的，只是在估算从非目标状态 S 到目标的距离时，除了使用其他可能可用的启发式估算之外，还使用了适用于 S 的算子的最小成本。当有多个启发式信息来源时，会通过取最大值的方式将它们结合起来。如果单个启发式信息是可接受的，那么这种组合多个启发式信息的方法就保证是可接受的，但即使单个启发式信息是可接受的，这种方法也可能不是单调的（相反的例子见下一节）。然而，我们不难发现，如果每个算子都有相同代价的倒数，那么将最小算子代价与任何单调启发式相结合就会产生单调启发式，我们实验中的搜索空间就是这种情况。</p>
<p>当没有其他启发式估计时，”最廉价算子 “信息最为有用（盲探： 对于所有 S，A* 的 h(S)&#x3D;0）。在这种情况下，使用 “最廉价算子 “可以大大减少扩展节点的数量。当有其他启发式估计时，”最廉价算子 “信息只对其他方法估计的非常接近目标的状态有用。</p>
<p>使用 A* 进行分层搜索非常简单。像往常一样，在 A* 搜索的每一步，一个状态都会从 OPEN 列表中移除，而它的每个后继状态都会被添加到 OPEN 列表中（如果它之前没有被打开过）。要将一个状态 S 加入 OPEN 列表，必须知道 h(S)。h(S) 的计算方法是在下一个更高的抽象层次进行搜索，使用与 S 对应的抽象状态 KS) 作为抽象起始状态，$\phi(goal) $作为抽象目标。找到抽象解路径后，就知道了从 $g(s)$ 到 $\phi(goal)$的确切抽象距离。如前文所述，这将与其他估计值（如适用于 S 的最便宜算子的成本）相结合，得出最终的 $h(S)$ 值。</p>
<p>当找到从 $\phi(s) $到 $\phi(goal)$ 的抽象路径时，这条路径上所有抽象状态的精确抽象距离到目标信息都是已知的。一般来说，每个抽象状态都对应着 “下一层”（包含 S 的状态空间）中的许多状态。因此，一次抽象搜索会对许多状态产生启发式估计。所有这些信息都被缓存起来。如果需要这些状态中任何一个状态的 h 值，只需简单查找即可，无需在抽象层进行任何搜索。尽管有这种缓存技术，但一般来说，要解决一个基础层问题，分层搜索技术需要解决许多抽象层问题。而这些抽象问题中的每一个都需要解决下一个抽象层次的许多问题，等等。解决单个基础层问题所扩展的节点数是在所有抽象层次（包括基础层本身）与该基础层问题相关的所有搜索过程中扩展的状态总数。</p>
<p>刚刚描述的分层搜索技术将被称为原始分层 A* (navie hierarchical A* )，以与下一节介绍的版本形成对比。我们在 8 个状态空间上对各种分层 A* 技术进行了经验评估（见 Holte 等人，1995 年）。所有算子都是可逆算子，应用所有算子的代价都是相同的 (1)。每个状态空间的测试问题都是随机选择 100 对状态生成的。每对状态 &lt;Sl,S2&gt; 都定义了两个要解决的问题： $&lt;start&#x3D;S1,goal&#x3D;S2&gt;$ 和 $&lt;start&#x3D;S2,goal&#x3D;Sl&gt;$。为了便于详细比较，每次实验都使用了相同的 200 个问题。显示的 “节点扩展 “结果是这 200 个问题的平均值。</p>
<p>在每个测试平台搜索空间中，天真分层 A* 扩展的状态都比盲法搜索多得多（见表 1）。要理解为什么会出现这种情况，关键在于天真分层 A* 扩展的状态比整个抽象分层中的状态多得多（表 1，第二列）。这意味着在解决单个基础层问题的过程中，某些状态被扩展了很多次。由于采用单调启发式的 A* 不会在一次搜索中重复扩展相同的状态，因此重复扩展一定是由于在与同一基础层搜索相关的多次不同搜索中扩展了相同的状态。下一节将介绍大大减少这种重复的方法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403032015234.png" alt="image-20240303201523037"></p>
<p>分层 A* 在基础层中扩展的节点数是 A* 在给定抽象层级下所能达到的提速的基本限制。这个数字表示启发式的质量，即启发式能在多大程度上减少原始空间的搜索工作量。例如，在 Permute-6 搜索空间中，分层 A* 在基础层中扩展了 77 个状态，比盲目搜索扩展的数量减少了 75%。这只是微不足道的节省。但这是表 1 中最好的启发式方法。另一个极端是为 “传教士与食人族 “搜索空间创建的启发式（MC 60-40-7），它只节省了 25%。启发式搜索的质量是抽象技术的属性，只能通过使用不同的抽象技术来提高。除了改变抽象的粒度外，这一主题超出了本文的范围。</p>
<p>目前的抽象技术所产生的启发式搜索只能适度减少在基础层上扩展的节点数，这使得打破瓦尔塔障碍变得尤为困难。为了突破这一障碍，所有抽象搜索所扩展的节点总数必须少于启发式搜索所节省的数量。例如，考虑 5 字谜。通过抽象产生的启发式结果是 A* 在底层扩展了 224 个状态，比盲目搜索节省了 124 个状态。为了打破瓦尔托塔的障碍，为所有这 224 个状态（以及被打开但从未关闭的额外状态）计算启发式的成本（以在所有抽象层次扩展的节点计）不得超过 124。这并非不可能：如上例所示，在抽象层次扩展几个状态，就能为基础层的许多状态提供启发式值。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403032016184.png" alt="image-20240303201609899"></p>
<h2><span id="customizing-a-for-hierarchical-search">Customizing A* for Hierarchical Search</span></h2><p>在分层搜索中，一个基础层级的搜索可能会产生大量抽象层级的搜索。如前面的结果所示，这些搜索通常会扩展许多相同的状态。减少这种重复的关键在于观察到与同一基础层搜索相关的所有搜索都具有相同的目标。天真分层 A* 的简单缓存策略在很小程度上利用了这一观察结果，因为它在特定抽象层次的缓存直到该层次的目标发生变化时才会被清除。表 1 中的结果表明，如果要使分层 A* 有效，还需要更多利用这一观察结果的方法。</p>
<p>当抽象层次的搜索结束时，已知求解路径上每个抽象状态 S 到目标的确切距离 h* (S)。这一信息可以被缓存起来，并在后续相同目标的搜索中代替 h(S)。这样可以提高启发式在这一抽象层次的质量，从而减少后续搜索所扩展的节点数量。这种技术被称为 h* 缓存。从表 2（第 Vl 列）中可以看出，这大约将扩展节点的数量减少了一半。</p>
<p>由 h* 缓存产生的启发式并不是单调的。例如，假设所有算子的代价都是 1，并且所有非目标状态的 h(S)&#x3D;1 。在解决了一个问题并缓存了 h*(-) 值后，求解路径上的状态可能会有相当大的 h(-) 值，而它们在求解路径之外的相邻状态仍会有 h(-)&#x3D;1 值。因此，相邻 h(-) 值之差将大于 1，即两个状态之间的 “距离”。因此，新的 h(-) 函数不符合单调性的定义。</p>
<p>由于 h(-) 函数不是单调的，因此有可能过早地关闭一个状态，即在找到从起始状态到该状态的最短路径之前就关闭了。一般来说，使用非单调启发式算法时，为了保证找到最短路径，有必要重新打开此类状态。然而，对于 h* 缓存所产生的非单调启发式来说，这并不是必须的，事实上，我们的 A* 实现并没有重新打开封闭状态的规定。为了说明这一点，让 S 作为起始状态，P 作为过早关闭的状态。要使 P 提前关闭，必须是 h* (P)是未知的，而且从 S 到 P 的每条最短路径都要经过某个状态 X，而 h* (-)是已知的。如果在任何从 S 到目标的最短路径上都没有这样的 X，那么 P 也不存在，所以 P 的过早关闭就无关紧要了。另一方面，假设从 S 到目标的最短路径经过这样一个 X。h* (X) 已知这一事实意味着在之前的搜索中 X 在解路径上，因此之前发现了一条从 X 到目标的最短路径。这条路径上的每个状态 h*(-) 都是已知的。因此，在当前搜索中，这些状态都没有被扩展，所以从 S 到目标的这段最短路径将被找到，而无需重新打开任何封闭状态。</p>
<p>如前所述，对于已知 h*(X)的每个状态 X，从 X 到目标的最短路径也是已知的。如果除了 h* (X)之外还缓存了这条路径，就没有必要再扩展 X 了。这是因为知道了一条长度为 g(X)到 X 的路径，就等于知道了一条长度为 g(X)+h* (X) 到目标的路径。因此，我们可以将目标添加到 OPEN 列表中，而不是将 X 添加到 OPEN 列表中，然后像往常一样，当目标位于 OPEN 列表顶端时终止搜索。这种技术称为最优路径缓存。表 2 中第 V2 列显示了在天真分层 A* 中添加最优路径缓存时扩展的节点数。最优路径缓存比 h* 缓存节省了大约一倍的时间，并打破了 Valtorta 在 Permute-6 搜索空间中的障碍。</p>
<p>最后一项技术与搜索过程中打开（或关闭）但不在求解路径上的状态有关。对于每个这样的状态 S，我们都知道它与起点的距离 g(S)。如果求解路径的长度为 P，那么根据其最优性，必须是 P I g(S) + h* (S)。将其重排为 P-g(S) I h* (S)，我们可以看到 P-g(S)是一个可接受的启发式，我们称之为 P-g 启发式。当所有算子都有反函数时，可以证明（Holte 等人，1995 年）P-g 启发式与任何单调启发式结合都会产生一个单调启发式。P-g 缓存包含 h* 缓存，因为当 S 在求解路径上时，P-g(S) &#x3D; h*(S)。最后，如果搜索终止时 S 是开放的，则无需计算 P-g(S)，因为在这种情况下 P 5 g(S)+h(S) 因此 P-g(S) I h(S)。</p>
<p>情况 P 5 g(S)+h(S)，因此 P-g(S) I h(S)。系统 V3 包括最优路径缓存和 P-g 缓存。在用于测试的 8 个搜索空间中，它有 5 个突破了 Valtorta 的障碍（表 2 中的粗体数字）。这表明，通过同态抽象，可以在实践中实现</p>
<h2><span id="varying-the-granularity-of-abstraction">Varying the Granularity of Abstraction</span></h2><p>我们的抽象技术允许我们通过设置抽象半径来控制所创建抽象的粒度。前面的结果是在抽象半径为 2 的情况下得出的，这意味着一个状态与其近邻状态分组。增加抽象半径对 “节点扩展 “的净影响并不明显，因为有两种相互对立的影响。一方面，半径越大，意味着抽象空间中包含的状态越少；另一方面，单次抽象搜索会产生更多状态的启发值。这些因素将减少分层 A* 扩展的抽象节点数量。另一方面，半径越大，启发式的区分度就越低：这往往会增加扩展节点的数量（如果启发式完全没有区分度，A* 就会退化为盲目搜索）。(Prieditis &amp; Davis, 1995）对 “抽象性”（即粒度）与启发式搜索结果的准确性之间的关系进行了初步的定量分析。</p>
<p>实验中，抽象半径设置为 2 到 5，某些搜索空间的抽象半径设置为更大。分层 A* 扩展的节点数随着半径的增大而减少，直到达到最小值；半径超过该值后，扩展的节点数会增加。表 3 显示了 V3 为每个搜索空间找到的最佳半径结果（天真分层 A* 的最佳半径有时更大）。现在，在每个搜索空间中，V3 在一半以上的问题上都突破了 Valtorta 的障碍（在其中两个搜索空间中，V3 在 95% 以上的问题上都突破了 Valtorta 的障碍）。</p>
<p>虽然最佳半径相当小，但在每种情况下，它们都占搜索空间直径的很大一部分。由此创建的抽象层次结构只有一个非三维抽象层，而且只包含少量状态。令人惊讶的是，如此粗略的启发式竟然能够减少扩展节点的数量。</p>
<p>只有一个小的非难抽象层次的后果是，上述算法改进的效果大打折扣：在几个空间中，天真的分层 A* 扩展的状态只比 V3 稍多一些。然而，算法改进之所以重要，是因为大多数创建抽象的技术都无法轻松控制所生成抽象的粒度。与天真层次 A* 不同的是，V3 具有很强的鲁棒性：它在任何粒度的抽象上都有很好的表现，因此是粒度无法控制时的首选搜索算法。</p>
<p>“节点扩展 “是一种方便的理论测量方法，但它并不能完全反映搜索系统所做的所有 “工作”，尤其是分层系统，因为它必须在抽象层级上反复初始化搜索，并将信息从一个层级传递到下一个层级。搜索系统的实际速度取决于所有这些操作。表 3 列出了盲搜索和 V3 解决所有 200 个问题所需的 CPU 时间。当然，在解释 CPU 时间结果时必须非常谨慎，因为它们可能会受到底层实现细节的严重影响。在目前的实现中，许多底层细节都相当笨拙，但 V3 所减少的节点扩展量似乎几乎完全抵消了分层搜索所带来的额外开销。</p>
<p>为了最大限度地减少分层搜索的开销，并在更大的状态空间和不同的同态抽象方法上评估分层 A* ，我们最近重新实施了分层搜索和缓存技术。该系统中的抽象是由用户提供的，而不是自动创建的，但到目前为止，我们还没有尝试对抽象进行优化，因为我们的目标是在 “典型 “抽象上评估 Hierarchical A* 。新实施的初步结果证实了表 3 所示的节点扩展结果的一般模式：在某些空间中，扩展的节点数量显著减少，而在其他空间（如河内塔）中，V3 扩展的节点数量则略有减少。不过，CPU 时间的结果却有很大改进。例如，在 &amp;puzzle 中，V3 将 CPU 时间减少了 10 倍（将扩展的节点数减少了 6.5 倍）。</p>
<h2><span id="conclusion">Conclusion</span></h2><p>在本文中，我们证明了使用同态抽象自动创建的启发式 A* 搜索可以 “打破瓦尔托尔塔的障碍”，即在扩展节点数量方面优于盲搜索。这一点在实验中使用的所有状态空间中都得以实现。为了实现这一目标，有必要在 A* 中添加两种新的缓存技术，即最优路径缓存和 P-g 缓存，在某些情况下，还需要选择适当粒度的抽象。所扩展的节点数量减少不多，但这是由于抽象技术的限制，而不是由于算法开销过大。开发一种非常适合分层 A* 搜索的抽象技术是今后研究的一个重要课题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-01T06:17:52.000Z" title="2024/3/1 14:17:52">2024-03-01</time>发表</span><span class="level-item"><time dateTime="2024-03-03T13:17:35.165Z" title="2024/3/3 21:17:35">2024-03-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约13349个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><div class="content"><h1><span id="the-grid-based-path-planning-competition-2014-entries-and-results">The Grid-Based Path Planning Competition: 2014 Entries and Results</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011423266.png" alt="image-20240301141900391"></p>
<h2><span id="abstract">Abstract</span></h2><p>基于网格的路径规划竞赛刚刚完成了第三次迭代。在此期间，竞赛中使用的参赛作品有了显著改进，改变了人们对网格寻路技术现状的看法。此外，大赛的参赛作品已经公开，提高了研究人员比较其工作的能力。本文总结了 2014 年竞赛的参赛作品，介绍了 2014 年的竞赛结果，并讨论了所学到的知识和有待改进的地方。</p>
<h2><span id="introduction-and-background">Introduction and Background</span></h2><p>基于网格的路径规划是一个被广泛研究的课题，在许多应用领域都有大量已发布的方法。多年来，该领域的工作缺乏广泛分布的标准基准问题来比较工作，也缺乏标准实现来比较工作质量。本文的第一作者致力于解决这两种情况：（1）引入各种标准基准问题，用于测试在基于网格的地图上运行的程序；（2）发起基于网格的路径规划竞赛（GPPC）。</p>
<p>引用次数表明，寻路基准已被广泛采用。(关于基准集中每张地图的来源，请参见（Sturtevant 2012）。GPPC 竞赛已举办过三次，分别在 2012 年、2013 年和 2014 年。在此期间，参赛作品的性能有了显著提高，对基于网格的地图结构的理解也有了改进。</p>
<p>本文详细介绍了竞赛采用的方法以及 2014 年竞赛的结果。随后，2014 年参赛作品的作者分别介绍了他们的参赛作品。论文最后讨论了竞赛和基于网格的寻路研究的未来方向。</p>
<h2><span id="competition-setup">Competition Setup</span></h2><p>竞赛的目的是对各种问题实例和各种地图大小进行实验。</p>
<p>GPPC 在一组 132 幅地图上运行，这些地图来自多个地图来源。表 1 列出了每组地图的来源以及每组地图的数量。竞赛中的地图样本如图 1 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011424610.png" alt="image-20240301142434375"></p>
<p>在 2012 年比赛之前，《龙腾世纪 2》中的地图尚未公开。这些地图已在 GPPC 竞赛中使用，但尚未作为通用在线寻路地图库的一部分发布，尽管今后有计划这样做。《星际争霸》和《龙腾世纪：起源》中的地图是寻路地图库的一部分；并使用了为这些地图创建的标准问题，尽管这些只是全部可用地图中的一小部分。随机地图、房间地图和迷宫地图都是人造的。这些地图的大小从 100 × 100 到 1550 × 1550 不等。随机地图中正好有 33% 的单元格被屏蔽，然后除了地图中最大的连接部分外，其他所有单元格都被移除，每张地图中大约又有 5% 的单元格被移除。房间地图包含的房间面积为地图面积的 10%。最初，所有房间都是封闭的，但房间之间的门会随机打开。当墙壁被打开时，墙壁中 1&#x2F;8 的单元格会被随机解封。图 1 显示了 (a) 100 × 100 地图中的 10 × 10 房间和 (b) 400 × 400 地图中的 40 × 40 房间。迷宫地图的走廊尺寸是地图一维尺寸的 1%。因此，100 × 100 地图上的走廊尺寸为 1，800 × 800 地图上的走廊尺寸为 8。图 1 显示了（c）100 × 100 迷宫的一部分和（d）400 × 400 迷宫的一部分。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011426604.png" alt="image-20240301142640786"></p>
<p>测试问题是随机选择的。问题按照最优解的长度除以 4 分成若干个桶。 因此，所有最优解长度为 [4, 8) 的问题都在同一个桶中。每个桶选出 10 个问题，每个地图的桶数由特定地图的路径长度决定。迷宫地图上的问题较多，因为迷宫中的路径非常长。《龙腾世纪 2》中的一些地图相对较小，因此即使地图数量较多，每张地图的问题数量也比其他地图少。</p>
<p>每个地图源的地图尺寸分布见图 2。从最大到最小，地图大小在 4 个数量级以上。较小的地图来自《龙腾世纪》游戏，而较大的地图则来自《星际争霸》和人造地图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011426954.png" alt="image-20240301142615062"></p>
<h2><span id="experimental-setup">Experimental Setup</span></h2><p>为确保比赛结果不会受到 CPU 时序变化的过度影响，我们在每个参赛作品上运行问题集 5 次。参赛项目必须实现一个简单的接口，用于预计算地图数据、加载预计算数据以及在地图上进行路径计算。所有条目在运行前都要进行预计算。重复运行并不是连续的，因此前一次运行的数据不会在随后的运行中进入缓存。条目可以选择一步返回整个路径，也可以逐步返回，从而创建一个可以交错规划和移动的实时智能体。</p>
<p>在历年的比赛中，实验都是在同一台机器上进行的，这台服务器配备了双处理器四核至强 E5620，主频为 2.4Ghz，内存为 12GB。求解过程使用顺序 API，但预处理可以并行进行。</p>
<p>根据不同的领域，有大量有趣的指标可以确定最佳入口。我们并不设定特定的效用函数来确定最佳入口，而是寻找非优势入口的帕累托最优前沿。这样，实践者就可以自己分析数据，选择最适合自己应用的方法。</p>
<p>衡量标准包括：</p>
<ul>
<li><p><strong>总时间（秒）</strong>： 这是找到所有问题的解决方案所需的总时间。</p>
</li>
<li><p><strong>平均时间（毫秒）</strong>： 这是查找单条路径的平均时间（毫秒）。</p>
</li>
<li><p><strong>20 步（毫秒）</strong>： 这是找到路径前 20 步的平均时间（毫秒）。这可以衡量可跟踪路径的速度，在游戏或机器人等实时应用中非常重要。</p>
</li>
<li><p><strong>最大线段（毫秒）</strong>： 这是生成路径中任何单独网段所需的最长时间的平均值。这衡量的是最差情况下的实时性能。</p>
</li>
<li><p><strong>平均长度</strong>： 这是返回路径的平均长度。如果一个条目在长路径上是最优的，而在短路径上是次优的，那么它将接近平均长度，因为大部分长度来自最长的路径。</p>
</li>
<li><p><strong>次优化</strong>： 这是每条路径的平均次优度。如果一个条目在长路径上是最优的，而在短路径上是高度次优的，那么由于大多数路径都是短路径，因此这个指标会很大。</p>
</li>
<li><p><strong>解决数量</strong>： 这是 347，868 ∗ 5 &#x3D; 1，739，340 个问题中已解决的问题总数。</p>
</li>
<li><p><strong>无效</strong>： 这是返回的无效解决方案的数量，这些解决方案的路径并不完整（例如，返回路径中的相邻位置在地图上并不相邻）。</p>
</li>
<li><p><strong>未解</strong>： 这是未解决、无解决方案的问题数量。</p>
</li>
<li><p><strong>内存（之前）</strong>： 这是加载预计算数据后的内存使用量（以 MB 为单位）。</p>
</li>
<li><p><strong>内存（后）</strong>： 这是运行全部问题集后的内存使用量（以 MB 为单位）。这包括用于存储结果的内存，因此所有条目的内存使用量都被人为夸大了。</p>
</li>
<li><p><strong>存储空间</strong>： 这是用于所有预计算存储的磁盘空间。</p>
</li>
<li><p><strong>预计算时间</strong>： 这是全部预计算所需的时间（分钟）。执行并行预计算的条目会在下一节的结果表中用 † 标记。</p>
</li>
</ul>
<p>最初的 GPPC 竞赛限制了 RAM 和预计算时间，但后来取消了这些限制，使参赛作品更加多样化，但代价是在竞赛期间需要更多的计算。</p>
<p>2014 年共有 6 个团队的 14 个程序参赛1 。下文将对这些参赛项目进行详细介绍，但参赛项目有几个高层次的趋势。首先，我们看到新参赛者大量重复使用代码。这降低了参赛门槛，使参赛者可以从以前最好的作品开始。以往参赛作品的可用性也有助于在比赛之外进行实验比较。接下来，我们可以将参赛作品分为几种高级方法。这些方法包括</p>
<ul>
<li><em><em>Faster A</em> implementations</em><em><em>。过去，这包括伪优先队列等工作。今年该类别有两个参赛作品，分别是 Relaxed A</em> (RA</em> ) 和桶式开放列表版 A* （ bucketed open list version of A*） 。</li>
<li><strong>Grid Exploitation.</strong> 有几个项目专门致力于利用网格中存在的结构。其中包括基于跳点搜索（Harabor 和 Grastien，2011 年）和子目标图（Uras 和 Koenig，2014 年）的条目。这些技术密切相关，但全面描述它们之间的关系超出了本文的范围。</li>
<li><strong>Compressed All Pairs Shortest Paths.</strong>  压缩路径数据库是压缩全对最短路径数据的第一种方法（Botea，2012 年）。今年有两个基于单行压缩（SRC）的新条目。</li>
<li><strong>Other approaches</strong>。子目标方法包含了收缩层次法（Geisberger 等人，2008 年）的一些理念；今年我们也有一个收缩层次法参赛。在往年的比赛中，也出现了一些次优方法。</li>
</ul>
<h2><span id="2014-competition-results">2014 Competition Results</span></h2><p>竞赛的全部结果见表 2。用粗体字标出的参赛作品是那些不被其他参赛作品所支配，形成帕累托最优边界的作品。也就是说，它们至少在一项指标上的表现优于所有其他参赛作品。这些条目的粗体指标是它们不占优势的指标。看完总体趋势后，我们再来研究被支配的条目。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011441487.png" alt="image-20240301144139572"></p>
<p>我们注意到以下数据趋势：</p>
<ul>
<li><p>很难设计出更好的开放式列表结构并保证其正确性。RA* 成功地做到了这一点。2012 年的伪优先队列（PPQ）方法无法解决的问题数量很少（23 个）。除此之外，它的速度明显快于 RA* ，次优性也较低。A* Bucket 作品也有类似的问题，但该作品是在较晚的时候才从组织者那里征集到的，因此参赛者在提交作品之前测试作品的时间相对较少。我们希望明年的参赛作品能有明显改善。</p>
</li>
<li><p>自 2012 年以来，子目标方法不断改进，使用的 RAM 相对较少。</p>
</li>
<li><p>在整个比赛期间，JPS 参赛作品的性能提高了 10 倍以上，如果考虑到算法的非预处理版本，提高的幅度甚至更大。</p>
</li>
<li><p>在道路网络中取得成功的收缩层次法（CH），现在在游戏地图上也有非常出色的表现。</p>
</li>
<li><p>预计算方向启发法（PDH）（Parra、de Reyna 和 Linares L ́ opez，2012 年）是之前少数几个利用增量计算的参赛项目之一。今年的单行压缩（SRC）参赛作品速度更快，性能更优，但占用内存更大。</p>
</li>
<li><p>查找完整路径最快的条目仍然是 Ken Anderson 在 2013 年发布的 “树缓存 “条目；新条目主要侧重于最优路径。</p>
</li>
<li><p>虽然严格来说 BLJPS 和 NSubgoal 条目使用的 RAM 最少，但许多条目使用的 RAM 量相差无几，因此在实际使用中这种差异并不一定有意义。</p>
</li>
</ul>
<p>出于篇幅考虑，我们在此不对这些数据作进一步细分（如按地图类型或路径长度）。有兴趣的读者可以查阅完整数据。不过，我们在此从过去的条目开始，说明每个条目被支配或不被支配的原因。</p>
<p><strong>过往作品</strong></p>
<ul>
<li><p>2012 年的 JPS 条目是非主导条目，因为没有其他最优条目不使用预计算。</p>
</li>
<li><p>2012 年的 “JPS+”项目被 2014 年的 “JPS+”项目弱支配。(这两个条目都是最优的，因此它们永远不会被完全支配）。</p>
</li>
<li><p>PPQ 条目（Guivant、Seton 和 Whitty，2012 年）将是非主导条目，但它并没有解决 23 个问题。</p>
</li>
<li><p>块 A* （Block）（Yap 等人，2011 年）除存储外，都被 BLJPS 所支配。但是，从 RAM 使用情况可以看出，Block A* 在运行时会计算一个 60MB 的表，而不会将其保存，因此我们仍然认为这个条目是被支配的。</p>
</li>
<li><p>2012 年和 2013 年的子目标条目被 2014 年的 NLevelSubgoal 条目所占据。</p>
</li>
<li><p>PDH 条目不占优势，因为只有一个条目的 20 步时间更快，但它使用的存储空间更大。</p>
</li>
<li><p>树 条目是非主导条目，因为没有任何条目能比该条目更快地找到完整路径。</p>
</li>
</ul>
<p><strong>2014 Entries</strong></p>
<ul>
<li>在所有不执行预计算的条目中，RA* 条目占用的内存最少，因此不占主导地位。</li>
<li>除了预计算存储空间外，BLJPS2 在 BLJPS2 中占主导地位。它是使用 20MB 或更少的存储空间速度最快的最佳条目。</li>
<li>JPS+ 以 BLJPS2 为主，尽管其差异在下文所述的 99% 置信度范围内。</li>
<li>BLJPS2 不占优势，因为它是使用 47MB 或更少的存储空间速度最快的最佳条目。</li>
<li>RA-Subgoal 不占优势，因为它是使用 264MB 或更少的存储空间的最快条目。</li>
<li>除预处理时间外，JPS+ Bucket 与 NSubgoal 相比优势微弱。但是，这些差异并不一定有意义。</li>
<li>除预处理时间外，BLJPS Sub 在 NSubgoal 中的优势较弱。但是，这些差异并不一定有意义。</li>
<li>NSubgoal 不占主导地位，因为它是使用 293MB 或更少的存储空间的最快最优算法。</li>
<li>CH 是非主导算法，因为它是使用 2.4GB 或更少的存储空间速度最快的最优算法。</li>
<li>由于 SRC-dfs-i 是最快的增量算法（20 步和最大分段时间），因此不占优势。</li>
<li>SRC-dfs 是非主导算法，因为它是返回完整最优路径的最快算法。</li>
<li>如果 A* Bucket 解决所有问题的次优性或速度都优于其他所有不进行预计算的参赛作品，那么它就不占优势。(由于是比赛组织者在最后一刻征集的作品，因此没有足够的时间进行测试）。</li>
<li>SRC-cut 条目由 SRC-dfs 条目主导。</li>
</ul>
<p>这些结果表明，帕累托前沿有许多算法。</p>
<p>表 3 显示了 2014 年每个条目的时间的 95% 置信区间。这些值基于每个参赛作品在每个问题上运行 5 次这一事实。因此，我们使用 5 个样本的 t 检验来计算置信区间。虽然样本数很少，但置信区间也很小，因为我们在五个样本中的每个样本中都运行了如此多的问题（347 868 个）。所有条目都能以 95% 的置信度区分。最接近的结果是 JPS+ 和 BLJPS2 条目；这些条目无法以 99% 的置信度区分。</p>
<h2><span id="2014-competition-entries">2014 Competition Entries</span></h2><p>在下面的文字中，每个条目的作者都详细介绍了自己的方法。各部分根据各部分内容的重叠程度排序。</p>
<h3><span id="subgoal-graph-子目标图">subgoal graph 子目标图</span></h3><p>该词条的作者是来自南加州大学的 Tansel Uras 和 Sven Koenig。他们提交了表 2 中的条目 NSubgoal。</p>
<p>本节介绍子目标图的两种变体。简单子目标图是通过在障碍物的凸角处放置子目标并将它们连接起来而构建的网格。它们类似于连续地形的可见度图，但边缘较少，可用于快速查找网格上的最短路径。简单子目标图的顶点可以划分为不同的级别，从而创建 N 级子目标图（今年的参赛作品），通过忽略与搜索无关的子目标，可以更快地找到网格上的最短路径，从而显著减少搜索图的大小。</p>
<p><strong>简单子目标图 (SSG）</strong>简单子目标图（Uras、Koenig 和 Hern ́ andez，2013 年）是通过在障碍物的凸角处放置子目标，并连接可直接到达的子目标对，从而从网格中构建出来的。定义 1 正式定义了这些概念。顶点位于无障碍单元的中心。边的长度等于它所连接的顶点之间的八分距离。图 3 显示了 SSG 的一个示例。请注意，子目标 C 和 E 是 h 可达的，但不是直接 h 可达的（由于子目标 D 的存在），因此没有连接它们的边。</p>
<p><strong>定义 1</strong>. 一个单元格 s 是一个子目标，当且仅当 s 是无阻塞的，s 有一个阻塞的对角线邻居 t，并且 s 和 t 的两个邻居单元格都是无阻塞的。&#x3D;&#x3D;当且仅当两个单元格 s 和 t 之间的最短网格路径长度等于它们之间的octile距离时，这两个单元格才是 h 可到达的。当且仅当两个单元格之间的最短路径都不经过子目标时，它们才是可直接到达的。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011454789.png" alt="image-20240301145422878"></p>
<p>使用 SSG 寻找最短网格路径时，需要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后用 A* 搜索此图，找到连接 s 和 g 的可直接到达子目标序列，即最短高层路径。例如，如果我们要使用图 3 中的 SSG 寻找 B1 和 H3 之间的最短网格路径，我们会将 B1 连接到子目标 A 和 B，将 H3 连接到子目标 F，然后搜索该图，找到最短高层路径 B1-D1-D3-F5-H5-H3。沿着网格上的这条高层路径，我们可以得到最短的网格路径 B1C1-D1-D2-D3-E4-F5-G5-H5-H4-H3。</p>
<p>通过使用预先计算出的间隙值的动态编程算法，可以高效地确定从给定单元可直接到达的子目标。使用这种算法，可以在几毫秒内构建 SSG，并在搜索前迅速将起始顶点和目标顶点连接到 SSG。</p>
<p><strong>N-Level Subgoal Graphs</strong></p>
<p>N 层子目标图（Uras 和 Koenig，2014 年）是通过在 SSG 的顶点之间创建层次结构来构建的。这种层次结构与本文后面描述的收缩层次结构（Geisberger 等人，2008 年；Dibbelt、Strasser 和 Wagner，2014 年 a）非常相似，只是 N 层子目标图可以将多个顶点置于层次结构的同一层次，并且只在 h 个可达到的子目标之间添加新的边。构建过程中，每个子目标的级别都是 1，然后重复将最高级别的子目标划分为全局子目标和局部子目标，并将全局子目标的级别增加一级（任何在划分之初不在最高级别的子目标在划分过程中都会被忽略）。这个过程一直持续到最高级别的子目标无法再被分割，或者图中的级别数达到用户定义的限制为止。在将最高层子目标划分为全局和局部子目标时，划分必须满足以下属性： 如果从图中移除任何一个本地子目标子集，剩余的本地子目标和全局子目标之间的最短路径长度必须保持不变。图 4 显示了由图 3 中的 SSG 构建的两级子目标图（在子目标 D 和 F 之间添加了一条边）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011455423.png" alt="image-20240301145531509"></p>
<p>要使用 N 级子目标图查找最短路径，首先要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后通过递增边（从子目标到更高级子目标的边，如果 s 和 g 不是子目标，则假定它们的级别为 0）确定所有可从 s 和 g 到达的子目标，并搜索由这些子目标和所有最高级子目标（以及它们之间的边）组成的图，从而在搜索过程中忽略其他子目标。例如，如果使用图 4 中的两级子目标图来查找 B2 和 H3 之间的路径，那么搜索到的图将包括子目标 A、B、D 和 F，但不包括 C 和 E。</p>
<p>在构建过程中考虑顶点的顺序决定了所得到的层次结构。正如收缩层次结构所显示的，良好的节点收缩排序可以大大加快路径规划的速度，这也是收缩层次结构方法经常花费大量预处理时间来寻找良好节点收缩排序的原因。未来的工作是在子目标层次结构的背景下考虑这种效果，因为子目标层次结构的 GPPC 条目使用任意节点排序。</p>
<h3><span id="jump-point-search-jps">Jump Point Search (JPS)</span></h3><p>由于多个条目都建立在跳点搜索（JPS）（Harabor 和 Grastien，2011 年；2014 年）的基础上，我们提供了算法的基本描述，作为这些条目的介绍。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011457933.png" alt="image-20240301145723064"></p>
<p>JPS 利用网格结构避免通过交替&#x2F;冗余路径到达许多状态。JPS 的核心理念是对路径进行排序，使所有对角线移动优先，然后是水平&#x2F;垂直移动。这就为所有路径创建了一个规范排序，确保每个目标只有一条路径。然而，仅有这一想法是不够的，因为障碍物可能会阻挡通往特定目标的自然典型路径。因此，我们引入了跳跃点。跳转点是地图中部分重置典型排序的位置，以便让搜索绕过障碍物。我们在图 5 中对此进行了说明。在图 5（a）中，我们展示了根据从 S 开始的规范排序可到达的状态。在图 5（b）中，我们添加了一个标为 J 的跳转点，在这里规范排序被重置，允许搜索向下、向右进行，从而到达目标。J 的新邻居称为强制邻居。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011458480.png" alt="image-20240301145822139"></p>
<p>跳跃点取决于地图上的障碍物，可以在运行时使用，也可以事先计算。JPS 的高效不仅在于它限制了对称路径的数量，&#x3D;&#x3D;还在于它减少了开放列表中存储的节点数量。我们不需要把节点的每个后继节点都放在开放列表中，而只需要把跳转点放在开放列表中。&#x3D;&#x3D;下面两个条目是在 JPS 的基础上改进其性能的。</p>
<h3><span id="bljps">BLJPS</span></h3><p>本条目作者是查尔斯特大学的杰森-特雷什（Jason Traish）和詹姆斯-图利普（James Tulip）。他们提交了表 2 中的参赛作品 BLJPS、BLJPS2 和 BLJPS Sub。</p>
<p>边界查找跳点搜索（BLJPS）是跳点搜索（JPS）的扩展。BLJPS 对地图上的边界进行预处理，以加快跳跃点检测速度。边界用于识别沿水平轴或垂直轴存在的跳转点，而无需反复检查大量单元格。</p>
<p>正常的 JPS 行为允许在相关主方向被阻挡时进行对角移动。但在本次比赛中，此类移动是被禁止的。在提交的代码中，这些行为之间的切换由标志变量 DIAG UNBLOCKED 控制。</p>
<p>下面的示例使用图 6 演示 JPS 如何从 P1 移动到 P4。每个基本方向的检查都以虚线显示。搜索从 P1 开始，检查所有 8 个方向（主方向和对角线方向）的跳转点。在本例中，只有东、北和东北三个方向可以访问。JPS 沿着一个基本方向遍历开放位置，直到到达一个受阻位置，然后终止搜索，不返回跳转点。在这种情况下，东面和北面都无法返回跳转点。然后，算法沿东北方向对角扩展到位置 (B8)。然后重复迭代检查相对于东北方向（北和东）的红心方向跳转点。同样，沿任一轴线都找不到跳转点，该过程重复进行，直到对角线扩展到达边界或在任一相对主轴方向上找到跳转点。在这种情况下，NE 扩展会继续到 P2 位置，此时东心轴方向检查会在 P3 位置返回一个潜在的跳转点，该跳转点由一个强制邻接点的存在而确定。然后，P2 就会被添加到开放列表（openlist）中，方向为 NE。无论是否发现东北方向的跳转点，都会终止从 P1 开始的搜索，因为只有北、东和东北方向可以访问。</p>
<p>然后弹出开放列表中的顶层节点，返回 P2。然后搜索 NE 扩展的自然邻接方向（N、E、NE）。在北向和东北向的搜索中没有发现其他跳转点，但在东向有 P3 作为潜在跳转点。P3 作为实际跳转点的评估方式与 P2 类似。然而，由于 P4 的强迫相邻点，东南方向也进行了搜索。在 SE 方向上的步进确定了目标 P4 已经到达。这就确认了 P3 为跳转点，并完成了路径（P1、P2、P3、P4）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011459012.png" alt="image-20240301145953935"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011501166.png" alt="image-20240301150103119"></p>
<p>表 4 显示了与图 6 相对应的边界查找表。表 4 中的数值记录了从西部（或北部）边界开始，单元格在阻塞和开放状态之间切换的边界。第 1 行至第 5 行没有障碍物，因此水平边界查询记录的是地图宽度（N）。但第 6 行至第 9 行在 K 处有边界，因此将其记录为第一个条目。然后，边界在 L 单元重新打开，并再次被地图宽度（N）阻挡。</p>
<p>当 BLJPS 的边界在给定方向上比其上下两行的重开值更远时，BLJPS 就会识别出东&#x2F;西方向的跳转点。例如，东面（A5）的边界为 N，小于其下面行（第 6 行）的重开值。第 6 行的边界为 K，向东重新打开的边界为 L，小于 N，因此跳转点为（L-1&#x3D;K 第 5 行，K5）或 P3。如果从（M5）开始向西移动，边界会在-A 处离开地图。5 下方的第 6 行以 K 为西部边界，并在（K-1&#x3D;L）上重新打开，该边界在西部方向上没有 -A 边界那么远。</p>
<p>BLJPS2 优化了这种方法，将四个主要方向的跳转点分别存储在不同的列表中。这样，每次检查轴的查表次数就从三次减少到一次。</p>
<p>BLJPS SubGoal 是一种介于 BLJPS 和 SubGoal 之间的混合方法。它使用与 SubGoal 相同的高层图剪枝方法，但用跳跃点代替低层子目标，以利用 JPS 的方向性。不过，将目标节点附加到低层 SubGoal 图上的计算成本很高，而且与基本的 SubGoal 算法相比没有任何改进。SubGoal 是从 2013 年基于网格的路径规划竞赛的参赛作品中提取的。</p>
<h3><span id="optimized-jps">Optimized JPS+</span></h3><p>本条目作者是史蒂夫-拉宾。提交的作品包括 JPS+、JPS+Bucket 和 A* Bucket。</p>
<p>JPS+ 为每个节点（每条边一个）预先计算 8 个值，这有助于在运行时引导搜索到预先确定的跳转点节点。通过典型排序搜索和在前往关键跳转点节点的途中跳过节点的组合，实现了显著的节点剪枝。这样做的效果是，通过检查更少的节点来加快搜索速度，从而减少开放列表中的节点数量。</p>
<p>优化后的 JPS+ 在编程时采用了多种最佳实践，每种实践对整体速度的贡献都很小。搜索所需的节点数据预先分配在一个二维数组中，每个节点中存储的搜索迭代计数避免了在每次搜索前重置节点数据的需要。所有成本均使用定点数学计算，启发式则使用八分启发式计算：我们计算两点之间在每个基本方向上的最大和最小距离。八分位距即为（minDiff ∗ (√2 - 1.0) + maxDiff）。此外，如果某个节点已经在开放列表中，而其成本需要更新，则会提取启发式，从而避免重新计算。最后，开放列表使用了堆优先级队列和哈希表，以加快 A* 在搜索中找到通往现有节点的更短路径时进行的 DecreaseKey 操作。</p>
<p>经过优化的 JPS+ 的 “桶 “版本将堆优先级队列换成了使用桶实现的优先级队列，桶以成本为索引，每个桶内包含一个堆栈。所需的桶数是最大搜索成本的 10 倍，节点的桶索引等于最终成本的 10 倍，因此每个桶内的成本差异为 0.1。一个指针记录着最便宜的非空桶，并根据需要在添加和删除时进行更新。每个水桶内都使用了搜索迭代计数，以实现每次新搜索时的懒重置。</p>
<p>有两项重要的优化未能在比赛中及时实施，但已证明它们都能进一步加快 JPS+ 的搜索速度。使用快速堆栈优化非常有帮助，2013 年的参赛作品 Subgoal 就实现了这一点。如果节点的成本等于父节点的成本，该优化就会将节点放在堆栈中，而不是开放列表中。&#x3D;&#x3D;然后，在检查开放列表之前，节点会从快速堆栈中移除。需要注意的是，这种优化方法只适用于使用 octile 启发式的网格搜索空间&#x3D;&#x3D;。此外，基于墙模式和父节点方向的函数指针查找表已经证明可以通过消除条件来加快搜索速度（2,048 个条目指向 48 个独特的函数）。最后，作为一种内存优化方法，通过对所有搜索成本进行重定向，以起始节点的原始八叉启发式成本为基准，可以减少桶的数量。</p>
<p>为了便于比较，A* Bucket 是一个基于 A* 的条目，它采用与 JPS+ 类似的方式，为开放式名单设置分桶。</p>
<h3><span id="relaxed-a">Relaxed A*</span></h3><p>本作品由 <a target="_blank" rel="noopener" href="http://www.iroboapp.org/">http://www.iroboapp.org/</a> 网站的一个研究小组撰写。由于非科学方面的原因，该作品的作者无法参与本论文；本说明由竞赛组织者撰写。</p>
<p>该小组的研究人员提交了表 2 中标有 RA* 和 RA-Subgoal 的条目。他们的条目在三个方面放宽了 A* 的行为。&#x3D;&#x3D;首先，它不允许节点的 g-cost 在首次设定后被更改。&#x3D;&#x3D;其次，由于节点的 g-cost 只更新一次，因此在使用 A* 打开节点时，无需明确检查打开列表中的成员。所有开放节点的 g-cost 都是无限的。最后，该条目不维护父节点指针，而是假设节点的父节点是 g 成本最低的节点。</p>
<p>这种方法首先应用于常规 A* 搜索，然后应用于作为子目标图一部分的 A* 搜索（Uras、Koenig 和 Hern ́ andez，2013 年）。子目标代码由 2013 年 GPPC 竞赛中的 SubgoalGraph-Fast 代码构建而成。</p>
<h3><span id="contraction-hierarchies-ch">Contraction Hierarchies (CH)</span></h3><p>本条目的作者是卡尔斯鲁厄理工学院的 Ben Strasser，在表 2 中标注为 CH。</p>
<p>CH 是一种在一般加权图中计算最短路径的加速技术。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以利用辅助数据，运行速度应该非常快。该技术在（Geisberger 等人，2012 年）中提出，此后成为许多研究论文的焦点。在各种独立研究中，该技术在道路图上得到了广泛的评估。然而，人们一直在质疑该技术在源自游戏网格的图上是否可行，或者该技术是否需要调整。本论文的唯一目标就是确定这一点。我们没有针对游戏地图对提交的代码进行优化。事实上，我们的代码取自（Dibbelt、Strasser 和 Wagner，2014b）的实现，并进行了大部分封装。应该可以对代码进行调整。例如，预处理代码并没有利用游戏图是无向的这一特点。这样做应该很简单，并能将预处理运行时间缩短 2 倍。</p>
<p>算法的核心思想很简单，但需要一些符号。用 G 表示输入图，在本次竞赛中，输入图是无向的。辅助数据包括一个有向无循环搜索图 G′，其节点集与 G 相同，且满足覆盖属性： 对于每一对源节点 s 和目标节点 t，都存在一个节点 m，这样对于 G 中的每一条最短 st 路径 P，G′ 中都存在一条 sm 路径 P ′ u 和一条 tm 路径 P ′ d，使得 P 的长度与 P ′ u 和 P ′ d 的长度之和相同。我们把 P′ u 称为向上路径，把 P ′ d 称为向下路径。我们把 P ′ u 和 P ′ d 称为上下路径。</p>
<p>将顶部节点视为覆盖许多最短路径的重要节点。例如，道路图中的桥梁。底部节点则非常不重要。将它们视为死胡同。你可以把上-下路径看作是 G 中最短路径的粗略化版本。粗略化意味着两个顶部节点（即桥梁）之间的所有边都不见了。该算法的思路是搜索 P′ u 和 P ′ d，即一条向上向下的路径，而不是 P。 该算法使用两个在 G′ 上运行的 Dijkstra 算法实例。第一个实例从 s 开始搜索，第二个实例从 t 开始搜索。第一个实例找到 P ′ u，第二个实例找到 P ′ d，由此可以重建 G 中的路径。我们将节点 x 可到达的 G′ 子图称为 x 的搜索空间。</p>
<p>要构建 G′，我们需要（加权）节点收缩的概念。这就是为 CH 命名的操作。节点收缩包括从图 H 中移除节点 x，并在两个相邻节点 y 和 z 之间插入一条边，条件是 y→x→z 路径是唯一最短的 yz 路径。检验 y→x→z 是否具有这一特性的方法是在 H{x} 上运行迪克斯特拉算法，检查 H{x} 中最短的 yz 路径是否比 y→x→z 长。这一操作称为见证搜索。我们的想法是从 H 中删除 x，同时保持 H{x} 中所有最短路径的距离。G′ 是通过沿着收缩阶 o1 … on 迭代收缩不重要节点从 G 中构造出来的。用 Gi 表示前 i - 1 个节点收缩后剩下的图，即 G1 &#x3D; G，Gi 是通过在 Gi-1 中收缩 oi-1 得到的。在枚举这些 Gi 的同时，算法按如下方式构建 G′： oi 的出弧指向 Gi 中 oi 的邻弧。正如（Geisberger 等人，2012 年）所述，这种构造符合覆盖属性。</p>
<p>剩下的关键问题是如何确定良好的节点收缩顺序。这是目前预处理中最慢的部分。文献中存在几种方法。最初的 CH 论文（Geisberger 等人，2012 年）采用了一种自下而上的方法，在 CH 收缩过程中贪婪地确定最不重要的节点。在（Abraham 等人，2012 年）中，引入了一种自上而下的方法。这种方法的理念是，最重要的节点是位于最多非覆盖最短路径上的节点。(自下而上的方法在类似道路的图中实际效果非常好，但却像烹饪食谱一样优雅： 你将各种启发式方法混合使用，最后问题就会迎刃而解。据我们所知，没有人真正知道为什么一种配方优于其他配方。自上而下的方法更为优雅，但其基本变体速度较慢。在（Delling 等人，2014 年）一书中，介绍了一种基于快速采样的自顶向下方法。自下而上和自上而下的方法计算的阶数都取决于 G 的边权重。在（Dibbelt、Strasser 和 Wagner，2014b；Bauer 等人，2013 年）中，引入了第三种基于平衡图分离器的与权重无关的构造，并证明其查询性能非常接近与权重有关的阶次。这种与权重无关的构造与树分解理论紧密结合在一起。</p>
<p>GPPC 提交的论文采用了一种相对缓慢但高质量的自下而上排序方法。其核心思想是将 G′的构建与收缩排序交织在一起。该算法为 Gi 中的每个节点 x 确定一个重要性值 Ii(x)。然后设置 oi &#x3D; min arg Ii(x)。在下文中，我们将去掉 Ii 中的 i 索引和，以避免不必要的符号杂乱。为了避免在每次迭代中重新计算所有 I(x)，我们使用了一个优先级队列，按照节点当前的重要性对所有节点进行排序。收缩节点只会修改相邻节点的重要性。这些值在每次迭代中都会更新，然后算法会继续收缩 I(x) 最小的节点。I(x) 的定义就像一份烹饪食谱。我们首先定义所有配料。我们用 L(x) 表示近似顶点 x 在 G′ 中的水平值。最初所有 L(x) 都是 0。如果 x 是收缩的，那么对于每一条入射边 {x, y}，我们都要执行 <code>(y) ← max&#123;</code>(y), &#96;(x) + 1}。我们进一步为每条弧 a 存储一个跳长 h(a)。这是该快捷方式完全解包后所代表的弧的数量。用 D(x) 表示如果 x 被收缩则删除的弧集，用 A(x) 表示将插入的弧集。集合 A(x) 和 D(x) 是通过模拟节点收缩计算得出的。我们设定:<br>$$<br>I(x) &#x3D; L(x) + \frac{|A(x)|}{|D(x)|} + \frac {\sum_{a \in A(x)} h(a)}{\sum_{a \in D(x)} h(a)}<br>$$<br>该公式源自（Abraham 等人，2012 年）。请注意，原始的 CH 变体（Geisberger 等人，2012 年）包含了更多旨在减少预处理时间的启发式。例如，如果 Dijkstra 算法运行时间过长，他们的变体就会中止见证搜索，而且不会更新所有 I(x)，而是使用一种称为 lazy-pop 的技术。而我们提交的 GPPC 没有做这些工作。</p>
<p>为了说明 CHs 的性能，我们在星际争霸 IceFloes 地图上进行了一次实验。该地图有 91,123 个单元，将其转化为一个有 91,123 个节点和 347,624 条边（权重为 1 或 √2）的图 G。确定顺序只需不到 2 分钟的时间。搜索图 G′包含 733 114 条弧。随机均匀节点的搜索空间平均包含 680 个节点和 6,677 条弧。搜索图 G′有 48 层。这个 CH 性能非常好。只有在极少数情况下，才能在保持合理搜索空间大小的同时，使每条输入边的搜索图弧少于两条。不过，我们相信，通过利用输入实例的映射结构，仍然可以取得显著的改进。例如，将输入图编码为二维位图的内存效率要远远高于任何等效的通用图表示法。利用这一观察结果可以大大降低内存占用。</p>
<h3><span id="single-row-compression-src">Single Row Compression (SRC)</span></h3><p>本条目作者为 Ben Strasser、Adi Botea 和 Daniel Harabor，对应表 2 中的条目 SRC-dfs、SRCdfs-i、SRC-cut、SRC-cut-i。</p>
<p>SRC 是一种在有界度的一般加权图中计算最短路径的加速技术。该技术在（Strasser、Harabor 和 Botea，2014 年）中提出，其理论复杂性在（Botea、Strasser 和 Harabor，2015 年）中进行了研究。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图形进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以使用辅助数据，运行速度必须非常快。</p>
<p>使用这种设置的一个非常基本的技术是计算一个大型的首步矩阵 A。从源节点 s 到目标节点 t 的第一次移动是从 s 到 t 的最短路径的第一条边。矩阵 A 的每个条目 aij 对应于从第 i 个节点到第 j 个节点的最短路径的第一条边。按照惯例，我们认为第 i 行包含了从第 i 节点到所有其他节点的所有首条路径。同样，第 j 列包含了所有向第 j 节点的第一次移动。这种设置的查询阶段速度极快，大部分时间只需一次随机存储器访问。这种方法的缺点是矩阵需要的空间是节点数的二次方，这对于大型图来说是无法承受的。</p>
<p>SRC 通过利用一个非常简单的观察结果来缓解这一空间问题： 一行中的所有边都必须是单个节点的出边。如果我们假设图的度数是有界的，那么许多边必须重复。SRC 利用这一事实，使用运行长度编码 (RLE) 对每一行进行单独压缩。如果处理得当，查询的运行时间可按压缩行长度的对数计算。遗憾的是，使用 RLE 可能无法很好地压缩行。因此，SRC 首先会对节点进行排列，使相似的首移在一行中倾向于出现在相邻位置。不幸的是，正如（Botea、Strasser 和 Harabor，2015 年）中所示，计算一个能使运行次数最小化的节点顺序是 NP 难的。幸运的是，启发式方法在实践中运行良好： Strasser、Harabor 和 Botea 2014）提出了 dfs 排序和 cut 排序。dfs-order 非常简单，只需从随机根节点开始使用深度优先预排序对节点重新排序。剪切阶更为复杂，对图形进行递归分割。在大多数测试过的图形上，剪切排序的效果略好于 dfs 排序。但在某些图上，由于不明原因，剪切阶数远不如 dfs 阶数。这导致了糟糕的压缩率。这就导致了整数溢出，这也解释了为什么剪切阶提交会在一些图形上失败。为了直观了解好的阶次是怎样的，请看美国道路图。考虑东南部某个节点的行 R。如果目的地在西北部，路径很可能总是从相同的第一步开始。成功的关键在于找到一种节点顺序，为西北部的所有节点分配连续的节点 ID。这样的顺序可以确保美国西北部的所有节点都在 R 中折叠成一个单一的运行。</p>
<p>SRC 的优势在于能快速计算先手。其主要缺点在于预处理时间，由于必须计算 A，预处理时间与节点数呈二次方关系。请注意，快速计算首步并不会自动转化为快速计算完整路径的最快算法。原因在于所有每次计算一条边的技术。这甚至包括基本的二次矩阵方法。这种算法需要对每条边进行一次随机内存访问。而将大部分路径预装在内存中的算法，只需对每个部分进行一次随机内存访问。由于缓存效应，速度会明显加快。(在当前的硬件上，顺序内存访问比随机内存访问快约 70 倍）。然而，在许多重要的应用场景中，对缓存更友好的路径计算最终并不会带来任何好处。考虑一个需要导航到某个位置的游戏单元。有两种不同的设置：(1) 在开始旅程时，单元会计算整个路径并将其存储在某处。每当单元到达一条边的终点时，它就会查找下一条边，即需要随机存取内存。(2) 每次单元到达一条边的终点时，它只计算下一条边。在实验室条件下，设置（1）可能比设置（2）更好，因为测得的运行时间通常只包括计算路径所需的时间。单元查找单条边所花费的时间往往被忽略。此外，(1) 方法需要在内存中存储长度可变的路径。这就增加了内存管理所需的时间，更重要的是，每个单元的内存消耗是不恒定的。考虑一种极端情况，即有ω(n) 个单元，其存储的路径有 Θ(n) 条边（n 为节点数）。这将导致 ω(n2) 的内存消耗。即使是采用二次矩阵方法的设置 2，在这种情况下也只需要 Θ(n2) 内存。</p>
<p>表 2 包含我们算法的 4 个变体。cut&#x2F;dfs 部分指的是所使用的节点顺序。-i “表示是在一次函数调用中提取完整路径，还是逐边提取路径。理论上，这应该没有什么区别。但在实际操作中，它会影响时序代码的调用频率。如果路径是在一次函数调用中提取的，那么定时代码只会在每次路径查询前后运行。然而，如果路径是逐边提取的，则定时代码会在每条边上运行一次。这种略有不同的实验设置导致 “dfs-i “和 “dfs “的路径提取平均运行时间相差 0.044ms。</p>
<h2><span id="looking-ahead-and-conclusions">Looking Ahead and Conclusions</span></h2><p>GPPC 涵盖各种基于网格的寻路问题。目前已开发出几种主要的竞争方法，它们利用网格结构的优势，显著提高了基本 A* 实现的性能。因此，该竞赛成功地记录了网格寻路的显著改进，并为实验和测试提供了高质量的寻路实现。</p>
<p>从作品的应用来看，比赛涵盖了游戏行业感兴趣的问题的一个子集，但并没有解决一些现实世界的问题，而这些问题有时是在使用网格时必须解决的。特别是，网格通常用于动态环境中，在这种环境中，世界和&#x2F;或在世界中移动的成本会定期发生变化（Sturtevant，2013 年）。这是因为当世界发生变化时，网格表示法易于更新且成本低廉。</p>
<p>目前的竞赛不允许在地图或动态地图中使用动态权重，而旨在促进此类比较的新赛道没有收到任何参赛作品。从某种意义上说，这并不完全令人惊讶，因为网格方法的研究已经有很多年了，所以有大量的作品可以参赛。此外，测试动态地图的方法有很多种，对于类似机器人的环境和游戏环境，可能需要进行不同的测试。</p>
<p>但是，经过几年的竞赛，我们可以看到用于提高性能的主要核心思想，以及一系列内存和预计算要求。随着这些方法的不断改进，我们期待看到更多技术填补这些参赛项目之间的空白。特别是，实时和次优条目还有很大的创新空间。</p>
<p>展望未来，重要的是要解决如何挑战研究界的难题，使其超越统一成本网格寻路问题，进而解决更能代表实践者所面临的真实世界问题。例如，本文第一作者正在与游戏行业合作，以获得更多地图和地图类型，从而为研究人员提供有意义的研究数据。我们将认真考虑如何利用竞赛来鼓励对不同问题类型的研究，这些问题类型在更广泛的领域中有着更广泛的应用。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-29T08:06:51.000Z" title="2024/2/29 16:06:51">2024-02-29</time>发表</span><span class="level-item"><time dateTime="2024-03-01T06:01:32.070Z" title="2024/3/1 14:01:32">2024-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约12365个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><div class="content"><h1><span id="near-optimal-hierarchical-path-finding">Near Optimal Hierarchical Path-Finding</span></h1><p>近似最优的分层路径搜索</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291608729.png" alt="image-20240229160758865"></p>
<h2><span id="abstract">Abstract</span></h2><p>商业计算机游戏中的路径搜索问题必须实时解决，而且往往受到内存和 CPU 资源的限制。使用 A* 等搜索算法确定路径所需的计算量会随着搜索空间的增大而增加。因此，在大型地图上寻路会导致严重的性能瓶颈。</p>
<p>本文介绍了 HPA* （Hierarchical Path-Finding A*），一种在网格地图上降低寻路问题复杂性的分层方法。该技术将地图抽象为相互关联的局部群组。在局部层面，预先计算并缓存穿越每个簇的最佳距离。在全局层面上，簇的穿越只需一大步。层次结构可以扩展到两级以上。小的聚类被组合在一起，形成较大的聚类。计算所有聚类的交叉距离时，会使用为包含的较小聚类计算的距离。</p>
<p>我们的方法是自动的，不依赖于特定的拓扑结构。在不使用特定领域知识的情况下，我们成功地处理了随机地图和真实游戏地图。我们的问题分解方法在环境不断变化的领域中效果非常好。该技术还具有简单和易于实现的优点。如果需要，还可以插入更复杂的领域专用算法，以提高性能。</p>
<p>实验结果表明，搜索工作量大大减少。与高度优化的 A* 相比，HPA* 的搜索速度最多可提高 10 倍，同时搜索到的路径与最优路径的差距不超过 1%。</p>
<h2><span id="1-introduction">1 Introduction</span></h2><p>商业计算机游戏中的路径选择问题必须实时解决，而且往往受到内存和 CPU 资源的限制。分层搜索被认为是降低这一问题复杂性的有效方法。然而，目前还没有关于商业游戏中分层路径搜索的详细研究报告。部分原因是游戏公司通常不会公开他们的想法和源代码。</p>
<p>行业标准是使用 A* [10]或迭代深化 A* ，即 IDA*  [3]。A* 通常速度更快，但 IDA* 使用的内存更少。这些算法有许多增强功能，可使其运行更快或探索更小的搜索树。对于许多应用，特别是那些有多个移动 NPC 的应用（如在实时战略游戏中），这些时间和&#x2F;或空间要求是限制因素。</p>
<p>本文介绍了在网格地图上进行分层路径搜索的新方法 HPA*，并进行了性能测试。我们的技术将地图抽象为相互关联的局部集群。&#x3D;&#x3D;在局部层面上，我们预先计算并缓存了穿越簇的最佳距离。&#x3D;&#x3D;在全局层面上，&#x3D;&#x3D;我们的行动是一步跨越一个簇，而不是移动到相邻的原子位置。&#x3D;&#x3D;</p>
<p>我们的方法简单、易于实现，而且通用，因为我们不使用任何应用特殊知识，应用该技术时也不受地图属性的影响。我们可以处理成本可变的地形和各种拓扑类型，如森林、带有任何形状障碍物的开阔区域或建筑物内部，而无需对实施进行任何更改。</p>
<p>对于许多实时路径搜索应用来说，并不需要完整的路径。通常只要知道有效路径的前几段就足够了，这样移动装置就能开始朝正确方向移动。随后发生的事件可能会导致移动装置不得不改变计划，从而不再需要路径的其余部分。A* 返回完整的路径。相比之下，HPA* 返回的是由子问题组成的完整路径。第一个子问题可以求解，让单位沿着路径走几步。根据需要，可以解决后续子问题，提供更多的移动。这样做的好处是，如果单位不得不改变计划，那么就不用浪费精力去计算通往前一个节点的路径，而这是根本不需要的。</p>
<p>分层框架适用于静态和动态变化的环境。在后一种情况下，&#x3D;&#x3D;首先假设不动的拓扑元素会发生局部变化（例如，a bomb 破坏了 a bridge）。&#x3D;&#x3D;我们在本地计算从被修改的集群中提取的信息，并保持框架的其他部分不变。其次，假设地图上有多个移动单元，计算出的路径可能会被另一个单元阻塞。我们将以较小的代价计算出一条抽象路径，而无需花费额外的精力将其还原为底层表示。我们会迅速让角色朝好的方向移动，并在角色需要时重新指定抽象路径的部分内容。如果路径受阻，我们会从角色的当前位置重新规划另一条抽象路径。</p>
<p>我们方法的层次结构可以有很多层，因此可以扩展到大型问题空间。当问题地图比较大时，可以通过增加层级数来减少搜索工作量，但代价是需要更多的存储空间和预处理时间。</p>
<p>我们的技术会产生次优解，以最优性换取更高的执行性能。在应用 apath-smoothing 程序后，我们的解决方案与最优方案的差距在 1%以内。</p>
<h3><span id="11-motivation">1.1 Motivation</span></h3><p>考虑从加利福尼亚州洛杉矶乘车前往安大略省多伦多市的问题。具体来说，从洛杉矶的圣莫尼卡大道 1234 号到多伦多的 Yonge 街 4321 号，开车行驶的最短距离是多少？给定一张详细的北美路线图，上面标注了所有道路的行车距离，A* 实现可以计算出最优（最小距离）行车路线。考虑到路线图的庞大规模，这可能是一项昂贵的计算。</p>
<p>当然，人类旅行规划师绝不会在如此低的细节级别上工作。他们要解决三个问题：</p>
<ol>
<li><p>从圣莫尼卡大道 1234 号前往通往洛杉矶以外的主要高速公路。</p>
</li>
<li><p>规划从洛杉矶到多伦多的路线。</p>
</li>
<li><p>从进入多伦多的高速公路行驶到 Yonge 街 4321 号。</p>
</li>
</ol>
<p>第（1）步和第（3）步需要绘制每个城市的详细路线图。第（2）步可以使用高密度地图，用道路连接城市，抽象出城市内部的所有细节。实际上，人类旅行规划师使用抽象方法快速找到从洛杉矶到多伦多的路线。然而，由于将城市视为黑盒子，这种搜索并不能保证找到最短的路线。例如，虽然在高速公路上行驶可能更快，但对于一些高速公路绕城而过的城市来说，离开高速公路穿过城市可能是更短的路线。当然，这也可能不是更快的路线（城市的车速比高速公路慢），但在这个例子中，我们试图尽量缩短旅行距离。</p>
<p>可以将抽象化提升到更高水平：在州&#x2F;省一级进行规划。一旦路径到达州界，就计算出州与州之间的最佳路线。知道各州的出入口后，再规划州际路线。同样，这样做也行得通，但可能会产生次优解决方案。</p>
<p>更进一步，抽象到国家层面：从美国到加拿大。显然，抽象到一定程度就会变得非常粗糙，以至于实际上毫无用处。</p>
<p>我们希望在计算机游戏路径搜索中采用类似的抽象策略。我们可以在一张完整的 1000 x 1000 地图上使用 A*，但这意味着一个巨大的搜索空间。将地图上的每个 10 x 10 个区块视为一个城市。现在，我们可以在 100  x 100 个城市的地图上进行搜索。对于每个城市，我们都知道城市的入口以及所有入口对的穿越成本。我们还知道如何在城市之间旅行。这样，问题就简化为三个步骤：</p>
<ul>
<li>起始节点： 在包含起点节点的区块内，找出通往区块边界的最佳路径。</li>
<li>在区块级（100 x100 个区块）搜索从包含起点节点的区块到包含目标节点的区块的最佳路径。</li>
<li>目标节点： 在包含目标节点的区块内，找出从区块边界到目标的最佳路径。</li>
</ul>
<p>其结果是，搜索速度大大加快，几乎可以得到最优解。此外，这种抽象与拓扑无关；设计人员无需手动将网格分解为高层次特征，也无需在网格上标注航点。</p>
<h3><span id="12-contributions">1.2 Contributions</span></h3><p>本文的贡献包括：</p>
<ol>
<li>HPA*，一种新的分层路径搜索算法（包括伪代码和源代码），该算法与领域无关，可很好地用于静态和动态地形拓扑。</li>
<li>对各种游戏迷宫（来自 BioWare’sB ALDUR’S GATE）进行分层搜索的实验结果表明，速度提高了 10 倍，而路径质量却下降了 1%。</li>
<li>一些游戏公司似乎正在使用分层搜索思想的变体，尽管它们的大多数算法细节并不公开。据我们所知，这是在商业电脑游戏领域使用分层 A* 的首次科学研究。</li>
</ol>
<p>第 2 节简要概述了背景文献。第 3 节介绍了我们的分层 A* 新方法，第 4 节对其性能进行了评估。第 5 节是我们的结论和进一步研究的主题。附录 A 提供了我们算法的伪代码。</p>
<h2><span id="2-literaturere-view">2 LiteratureRe view</span></h2><p>本节第一部分总结了商业游戏中用于路径定位的分层方法。第二部分回顾了更广泛背景下的相关工作，包括在机器人等其他网格领域的应用。</p>
<p>文献[5]描述了使用两级层次结构进行路径标定的方法。作者只提供了该方法的高分辨率演示。问题地图被抽象成一个个群组，如建筑物中的房间或场地上的方形块。一个抽象动作从入口中间穿过一个房间到达另一个房间。首先，这两种方法都将问题地图划分为方形块等群组。其次，抽象行动都是穿越街区（而不是从一个街区中心到另一个街区中心）。第三，两种技术都将区块入口抽象为一个过渡点（事实上，我们允许一个或两个过渡点）。这两种方法之间也存在显著差异。我们将层次结构扩展到多个抽象层，并以独立于领域的方式进行抽象。我们还预先计算并缓存了区块交叉的最佳距离，从而降低了在线计算的成本。</p>
<p>另一种重要的分层方法是利用可见度点（point of visibility）来进行商业游戏的路径定位[6]。对于每个节点，都会为从当前节点可以看到的所有节点添加边（即可以用直线连接的节点）。</p>
<p>当障碍物数量较少且形状为正多边形（如建筑物内部）时，这种方法尤其有用。当障碍物数量较多且&#x2F;或其形状不是正多边形时，该方法的有效性就会降低。考虑一下包含森林的地图，森林是小尺寸障碍物的密集集合。用可见度点来模拟这种顶部结构，会产生一个具有短边的图形（就节点和边的数量而言）。因此，就无法有效利用在单步中进行长距离行进的关键想法。当问题地图包含凹形或曲面时，该方法要么性能不佳，要么需要复杂的工程设计才能有效地构建图形。相比之下，我们的方法适用于多种类型的地图，并且不需要复杂的领域分析来进行抽象。</p>
<p>导航网格（又名 NavMesh）是一种强大的抽象技术，适用于二维和三维地图。在二维环境中，这种方法用一组（最小的）凸多边形来覆盖地图的无遮挡区域。[11]中介绍了一种构建接近最优 NavMesh 的方法，这种方法放宽了最小多边形集的条件，构建地图覆盖范围的速度更快。</p>
<p>除了商业电脑游戏，路径标定还应用于许多研究领域。在机器人领域探索过的基于拓扑抽象的路径定位方法与本文描述的工作尤其相关。四叉树[8]已被提出作为进行分层地图分解的方法。这种方法将地图分割成不同大小的方形块，使每个块只包含可行走的单元格或只包含阻塞的单元格。问题地图最初被划分为 4 个块。如果块中同时包含障碍单元和可行走单元，则将其进一步分解为 4 个更小的块，依此类推。在这个抽象框架中，行动就是在两个相邻区块的中心点之间行走。由于智能体总是走在两个区块的中间，因此这种方法会产生次优解。</p>
<p>为了提高求解质量，可以将四叉树扩展为有框四叉树 [1,12]。在有框四叉树中，块的边界以最高分辨率的单元增强。一个动作在任意两个边界单元之间穿过一个块。另一方面，框架四叉树比四叉树占用更多内存。</p>
<p>与四叉树相比，框架四叉树与我们的工作更为相似，因为我们也将区块交叉作为抽象动作。不过，我们并不把区块边界上的所有单元格都视为入口点。通过将一个入口抽象为一个或两个入口点，我们减少了区块入口点的数量。此外，我们的方法允许区块包含障碍物。因此，我们必须计算位于同一区块边界上的入口点之间的最优路径。</p>
<p>在马尔可夫决策过程（MarkovDecision Process，MDP）框架下，多目标路径规划的性能已得到提升[4]。所提出的问题是针对所有地图位置对 (x;y) 有效地学习从 x 到 y 的近似最优策略 (x;y)。需要计算和存储的策略数量是地图单元数的二次方。问题地图上的所有位置都是机场，它们被分配到不同的层次结构中。从 x 到 y 的旅行策略与现实世界中的飞机旅行类似。首先，前往越来越大的机场，直到我们到达一个大到足以与目的地所在区域相连的机场。其次，依次前往更小的机场，直到到达目的地。这种方法与第 1.1 节中概述的策略非常相似。</p>
<p>文献[7]对各种框架中路径搜索的性质进行了分析。作者根据所寻求结果的类型、环境类型、可用信息量等对路径搜索问题进行了分类。文中还讨论了每种问题类型所面临的挑战以及解决策略，如重新规划和使用动态数据结构。</p>
<p>[9]分析了与HPA* 相 似 的最短路径算法的层次方法。该方法将初始问题图分解为片段子图集和连接片段子图的全局边界子图。计算并缓存最短路径供将来使用，这与 HPA* 对集群遍历路径执行的缓存类似。作者分析了应缓存哪些最短路径（即来自哪些子图），以及应保留哪些信息（即完整路径或仅成本），以便在内存有限的情况下获得最佳性能。</p>
<p>与 HPA* 相关的另一种技术是分层 A* [2]，它也使用空间的分层表示，目的是减少总体搜索工作量。不过，这两种技术使用层次化表示的方式有所不同。我们的方法使用抽象来构造和增强搜索空间的表示，而分层 A* 是一种自动生成与领域无关的启发式状态评估的方法。在单个代理搜索中，一个能评估从状态到目标之间距离的启发式函数被用来指导搜索过程。这种函数的质量在很大程度上影响着整个搜索算法的质量。从初始空间开始，分层 A* 建立抽象空间的分层，直到得到一个抽象的单状态空间。在建立下一个抽象空间时，当前空间中的几个状态会被组合成下一个空间中的一个抽象状态。在这种层次结构中，一个抽象空间用于计算前一个空间的启发式函数。</p>
<h2><span id="3-hierarchical-path-finding">3 Hierarchical Path-Finding</span></h2><p>我们的分层方法实现了 1.1 节中描述的策略。在我们的分层框架中，搜索抽象解的过程分为三步，即在线搜索。其次，搜索从起始邻域边界到目标邻域边界的路径。这是在抽象层面上进行的，搜索更加简单快捷。第三，完成从目标邻域边界到目标位置的路径。</p>
<p>在线搜索的抽象图是利用从问题迷宫中提取的信息构建的。我们将更详细地讨论如何构建分层搜索框架（预处理）以及如何用于路径遴选（在线搜索）。起初，我们专注于构建两个层次的层次结构：一个低层次和一个抽象层次。本节末尾将讨论如何添加更多的层次。我们将在图 1(a) 所示的 40 40 小地图上演示我们的方法是如何工作的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291621074.png" alt="image-20240229162103866"></p>
<h3><span id="31-pre-processing-a-grid">3.1 Pre-processing a Grid</span></h3><p>构建分层搜索框架的第一步是对迷宫进行顶层抽象。我们利用这种迷宫抽象来构建分层搜索的抽象图。</p>
<p>图 1(b)中的粗线表示用于拓扑抽象的抽象簇。在本例中，40 x 40 个网格被划分为 16 个大小为 10 x 10 的簇。请注意，这种抽象没有使用任何领域知识（除了调整簇的大小）。</p>
<p>对于两个相邻集群之间的每条边界线，我们都要确定一组（可能为空）连接它们的入口。&#x3D;&#x3D;入口是沿两个相邻集群 c1 和 c2 的共同边界的最大无障碍线段，&#x3D;&#x3D;其形式表示如下：考虑瓦片 l1 和 l2 的两条相邻线（每个集群一条），它们决定了 c1 和 c2 之间的边界边缘。 对于 $tile t \in l1 \cup l2$，我们将 symm(t)定义为 t 相对于 c1 和 c2 之间边界的对称瓦片。请注意，t 和 symm(t) 是相邻的，绝不属于同一个簇：</p>
<ul>
<li>边界限制条件：$e\in l1 \cup l2$.该条件规定，入口沿相邻两个集群之间的边界分布，且不能超过这两个集群之间的边界。</li>
<li>对称条件：$\forall t \in l_1 \cup l_2: t \in e \Leftrightarrow symm(t) \in e $。</li>
<li>无障碍条件：入口处没有任何障碍物。</li>
<li>最大化条件：只要前面的条件保持不变，入口就会向两个方向延伸。</li>
</ul>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011056359.png" alt="image-20240301105641344"></p>
<p>图 2 是样本地图左上角的缩放图片。图中显示了我们如何识别入口并利用它们构建抽象问题图的细节。在这个例子中，左侧的两个集群分别由宽度为 3 和 6 的两个入口连接。如果入口的宽度小于预设常数（在我们的例子中为 6），那么我们就在入口中间设置一个转换。否则，我们在入口两端各设置一个过渡段。</p>
<p>我们使用过渡来构建抽象问题图。对于抽象图中的每一个过渡，我们都会指定两个节点和一条连接它们的边。对于簇内的每对节点，我们都会找到一条连接它们的边，称为内边。我们通过搜索簇区域内的最优路径来计算内边的长度。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011117648.png" alt="image-20240301111739537"></p>
<p>图 2 显示了所有节点（浅灰色方块）、所有边间（浅灰色线条）和部分边内（右上角集群）。图 3 显示了图 2 右上角集群的抽象内部拓扑细节。数据结构包含节点集以及节点之间的距离。直线转换时，距离为 1；对角线转换时，距离为 1:42。我们只缓存节点之间的距离，而舍弃与这些距离相对应的实际最优路径。如果需要，也可以存储路径，但代价是占用更多内存。详见第 3.2.2 节的讨论。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011118129.png" alt="image-20240301111848771"></p>
<p>图 4(a) 显示了运行示例的抽象图。图中包括将起点节点 S 和目标节点 G 插入图中的结果（虚线），下一小节将对此进行描述。图中有 68 个节点，包括 S 和 G，每次搜索时它们都会发生变化。在此抽象层次上，有 16 个群组，其中 43 个相互连接，88 个内部连接。还有 2 条额外的边将 S 和 G 与图的其他部分连接起来。为了便于比较，低层次（非抽象）图包含 1; 463 个节点（每个未阻塞瓦片一个节点）和 2; 714 条边。</p>
<p>一旦构建了抽象图形并计算了边内距离，就可以在分层搜索中使用网格了。这些信息可以预先计算（在游戏启动前），存储在磁盘上，并在游戏运行时加载到内存中。这对于静态（不变化的）网格非常有用。对于动态变化的网格，必须在运行时修改预先计算的数据。当网格拓扑结构发生变化时（如桥被炸毁），受影响的本地群组的内边和间边需要重新计算。</p>
<h3><span id="32-on-line-search">3.2 On-line Search</span></h3><p>在线搜索的第一阶段是将起始位置 S 与包含 S 的簇边界连接起来，这一步是通过将 S 临时插入抽象图来完成的。同样，将目标位置 G 连接到其群集边界也是通过将 G 插入抽象图来完成的。</p>
<p>添加 S 和 G 后，我们使用 A* [10]在抽象图中搜索 S 和 G 之间的路径。这是在线搜索中最重要的部分。它提供了一条抽象路径、从 S 到 S 簇边界的实际移动、到 G 簇的抽象路径以及从 G 簇边界到 G 的实际移动。</p>
<p>在线搜索的最后两个步骤是可选的：</p>
<ol>
<li>路径重整可用于将抽象路径转换为原始网格上的移动序列。<ol start="2">
<li>路径平滑可用于提高路径重整解决方案的质量。</li>
</ol>
</li>
</ol>
<p>抽象路径可在后续处理步骤中进行重整，以获得从 S 到 G 的详细路径。对于许多实时路径搜索应用来说，并不需要完整的路径，只需要前几段路径即可。这些信息可以让角色开始朝着目标的正确方向移动。相比之下，A* 必须完成搜索并生成从 S 到 G 的完整路径，然后才能确定角色的最初步骤。</p>
<p>&#x3D;&#x3D;考虑一个经常发生动态变化的领域（例如，有许多移动装置在周围穿梭）。在这种情况下，找到一条抽象路径后，我们可以在角色向目标导航的过程中逐步重新定义它。如果当前的抽象路径变得无效，智能体就会丢弃它，寻找另一条抽象路径。没有必要事先重新定义整条抽象路径。&#x3D;&#x3D;</p>
<h4><span id="321-searching-for-an-abstract-path">3.2.1 Searching for an Abstract Path</span></h4><p>要在抽象图中搜索路径，S 和 G 必须是图的一部分。我们将 S 连接到包含它的集群 c 的边界。我们将 S 添加到抽象图中，并在本地搜索 S 和 c 的每个抽象节点之间的最优路径。如果存在这样的路径，我们就在抽象图中添加一条边，并将其权重设置为路径的长度。在图 4 中，我们用虚线表示这些边。</p>
<p>在我们的实验中，我们假设每次新的搜索都会改变 S 和 G。因此，插入 S 和 G 的成本会被添加到找到解决方案的总成本中。找到路径后，我们会从图中移除 S 和 G。然而，在实际操作中，这种计算方法可以更加高效。在这种情况下，我们插入 G 一次，然后重复使用。插入 G 的成本会在多次搜索中摊销。一般来说，缓存可以用来存储热门起始节点和目标节点的连接信息。</p>
<p>插入 S 和 G 后，抽象图可用来搜索 S 和 G 之间的抽象路径。</p>
<h4><span id="322-path-refinement">3.2.2 Path Refinement</span></h4><p>路径重构将抽象路径转化为低级路径。抽象路径中的每个集群交叉都会被等效的低级移动序列所取代。</p>
<p>如果簇预处理缓存了这些附着在内侧边上的移动序列，那么重新定位就只需简单地查找即可。否则，我们将在每个簇内沿着抽象路径进行小规模搜索，以重新发现最优局部路径。有两个因素限制了重新定位搜索的复杂性。首先，只要在找到抽象路径后环境不发生变化，抽象解就能保证正确。这意味着我们永远不必为修正抽象解而回溯和重新规划。其次，初始搜索问题已被分解成几个非常小的搜索（抽象路径上的每个群组一个），搜索复杂度很低。</p>
<h4><span id="323-path-smoothing">3.2.3 Path Smoothing</span></h4><p>拓扑抽象阶段每个入口只有一个转换点。虽然这样做很不科学，但却放弃了计算解决方案的最优性。解决方案在抽象图中是最优的，但在初始问题图中不一定。</p>
<p>为了提高解决方案的质量（即长度和美观度），我们进行了路径平滑的后处理阶段。我们的路径平滑技术很简单，但效果很好。其主要思路是用直线取代解的局部次优部分。从解法的一端开始。对于解中的每个节点，我们都要检查是否能以直线到达路径中的下一个节点。如果可以，那么这两个节点之间的直线路径就取代了这些节点之间的初始次优序列。</p>
<h3><span id="33-experimental-results-for-example">3.3 Experimental Results for Example</span></h3><p>表 1 的前两行总结了运行示例的实验结果。L-0 表示在低层图上运行 A*（我们称之为第 0 层），L-1 使用两个层次（即第 0 层和第 1 层），L-2 使用三个层次（即第 0 层、第 1 层和第 2 层）。最后一行 L-2 的含义将在第 3.5 节中说明。</p>
<p>使用曼哈顿距离作为启发式的低层（原始网格）搜索性能较差。我们选择这个例子是为了展示最糟糕的情况。在没有抽象的情况下，A* 将访问迷宫中所有未封锁的位置。搜索会扩展 1 462 个节点。限制搜索复杂度的唯一因素是迷宫的大小。具有相似拓扑结构的 Alar ger 地图对 A* 来说是一个难题。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011223945.png" alt="image-20240301122311792"></p>
<p>使用分层搜索可以大大提高性能。将 S 插入抽象图时，它只能与起始簇边界上的一个节点相连。因此，我们添加了一个节点（对应 S）和一条边，将 S 与簇中唯一可访问的节点相连。将 G 插入图中是相同的。</p>
<p>在抽象图上使用 A* 搜索 S 和 G 之间的路径。在第 1 层搜索也会扩展抽象图的所有节点。不过，这次搜索的工作量大大减少。</p>
<p>主搜索扩展了 67 个节点。此外，插入 S 和 G 会扩展 16 个节点。找到一条抽象路径总共需要扩展 83 个节点。如果需要，抽象路径可以部分或全部重写，但需要额外费用。最糟糕的情况是，我们必须完全重写路径，而且没有缓存内边的实际路径。对于路径中的每一条内边（即簇交叉），我们都要执行一次搜索，以计算出相应的低水平作用序列。这样的小规模搜索共有 12 次，共扩展了 145 个节点。</p>
<h3><span id="34-adding-levels-of-hierarchy-添加层次结构级别">3.4 Adding Levels of Hierarchy 添加层次结构级别</span></h3><p>层次结构可以扩展到多个层次，从而将抽象图转化为多层次图。在多层次图中，节点和边都有标签，显示其在抽象层次结构中的层级。层级结构中的附加层级可以减少搜索工作量，尤其是在大型迷宫中。有关在多线索图中进行高效搜索的详情，请参阅附录 A.2.2。为了构建多层迷宫图，我们将迷宫抽象为多个层次。层级越高，迷宫分解中的簇就越大。第 l 层的簇称为 l 簇。在现有结构的基础上建立每个新的层级。第 3.1 节介绍了第 1 个簇的构建。对于第 2 层，将 n x n 个相邻的（第 1 层）簇组合在一起就得到了第 l 层簇，其中 n 是参数。</p>
<p>位于新创建的 l 簇边界上的节点会将其等级更新为 l（我们称之为 l 节点）。在第 l 个簇之间进行转换的边际节点也会将其等级提升至第 l 级（我们称之为 l-边际节点）。</p>
<p>我们为位于同一 l 簇边界上的 l 个通信节点对添加了级别为 l 的内部边（即 l-intra-edges），该边的权重是仅使用（l 1）个节点和边连接簇内两个节点的最短路径的长度。更多细节见第 A.2.2 节。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011343101.png" alt="image-20240301134357121"></p>
<p>将 S 插入图中会反复连接 S 和包含它的 l 簇边界上的节点，l从 1 到最大抽象层级递增。搜索 S 和 l 节点之间的路径仅限于 l 1 层和包含 S 的当前 l 簇的区域。</p>
<p>&#x3D;&#x3D;我们构建抽象图的方式确保了无论我们使用多少抽象层级，都能找到相同的解。&#x3D;&#x3D;特别是，在图中添加新的第 l 2 层并不会降低解的质量。在此，我们将提供简要的直观解释，而不是形式上的证明。在第 l 层添加的新边对应于第 l 1 层的现有最短路径。在第 l 层搜索得到的解与在第 l 1 层搜索得到的解相同，只是速度更快。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202403011351464.png" alt="image-20240301135115029"></p>
<p>在我们的示例中，增加一个 n &#x3D;2 的额外层级会产生 4 个大的簇，地图的每个四分之一都有一个。图 2 中的整个图是一个 2 簇的例子。这个簇包含 2 个大小为 10 x 10 的 2-1 簇。除了 S，这个簇中唯一的 2 节点是左下角的那个。第 2 层是进行主要搜索的地方，共有 14 个节点（包括 S 和 G）。图 4(b) 显示了抽象图的第 2 层。图中虚线所示的边将 S 和 G 与第 2 层的图连接起来。</p>
<p>抽象层 2 很好地说明了预处理如何解决局部限制并降低抽象图的搜索复杂度。在第 2 层，我们避免在这个 “房间 “中进行任何无用的搜索，而是直接从 S 到左下角的出口。</p>
<p>插入 S 和 G 后，我们就可以搜索 S 和 G 之间的路径了。由于起点和目标的抽象层级最高，因此假设存在解决方案，我们将始终找到解决方案。搜索结果就是最高抽象层次的节点序列。如果需要，抽象路径可以反复重演，直到获得低层次的解决方案。</p>
<h3><span id="35-experimental-results-for-example-with-3-levelhierar-chy">3.5 Experimental Results for Example with 3-LevelHierar chy</span></h3><p>表 1 的第三行列出了我们的运行示例的数字数据，该示例采用 3 级层次结构（即三个层次：L 0、L 1 和 L 2）。</p>
<p>如第 3.3 节所示，将 S 和 G 连接到它们的 1 簇边界共扩展了 16 个节点。同样，我们现在将 S 和 G 连接到它们的 2 簇边界。这些第 1 级搜索为 S 扩展了 3 个节点，为 G 扩展了 22 个节点。</p>
<p>第 2 层的主搜索只扩展了 7 个节点。除了抽象路径中的节点外，没有其他节点被扩展。如果我们考虑到在第 1 层图中的搜索扩展了图中的所有节点，那么这是一个重要的改进。在扩展层次中找到抽象解总共需要 48 个节点。</p>
<p>值得注意的是，在增加了一个新的抽象层后，插入 S 和 G 的成本就占了主搜索成本的绝大部分。这说明了该方法的一般特点，即插入 S 和 G 的成本随着层次数的增加而增加，而主搜索则变得更简单。</p>
<p>表 1 还显示了完整解决方案重构的成本。将解决方案从第 2 层重置到第 1 层会扩展 16 个节点，从第 1 层重置到第 0 层会扩展 145 个节点，总计 161 个节点。</p>
<h3><span id="36-storage-analysis">3.6 Storage Analysis</span></h3><p>除了计算速度之外，分层方法用于路径标定的存储量也是另一个重要的性能指标。影响分层方法内存使用量的有两个因素：问题图的大小和 A* 使用的开放列表的大小。我们将在本节的其余部分详细讨论这两个因素。对于图的存储，我们既有经验分析，也有最坏情况的理论讨论。</p>
<h4><span id="361-graph-storage-requirements">3.6.1 Graph Storage Requirements</span></h4><p>表 2 显示了 BALDUR’S GATE 测试套件的问题图平均大小。有关该数据集和设置（如群组大小或原始问题图中的边定义）的详细信息，请参见第 4 节。我们将原始低级图与抽象图进行了比较，抽象图的抽象层级有一个、两个和三个（不包括第 0 层）。表中显示了节点数 N、边间数 E1 和边内数 E2。对于多层次图，我们同时显示了总数量和各层次的数量 $L_i, i \in {1, 2, 3}$。</p>
<p>数据显示，与原始问题图的大小相比，抽象图的存储开销很小。添加新的图级别会更新一些现有节点和边间的级别，而不会创建任何这些类型的新对象。唯一的开销就是新增的内边。在我们的数据集中，我们在一个有 4469 个节点和 16420 条边的初始图中添加了至少 1846 条内边（当有三个抽象层时）。假设节点和边占用的内存量大致相同，我们得到的开销为 8.83%。</p>
<p>以内存字节数表示的开销很大程度上取决于实现、编译器优化或问题图大小等因素。例如，如果图的大小至少为 256 x 256，那么存储图节点的坐标就需要两个字节。更大的地图需要更多内存。</p>
<p>由于抽象节点和边是按级别标记的，因此在抽象图中存储元素所需的内存可能比在初始图中更大。由于大多数编译器会将对象的比特大小四舍五入为 8 的倍数，因此实际上可能不存在比特开销。</p>
<p>通过在内存（如缓存）中只保留当前搜索所需的图部分，可以优化存储利用率。在分层框架中，我们只需要与当前搜索所在层级和区域相对应的子图。例如，在进行主抽象搜索时，我们可以放弃低层次的问题图，从而大大减少该搜索的内存需求。</p>
<p>一个簇的最坏情况是边界上交替出现阻塞地砖和空闲地砖，并且任何两个边界节点都可以相互连接。假设问题迷宫的大小为 m x m，迷宫被分解为 c x c 个簇，一个簇的大小为 n x n。在最坏的情况下，我们得到每个簇有 4n&#x3D;2&#x3D;2 n 个节点。由于每对节点表示一条内边，因此一个簇的内边数量为 2n(2n 1)&#x3D;2&#x3D; n(2n 1)。迷宫边缘没有抽象节点，因此边缘集群的抽象节点数量较少。对于位于迷宫角落的簇，节点数为 n，边缘内的节点数为 n(n 1)&#x3D;2. 对于位于迷宫边缘的簇，节点数为 1:5n，边缘内的节点数为 1:5n(1:5n 1)&#x3D;2. 因此，抽象节点总数为 2m(c 1)。内边总数为 n(c 2)2(2n 1)+2( n 1)+3( c 2)(1:5n 1)。</p>
<h4><span id="362-storage-for-the-a-open-list">3.6.2 Storage for the A* Open List</span></h4><p>由于分层路径搜索将问题分解为若干个小搜索，因此分层搜索中 A* 的平均打开长度比低层搜索小。表 3 比较了低层搜索和分层搜索中开放列表的平均长度。表 3 比较了低层搜索和分层搜索中开放列表的平均长度，该平均值是对第 4.1 节中描述的所有搜索的平均值，而不是在求解长度之后的结果。数据显示，在抽象框架中，低层搜索和主搜索的列表长度减少了三倍。</p>
<h2><span id="4-experimental-results">4 Experimental Results</span></h2><h3><span id="41-experimental-setup">4.1 Experimental Setup</span></h3><p>实验对象是从 BioWare 的游戏《BALDUR’S GATE》中提取的 120 幅地图，地图大小从 50 x 50 到 320 x 320 不等。对于每幅地图，我们使用随机生成的 S 和 G 对进行了 100 次搜索，搜索结果显示这两个位置之间存在有效路径。</p>
<p>八边形是指在 4 个直线方向和 4 个对角线方向上具有邻接关系的图块。垂直和水平转换的成本均为 1，对角线转换的成本设定为 1:42。宽度小于 6 的入口只有一个过渡。对于较大的入口，我们会生成两个过渡。</p>
<p>代码使用阿尔伯塔大学路径定位代码库 (<a target="_blank" rel="noopener" href="http://www.cs.ualberta.ca/%C3%B2games/pathfind">http://www.cs.ualberta.ca/ògames/pathfind</a>) 实现。该库被用作搜索工具，可使用不同的网格表示快速实现不同的搜索算法。由于其通用性，使用该库会产生一些开销。本文中报告的所有时间应被视为自定义实现的宽松上限。</p>
<p>定时在 800 MHz 奔腾 III 处理器和 3GB 内存上进行。程序使用 gcc 2.96 版本编译，并在 Red Hat Linux 7.2 版本下运行。</p>
<h3><span id="42-分析">4.2 分析</span></h3><p>图 5 比较了在最大层级设置为 1、2 和 3 的层次结构上进行低层 A* 抽象搜索的情况。对于分层搜索，我们显示的是总工作量，其中包括在图中插入 S 和 G、在最高层搜索以及重新生成路径。实际花费可能更少，因为插入 S 或 G 的成本可以在多次搜索中摊销，而且路径重定并非总是必要的。从图中可以看出，当需要进行完整处理时，第一抽象层对于我们在本实验中使用的地图大小来说已经足够好了。我们认为，对于更大的地图，更多层次的好处会更显著。复杂度的降低可能会大于增加层级的开销。正如我们接下来所展示的，当不需要路径重构，并且 S 或 G 可用于多次搜索时，更多层次也是有用的。</p>
<p>尽管报告的时间是针对通用实现的，但值得注意的是，对于任何长度的解决方案，适当的抽象层次都能在平均不到 10 毫秒的时间内提供答案。在长度为 400 的情况下，在 800 MHz 的机器上每次搜索的平均时间不到 5 毫秒。</p>
<p>当解题长度很小时，A* 略优于 HPA<em>。解长小通常表示搜索问题简单，A</em> 只需付出较少的努力就能解决。在这种情况下，HPA* 的开销（例如插入 S 和 G 的开销）大于算法可能节省的费用。在这种情况下，使用欧几里得距离作为启发式提供了完美的信息，而 A* 除了那些属于解决方案的节点外，不会扩展其他节点。</p>
<p>图 6 显示了分层搜索的总耗费是如何由抽象耗费、插入 S 和 G 的耗费以及解决方案再改进的耗费组成的。查找抽象路径的成本是主要成本与插入 S 和 G 的成本之和。当 S 或 G 在多次搜索中重复使用时，只有部分成本计入问题的抽象成本。考虑到这些因素，图中显示，在层级较多的层次结构中，寻找抽象路径变得更加容易。</p>
<p>图 7 显示了解决方案的质量。我们将分层路径平滑得到的解决方案与低层 A* 计算出的最优解决方案进行了比较。我们绘制了路径平滑前后的误差。误差用百分比来衡量开销，计算公式如下：<br>$$<br>e &#x3D; \frac{hl - ol}{ol} \times 100<br>$$</p>
<p>其中，hl 是用 HPA* 求得的解的长度，ol 是用 A* 求得的最优解的长度。误差与层次数量无关。唯一导致次优的因素是没有考虑入口的所有可能转换。</p>
<p>聚类大小是一个可以调整的参数。我们在性能测试中使用了大小为 10 10 的 1 个集群。该图显示了抽象搜索的平均扩展节点数是如何随着簇大小的变化而变化的。虽然主搜索随着簇大小的增加而减少，但插入 S 和 G 的成本增加得更快。</p>
<p>对于更高层次，一个 l 簇包含 22( l 1)个簇。我们使用这个较小的值，是因为当使用较大的值时，插入 S 和 G 的成本增加速度要快于主搜索的减少速度。这种趋势在相对较小的地图上尤为明显，在这种地图上，较小的簇就能实现良好的性能，而使用较大簇所增加的成本可能无法摊销。插入 S 和 G 的开销来自于必须将 S 和 G 连接到位于簇边界上的节点，簇边界越长，需要连接的节点就越多。我们对随机生成的地图进行了类似测试。主要结论类似，但由于篇幅有限，本文不再讨论细节。</p>
<h2><span id="5-conclusions-and-futurework">5 Conclusions and FutureWork</span></h2><p>尽管分层路径定位非常重要，也做了大量工作，但有关商业游戏中分层路径定位的详细出版物并不多。</p>
<p>在本文中，我们提出了一种高效近优路径定位的分层技术。我们的方法与领域无关，易于应用，并且适用于不同类型的地图拓扑结构。该方法能适应动态变化的环境。层次结构可以扩展到多个抽象层次，因此可以扩展到大型问题空间。我们使用从areal game中提取的地图测试了我们的程序，获得接近最优解的速度明显快于低层次的A*。</p>
<p>我们为分层路径搜索的未来工作提出了一些想法。我们计划优化将 S 和 G 插入抽象图的方式。如图 6 所示，增加新的抽象层后，这些成本会显著增加。提高性能的一种策略是只将 S 连接到边界上的稀疏节点子集，以保持抽象图的完整性。例如，如果抽象图中的每个 “未连接 “节点（即我们没有尝试连接 S 的边界上的节点）都可以从 “已连接 “节点（即我们连接了 S 的边界上的节点）到达，那么就可以保持抽象图的完整性。另一种方法是只考虑连接在 G 方向上的边界节点。然而，最后一种方法并不能保证完备性，而且很难事先评估其优点。如果由于图的不完整性导致搜索失败，我们就必须重新进行搜索，并逐渐扩大边界节点的子集。</p>
<p>我们目前使用的聚类方法很简单，效果也不错。不过，我们还想探索更复杂的聚类方法。一种与应用无关的策略是自动最小化一些聚类参数，如抽象聚类的数量、聚类相互作用和聚类复杂性（如内部障碍物的百分比）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-28T15:35:45.000Z" title="2024/2/28 23:35:45">2024-02-28</time>发表</span><span class="level-item"><time dateTime="2024-02-29T08:56:02.483Z" title="2024/2/29 16:56:02">2024-02-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约11470个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><div class="content"><h1><span id="hierarchical-path-planning-for-multi-size-agents-in-heterogeneous-environments">Hierarchical Path Planning for Multi-Size Agents in Heterogeneous Environments</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402282337947.png" alt="image-20240228233710737"></p>
<p>异构环境中多规模智能体的分层路径规划</p>
<p>摘要– 路径规划是游戏和其他研究领域（如机器人学）的核心课题。尽管如此，很少有研究涉及具有多种尺寸和地形穿越能力的智能体问题。&#x3D;&#x3D;在本文中，我们介绍了一种新的规划器 Hierarchical Annotated A* (HAA* )，并演示了<strong>如何使用单个抽象图为具有不同大小和地形穿越能力的智能体进行规划</strong>&#x3D;&#x3D;。通过理论分析和实验评估，我们证明 HAA* 能够为各种问题生成接近最优的解决方案，同时比低级搜索的工作量保持指数级下降。HAA* 所需的存储空间也仅为原始网格地图的一小部分。</p>
<h2><span id="i-introduction">I. INTRODUCTION</span></h2><p>单智能体路径规划是计算机科学中一个众所周知、研究广泛的问题。它有很多应用领域，如物流、机器人和最近的计算机游戏。尽管在这一领域已经取得了大量进展，但迄今为止，专门针对异构地形环境中不同规模智能体规划问题的研究还很少。</p>
<p>这个问题非常有趣，因为在解决路径规划问题时，这种多样性会带来更多的复杂性。现代即时战略或角色扮演游戏（例如 EA 广受欢迎的《红色警戒 3》或 Relic Entertainment 的《英雄连》）中经常会出现各种形状和能力各异的单位，它们必须在具有复杂地形特征的环境中进行导航，这些地形特征包括多种地形、不同的海拔高度等。因此，对步兵突击队来说可能有效的路线，对重型装甲坦克来说可能无效。同样，汽车和越野车的大小和形状可能相似，但各自选择的路径可能大不相同。</p>
<p>遗憾的是，目前大多数路径规划器，包括最近出现的分层规划器（[1]、[2]、[3]、[4]），只在某些理想条件下表现良好。例如，它们假定所有智能体都有同等能力到达给定地图上的大部分区域，而且一个智能体无法穿越的任何地形，任何智能体都无法穿越。此外，还经常对每个智能体的大小做出假设；由于所有智能体通常大小一致，因此为其中一个智能体计算的路径对其他任何智能体都同样有效。这些假设限制了这些技术的适用性，使其只能解决非常狭窄的问题：同质环境中的同质智能体。我们将讨论相反的情况，并展示如何在智能体的大小和地形穿越能力都可变的情况下计算出高效的解决方案。</p>
<p>首先，我们扩展了最近基于清除的寻路[4]工作，以便测量环境中关键位置的障碍物距离（第四节），并展示这些信息如何帮助智能体规划适当的路径（第五节）。接下来，我们将借鉴一种成功的基于集群的抽象技术[1]，以生成结构紧凑但信息丰富的搜索抽象（第六节）。最后，我们将介绍一种新的&#x3D;&#x3D;基于清除（clearance-based）的分层路径规划器 HAA*&#x3D;&#x3D;（第八节），并对其在异构多地形环境中涉及多规模智能体的各种问题上的性能进行详细的实证分析（第十节）。</p>
<h2><span id="ii-related-work">II. RELATED WORK</span></h2><p>高效计算路径规划解决方案的一个非常有效的方法是，通过创建一个较小的近似抽象空间并在其中进行搜索，使原始问题变得更加容易解决。抽象空间将一个搜索问题分解成许多更小的问题，从而使智能体能够根据宏观操作来推理路径规划策略。这就是所谓的分层路径规划。</p>
<p>[1]和[2]、[5]中介绍了两个与我们的工作相关的最新分层路径规划器。其中第一个分层路径规划器 HPA* 通过将环境划分为由入口连接的方形簇来构建抽象搜索图。规划工作包括在抽象图中插入低层次的起点和目标节点，并找出它们之间的最短路径。&#x3D;&#x3D;第二种算法 PRA* 通过抽象节点群来构建多层次搜索空间；其结果是将原始问题中的搜索空间缩小到沿最优最短路径的节点 “窗口”。&#x3D;&#x3D;HPA* 和 PRA* 都专注于解决同质智能体在同质地形环境中的规划问题，因此当其中任何一个变量发生变化时，它们都是不完整的。我们的技术与 HPA* 类似，但我们对其进行了扩展，以解决更广泛的问题。</p>
<p>在机器人学中，力势可以帮助自主机器人在环境中找到无碰撞的路径。其基本原理是，当机器人接近障碍物时，会被远处的目标吸引，并被障碍物排斥。基于势能的路径规划的一种著名方法是 “刷火 “算法[6]，该算法通过在网格图上的每块瓷砖上标注与最近障碍物的距离来进行规划。这种嵌入式信息可让机器人计算斥势，从而使用梯度下降策略进行规划。Brushfire与HAA* 类似，它所产生的注释能让智能体了解自己与附近障碍物的距离。HAA*  的不同之处在于它能明确计算地图上每个位置的最大可穿越空间。此外，与 “刷火 “不同的是，HAA* 不会受到不完整性的影响，因为当排斥力相互抵消并导致机器人进入局部最小值时，就会出现不完整性。</p>
<p>走廊地图法（CMM）[4] 是最近推出的一种路径规划器，它能通过使用概率路线图来表示地图的连通性，从而回答多规模智能体的查询。路线图（或主干路径）由节点组成，节点上标注有间隙信息，表明在遇到障碍之前最大边界球的半径。通过创建 Voronoi 区域将节点放置在路线图上，以分割地图并确定与固定障碍物保持最大局部距离的位置。与 CMM 类似，HAA* 也是计算给定位置的可穿越空间大小，但我们的方法适用于网格环境，因为网格环境比路线图更容易创建，在各种应用中也更常见。另一个关键区别在于，我们允许对抽象图的大小进行细粒度控制；而 CMM 抽象图的大小是固定的。最后，我们处理的是多rain 情况，这使得我们的方法具有更丰富的信息。</p>
<p>在文献中，使用导航矩阵来表示环境越来越流行。在这一类别中，最近的两个规划器是三角剖分 A* 和三角剖分还原 A* [3]。TA* 利用一种被称为 Delaunay 三角剖分的技术来构建环境的多边形表示。其结果是一个由受限边和非受限边连接的无向图；前者可遍历，后者不可遍历。TRA* 是这种方法的延伸，它将三角形网格抽象为类似路线图的结构。与我们的方法一样，TA* 和 TRA* 都能回答多规模智能体的路径查询。不过，TA* 和 TRA* 所使用的抽象方法与我们的工作截然不同。我们使用的是将环境简单划分为正方形群组的方法，而他们的方法则旨在最大化三角形大小。我们还处理额外的地形要求，而 TA* 和 TRA* 都假定环境是均质的。</p>
<h2><span id="iii-problem-definition">III. PROBLEM DEFINITION</span></h2><p>网格图是由原子正方形单元组成的结构。每个网格单元称为一个八面体，与 k 个相邻单元相连，其中 0 ≤ k ≤ 8。每个八面体要么被阻挡，要么可以穿越。被阻挡的八边形称为硬障碍物，因为没有智能体可以占据它们。&#x3D;&#x3D;每个可穿越的八边形 t 都与特定的地形类型相关联，即 terrain(t) ∈ T，其中 T 是所有可能地形的集合，有 r &#x3D; |T | ≥ 1 种可能的地形&#x3D;&#x3D;。网格图可以表示为一个图 G &#x3D; (V，E)，其中每个可穿越的八边形生成一个节点 v∈ V，每个八边形的邻接关系用边 e∈ E 表示。&#x3D;&#x3D;（八边形 octile   可以指一个栅格，因为一个小栅格与八个其他的小栅格邻接， 更泛泛地，八边形指一个能够与八个同构图形临界地一个图形）&#x3D;&#x3D;</p>
<p>智能体是试图在网格图上移动的任何实体。每个智能体都是正方形，大小为 s ≥ 1 : s ∈ S，其中 S 是为问题定义的所有智能体大小的有限集合。一个智能体占据 s × s 个栅格，这些栅格对应着它当前的位置。每个智能体都有地形穿越能力 c ⊆ T，它由一个或多个地形组合而成。让 C ⊂ 2T 成为所有智能体能力 c 的集合。如果一个智能体的能力中不包含其地形类型，则该智能体永远无法占据一个八分区。一个智能体可以在两个 s×s 的地点 l1 和 l2 之间沿正中方向移动，条件是：（1）智能体可以穿越 l1 和 l2；（2）l1 和 l2 之间的总位移量仅限于一个栅格的长度或宽度。对角线移动只有在存在等效（但更长）的两步移动时才允许。</p>
<p>问题实例（或查询）被定义为与智能体相关联的一对位置，即起点和目标。如果在这两个地点之间至少存在一条路径，且该路径仅由智能体可穿越的栅格组成，那么问题就是有效的。</p>
<h2><span id="iv-computing-clearance-value-annotations">IV. COMPUTING CLEARANCE VALUE ANNOTATIONS</span></h2><p>间隙值（clearance）是与八分区 t 和能力 c 相关联的障碍距离度量。它表示一个正方形的最大长度（或宽度），该正方形的左上方八分区为 t，且只包含地形类型包含在 c 中的八分区。 一个八分位点可以有多个与之相关的间隙值，每个能力点一个。</p>
<p>为了使我们的想法更容易理解，我们将以一个简单的环境为例，该环境有两种地形类型： 地面（用白色地砖表示）和树木（用灰色地砖表示）。为了区分可穿越地砖和不可穿越地砖（硬障碍），我们将后者涂成黑色。因此，穿越这种地图所需的能力集 C 定义为 $C &#x3D; { { Ground }, {Trees }, {Ground ∨ Trees} }$。我们将使用两种大小的智能体穿越这个环境，因此让 S &#x3D; {1, 2}。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402282351732.png" alt="image-20240228235158271"></p>
<p>&#x3D;&#x3D;(g)描述了，当tree障碍物可以被穿越时，地图的clearance&#x3D;&#x3D;</p>
<p>图 1(a)至(d)说明了在上述环境中如何通过迭代程序计算间隙。在图 1(a)中，突出显示的可穿越目标瓦片的间隙方格初始化为 1。随后的迭代（图 1(b)-(c)）扩展了方格并增加了间隙。该过程一直持续到该方格包含障碍物（图 1(d)）或超出地图边界为止，此时我们终止迭代，不再增加间隙。</p>
<p>图 1(e) 显示了玩具地图示例中单一地形 {Ground} 能力的clearance（请注意，我们省略了零值clearance）。同样，图 1(f) 和图 1(g) 分别显示了与 {Trees} 和 {Ground ∨ Trees} 功能相关的净空值。</p>
<p>得出清除值后，我们将其存储在内存中，并对每个能力 c∈C 重复整个过程。因此，以这种方式计算清除值的最坏情况空间复杂度为：</p>
<p><strong>定理 1</strong>：设 CV 是用 r 个地形标注八分网格图所需的所有间隙值的集合。此外，让 G &#x3D; (V, E) 表示网格图，其中 $VHO \subseteq V$ 是硬障碍物集。那么<br>$$<br>|CV| &#x3D; (|V|-|V_{HO}|) \times 2^{r-1}<br>$$</p>
<p>证明 &#x3D;&#x3D;要使某个节点可被某种能力穿越，该能力必须包含该节点的地形类型。&#x3D;&#x3D;地形（以及能力）有 $2^r$ 种组合，但一种固定的地形类型最多只能出现在 $2^{r-1}$ 种能力中。表示环境的节点共有 V 个，我们避免在 $V_{HO}$ 中为所有节点存储任何间隙值。<em>（举个例子：对于20x20大小的栅格图，只有0， 1，表示可通行和不可通行，其中障碍物栅格约有20个，CV是所有间隙值的集合，则$|CV| &#x3D; (|400|-|20|) \times 2^{2-1}$）</em></p>
<p>从 Lemma 1 得出的结果是一个上限；如果没有智能体具有给定的能力 c，就没有必要存储相应的清除值。尽管如此，相关的指数增长函数表明，由于每个节点都有 $Θ(2^r)$ 个清除值，因此存储每个清除值是不切实际的。幸运的是，清除值可以按需计算，不费吹灰之力。特别是，计算大小为 $s \in S$ 的任何智能体 a 的清除值，只需构建一个最大面积为 $s^2$  octile 的清除方阵。我们在算法 1 中介绍了这种方法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402290854419.png" alt="image-20240229085359644"></p>
<p>计算间隙的主要优势在于，我们能够将扩展问题映射为一个经典问题，即 “典型问题”，其中只有两种瓦片类型（可穿越瓦片和受阻瓦片），且只有原子大小的智能体。我们将其形式化为:</p>
<p><strong>定理 2</strong>：给定一个注释网格图和一个具有任意大小和能力的智能体，任何路径规划问题都可以简化为经典路径规划问题，其中智能体的大小为一个八分位点，智能体的能力为一个地形。</p>
<p>证明 考虑一个规模为 $s_a$、能力为 $c_a$ 的智能体 a。进一步考虑大小为 $s_a × s_a$ 的位置 l、其左上方的八分位点 ul，以及与八分位点 ul 和能力 ca 相关的间隙值 cv（ul，ca）。很容易观察到，当且仅当 cv（ul，ca）≥ sa 时，智能体 a 可以穿越位置 l。这样，我们就可以将原始问题映射为一个经典的路径规划问题，如下所示： 将当前占据 sa × sa 位置 l 的智能体 a 映射为一个原子大小的智能体，其位置为 ul。在搜索路径时，只有当 cv(t, ca) ≥ sa 时，原子大小的智能体才能穿越任何八分区 t。所有其他八分区都被视为阻塞区。</p>
<p>这是一个有用的结果，因为它表明我们可以应用经典路径规划中的抽象技术来回答涉及多种地形类型和智能体大小变量的更为复杂的查询。特别是，如果将把网格图划分为互不相连的簇的拓扑抽象直接应用于具有任意大小智能体的问题，那么一个大型智能体可能同时处于多个簇中。这就提出了一系列我们认为难以处理的难题。上述定理巧妙地消除了这一问题，因为一个原子大小的智能体一次只能处于一个簇中。</p>
<h2><span id="v-annotated-a">V. ANNOTATED A*</span></h2><p>使用清除值对我们的扩展问题进行低层次规划，是迄今为止各种想法的直接应用。为了计算起点和目标节点之间的最优最短路径，我们使用了经典 A* 算法的一种变体 [7]，我们称之为注释 A* （简称 AA* ）。我们的方法与标准 A* 算法不同，每个查询都需要两个额外参数：智能体的大小和能力。回想一下，可以按需计算每个访问地点的清除率。因此，算法所考虑的每个原子八面体都可以动态地评估为阻塞或可穿越。这样，我们就可以将任何查询映射为一个典型问题，如前所述。</p>
<h2><span id="vi-cluster-based-map-abstraction">VI. CLUSTER-BASED MAP ABSTRACTION</span></h2><p>AA* 对于原始网格图上的低层次规划来说已经足够，但对于大型问题来说效率不高；我们更倾向于使用宏运算符来表达更好的策略。现有的分层路径规划方法，尤其是那些专注于网格图的方法，如 [1] 和 [2]，通过将网格图分解为离散的相邻区域来实现这一目标。每对相邻区域都由一条最短路径连接，每个典型问题都被映射到这个更小的分层表示中。然而，当我们引入任意大小和能力的智能体时，以前的抽象技术就会崩溃，因为它们产生的分层抽象是不完整的。特别是，每对相邻区域之间可能存在多条最短路径，智能体大小和能力的每种组合都可能有一条最短路径。为了解决这个问题，我们以定理 2 中的结果为基础，该定理是本节所述空间抽象的关键。</p>
<p>我们的技术扩展了 [1] 中的流程，即把网格地图分成固定大小的正方形部分，称为簇。图 2(a) 显示了这种分解方法的结果；我们使用大小为 5 的簇，将玩具地图分成 4 个相邻的簇。</p>
<p>在最初的工作中，&#x3D;&#x3D;入口被定义为沿两个相邻集群边界存在的最大无障碍过渡区域。&#x3D;&#x3D;每个入口都有一个或两个过渡点（取决于其大小），在抽象搜索图中，这些过渡点由一对节点表示，节点之间用权重为 1.0 的无向边连接。我们使用类似的方法，但需要将所有能力的集合 C 作为参数，从而尝试识别每个 c∈C 的入口。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402290919568.png" alt="image-20240229091938471"></p>
<p>给定一个能力 c，我们从沿相邻边界区域的第一对可穿越地砖（即地形类型在 c 中的地砖）开始，扩展每个入口，直到出现以下三个终止条件之一：到达边界区域的尽头、检测到障碍物（即硬障碍物或地形类型不在 c 中的可穿越地砖）或任一集群中沿边界区域的节点间隙值开始增加。最后一个条件对于大型智能体来说非常重要，因为在这种情况下，一个集群会被边界附近的障碍物（如墙壁）部分分割开来。通过利用间隙，我们能够推理出此类障碍物的存在，并在每次检测到任一集群内部的可穿越空间量增加时，建立一个新的入口。</p>
<p>一旦找到入口，我们就会在每个群组中选择第一对相邻节点作为转换点，这对节点能最大限度地提高 c 的clearance（清除值、间隙值）。	给定能力 c 的一对相邻节点 (n1, n2) 的间隙定义为 cv(n1, n2, c) &#x3D; min(cv(n1, c), cv(n2, c))。因此，我们在抽象图中添加了两个节点之间的新边 $e_{inter}$，并标注了相应的能力和清除值。该算法对每个 c∈C 重复进行，当所有相邻群组都被考虑后，算法结束。这样可以确保我们为每种可用能力识别出所有可能的入口。</p>
<p>在图 2(b) 中，我们展示了通过扫描集群 C1 和 C3 之间的边界发现的三个入口。入口 E1 和 E2 分别使用 {Ground} 和 {Trees} 功能发现，每个入口只跨越部分边界区域。入口 E3 横跨整个边界区域，使用 {Ground ∨Trees} 功能发现。连接的瓦片代表后续转换点的位置；  最终结果如图 2(c) 所示。请注意，E1 和 E3 在抽象图中的同一对节点上。这是由于我们尝试重新使用抽象图中任何现有节点的策略所致。</p>
<p>分解的最后一步是尝试为集群内的每对抽象节点在抽象图中添加一组内边。我们通过运行多个 AA* 搜索∀(c, s) : c∈C, s∈S 来实现这一目标、 注释为 AA* 使用的能力和通关参数，并将其权重设置为等于成本和通关参数。并将其权重设置为等于路径成本。当所有集群都已考虑完毕时，算法结束。</p>
<p>因此，我们构建了一个抽象多图，其中每条边 e 都标注了能力值 ce 和清除值 cv(e,ce)。如果 ce ⊆ ca ∧cv(e,ce)≥sa，则每个 e∈Eabs 都可被大小为 sa、能力为 ca 的智能体 a 遍历。我们将由此产生的抽象称为初始抽象，并给出以下定理来描述其空间复杂性：</p>
<p><strong>定理 3</strong>：让 $V_{abs}$ 表示网格图抽象图中的节点集，网格图完全可以划分为 c×c 个簇、 每个簇的大小为 n × n。那么，在最坏情况下，节点总数为<br>$$<br>|V_{abs}| &#x3D; 4(2n-1)+(4c-8)(3n-2) + (c-2)^{2}(4n-4)<br>$$<br>证明 每个过渡点都会在抽象图中产生两个节点。如果没有坚硬的障碍物，并且两个集群之间相邻边界上的每对节点都具有不同的地形类型，那么过渡点的数量将是最多的。在这种情况下，地图中间的集群有 $(c - 2)^2 $ 个，每个集群有 4 个相邻集群，每个集群包含 $4n - 4$ 个节点。地图周边（不包括角落）的集群有 4c - 8 个，其中有 3 个相邻集群和 3n - 2 个节点。边角集群共有 4 个，有 2 个相邻集群，每个集群包含 2n - 1 个节点。</p>
<p><strong>定理 4</strong>：让 Eabs(L) ⊂ Eabs 表示包含 x 个抽象节点的群集 L 的内边集合。此外，假设 r 是地图中发现的地形总数，k 是 L 中发现的不同地形类型的数量。那么，在最坏情况下，连接 L 中所有节点所需的内边数量为<br>$$<br>|E_{abs}(L)|&#x3D;|S| \times 2^{k-1} \times \frac{x(x-1)}{2}<br>$$</p>
<p>证明 对于集群中的每对抽象节点和每种大小&#x2F;能力组合，我们最多能计算出一条最佳长度的路径。根据阶式 1，我们知道每个节点最多可由 $2^{r-1}$ 种能力穿越，因此覆盖 2 个节点的路径最多为 $|S| × 2^{r-1}$ 种。然而，集群内的地形数量受集群大小的制约；只能找到 $k ≤ r$ 个地形。由此可见，覆盖每对节点的边集的大小上限实际上是 $|S| × 2^{k-1}$。在最坏的情况下，每对节点之间的边的数量将达到最大值，每个集群中总共有 $\frac{x(x-1)}{2}$ 对这样的节点。</p>
<p><strong>定理 5</strong>：设 $E_{inter} ⊂ E_{abs}$ 表示网格图抽象图中的内边集合。在最坏的情况下，网格图完全可以划分为 c × c 个簇，每个簇的大小为 n × n，簇间边的数量由以下公式给出：<br>$$<br>|E_{inter}| &#x3D; (2c^{2} - 2c) \times \frac{n(n-1)}{2}<br>$$<br>证明 我们从定理 3 的证明中得知，在最坏的情况下，两个相邻集群之间边界上的每块瓷砖都由抽象图中的一个节点表示。如果我们计算邻接数，避免重复，我们会发现总共有 $2c^2 - 2c$。</p>
<p>每个过渡都会产生一条互边，每个邻接有 n 个间隙为 1 的单地形过渡，还有一定数量的互边代表间隙较大的多地形过渡。通过观察我们可以发现，每个邻接会产生 [n 个单地形转换]…[1 个 n 地形转换]。这一递推关系适用于一般序列计数公式 $\frac {n(n-1)}{2}$</p>
<p>上述结果之所以有趣，有几个原因。首先，&#x3D;&#x3D;定理 3 表明图中节点的数量是簇大小的函数。&#x3D;&#x3D;这表明，通过改变簇的大小，&#x3D;&#x3D;我们可以用一点性能（遍历一个簇所需的时间）来换取内存（更少的抽象开销）&#x3D;&#x3D;。定理 4 和 5 中的结果似乎支持这一假设。我们看到，图中节点之间的边数主要取决于节点所在集群的复杂度，而不是能力数的指数。这一点非常重要，因为它意味着，尽管有一个指数型的抽象边缘增长函数，但我们可以直接控制指数的大小。基于簇的分解技术允许我们根据需要在每个簇中包含或多或少的复杂性。</p>
<h2><span id="vii-optimising-abstract-graph-size-优化抽象图大小">VII. OPTIMISING ABSTRACT GRAPH SIZE 优化抽象图大小</span></h2><p>正如我们在定理 4 和 5 中观察到的，初始抽象算法试图表示簇之间和簇内部的每一条最优路径。然而，大多数图的拓扑结构远比最坏情况简单；在我们的实验场景中，我们经常观察到在发现内部边缘时，不同的（c, s）参数对会返回相同的路径。这就为我们提供了一个机会，通过删除抽象边集中不必要的重复来压缩图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291002081.png" alt="image-20240229100201798"></p>
<p>请看图 3(a) 中的初始抽象，并与图 3(b) 中的预期结果进行对比。{E3、E5} 表示节点 w 和 y 之间的相同路径，但标注了不同的间隙值。在这种情况下，我们认为 E3 和 E4 具有强支配性，即 E3 ≻ E5 和 E4 ≻ E6。这是边与边之间的非对称且不可反反复复的关系，我们将其形式化为</p>
<p><strong>定理 6</strong>：假设{ea, eb}∈ Eabs 是两条不同的边，它们连接同一对抽象节点，并标注了能力 ca ⊆ cb，这样就可以了：<br>$$<br>cv(e_{a}, c_{a}) \ge cv(e_{b}, c_{b}) \and weight(e_{a}) &#x3D; weight(e_b)<br>$$<br>那么 ea ≻ eb，我们可以从 Eabs 中移除 eb，而不失一般性或最优性。</p>
<p>证明 由于 ca ⊆ cb，因此任何有能力穿越 eb 的智能体也一定有能力穿越 ea。此外，如果 cv（ea，ca）≥ cv（eb，cb）成立，那么任何足以穿越 eb 的智能体也一定足以穿越 ea。这些条件足以保持一般性。最后，由于 ea 与 eb 的权重相等，我们不能因为删除 eb 而失去最优性。</p>
<p>我们将去掉所有强主导边后的结果图称为高质量抽象图。</p>
<p>我们在分析这一问题时还发现，在许多情况下，存在多条到达目标位置的备选路线。最短路径往往需要穿越最佳长度的多地形边。然而，使用稍长的单地形边往往也能到达相同的目的地。这表明抽象图可以进一步压缩，而不会影响表示的完整性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291006942.png" alt="image-20240229100652876"></p>
<p>图 4(a)和 4(b)显示了典型的高质量抽象，而图 4(c)和 4(d)则突出显示了进一步压缩图形后的理想结果。在这个例子中，我们可以看到，虽然边 E1 和 E2 有不同的遍历要求，但任何大小为 s∈{1, 2} 的智能体都能遍历 E2，而且不失一般性。在这种情况下，我们称 E1 为弱支配，并将其标记为 $E1 \succsim E2$。我们还注意到 $E3 \succsim E4$、$E6 \succsim E7$、$E10 \succsim E8 $和 $E10 \succsim E9$。</p>
<p>与强支配性的情况不同，它只保留了表征完整性（而非最优性）。我们将其形式化为</p>
<p>定理 7：假设 La 和 Lb 是两个相邻的簇，{wa, xb}, {ya, zb}∈ Vabs 是两对抽象节点，每对节点连接 La 和 Lb。将与这些节点对相关的边表示为 {ewx, eyz} ∈ 在这种情况下，如果满足以下条件，$ewx \succsim eyz$：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291015646.png" alt="image-20240229101551527"></p>
<p>那么，任何可以通过遍历 eyz 到达的地点也可以通过 $e_{wx}$ 到达。</p>
<p>证明 如果在边集 ${ewx、eyz、ewy、exz}$ 之间存在一条回路，其中每条边都可被 cyz 穿越，且清除值至少等于 $cv(eyz、cyz)$，那么就可以得出，La 或 Lb 中任何可从 ya 或 zb 到达的节点都必须可从 wa 或 xb 到达。因此，智能体可以通过 $e_{yz}$ 到达的任何目的地也可以通过 $e_{wx}$ 到达。</p>
<p><strong>推论 8</strong>：如果 $ewx \succsim eyz$，那么 ya 和 zb 也是主边，可以移除，除非另一条（非主边）中间的边需要移除。</p>
<p>证明 如果 ya 和 zb 是非支配内部边所需要的，我们就不能在不违反清除支配条件的情况下删除它们，而清除支配条件是保持表征完整性所必需的。然而，如果情况并非如此，根据回路条件，我们知道任何节点都可以通过 $y_a$ 或 $z_b$ 从内部边到达，也可以通过 $e_{wx}$ 的端点到达。因此，这两个节点和任何依赖于它们的相关内边都可以安全地删除。</p>
<p>在许多情况下，多地形间边缘往往与非常大的间隙相关联；比我们最大的智能体的大小要大得多。这不必要地限制了定理 7 中间隙优势条件的适用性。利用已知的 $s_M &#x3D; max_{s \in S} s$ 这一事实，我们可以通过对定理 7 中的 $E_{abs}$ 应用以下截断条件，最大化弱支配边的数量：<br>$$<br>\forall E_{abs}(cv(e, c_e)) \gt S_{M} \Rightarrow cv(e, c_e) \leftarrow s_{M}<br>$$<br>当然，以这种方式选择低质量抽象确实会影响计算解的质量。在最糟糕的情况下，高质量图中代价为 1.0 的一步转换可能长达 f (n) &#x3D; 4n + f (n - 2) : f (2) &#x3D; 3, f (3) &#x3D; 13，其中 n ≥ 2 是 n × n 簇的长度。然而，这只是一种病态情况；我们将证明，实际情况中的差异要小得多，而且仍然接近最优。选择采用哪种质量抽象技术取决于具体应用的要求；这是运行时性能与空间之间的典型权衡。</p>
<h2><span id="viii-hierarchical-planning">VIII. HIERARCHICAL PLANNING</span></h2><p>有了合适的图抽象，我们就可以再次将注意力转回到智能体规划上。为了计算一个典型问题的层次解，我们采用了与 [1] 中描述的类似方法。我们在此简要介绍一下他们的方法；如需更详细的说明，请读者参阅原著。</p>
<p>首先，我们使用起点和目标节点的 x、y 坐标来确定每个节点所在的本地集群。接下来，我们在抽象图中插入两个临时节点（完成后删除），分别代表起点和目标。要将节点连接到图的其他部分，需要尝试使用 AA* 找到从每个节点到群组中其他抽象节点的内边。这一阶段总共需要 i + j 次搜索，与起点和目标簇中的合并抽象节点数相对应。</p>
<p>为了计算高级计划，我们再次使用 A* 的变体–这次是在将节点添加到开放列表之前评估抽象边的注释。一旦搜索结束，我们就可以获取结果，如果不需要立即执行，我们就完成了。否则，我们会沿着抽象最优路径在原始网格图中的每对节点之间进行多次小规模搜索，从而完善计划。我们将这种算法称为分层注释 A* （简称 HAA* ）。</p>
<h2><span id="ix-experimental-setup">IX. EXPERIMENTAL SETUP</span></h2><p>我们从一款流行的角色扮演游戏中借用了一组 120 张八角形地图，大小从 50x50 到 320x320 不等，对 AA* 和 HAA* 的性能进行了评估。以前的游戏相关研究（如 [1]）也使用过相同的地图。在默认配置下，这些地图只有一种类型的可穿越地形，其间夹杂着坚硬的障碍物。因此，我们创建了五个衍生集（共 720 张地图），每张地图上的每块可穿越地砖都有{10%、20%、30%、40%、50%}的概率被转换成第二种可穿越地形。具有这种地形类型的地块被称为软障碍，因为它们不是所有智能体都能穿越的。这样，我们就可以在同时存在软障碍和硬障碍的环境中对算法进行评估。</p>
<p>对于每张地图，我们通过在任意选择的地点对和一些随机能力之间随机创建有效问题，生成了 100 个实验。我们在每个实验中使用了两种智能体大小：小型（占用一块地砖）和大型（占用四块地砖），结果总共产生了 144,000 个问题实例（720x200）。所有实验均在运行 OSX 10.5.2 的 2.4GHz 英特尔酷睿 2 双核处理器和 2GB 内存上进行。为了实现这两个规划器，我们使用了阿尔伯塔大学免费提供的寻路库 HOG (<a target="_blank" rel="noopener" href="http://www.cs.ualberta.ca/">www.cs.ualberta.ca/</a> ̃nathanst&#x2F;hog.html)。</p>
<h2><span id="x-results">X. RESULTS</span></h2><p>在表 I 中，我们列出了抽象图相对于原始图的大小，原始图平均有 4469 个节点和 16420 条边。我们研究了将软障碍（SO）的数量从 0%（原始测试地图只有一个可穿越地形）增加到 50%的效果。我们还对比了群集大小{10、15、20}范围内的高质量和低质量抽象（表示为 HQ 和 LQ）（表示为 CS10、CS15 和 CS20）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291027483.png" alt="image-20240229102710481"></p>
<p>首先要注意的是，在所有情况下，抽象图的大小都只是原始图的一小部分。不出所料，较大的集群生成的图较小；在使用 CS20 的 SO 0% 问题集上观察到的抽象图最小。在这种情况下，使用 HQ 抽象后，原始图形中的节点数减少了 4.0%，边数减少了 5.0%。LQ 抽象效果更好，节点数量仅为原始图的 2.0%，边缘数量仅为原始图的 0.9%。</p>
<p>与存储图表相关的总空间复杂度由存储节点和边所需的总空间给出。如果我们假设每个非抽象节点和边都需要一个字节的内存来存储，那么我们最小的抽象图（每条边包含 2 个注释（能力和许可，共需要 1 个额外字节））的空间复杂度是使用 HQ 抽象时原始图大小的 8.7%，而使用 LQ 抽象时仅为 1.8%。同样，最大的 HQ 图形（出现在 SO 20% 的 CS10 中）的空间复杂度是原始图形的 63.8%。相比之下，最大的 LQ 图形出现在 SO 50% 的 CS10 中，其空间复杂度为原始网格图的 40.4%。从 CS10 到 CS20，HQ 图形的最坏情况空间复杂度降低到 47.0%，LQ 图形降低到 26.4%。</p>
<p>有趣的是，如果我们用节点数来表示图形中的内边数量，就可以推断出大多数 HQ 图形主要是由内边组成的。具体数量取决于集群中软障碍物的密度；密度较低的集群（如 SO 20%）会导致更多的内边，因为在每对抽象节点之间会发现更多的独特路径（大小和能力各不相同）。这与推理 4 一致，有助于理解 HQ 抽象的最坏情况行为。</p>
<p>LQ 图大小的线性增加是由于随着软障碍物数量的增加，发现了更多的单地形入口（这一观察结果与定理 3 一致）。增加集群中软障碍物的密度会降低定理 7 中电路条件的满足率，从而导致 SO 50% 的最坏情况。</p>
<p>接下来，我们考虑 HAA* 在路径质量方面的性能。我们的衡量标准是<br>$$<br>% error &#x3D; \frac{apl - opl}{opl} \times 100<br>$$<br>其中，oppl 是 AA* 计算出的最优路径长度，apl 是 HAA* 使用的抽象路径长度。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291029662.png" alt="image-20240229102942750"></p>
<p>图 5(a) 显示了 HAA* 在群集大小和软障碍物方面的平均性能。请注意，HQ 图形产生的误差非常小；在大多数情况下，误差在 3-6% 之间。然而，最令人鼓舞的也许是 LQ 抽象的结果，在大多数情况下，HAA* 的性能都在最佳值的 610% 以内。在这两种情况下，观察到的最大误差出现在 SO 0%，这是由于我们的边间放置策略造成的。在所有情况下，我们选择入口处间隙最大的一对节点作为过渡点，这对节点往往位于入口区域的起点，而这并不是最佳位置。在以单一地形为主的低复杂度地图集群中，这种情况会导致入口过长，而单条边际线又无法很好地体现这种情况。增加软障碍物的数量可以缩短入口并产生更多的过渡点，从而显著减少误差。HAA* 似乎针对复杂情况进行了优化，因此在较简单的问题上性能略有下降。</p>
<p>有趣的是，与 HQ 和 LQ 抽象相关的误差在 SO 20% 时达到最小，然后逐渐增加到 SO 50%。为了更好地理解这一现象，我们在图 5(b) 中展示了使用 15 个固定群集大小的 HQ 和 LQ 图上小型和大型智能体的性能。请注意，小型智能体的性能在 SO 20% 之后继续提高，而大型智能体的性能则开始下降。所观察到的误差上升源于在具有更密集集群的问题集上入口尺寸的减小。如表 I 所示，软障碍物较多的地图会产生更多较小的单地形入口。这种情况对小型智能体来说是有利的（有更多的过渡点可供选择），但对大型智能体来说却是不利的，因为它们必须越来越频繁地通过单一过渡点从一个集群穿越到另一个集群：这一过渡点是由横跨两个集群之间边界区域长度的长长的多地形入口产生的。每一次这样的穿越通常都是次优的，会降低路径的质量。最糟糕的情况出现在 SO 50% 数据集上，HAA* 的性能开始接近 SO 0% 数据集上的性能。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402291030626.png" alt="image-20240229103027513"></p>
<p>最后，我们将目光转向图 6，在图 6 中，我们使用搜索工作量指标对 HAA* 进行了评估。在这里，我们将 HAA<em>（在插入、分层搜索和细化阶段）与 AA</em> 在 HQ 和 LQ 图上扩展的节点总数进行了对比。我们将重点放在 SO 20% 问题集上，以分析随着路径长度的增加对搜索工作量的影响，但也注意到其他问题集也有类似的趋势。</p>
<p>通过观察图 6(a)，我们可以发现使用大集群规模 HQ 图的智能体在这项测试中处于劣势。将起点和目标连接到其本地簇中的每个抽象节点所需的插入工作在总工作中占了很大比重，导致 HAA* CS20 在处理长度不超过 250 的问题时落后于 AA* 。我们可以看到，随着问题长度的增加，CS20 与较小集群规模之间的差距也在缩小。相比之下，在图 6(b) 中，我们可以看到使用 LQ 图时，差距并不明显（每个簇的抽象节点较少）。不过，对于最大长度为 450 的问题，CS10 或 CS15 似乎更适合。计算解决方案所需的平均时间与图 6 中显示的趋势非常相似；在此特定数据集上，使用 HQ 图和 LQ 图，HAA* 每次查询的平均时间分别为 6.3ms 和 3.7ms。这进一步重申了我们的技术在游戏等现实世界应用中的适用性，因为在这些应用中，用于路径规划的计算资源非常有限。</p>
<h2><span id="xi-conclusion">XI. CONCLUSION</span></h2><p>路径规划中的异质性是许多现实世界问题的特征，但迄今为止却很少受到关注。在本文中，我们通过展示如何计算和利用基于间隙的障碍物距离来改进异构地形网格世界环境中多智能体的路径规划，从而解决了这一问题。我们的方法将涉及不同大小智能体和多地形穿越能力的复杂问题简化为简单得多的单大小、单地形搜索问题。在这些新见解的基础上，我们引入了一种新的规划器–分层注释 A* ，并通过比较分析表明，HAA*  能够在各种环境中找到接近最优的问题解决方案，而且搜索工作量仍然比标准 A* 低得多。我们的分层抽象技术应用简单，但非常有效；我们已经证明，在大多数情况下，存储抽象图的开销仅是非抽象图开销的一小部分。</p>
<p>未来的工作可能涉及计算注释，以处理海拔高度和其他常见地形特征。我们还希望找到一种更好的边间放置方法，并减少在抽象图中插入起点和目标的工作量。最后，我们相信 HAA* 可以有效地应用于解决异构多代理问题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-24T12:48:34.000Z" title="2024/2/24 20:48:34">2024-02-24</time>发表</span><span class="level-item"><time dateTime="2024-02-24T13:11:46.310Z" title="2024/2/24 21:11:46">2024-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">7 分钟读完 (大约981个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/24/Visibility-graph/">Visibility graph</a></p><div class="content"><h1><span id="visibility-graph">Visibility Graph</span></h1><h2><span id="定义">定义</span></h2><p>在计算几何和机器人运动规划中$^{[1]}$，可见度图是一组相互可见的位置图，通常是欧几里得平面上一组点和障碍物的位置图。图中的每个节点代表一个点位置，每条边代表它们之间的可见连接。也就是说，如果连接两个位置的线段不经过任何障碍物，则在图中它们之间画一条边。当地点集位于一条线上时，这可以理解为一个有序序列。因此，可见度图被扩展到时间序列分析领域。</p>
<h2><span id="应用">应用</span></h2><p>可见度图可用来寻找平面上一组多边形障碍物之间的欧氏最短路径：两个障碍物之间的最短路径除了在障碍物的顶点处可能转弯外，都是沿着直线段走的，因此欧氏最短路径就是以起点、终点和障碍物顶点为节点的可见度图中的最短路径$^{[2]}$。 因此，欧氏最短路径问题可分解为两个更简单的子问题：构建可见度图，以及对可见度图应用最短路径算法（如 Dijkstra 算法）。对于与障碍物相比体积不可忽略的机器人的运动规划，也可以采用类似的方法，在扩展障碍物以补偿机器人的体积后再进行规划$^{[2]}$。 Lozano-Pérez &amp; Wesley (1979) 将欧几里得最短路径的可见度图法归功于 1969 年 Nils Nilsson 对机器人 Shakey 运动规划的研究，并引用了 1973 年俄罗斯数学家 M. B. Ignat’yev、F. M. Kulakov 和 A. M. Pokrovskiy 对该方法的描述。</p>
<p>可视图还可用于计算无线电天线的位置，或通过可视图分析作为建筑和城市规划的工具。</p>
<p>位于一条直线上的一组位置的可视图可以解释为时间序列的图论表示[3]。这种特殊情况在时间序列、动力系统和图论之间架起了一座桥梁。</p>
<h2><span id="特点">特点</span></h2><p>简单多边形的可见度图以多边形的顶点为点位置，多边形的外部是唯一的障碍物。简单多边形的可见性图必须是哈密顿图：多边形的边界在可见性图中形成一个哈密顿循环。众所周知，并非所有可见性图都能诱导出简单多边形。然而，简单多边形可见性图的高效算法特征描述仍然未知。这些图不属于许多已知的结构良好的图族：它们可能不是完美图、圆图或弦图$^{[4]}$。这种现象的一个例外是，简单多边形的可见性图是共赢图$^{[5]}$。</p>
<h2><span id="相关问题">相关问题</span></h2><p>艺术画廊问题是指找到一小组点，使所有其他非障碍点都能从这组点上看到的问题。艺术画廊问题的某些形式可以解释为在可见度图中寻找支配集。</p>
<p>多边形或曲线系统的位切线是接触其中两条多边形或曲线而不穿透其接触点的直线。一组多边形的位切线构成可见度图的一个子集，可见度图以多边形的顶点为节点，以多边形本身为障碍物。由于欧氏最短路径只能沿着一条位切线进入或离开障碍物的边界，因此用可见度图法来解决欧氏最短路径问题，可以加快速度，因为可见度图是由位切线组成的，而不是使用所有可见度边$^{[6]}$。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-21T14:50:35.000Z" title="2024/2/21 22:50:35">2024-02-21</time>发表</span><span class="level-item"><time dateTime="2024-02-22T08:54:22.555Z" title="2024/2/22 16:54:22">2024-02-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约7846个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/21/An-Algorithm-for-Planning-Collision-Free-Pahts-Among-Polyhedral-Obstacles/">An Algorithm for Planning Collision-Free Pahts Among Polyhedral Obstacles</a></p><div class="content"><h1><span id="an-algorithm-for-planning-collision-free-paths-among-polyhedral-obstacles">An Algorithm for Planning Collision-Free Paths Among Polyhedral Obstacles</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402212252966.png" alt="image-20240221225204821"></p>
<h2><span id="abstract">Abstract</span></h2><p>本文介绍了一种避免碰撞的算法，用于规划多面体物体在已知多面体物体间移动的安全路径。该算法对障碍物进行转换，使其代表移动物体上任意参考点的禁区位置。该参考点的轨迹若能避开所有禁区，则不会发生碰撞。轨迹是通过搜索一个网络来找到的，该网络可以为变换后的障碍物中的每个顶点指出可以安全到达的其他顶点。</p>
<h2><span id="introduction">Introduction</span></h2><p>在物理对象的计算机模型上进行操作时，避免碰撞是基于模型的操纵系统的核心问题。本文介绍了一种在类似描述的障碍物中为多面体物体规划安全（即无碰撞）路径的算法。1 算法需要</p>
<p>(1) 找到可能会靠近障碍物的安全路径，以及</p>
<p>(2) 保证这些路径相对于预先指定的距离度量较短。</p>
<p>最简单的避免碰撞算法属于生成和测试范例。首先假设一条从起点到目标的简单路径，通常是一条直线，然后测试路径是否存在潜在碰撞。如果检测到碰撞，就会提出一条新路径，可能会使用检测到的碰撞信息来帮助假设新路径。如此反复，直到检测到路径上没有碰撞为止。这种算法的三个步骤大致如下</p>
<p>(1) 计算移动物体沿建议路径扫过的体积、</p>
<p>(2) 确定扫过的体积与障碍物之间的重叠，以及</p>
<p>(3) 提出新路径。</p>
<p>第二步是确定扫过的体积与障碍物之间的重叠，也称为交叉或干涉计算 [2，3]。目前的计算机建模技术采用了大量的简单曲面，即使是最常见的物体也能精确建模。要确定两个这样的模型是否重叠是相当困难的。我们将这种一般方法称为 “扫掠体积法”，它有一个更根本的缺点。问题在于第二步和第三步之间的关系。每条建议路径只提供了潜在碰撞的局部信息，例如相关体积交点的形状，或导致碰撞的障碍物的特征。这些信息会建议改变局部路径，但不足以确定何时采用完全不同的路径会更好。这种全局观念的缺乏会导致在可能的路径空间中进行昂贵的搜索，而路径的最坏长度上限又非常大。</p>
<p>扫掠体积法的一个根本替代方法是明确计算移动物体相对于障碍物的位置约束。所需的轨迹是满足所有位置约束条件的最短路径。如果将物体建模为凸多面体集合，则位置约束条件可以用移动物体顶点相对于障碍物表面平面的位置来表示。这样，轨迹问题就可以像 Ignat’yev [5] 那样被视为一个优化问题。这种表述方式的难点在于，这些位置约束条件虽然是线性的，但并非同时适用。移动物体上的每个点不一定要在所有障碍物的平面之外；每个点至少在每个障碍物的一个平面之外就足够了。这一特性使得传统的线性优化方法不再适用。</p>
<p>本文介绍的算法与优化方法密切相关。计算移动物体上任意参考点位置的约束条件。二维或三维的多面体障碍物会产生多面体禁区集，即与会发生碰撞的参考点位置相对应的区域。这种转换将为多面体寻找安全路径的问题简化为为点寻找安全路径的问题。要完成最后一项任务，就必须找到一条路径，穿过连接禁区顶点的图形。</p>
<p>将物体的位置约束条件作为参考点的约束条件进行计算的技术非常强大，已被独立应用于不同的问题。Udupa [9] 将其用于规划计算机控制机械手的安全路径，Lozano-Perez [6] 将其用于识别物体上可行的抓取点，Adamowicz 和 Albano [1] 将其用于二维模板布局。</p>
<p>Udupa 利用对障碍物的简单 “增长 “变换来计算操纵器三自由度子集的三维参考点的禁区近似值。该系统对参考点的合法位置（the ]ree space）进行可变分辨率描述。子集操纵器的安全路径是通过递归方式将中间目标引入直线路径，直到完整路径位于自由空间中。这种方法有两个缺点： 	</p>
<p>(1) 由于完整的机械手有三个以上的自由度，三维禁区无法模拟机械手的所有约束条件。当轨迹失效时，Udupa 系统会使用与操纵器相关的启发式方法进行修正。启发式方法的使用往往会限制算法在杂乱空间中的性能。</p>
<p>(2)递归路径搜索器仅使用局部信息来确定安全路径，因此存在一些与体积扫频法相同的缺点。</p>
<p>本文提出的算法使用更精确的增长操作来计算二维和三维的禁区。它引入了一种图搜索技术来寻找路径，当只涉及平移时，这种技术能产生最佳的二维路径。然后，该技术被推广到处理三维障碍物，并扩展到统一处理三个以上的自由度。由此产生的算法不再保证最优路径。这种算法已被用于规划一个七自由度机械手的安全轨迹。这些轨迹已成功执行。</p>
<p>Udupa [9]详细介绍了以前在避免碰撞方面所做的工作，特别是与计算机控制的机械手有关的工作。</p>
<p>障碍物模型的性质会影响任何避免碰撞算法的细节。为具体起见，本文的详细讨论和示例假定所有物体都被建模为一组可能重叠的凸多面体。任何物体都可以按照这种方式进行建模，达到所需的任何精确度。在凸多面体集合中为单个凸多面体寻找无碰撞路径的方法可以简单地扩展为在复杂障碍物中为复杂运动物体规划安全路径。扩展方法包括找到移动物体的每个凸分量相对于所有障碍物的每个分量的约束条件。综合移动物体的约束条件是其各部分约束条件的总和。</p>
<p>避免碰撞算法是为三维空间定义的。不过，二维的表述更容易理解；为了清晰起见，接下来的章节首先介绍二维情况下的完整算法，然后考虑扩展到三维。第 2 节介绍了多边形物体在平面内多边形障碍物间平移的简单算法。第 3 节考虑了允许移动物体旋转和平移的效果。第 4 节讨论具有更多自由度的更复杂移动物体。第 5 节讨论了向三维空间的推广。算法的两个步骤直接受到建模方法选择的影响，对这两个步骤的讨论将在附录中进行。这些步骤将在本文正文中进行功能描述。</p>
<h2><span id="2-collision-avoidance-on-the-plane">2. Collision Avoidance on the Plane</span></h2><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402212331767.png" alt="image-20240221233150585"></p>
<p>考虑图 1 所示的问题：将一个点物体 A 从位置 S 移动到位置 G，同时避开障碍物（如阴影所示）；图中还显示了从 S 到 G 的最短无碰撞路径。这条路径的重要特性是，它由直线组成，通过可能为空的障碍物顶点序列连接起点和终点。在任意多边形物体的平面运动中，连接任意两个可达点的最短无碰撞路径总是具有这一特性。</p>
<p>定义了无向图 VG（N，L）： 节点集 N 为 V u (S, G}，其中 V 是所有障碍物顶点的集合，链接集 L 是所有链接（n~, nj）的集合，使得连接 N 第 i 个元素和第 j 个元素的直线不会与任何障碍物重叠。图 VG(N, L) 称为 N 的可见性图 (VGRAPH)，因为图中相连的顶点可以相互看到。VGRAPH 如图 1 所示。平面上从 S 到 G 的最短无碰撞路径是 VGRAPH 中从与 S 对应的节点到与 G 对应的节点的最短路径，此时链路上使用的是欧几里得度量。我们将这种通过寻找可见度图中的最短路径来为一个点寻找无碰撞路径的方法称为 VGRAPH 算法。这种方法曾用于早期的机器人车辆 SHAKEY [8]的导航，Ignat’yev [5]中也有详细描述。</p>
<p>VGRAPH 算法之所以简单，是因为移动物体 A 是一个点。对于相对于障碍物较小的移动物体来说，这是一个很好的近似值，但在其他情况下就会出现问题，lgnat’yev [5, 第 241 页] 是这样说的：</p>
<p>机器人从 y0 点（本例中为 S 点）开始沿 xla（顶点）方向移动。在这里，它必须考虑自己的尺寸，以免撞上障碍物和墙壁。</p>
<p>本文展示了如何将更一般形式的避免碰撞问题简化为 VGRAPH 问题。换句话说，它涉及机器人如何 “必须考虑自己的尺寸”。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402212332757.png" alt="image-20240221233227498"></p>
<p>图 1 中问题的一个简单概括是将移动物体 A 变为半径为 rA 不可忽略的圆。VGRAPH 算法可以适应这种情况，方法是将顶点移开障碍物，使它们至少与所有边相距 ra（图 2）。移动 A，使其中心点穿过新移出的顶点，仍然可以得到一条距离最小、无碰撞的路径。不过请注意，找到的路径与图 1 中的不同。SHAKEY [8] 中也使用了这种顶点位移技术。</p>
<p>VGRAPH 算法要求移动物体是一个点；然后，障碍物代表该点位置的禁区。如果移动物体不是点，则必须计算一组新的障碍物，它们是移动物体上某个参考点的禁区。这些新的障碍物必须描述会导致与任何原始障碍物发生碰撞的参考点的位置。当参考点为 A 的中心时，图 2 中被移动的顶点实际上就是这些新障碍物顶点的近似值。</p>
<p>由原始障碍物 O 和移动物体 A 计算出一个新障碍物 O’ 的操作称为 “A 生长 0”。由 A 生成一组障碍物的结果将用 GOS(A) 表示，即 4 的 “生成障碍物集”。请注意，生长操作与推导机床切割零件的路径密切相关。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402212343628.png" alt="image-20240221234328525"></p>
<p>请看图 3(a)。图 1 和图 2 中的障碍物相同，但移动物体A现在是一个矩形实体。图 3(b) 显示的是A长大后的障碍物。该图还显示了A的参考点从 S 到 G 的最短无碰撞路径。请注意，障碍物空间的边界也被视为障碍物并进行了生长，从而避免了在空间外移动的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220840176.png" alt="image-20240222084023203"></p>
<p>增长操作的定义是计算移动物体的参考点位置中会与给定障碍物发生碰撞的位置。移动物体的位置被解释为其 (x, y) 位置，即生长出来的障碍物是 (x, y) 空间中的多边形。这是一个任意但自然的选择。不同类型的移动物体需要不同的选择。图 4(a) 显示了 (x, y) 坐标系中的一种情况。移动物体A可以围绕一个固定点旋转并改变长度。图 4(b) 显示了 $(r, \alpha)$ 空间中由于图 4(a) 中障碍物的存在而禁止A尖端进入的区域；图 4(c) 显示了以 (x, y) 坐标系表示该区域的另一种方法。选择哪种表示方法取决于</p>
<p>(1) 计算禁区（即增加障碍物）的难易程度，与</p>
<p>(2) 从生长出来的障碍物建立 VGRAPH 的难易程度。</p>
<p>将多面体作为形状描述的基本单位会影响我们对障碍物表示方法的选择。多面体（平面上的多边形）的边界是坐标变量的线性方程。这一特性使它们在计算上更具吸引力。在本节中，我们将物体表示为平面直角坐标系中的多边形。自然的选择是在同一空间中表示生长的障碍物，从而使生长操作成为从多面体到多面体的映射。请注意，在图 4（b）中，物体 O 被解释为（x，y）空间中的多边形，而由此产生的$（r，\alpha）$ 空间中的生长障碍物 O’ 并不是该空间中的多边形。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220841771.png" alt="image-20240222084101675"></p>
<p>选择障碍物表示法的另一个因素是 VGRAPH 中两个节点之间路径的形状。VGRAPH 中连接两个节点的链接意味着相应位置之间的路径不会与任何障碍物重叠。到目前为止，路径都是以直角坐标空间中的直线来表示的；由于生长出来的障碍物都在这个坐标空间中，因此使用直线简化了重叠检测。当然，路径可以是更复杂的曲线，最好用不同的坐标系来表示。例如，图 4 中的物体可能在 $ (r, \alpha) $ 坐标系中以直线运动。在这种情况下，使用生长障碍物的极坐标形式来检测重叠可能会更有效。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220842170.png" alt="image-20240222084245005"></p>
<p>生长障碍物的表示方法取决于应用领域的几何细节。选择时应尽量简化整体计算。为简单起见，下一节将继续假设生长的障碍物是 (x, y) 空间中的多边形。</p>
<h2><span id="3-the-effect-of-rotation">3. The Effect of Rotation</span></h2><p>值得注意的是，如图 2 和图 3 所示，生长操作对 A 的方向非常敏感。与方向有关的原因是，生长的障碍物被定义为参考点的禁区。平面上一个点的位置只能编码两个自由度，而区分 A 的两个不同方向位置的合法性至少需要三个自由度。图 5 显示，A 的方向与图 3 中的不同，会产生不同的生长障碍和不同的路径。为了明确方向，我们将用移动物体 A（其方向参数为角度 $\alpha$）表示所有障碍物的生长结果，即 $GOS(A_{\alpha})$ 。这些生长出来的障碍物的顶点集合称为 $V_{\alpha}$。</p>
<p>概括地说，A 的参考点位于生长障碍物集所有元素之外的 A 在方位 ,$\alpha$ 的任何位置都不会发生碰撞。GOS(A,)中每个障碍物的边都是在保持 A 与障碍物接触的情况下，通过追踪 A 的参考点在每个原始物体周围的路径计算出来的。在两个物体发生碰撞之前，它们必须首先接触；因此，任何会导致碰撞的参考点位置都必须在障碍物内部，而在障碍物外部的任何位置都必须是安全的。显然，这个条件的前提是 A 的方向不会改变。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220846460.png" alt="image-20240222084635421"></p>
<p>考虑将物体 A 从方位为 o~ 的位置 S 移到方位为 ft 的位置 G 的问题。简单地计算一条在 GOS(A,) 和 GOS(A~) 中没有碰撞的路径是找不到安全轨迹的，因为在改变方向从 a 到&#x2F;3 的过程中，A 必须经过整个中间方向范围。寻找路径的一种方法是了解平面上哪些位置可以实现所需的旋转。然后，算法就可以规划出一条从起点到这些位置之一的路径，旋转到所需的方向，然后沿该方向移动到目标。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220846014.png" alt="image-20240222084651784"></p>
<p>要使一个位置允许改变方向，旋转物体在其任何中间方向上都不能与任何障碍物重叠。图 6 显示了 A 从方位 a 到方位 fl 所经过的区域；这个区域可以用另一个多边形 A t,, 来近似表示。为简单起见，Ca 显示为矩形。这个新对象被称为包络线，可以用来生长一个新的障碍物集 GOS(A t~, m)，也如图 6 所示，它表示 A 的参考点在区间 [a,&#x2F;3] 内任何一个方向上的禁止区域。我们将把它称为过渡障碍集。类比顶点集 V，，集合 Vt,, ~ 代表过渡障碍集中的障碍顶点集。一般来说，我们可以为顶点集的所有元素关联一个方向区间（可能是奇异的）以及一个位置。</p>
<p>要使一个位置允许改变方向，旋转物体在其任何中间方向上都不能与任何障碍物重叠。图 6 显示了 A 从方位 a 到方位 fl 所经过的区域；这个区域可以用另一个多边形 A t,, 来近似表示。为简单起见，Ca 显示为矩形。这个新对象被称为包络线，可以用来生长一个新的障碍物集 GOS(A t~, m)，也如图 6 所示，它表示 A 的参考点在区间 [a,&#x2F;3] 内任何一个方向上的禁止区域。我们将把它称为过渡障碍集。类比顶点集 V，，集合 Vt,, ~ 代表过渡障碍集中的障碍顶点集。一般来说，我们可以为顶点集的所有元素关联一个方向区间（可能是奇异的）以及一个位置。</p>
<p>图 6 中的问题现在可以通过以下方法解决：</p>
<p>(1) 在 S 处找到一条以方位 a 为起点的路径，该路径要避开 $GOS(A_{\alpha})$ 中的障碍物，并以 $GOS(A_{[\alpha, \beta]})$ 中没有障碍物的点为终点、</p>
<p>(2) 旋转到方向 $\beta$，并</p>
<p>(3) 找到一条通往 G 的路径，避开 $GOS(A_{\alpha})$ 中的障碍物。</p>
<p>这可以说是一个 VGRAPH 问题，即在如下定义的可见度图中找到从 S 到 G 的最短路径：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220852708.png" alt="image-20240222085220474"></p>
<p>使以下可见性条件在链路上成立：</p>
<p>(1) 方向区间 [a, b] 和 [c, d] 必须不相交、</p>
<p>(2) $n_i$ 位于 $GOS(A_{[a, b]})$ 的所有障碍物之外、</p>
<p>(3) $n_j$ 位于 $GOS(A_{[c, d]})$ 的所有障碍之外、</p>
<p>(4) 从 $n_i$ 到 $n_j$ 的路径要么：</p>
<p>(a) 不与 $GOS(A_{[a,b]})$ 中的任何障碍物重叠，或</p>
<p>(b) 不与 $GOS(A_{[c, d]})$ 中的任何障碍物重叠。</p>
<p>$VG_{\alpha, \beta}$ 中的求解路径是以 S 为起点、以 G 为终点的节点序列：</p>
<p>$S, n_1, n_2, …, n_k, G$</p>
<p>其中相邻节点通过 L<del>, ~ 中的链接相连。每个 n</del> e Vt<del>, ~,1 的定义是：如果 n</del> 位于 GOS(A E<del>.bl) 的所有障碍物之外，则移动物体 A 的参考点可以位于区间 [a, b] 内任意方向的 nj 位置，而不会有碰撞危险。从 ni 到 nj+</del> 的链接意味着 A 的参考点必须进行相应的平移。此外，如果 nj 和 ni +1 分别属于不同的顶点集 Via, <del>1 和 Vtc, ~1，那么也可能需要改变方向。L,, ~ 的条件要求链路端点对应的方向区间必须不相交。这意味着存在某个方向 x，如果 a _&lt; b 和 c _&lt; d，那么 max(a, c) &lt; x &lt; min(b，d)，A 可以安全地位于链接的任一节点。沿着链接移动需要首先旋转到 x 方向，然后从第一个节点平移到第二个节点。由于平移的方向与链接的两个节点都兼容，因此链接的可见性条件只需检查是否与任一节点的障碍集中的障碍物重叠即可。或者，如果从 n</del> 到 nj+l 的路径在 GOS(A t<del>, ~l) 和 GOS(A t</del>..d~) 的所有障碍物之外，那么旋转可以与沿链接的平移同时进行。</p>
<p>使用过渡集（如 GOS(A t-, <del>]）有两个重要缺点。VG&lt; ~ 中的最短解路径不再保证是原始问题的最优解，而在 VGRAPH 中找不到解路径并不一定意味着不存在安全轨迹。原因有两个方面。首先，也是最基本的原因是，在 VGRAPH 中找到的路径只会在可以进行完全旋转的位置改变运动物体的方向。如果最佳路径涉及穿越一条狭窄的通道，其中 A 的方向必须在 ,</del> 和&#x2F;3之间的一个小范围内，那么这条路径就不可能是这一版本 VGRAPH 算法的求解路径。其次，即使避免了第一个问题，目前的算法也只考虑[~, &#x2F;3]范围内的方向，因此无法计算移动物体只能在指定范围外的方向上移动的通道。后一个问题可以简单地通过扩大方向区间来解决，但代价是前一个问题变得更加严重。</p>
<h2><span id="4-more-degrees-of-freedom">4. More Degrees of Freedom</span></h2><p>只要移动物体的自由度大于障碍物坐标空间中的一个点，就可以使用过渡障碍物集。唯一的要求是可以计算出一个包络 At, ‘ <del>1 ，它是一个与 A 相同类型的对象，例如一个多边形，使得 A&#x3D;, x &lt; z _&lt; y 内的任何一点也在 A tx, ~J] 内。然后，这个对象就可以用于生长操作，生成一个过渡障碍集。参数范围 Ix, y] 的性质没有其他限制；特别是，它不必是一个方向范围，x 和 y 也可以是矢量。在 GOS(A tx, yl) 中所有障碍之外的点表示 A</del> 的配置参数 z~ 可以安全取值的位置，即 x~ &lt; z~ _&lt; yi。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402220902408.png" alt="image-20240222090238290"></p>
<p>图 7 重复了图 4 的示例，只是现在移动物体可以进行 x 和 y 方向的平移、旋转并改变长度。选择生长障碍物的坐标系还将决定配置参数使用哪个坐标变量。例如，如果生长出来的障碍物在 (x, y) 坐标系中表示为多边形，那么 (r, a) 就是配置参数，反之亦然。</p>
<p>配置参数还可用于处理移动物体，该物体的形状会因各组成部分相对位置的变化而改变。图 8 所示的物体由两个矩形组成，这两个矩形可以围绕一个共同点自由旋转。该物体相对于静止障碍物的形状可以用以下公式描述：</p>
<p>(1) 部件的形状、</p>
<p>(2) 它们的相对位移、</p>
<p>(3) 图 8 所示的两个角度 0 和 O。</p>
<p>在本例中，运动过程中只有角度会发生变化；因此，该运动物体的障碍物集必须通过 0 和 p 的值进行参数化。</p>
<p>一般来说，对象不需要在全维配置空间中生长；相反，重复使用对低维、分区配置空间的操作，可以使生长操作在全配置空间的子空间中方便地进行。第 2 节和第 3 节所述的 VGRAPH 算法保持不变，只是将标量参数和区间替换为矢量参数和区间。</p>
<h2><span id="5-collision-avoidance-in-three-dimensions">5. Collision Avoidance in Three Dimensions</span></h2><p>迄今为止，VGRAPH 算法一直是作为平面防撞算法来介绍的。本节将探讨三维障碍物对算法的影响。这种概括并不影响算法的陈述，但会影响障碍物生长和图形搜索的细节。这些主题将在附录中讨论。</p>
<p>泛化到三维空间有一个不幸的副作用。绕过多面体障碍物的最短路径一般不会只穿过多面体的顶点（图 9）。也就是说，VGRAPH 中的最短路径（其节点集仅包含生长出来的障碍物顶点）并不能保证是最短的无碰撞路径。一般来说，最短路径需要经过障碍物边上的点。我们的方法是沿着已生长障碍物的边缘引入额外的顶点，使任何边缘的长度都不超过预先规定的最大长度。这种方法通常能很好地逼近最优路径。</p>
<p>使用三维障碍物对算法的执行时间也有很大影响。三维生长操作比二维生长操作耗时更多。三维生长的障碍物通常比底层对象复杂得多（附录 1）。较大的顶点集也增加了搜索可见度图所需的时间。这些影响使得在实际应用中必须使用近似值。</p>
<p>少用细节生长操作可以大大节省成本。许多应用领域的特性是，移动物体只需在路径上的少数几个点靠近障碍物即可。这些关注点通常包括路径的起点和终点。在其他情况下，对路径的要求并不那么严格；事实上，当移动物体远离障碍物时，靠近障碍物往往是不可取的。VGRAPH 算法可以很容易地利用这一特性；无需对每个已知障碍物执行详细的生长操作，只需对靠近照料点的障碍物执行生长操作即可。而在远离观测点的地方，则可以安全地使用大幅度的近似值。由多个多面体构成的复杂物体可以用一个外围多面体来近似。移动物体也可以采用类似的近似方法，从而进一步简化过程。此外，还可以使用一种非常简单的生长运算（附录 1），这种运算虽然牺牲了精确度，但速度更快，得到的物体也更简单。</p>
<p>使用这种近似技术的关键在于如何有效地确定哪些物体靠近观测点。显然，如果一个观察点位于一个物体的内部或靠近由其产生的长大障碍物的一个侧面，那么该观察点就靠近该物体。这意味着，移动物体位于观察点时，要么在该物体的内部，要么靠近该物体的一侧。对运动物体和静止物体进行近似处理，会使照料点位于增大的障碍物内部。这一条件可作为谨慎生长的标准。当移动物体相对于障碍物较大时，将其近似为单个物体会导致过多障碍物的详细生长。移动物体越大，简单近似的效果可能就越差。特别是移动物体的某些部分，如果距离照应点相对较远，就会导致生长出来的障碍物包括照应点。解决方法是对移动物体进行分层分解；也就是说，如果最粗糙的描述测试失败，则使用稍好的近似值。这样就能更好地隔离潜在的碰撞源。而不涉及的运动物体的其他部分则无需仔细考虑。Udupa [9] 提出了类似的可变细节近似方案。</p>
<p>提高算法效率的另一种方法是在图搜索操作中使用启发式方法。附录 2 对 VGRAPH 的搜索进行了简要讨论。</p>
<h2><span id="6-summary-and-discussion">6. Summary and Discussion</span></h2><p>本文展示了如何将 SHAKEY [8] 用于导航的简单可见度图算法扩展到更一般的避免碰撞问题。实现这一目标所需的机制包括增加障碍物和将移动物体缩小到一个点。这种方法有一个理想特性，即提供了两个子问题，即增加障碍物和搜索可见性图，这两个问题可以独立解决。附录中介绍了我们目前解决这些问题的方法。</p>
<p>VGRAPH 算法尚存在的最重要问题是将配置参数量化为区间。需要几乎连续改变方向和位置的路径需要较小的量化区间，从而产生许多过渡障碍集，因此计算成本很高。</p>
<p>本文所述的 VGRAPH 算法是在 IBM 370&#x2F;168 型计算机上用 PL&#x2F;1 实现的。它已被用于为一个七自由度计算机控制的机械手规划无碰撞轨迹[10]；这些轨迹已在实验室中成功执行。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-16T11:37:59.000Z" title="2024/2/16 19:37:59">2024-02-16</time>发表</span><span class="level-item"><time dateTime="2024-02-25T03:50:25.197Z" title="2024/2/25 11:50:25">2024-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">29 分钟读完 (大约4312个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/16/A-review-On-path-planning-strategies-for-navigation-of-mobile-robot/">A review: On path planning strategies for navigation of mobile robot</a></p><div class="content"><h1><span id="a-review-on-path-planning-strategies-for-navigation-of-mobile-robot">A review: On path planning strategies for navigation of mobile robot</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402161939446.png" alt="image-20240216193925254"></p>
<h2><span id="abstract">Abstract</span></h2><p>本文对迄今为止使用的移动机器人导航技术进行了深入研究。本文对经典方法和反应式方法进行了逐步研究，以了解各种环境条件下路径规划策略的发展，并找出研究差距。经典方法包括单元分解法（CD）、路线图法（RA）和人工势场法（APF）； 研究考虑了遗传算法 (GA)、模糊逻辑 (FL)、神经网络 (NN)、萤火虫算法 (FA)、粒子群优化 (PSO)、蚁群优化 (ACO)、细菌觅食优化 (BFO)、人工蜂群 (ABC)、布谷鸟搜索 (CS)、洗牌蛙跳算法 (SFLA) 和其他杂项算法 (OMA) 等反应式方法。对静态和动态条件下的导航进行了分析（针对单个和多个机器人系统），结果表明，与传统方法相比，反应式方法更加稳健，在所有地形下均表现良好。同时还发现，作为一种混合算法，反应式方法可用于提高经典方法的性能。因此，反应式方法在移动机器人的路径规划中更为流行和广泛。本文最后以表格数据和图表的形式比较了各种导航策略的使用频率，这些策略可用于机器人技术中的特定应用。</p>
<h2><span id="introduction">Introduction</span></h2><p>最初，移动机器人的应用仅限于制造业。但如今，它已普遍应用于娱乐、医疗、采矿、救援、教育、军事、太空、农业等领域。在执行导航任务时，机器人配备了许多智能设备，这些设备需要对环境进行建模、定位、控制运动、检测障碍物，并利用导航技术避开障碍物。从初始位置到目标位置的安全路径规划（通过检测和避开障碍物）是任何导航技术最重要的功能。因此，在简单和复杂的环境中工作时，正确选择导航技术是机器人路径规划中最重要的一步。目前，不同研究人员在移动机器人导航领域开发了许多技术，是当今研究最多的课题。移动机器人导航分为三类：全局导航、局部导航和个人导航。全局导航能够确定环境中各元素相对于参考轴的位置，并朝着预先确定的目标前进。局部导航涉及环境动态条件的识别和各种元素之间位置关系的建立。通过考虑环境中各种元素的位置，处理它们之间的相对关系，这就是个人导航。机器人运行的基本步骤[1]如图 1 所示。</p>
<p>本文根据路径规划所需的先验环境信息对导航策略进行了分类。大致可分为全局导航和局部导航。在全局导航中，移动机器人必须先获得环境、障碍物位置和目标位置的信息，而在局部导航中，移动机器人不需要先获得环境信息。全局导航策略处理的是完全已知的环境。局部导航策略处理的是未知和部分已知的环境。已知环境下的路径规划算法基于传统方法，如 CD、RA 和 APF。这些算法都很传统，智能性有限。本地导航方法被称为反应式方法，因为它们更加智能，能够自主控制和执行计划。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162036016.png" alt="image-20240216203638727"></p>
<p>许多研究人员都提交了有关移动机器人导航的调查论文[2-3]，但这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在找出特定领域的研究空白和创新范围。它深入分析了静态环境、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合、在三维（3D）环境中的应用以及在军事或国防设备中的应用等方面的单项算法。调查还强调了经典方法和反应方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。参考文献[2]的重点是 “在特定的环境中”。2]主要关注基于本地传感器信息的反应式方法、滑动模式控制和基于分散式 MPC 的方法，而参考文献[3]则仅限于三维环境。[3] 则仅限于三维路径规划。</p>
<p>第 2 节将导航策略分为传统方法和被动方法。第 3 节讨论文献调查，第 4 节为结论。</p>
<h2><span id="2-navigational-techniques-used-for-mobile-robot-navigation">2. Navigational techniques used for mobile robot navigation</span></h2><p>几十年来，各类研究人员和科学家提供了大量导航方法。用于移动机器人导航的各种方法大致分为两类，即经典方法和反应方法（图 2）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162044040.png" alt="image-20240216204419104"></p>
<h3><span id="21-classical-approaches">2.1. Classical approaches</span></h3><p>最初，经典方法在解决机器人导航问题方面非常流行，因为当时还没有开发出人工智能技术。使用经典方法执行任务时，要么会得到结果，要么会确认结果不存在。这种方法的主要缺点是计算成本高，无法对环境中存在的不确定性做出反应，因此不太适合实时执行。本文将对 CD、RA 和 APF 等经典方法进行综述。</p>
<h4><span id="211-cell-decomposition-cd-approach">2.1.1. Cell decomposition (CD) approach</span></h4><p>这种方法将区域划分为不重叠的网格（单元），并使用连接图从一个单元穿越到另一个单元，以实现目标。在遍历过程中，考虑纯单元（无障碍单元），以实现从初始位置到目标位置的路径规划。在确定从初始位置到目标位置的最佳路径时，路径中存在的损坏单元格（包含障碍物的单元格）会被进一步分割成两个新单元格，从而得到一个纯单元格，这个纯单元格会被添加到序列中。在 CD 方法中，初始位置和目标位置分别由起点和终点单元表示。连接这两个位置的纯单元序列表示所需的路径 [4-5]。CD 方法分为自适应、近似和精确三种。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162051037.png" alt="image-20240216205137828"></p>
<p>在图 3 所示的精确单元分解法[6-7]中，单元没有特定的形状和大小，但可以根据环境地图、形状和其中障碍物的位置来确定。这种方法以多种方式使用规则网格。首先，将环境中可用的自由空间分解成小元素（梯形和三角形），然后为每个元素编号。环境中的每个元素都是连接图的一个节点。相邻的节点可以在配置空间中连接起来，该图中的一条路径相当于自由空间中的一条分道线，由连续的条纹单元勾勒出来。该图中的一条路径与自由空间中的一个网络相连，该网络由连续的条纹单元格勾勒而成。然后，通过通道中相邻单元格交叉点的中点，将底层布置与目标设计连接起来，从而将该通道转换为自由通道。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162053916.png" alt="image-20240216205302554"></p>
<p>在近似单元分解法[8-9]中，规划空间被用来定义具有特定形状和大小的规则网格，因此很容易实现。在空间中，物体的边界不应与之前确定的单元边界相匹配，因此被称为近似。在这种导航方法中，如果物体占据了网格空间，就会被视为障碍物，否则就会被视为空白空间。在搜索区域的寻路过程中，每个单元格的中心被假定为一个节点。图 4 显示了 4 节点和 8 节点连接系统，机器人必须在它们之间以对角线方式行进。自适应单元分解可以理解自由空间中存在的信息，并遵循常规单元分解中避开自由空间的基本概念。Samet [10] 和 Noborio [11] 提出了一种四重自适应分解法。它将环境划分为大尺寸的单元格，但当网格单元被部分占用时，它会将单元格划分为四个相等的子部分，直到单元格变空为止。图 5 显示了在不同大小的网格单元触及障碍物边界时产生的工作空间地图。该系统有一个缺点，即在获得新数据（障碍物的新位置）时无法更新程序，因此在动态环境中会失效。Lingelbach [12] 对高维静态配置空间中的路径规划问题进行了论证。他解决了链状机器人平台和迷宫环境的路径规划问题。Rosell 等人[13] 将谐函数应用于 C 形障碍物环境中的单元分解，而 Sleumer 等人[14] 则提出了基于 CAD 信息的移动机器人路径规划策略。Cai 等人[15] 提出了一种基于传感器的近似单元分解策略，用于对复杂环境中的多个固定目标进行分类。该方法在静态环境中的表现优于最短路径，并能完全覆盖环境。Dugarjav 等人[16] 提出了同样的基于传感器的单元分解模型，用于处理移动机器人任务中的未知直线工作空间。他们将 CD 方法与激光扫描机制结合使用，以避开未知环境中的物体。Glavaski 等人[17] 提出了一种混合方法，以填补路径规划问题中理论成果与实际考虑之间的差距。他们开发了一种基于 APF 的精确单元分解路径规划器，以降低计算成本。为了在不确定的环境中执行，Tunggal 等人[18]提出了实时运行的 FL 和 CD。为了在三维环境中同时处理多个活动，Mark 等人[19] 提出了一种贪婪深度优先搜索算法和基于 GA 的单元分解方法，用于机械手的路径规划。Gonzalez 等人[20]通过改变所涉及的单元分解、图权重和计算航点的程序，对轨迹进行了定量研究。Wahyunggoro 等人[21]将单元分解方法应用于探索三维环境的空中导航问题。在这种方法中，模糊逻辑与单元分解方法相结合，用于引导和控制航空飞行器。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162102538.png" alt="image-20240216210253583"></p>
<h3><span id="212-roadmap-approach-ra">2.1.2. Roadmap approach (RA)</span></h3><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162103361.png" alt="image-20240216210342486"></p>
<p>RA 也被称为高速公路方式。它是从一个地方到达另一个地方的方法，自由空间之间的连接用一组一维曲线来表示[22]。当路线图绘制完成后，规划者就可以将其作为同质道路的排列方式，从而发现理想的排列方式。在这里，节点在为机器人找到理想路径中扮演着重要角色。RA用于寻找从机器人初始位置到目标位置的最短路径；Voronoi图和可见性图用于绘制路线图。可见度图法将初始位置和目标位置与地图上的节点连接起来。图 6 表示可见度图，其中暗区表示障碍物，虚线表示从初始位置到最终位置的相应路径 [23]。这种方法也可用于多边形障碍物环境，其中多边形的顶点由节点表示，边则是节点之间的连接[24]。Voronoi 图 [2527] 是另一种用于机器人路径规划的路线图算法。这种方法将区域划分为若干子区域，图中的所有边都是利用障碍物边界上相邻两点的等距点来构建的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402242119612.png" alt="image-20240224211934401"></p>
<p>图 7 显示了 Voronoi 图的工作原理。文献[28-30]介绍了 Voronoi 图在移动机器人绕障碍物导航领域的应用。为了提高性能，消除 Voronoi 图中的急转弯和长循环等缺点，对有效路径规划进行了一些改进[31]。混合方法是通过结合可见度图、沃罗诺图和势场方法 [32] 来实现路径优化。据观察，该方法无法获得最佳路径，且执行过程复杂。为了成功利用 Voronoi 图进行路径规划，Yang 等人[33]采用了骨架图等多种策略。Wein 等人[34]提出了一种结合使用可见性图和 Voronoi 图的方法，以获得最佳路径。Kavraki 等人[35]提出将概率应用于 RA，以理解和生成路径规划的解决方案。然而，这种方法在获得最佳路径长度方面效率较低。为了改进寻找最短路径的过程，Sanchez 等人[36] 对概率路线图方法（PRM）进行了细微的改进。在他们的方法中，将懒碰撞检查策略与 PRM 结合起来，以解决真实环境中的路径规划问题。Yan 等人[37]成功测试了无人飞行器在三维环境中的导航。在该方法中，路线图方法采用概率公式来控制飞行路线。</p>
<h3><span id="213-artificial-potential-field-apf-approach">2.1.3. Artificial potential field (APF) approach</span></h3><p>Khatib [38] 于 1986 年提出了用于移动机器人导航的 APF 方法。他认为，目标和障碍物就像带电表面，总电势会对机器人产生假想力。如图 8 所示，这种假想力会吸引机器人朝目标前进，并使其远离障碍物。在这里，机器人沿着负梯度避开障碍物，到达目标点。Garibotto 等人[39]介绍了这种方法在移动机器人导航中的应用。Kim 等人[40] 利用 APF 讨论了在未知环境中的一种新的避障策略。他们使用谐函数来避免局部最小值问题。Borenstein 等人[41] 也提出了局部最小值条件问题的解决方案。在这项研究中，他们考虑了机器人导航的动态特性。文献[42-43]对动态环境中的避障 APF 进行了分析。利用静电定律对 APF 方法进行了一些改进 [44]。静电法的实施有助于产生势函数和实时确定无碰撞路径。在实时环境中移动避障并非易事，因此 Huang [45] 开发了一种速度控制机制，以便在实现目标的同时了解障碍物的位置和速度。为了避免局部最小值并实现全局最优，Shi 等人[46] 引入了上位势函数和上位斥势函数。Sfeir 等人[47] 通过振荡和冲突等 APF 方法解决了移动机器人导航中的观测问题。他们提出了一种改进版的 APF，当目标靠近障碍物时，可将振荡和冲突最小化。为了测试 APF 的适用性，Pradhan 等人 [48] 使用了 ROBOPATH 仿真工具。他们考虑了各种环境条件下的多个移动机器人，观察到在无碰撞的情况下，协调策略的效果更好。为了提高 APF 路径规划器的性能，它与许多技术结合使用，如 BFO [49]（如图 9 所示）、GA[50]、PSO [51] 和 FL [52]。在三维空中和水下条件下导航是一项具有挑战性的任务，但 Cetin 等人[53]和 Li 等人[54]分别使用 APF 方法取得了成功。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-01T02:04:35.000Z" title="2024/2/1 10:04:35">2024-02-01</time>发表</span><span class="level-item"><time dateTime="2024-02-25T16:30:29.548Z" title="2024/2/26 00:30:29">2024-02-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">2 小时读完 (大约16605个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/01/Path-Planning-for-Autonomous-Mobile-Robots-A-Review/">Path Planning for Autonomous Mobile Robots: A Review</a></p><div class="content"><h1><span id="path-planning-for-autonomous-mobile-robots-a-review">Path Planning for Autonomous Mobile Robots: A Review</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011006947.png" alt="image-20240201100645752"></p>
<h2><span id="abstract">Abstract</span></h2><p>摘要：为移动机器人提供自主能力是有好处的。它使人们可以免去人类操作员的干预，这可能会在经济和安全方面带来好处。在大多数情况下，自主性要求使用路径规划器，使机器人能够考虑如何从其所在位置在某一时刻移动到另一时刻。鉴于文献中存在大量的方法，根据用户的要求寻找最合适的路径规划算法可能具有挑战性。此外，本文所分析的过去的综述作品只涵盖了其中的一些方法，遗漏了一些重要的方法。因此，我们的论文旨在作为一个起点，对迄今为止的研究进行清晰而全面的概述。本文介绍了路径规划算法的总体分类，重点关注与自主地面车辆一起使用的方法，但也可扩展到在表面上移动的其他机器人，如自主船只。此外，还从路径规划的角度探讨了用于表示环境的模型以及机器人的移动性和动力学。对分类中提出的每个路径规划类别都进行了披露和分析，并在最后对其适用性进行了讨论。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>自主导航是移动机器人的宝贵财富。它有助于减轻机器人对人工干预的依赖。然而，它也需要解决许多任务或问题，例如路径规划。这项任务在于找到最佳行动方案，使机器人从当前状态到达理想状态。例如，这两个状态可以分别是目标和初始位置。这一行动路线以路径的形式出现，在许多其他著作中也被称为路线。路径的作用是引导机器人到达所需的状态。然而，考虑到机器人可移动的自由空间，可能会有无数条可能的路径。路径规划算法通常试图获得最佳路径，或至少是其可接受的近似值。&#x3D;&#x3D;这里的最佳路径指的是最优路径，即通过最小化一个或多个目标优化函数得到的路径。&#x3D;&#x3D;例如，这条路径可能是耗时最少的路径。这在搜救等任务中至关重要[1]：灾难受害者可能会在生死关头请求帮助。另一个需要考虑的优化功能可能是机器人的能量。在行星探索中，这一点至关重要，因为漫游车可用的能源资源有限[2]。同时，规划器生成的路径必须遵循任何强加的限制。这些限制可能来自于机器人对某些地形的适应性限制。机器人的运动能力和现有地形的特点限制了可执行的操作类型。这就减少了路径规划器可生成的可行路径的数量。</p>
<p>在文献中，有大量的路径规划方法，而且这种方法的数量近年来还在不断增加。因此，根据特定要求（例如上述运动限制）选择最合适的方法是一项具有挑战性的任务。此外，如下文所述，有关路径规划的最新评论和调查并未对大多数现有路径规划解决方案进行全面概述。这就是撰写本综述论文的主要动机：它详细描述了不同的路径规划类别，并针对其中的每一类，介绍了文献中具有代表性的相关参考文献，重点关注那些针对在表面上（地面、水面等）移动的机器人的算法。本文的结构如下。第 2 节介绍本文提出的对现有路径规划算法进行分类的方法。根据该方法，本文还明确指出了之前的工作存在重要疏漏的事实。此外，本节还分析了用于处理环境和运动信息的方法。接下来的章节将分别讨论这一分类中的一个类别： 反应计算（第 3 节）、软计算（第 4 节）、C 空间搜索（第 5 节）和最优控制（第 6 节）。最后，第 7 节总结了本文的内容，并对上述类别中包含的路径规划算法进行了讨论。</p>
<h2><span id="2-path-planning-algorithms">2. Path Planning Algorithms</span></h2><p>图 1 描述了路径规划的四个类别，每个类别又分为两个子类别。这种分类基于构建和返回路径的原则和基本机制。下一小节将更详细地介绍这些类别以及为何如此分类。第二小节将介绍环境建模和机器人与地形交互建模的不同方法。我们认为有必要增加这一内容，因为对于许多算法，尤其是 C 空间搜索类算法，有必要事先构建这些模型。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011012260.png" alt="image-20240201101204048"></p>
<p>图 1. 现有路径规划方法分类示意图。共有四个主要类别，每个类别包含两个子类别。不同类别中相邻的两个子类别具有共同特征。该示意图还显示了某些子类别更倾向于全局规划或局部规划。</p>
<h3><span id="21-general-classification">2.1. General Classification</span></h3><p>建议的分类考虑了路径规划算法的功能。在过去的许多综述中，人们对路径规划算法进行了两种区分：一是根据环境是否动态来区分；二是根据在线和离线路径规划算法来区分[3]；三是根据环境的大小来区分，是局部环境还是全局环境。通常，”在线 “与 “本地 “相关，而 “离线 “与 “全局 “相关。这其中的主要问题是，有一些算法可以同时归为这两类。没有重新规划能力的算法由于计算速度快，可以在线使用。相反的情况也可能发生。例如，一种名为动态窗口法（DWA）的反应式计算算法通常用于局部规划[4]，但也可用于全局规划[5]。Vagale 等人[6]提出了一种有趣的算法划分方法，即需要初步地图表示的算法（经典算法）[7] 和不需要初步地图表示的算法（高级算法）。经典算法包括图搜索方法，而高级算法则包括软计算和基于采样的算法。Souissi 等人[7]提出了几种清晰合理的路径规划分类：根据机器人模型（整体动力学、非整体动力学、动力学）；根据地图模型要求（需要或不需要）；根据重新规划能力（离线或在线）；根据初步配置参数（确定性或概率性），根据算法是否总是计算出相同的解决方案。</p>
<p>本文提出的分类（如图 1 所示）有两个主要目的。首先，与以往的综述相比，本分类旨在涵盖更多种类的算法。过去的许多综述都提出或声称要对路径规划进行综述，但从表 1 中可以看出，大多数综述都存在重大遗漏。在本表中，”是 “表示对相关算法进行了重要讨论。仅提及表示出版物承认至少存在一种或多种该类算法。如果括号之间有一两个算法，则表示这些算法只被简单提及。其次，在某些情况下，路径规划类别的命名方式并不明确。例如，其他一些综述对经典方法和启发式方法进行了区分 [8,9]。Patle 等人[10] 将后者称为 “反应式”。然而，”经典 “一词可能是一个相当模糊的术语，因为大多数规划算法都是基于已有数十年历史的方法。这一类算法还包括许多运作方式完全不同的算法。&#x3D;&#x3D;启发式这一术语不仅用于指进化算法和人工智能算法 [8]，也用于指基于图搜索的规划算法 [4]。&#x3D;&#x3D;有鉴于此，我们&#x3D;&#x3D;建议使用四个类别（见图 1）进行一般分类： 反应计算、软计算、C 空间搜索和最优控制&#x3D;&#x3D;。此外，图 1 显示了这些类别中的每个类别在一般情况下是如何主要用于局部或全局规划的。此外，每个子类别与其他类别的子类别在功能上也会有一些共同点，例如使用数值方法、存在用于事先调整算法的参数、要求用图形对地图进行建模或使用随机迭代过程。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011013062.png" alt="image-20240201101344831"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011014363.png" alt="image-20240201101410215"></p>
<h3><span id="22-path-planning-workspace-modeling">2.2. Path Planning Workspace Modeling</span></h3><p>路径规划器需要获得描述环境的信息。例如，这些信息可以描述是否存在障碍物或与规划相关的表面特征。此外，用于计算路径的标准还与机器人与环境的交互方式有关。例如，只需尽量缩短路径长度，或许还能获得哪些区域可以穿越、哪些区域不可以穿越的信息就足够了，而要尽量减少能量消耗，则应考虑到地形力学和机器人的转向方式。</p>
<h4><span id="221-environment-modeling">2.2.1. Environment Modeling</span></h4><p>表面移动机器人是在空间的某个区域内从一个位置移动到另一个位置。因此，有必要考虑运动模型将如何与该表面交互，以及路径规划器将如何处理。例如，有些算法需要构建一个图形，以某种方式代表机器人移动的环境。&#x3D;&#x3D;图搜索算法（属于 C 空间搜索范畴）大多属于这种情况&#x3D;&#x3D;。蚁群优化算法（ACO）等进化算法也可以使用图形。这种资产可以表示影响机器人导航的地形特征在场景中的空间排列方式。特别是，本文假定有关图形是建立在度量图的基础上，同时也承认本文讨论范围之外存在其他类型的地图，如拓扑图和语义图[22]。根据 Souissi 等人的研究[7]，有多种构建图的方法，如图 2 所示。Nash 和 Koenig [11] 的研究也对这种分类方法有所启发。他们对单元分解和路线图进行了区分。第一种方法是将曲面分割成单元格。这些单元格可以使用规则网格[3,4,7,11]或不规则网格[7,11]进行排列。图 2a-c 展示了如何使用正方形、三角形和六边形三种多边形中的一种来构建规则网格。它的主要优点是每个节点的索引简单，可以快速访问其中任何一个节点，并以优化的方式将其存储在内存中[23]。&#x3D;&#x3D;不规则网格（如图 2d 所示）可以使网格更好地适应不同分辨率值的地形特征，但代价是可能获得较差的路径[24]。&#x3D;&#x3D;单元格分解的其他形式还有导航网格和基于圆的航点图，如 Nash 和 Koenig 所解释的那样[11]。如前所述，环境的另一种表示形式是使用路线图。路线图是由边连接的节点构成的图形。每个节点代表机器人的一种可能状态，而每条边则表示如何从另一种状态到达该状态。路线图的例子包括&#x3D;&#x3D;沃罗诺图[25]&#x3D;&#x3D;（见图 2e）、&#x3D;&#x3D;可视图[26]&#x3D;&#x3D;和&#x3D;&#x3D;状态网格图（见图 2f）&#x3D;&#x3D;。后者包括根据运动基元制作边，因此在机器人移动限制条件下，所产生的路径确保是可行的，尤其是在使用图搜索算法时，如 Likhachev 和 Ferguson [27] 以及 Bergman 等人 [28] 的研究。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011015051.png" alt="image-20240201101538891"></p>
<p>图 2. 不同类型的环境单元分解图（a-d）和路线图（e-f）。(a) 正方形网格。(b) 使用三角形的棋格图。(c) 使用六边形的网格。(d) 不规则网格。(e) Voronoi 路线图。(f) 状态网格图。</p>
<p>这些图中的单元或节点可以静态或动态元素的形式存储其所在位置的地表信息[10]。例如，这可以是高程信息。数字高程图（DEM）是一个网格，其中每个节点都有一个相关的高程值。高程图也可以用多边形表示，&#x3D;&#x3D;但常规网格图更受欢迎[29]&#x3D;&#x3D;。与形状相关的特征，&#x3D;&#x3D;如坡度或表面粗糙度，可通过卷积矩阵提取 [30]。&#x3D;&#x3D;核的大小和 DEM 的分辨率将决定提取的特征类型。此外，这种分辨率还决定了地图中所包含要素的详细程度。如图 2d 所示，这种分辨率可以是非均匀的，也可以是多重的。网格的大小可以根据规划的规模来选择： 在覆盖机器人周围环境的情况下（或多或少是机载传感器可触及的距离），网格的大小为本地网格；而在覆盖范围大于本地网格的情况下，网格的大小为全球网格，通常使用卫星或无人机等外部来源的信息。</p>
<p>关于如何定义规划器工作区的成本，有不同的方法。首先，&#x3D;&#x3D;我们将成本理解为机器人在移动过程中累积的度量。路径规划器的目标是通过生成最优路径，最大限度地减少这种累积。&#x3D;&#x3D;有关成本可以是统一的，即机器人可以进入的区域始终具有相同的值。这种方法可用于避免碰撞的路径规划，在这种规划中，诸如二维平面上的路径长度等指标都会被最小化。&#x3D;&#x3D;非均匀成本地图可用于为不同的可访问区域分配不同的成本值。例如，这对确定机器人在每个位置的能量性能非常有用。&#x3D;&#x3D;此外，成本还可以根据方向向量来定义。这意味着，机器人将根据其航向具有不同的成本值。在这种情况下，&#x3D;&#x3D;成本被归类为各向异性[31]&#x3D;&#x3D;，而在相反的情况下，成本则是各向同性的。此外，机器人的转向动作也会根据其运动情况产生不同的成本值。最后，值得注意的是，环境可以是完全已知的，也可以是部分已知的，甚至是完全未知的。</p>
<h4><span id="222-robotsurface-interaction-modeling">2.2.2. Robot–Surface Interaction Modeling</span></h4><p>地面移动机器人与脚下的地表相互作用，推动自身前进。为了实现这一功能，有许多不同的运动执行器，例如轮子、履带、腿，甚至全向轮。图 3 展示了三个使用不同配置执行器的地面移动机器人的实际例子。这些致动器以及将它们连接到机器人本体的关节决定了机器人的运动结构和动态行为。换句话说，它们决定了机器人的运动配置。Zhang 等人[20]总结了一些众所周知的不同配置的运动学和动力学模型： 差动驱动[32]（见图 3a 中的 Koguma 机器人[33]为例和图 4a 中的模型描述）、阿克曼转向[34]（见图 4b、d）、滑行转向[35]（见图 4c）和全向[36]。其中一些模型包含与路径规划相关的约束条件，如前阿克曼转向机器人的最小转弯半径[37]（见图 4b）或滑行转向机器人在转弯动作中的高能耗[38]。此外，还有一种称为 “蟹行 “的模式（见图 4e）。由于所有车轮的顶部都有转向关节，这种模式允许机器人朝不同的方向行驶 [39]。此外，某些运动学配置还允许机器人进行点转向操作，使其在不平移的情况下旋转。值得一提的是，有一些铰接式机器人能够重新配置自己，以获得某种好处，并执行多种类型的运动（图 3c 中的 SherpaTT 就是一个例子）。例如，带有履带的铰接式机器人可以在崎岖地形上行驶时主动控制其稳定性[40,41]。还有一些机器人使用脚轮配置来执行一种名为 “轮行”（Wheelwalking）的运动模式 [42,43]。这种模式旨在克服机器人可能被卡住的松软地形。与此类似，推拉式运动模仿毛毛虫的运动方式，以增加在此类地形中的牵引力[44-46]。承认这种重构能力的路径规划算法是这类机器人必须具备的，因为这些算法可以找到利用其高度适应性的路径。在全局规划方面，Rohmer 等人[47] 使用了一种名为 Dijkstra 的图搜索算法，首先生成一条路径，然后通过仿真工具评估哪种运动模式更适合驱动每个部件。我们，这篇综述文章的作者，提出了使用 PDE 求解方法，在规划时使用各向同性成本函数考虑多种运动模式 [48,49]。据作者所知，目前还没有很多局部规划方法可以解决具有多种运动模式的机器人的动力学约束问题。Reid 等人[50]提出使用基于采样的算法–快速行进树（FMT*）–来解决带轮腿的可重构混合机器人的运动规划问题。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011018540.png" alt="image-20240201101840941"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011019926.png" alt="image-20240201101902693"></p>
<p>机器人的运动适应性好坏取决于地形特征，这在前面已经简要提到过。这些特征可能与地形的形态（形状）或构成有关。其中之一就是地形的倾斜度或坡度[51]。坡度会影响机器人的滚动角和俯仰角，这对于保持机器人的稳定性非常重要 [41,52,53]。此外，坡度还会根据方向影响机器人的能量表现。这种对方向的依赖性是由于重力的影响，使机器人在爬坡、下坡、横向或斜向穿越斜坡时消耗不同的能量[29,54-57]。另一个相关的地形特征是粗糙度。这是对法线矢量多样性的衡量 [58,59]，可能会影响机器人所经历的振动。根据机器人的底盘，它还可以克服其他地形。例如，机器人可以利用机身间隙（即机身下表面与地形表面之间的空间）克服岩石[60,61]。洞或沟等负面障碍物的存在可能会造成问题，因为它们很难被机器人的传感器捕捉到 [62]。至于地形的构成，它对机器人与地表交互的基本动态有影响。这种表面可能更坚硬，也可能更容易变形 [63]。这会影响机器人附着在表面上的方式，甚至限制其运动 [64]。一般来说，滑移是衡量机器人实际速度与指令速度之间差异的指标，通常通过计算两者之间的比率来实现 [65,66]。一些研究同时考虑了滑移和地形坡度，以便在穿越崎岖地形时对机器人进行更精确的估算 [67,68]。重力大小也会影响机器人与地形之间的动态交互 [30,69]。最后，路径规划器通常使用包含与形状和组成相关的多种地形特征的成本函数。例如，Ishigami 等人[2] 引入了动态移动指数，包括稳定性、滑移、经过时间和能耗。此外，与地形没有直接关系的其他因素也可能影响机器人的导航性能。其中之一就是太阳辐射 [66,70]，可将其建模为动态函数 [71]。Groves 等人[72]绘制了可能对机器人造成伤害的其他辐射类型，如在核拆除场景中。此外，风险概念对于防止机器人陷入危险境地也非常重要 [73]，例如，随着机器人靠近障碍物，成本也会增加 [74]。</p>
<p>图 4 轮式地面移动机器人的运动模型 轮式地面移动机器人使用的运动模型以及路径规划器： 差速驱动 (a)、前阿克曼 (b)、滑移转向 (c)、全阿克曼 (d)、抓取 (e) 和点转向 (f)。</p>
<h2><span id="3-reactive-computing-based-path-planning-algorithms">3. Reactive-Computing-Based Path Planning Algorithms</span></h2><p>这类算法包括路径规划算法，在这类算法中，环境（通常是一张区分障碍物和非障碍物区域的地图）只显示现有障碍物的位置和形状。&#x3D;&#x3D;反应式计算算法通常被用作局部路径规划算法&#x3D;&#x3D;（覆盖机器人周围环境并进行动态重新规划），因为它们有能力快速处理新信息（例如，以新发现障碍物的形式），这些信息通常来自有限的机载传感器。作为局部规划算法，&#x3D;&#x3D;这些算法通常会在遵循另一种算法制定的全局规划的同时，规划下一条直接路径或机动动作，以避开附近的障碍物。&#x3D;&#x3D;不过，&#x3D;&#x3D;这些算法可能会计算出局部最小路径，甚至导致机器人被卡住，因此必须特别小心。&#x3D;&#x3D;反应式计算算法有两个子类别： 反应式机动方法，即由障碍物的存在决定机器人的下一步行动；局部优化方法，即根据障碍物的存在修改现有路径。</p>
<h3><span id="31-reactive-manoeuvre">3.1. Reactive Manoeuvre</span></h3><p>本文介绍的算法依赖于定义机器人在每一时刻对障碍物的存在做出的反应。这种反应可以根据处理现有障碍物位置的公式来定义。不同表述方法的共同特点是产生反应所需的计算量较低，通常以转向或速度指令的形式出现。由于这种表述方式缺乏全局信息，因此这些技术通常被用作局部规划器。这种方法可以利用场来确定障碍物的位置，也可以通过检测障碍物边界来绕过障碍物，还可以在评估可用自由空间或移动障碍物的速度后发出速度指令。</p>
<p>&#x3D;&#x3D;势场法方法包括人工势场（APF）和矢量场直方图（VFH）算法。&#x3D;&#x3D;在人工势场算法中，机器人的运动可以来自障碍物等外部元素产生的虚拟力的总和。这样，机器人会离这些障碍物越来越远，并避免与它们发生碰撞，因为来自它们的力是排斥性的 [75]。目标位置产生的吸引力会使机器人朝目标位置前进。从图 5a 中可以看出这一点。Ge 和 Cui [76] 提出了 APF 在包含动态障碍物环境中的应用。不过，这种策略的主要缺点是容易导致机器人陷入局部最小点。因此，进一步研究工作的方向是克服这一问题。这正是 Vadakkepat 等人[77]研究的主要目标。他们将 APF 与遗传方法（进化算法）相结合，以克服这种情况。这一组合还被用于规划模拟六轮漫游车的运动[78]。另一个混合版本包括使用 PSO 算法 [79]。Triharminto 等人[80] 提出了一种非混合解决方案，即在漫游车周围添加一个斥势场。不过，该方案尚未在 U 形障碍物上进行过测试。其他研究通过在检测到机器人处于局部最小点时创建自定义逃逸路径来解决这一问题 [81]。此外，Bayat 等人[82] 提出了一种受静电势场启发的解决方案，即用所谓的标量势场来引导机器人，而不是使用虚拟力的总和。Borenstein 等人[83]提出的 VFH 可创建极直方图来评估机器人周围的障碍物密度，从而选择障碍物密度最低的转向角。几年后，VFH 又有了一些改进 [84,85]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011020319.png" alt="image-20240201102053094"></p>
<p>&#x3D;&#x3D;Bug 算法，即 Bug1 和 Bug2，可使机器人绕过途中发现的任何障碍物，直至到达目标[86]。&#x3D;&#x3D;它们的主要区别在于，Bug1 能让机器人绕过所有障碍物（见图 6a），而 Bug2 只能绕过部分障碍物 [19]。Bug1 和 Bug2 都不追求最优性，而是追求简单易用和计算量极少。它们可以用在只配备传感器的机器人上，这些传感器只能探测到机器人附近的障碍物。这样，这些机器人要么朝着目标行驶，要么沿着它们发现的障碍物的边界行驶。Buniyamin 等人[87] 和 Campbell 等人[19] 的研究提到了改进这种算法的一些变体，总体上减少了机器人的行驶距离。Xu 等人[88] 使用的 Bug 算法考虑了转弯半径限制，可生成平滑转弯的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011021497.png" alt="image-20240201102138305"></p>
<p>图 6. Bug 算法（a）和带气泡边界的弹性带（b）算法中使用的概念的图形表示。(a) 使用 Bug1 算法后的路径。(b) 经历拉伸后的路径。</p>
<p>以下方法主要是为机器人生成速度指令。速度障碍法考虑到智能体和任何其他移动障碍物的速度矢量，计算出一条安全轨迹[89,90]。这种计算方法会评估一个碰撞锥，如图 5b 所示。Chen 等人[91]将速度障碍与另一种称为快速行进方阵（FMS）的算法混合使用。Wilkie 等人[92]考虑了汽车的 Front-ackermann（见图 4b）运动模型。Chakravarthy 和 Ghose [93] 建议使用碰撞锥算法，该算法与速度障碍类似，但考虑到了任意形状的障碍。Qu 等人[94]介绍了该算法与汽车模型（如图 4b 所示，采用 Front-ackermann 配置）的结合使用。最后，动态窗口法（DWA）是一种在速度空间中搜索速度指令以遵循无碰撞圆形轨迹的算法，该轨迹由可接受速度值和时间窗口限定[95]。该方案可能不是全局最优方案，而是局部最优方案 [4]。DWA 甚至可用于高速航行的机器人 [96]。Feng 等人[97] 提出了一种改进版本，通过减少搜索速度空间来降低复杂性。其他方法将该算法用于能量最小化路径规划 [98,99]。虽然该算法通常被用作局部规划算法，但 Zhang 等人[5]提出将其作为全局路径规划算法在全球范围内使用。</p>
<h3><span id="32-local-optimization">3.2. Local Optimization</span></h3><p>&#x3D;&#x3D;这些算法通常从预先存在的路径出发，根据现有障碍对其进行修改。&#x3D;&#x3D;在这种情况下，优先考虑的是将计算量保持在最低水平，而不是牺牲最优性甚至完整性。修改路径有多种选择，从在速度空间内选择速度曲线，到在人造力作用下拉伸和拉长路径，不一而足。</p>
<p>在路径规划中使用弹性带是由 Quinlan 和 Khatib [100] 提出的。该方法根据障碍物的情况对现有的无碰撞路径进行变形，拉伸（见图 6b）或拉长。根据路径中的一组点，创建一组重叠的子区域，称为 “气泡”。这些 “气泡 “覆盖了无碰撞区域，其大小以与障碍物的距离为界。这就意味着，在路径中靠近障碍物的部分，气泡更小、数量更多。该方法可用于动态环境中，但较大的变化可能会导致方法失效 [100]。此外，该方法还通过遵守曲率约束 Khatib 等人[101]和使用贝塞尔曲线[102]适用于非自主车辆。弹力带的扩展包括时间约束，被命名为定时弹力带（TEB）。这一扩展版本解决了机器人的动力学约束 [103]。</p>
<h2><span id="4-soft-computing-based-path-planning-algorithms">4. Soft-Computing-Based Path Planning Algorithms</span></h2><p>&#x3D;&#x3D;这类算法的目的不是找到精确的最优解，而是近似最优解，并能容忍一定范围内的不精确。&#x3D;&#x3D;一般来说，这些算法需要用户调整某些参数，以便根据环境特征正常工作。这些算法甚至可以处理动态环境，适用于涉及大量变量和高自由度的问题[8]。不过，一般来说，它们需要大量的计算资源。本综述沿用 Mirjalili 和 Dong 提出的分类方法[104]，将其分为进化法、模糊控制法和机器学习法。第一种方法使用受生物学和自然界启发的技术：它们从一个由个体组成的系统开始，随着时间的推移而变化，即进化。模糊控制和机器学习方法属于人工智能的一个子类别。它们分别使用模糊规则和神经网络来生成控制器。这些控制器对于在最初的未知场景中导航非常有用，一般来说，它们会根据机器人探测到的障碍物生成路径。总之，软计算算法允许对一系列重复性元素（自然个体、模糊规则或人工神经元）进行调整，以生成路径。</p>
<h3><span id="41-evolutionary-computation">4.1. Evolutionary Computation</span></h3><p>&#x3D;&#x3D;进化算法也被称为元启发式或自然启发式 [105]&#x3D;&#x3D;。这些算法通过种群的进化产生一条路径。种群由智能个体组成，其行动仿照自然界中的行为[104]。这些行为可能涉及修改自身和&#x2F;或与其他个体交互。在某些情况下，这些操作意味着个体在环境的自由空间（即机器人可到达的空间）中进行运动。在执行一系列这些操作后，算法会逼近最优解。最终的路径和收敛所需的时间取决于分配给个体的行为策略、场景的性质以及用户分配给某些可配置参数的值。后者的一个例子就是填充路径规划问题的个体数量。进化算法包括遗传方法和蜂群优化器。第一种方法使用染色体模型，而第二种方法则以生物的行为为模型。</p>
<p>如前所述，遗传算法是以染色体为模型的个体[106]。这些个体包含基因，就像染色体一样，以二进制数字的形式存在。这些数字编码了一个解决方案，即在解决路径规划问题的特定情况下形成路径的一组航点。换句话说，群体中的每个染色体都代表一条路径。图 7a 展示了一个使用网格的例子。网格由单元格组成，每个单元格都标有一个数字。遗传算法从一组随机染色体开始。这组染色体通过三个过程进化： 繁殖、交叉和突变 [107]。复制通过复制最好的染色体来产生新的染色体。同时也会删除最差的染色体。交叉是染色体交换基因的过程。突变在基因中引入随机变化，以鼓励探索搜索空间并避免局部最小值。不断重复这些过程，算法就会收敛。Zhang 等人[4]提到，遗传算法在接近最优解时收敛速度会越来越慢。Han 等人[108] 使用遗传算法在有动态障碍物的环境中寻找最短路径。Tuncer 和 Yildirim [109] 对突变过程进行了修改。这包括检查即将发生突变的位置周围的空闲节点。这项工作将结果与之前的变异方法进行了比较。另一项研究工作使用了遗传算法以及高达 2000 × 2000 节点的大型网格[110]。用于路径规划的遗传算法也在一个实验平台上进行了测试[111]。更多的改进包括初始选择航点时，考虑那些位于障碍物附近的航点[112]。Elhoseny 等人[113]考虑到染色体的多样性，在突变过程中引入了更为规范的探索策略。此外，&#x3D;&#x3D;这项研究不仅优化了路径长度，还利用贝塞尔曲线保持了平滑度。&#x3D;&#x3D;最后，Lamini 等人的研究[114]还对交叉过程进行了改进，使解决方案收敛得更快，并减少了机器人转弯的次数。Patle 等人[10]的综述中介绍了许多基于遗传方法的路径规划应用。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011024879.png" alt="image-20240201102408753"></p>
<p>图 7. 进化算法示例： 遗传算法 (a) 和蜂群优化算法 ACO (b)。(a) 用于执行路径规划的遗传算法的功能。图中的路径为染色体形式，基因为 21-08-03-06。(b) ACO 算法的功能。模拟蚂蚁在最短路径上沉积更多的信息素。最终，大多数蚂蚁会沿着这条路径前进。</p>
<p>与基于遗传方法的算法不同，蜂群优化器使用在自由空间中移动和行动的智能体。在大多数情况下，这些个体是以动物为模型的。经过一系列迭代后，这些个体朝向目标的运动会形成一种模式，最终收敛到产生的路径上。表 2 介绍了文献中使用的一些模型。粒子群优化（PSO）算法因其简单性而脱颖而出。它的灵感来源于某些动物群体的行为，如鱼群[115]。它创建了一系列粒子，这些粒子会随着时间的推移自行重新定位，直到算法收敛。这些算法寻找最佳位置，并根据以往经验相互交流 [116]。Mac 等人[117]提出了一种路径规划器，将 PSO 与 Dijkstra 算法（下文将讨论的一种图搜索规划器）相结合。另一种著名的算法是蚁群优化器（ACO），顾名思义，它是模拟蚂蚁的行为。这些昆虫在寻找食物的过程中会留下信息素的痕迹。其他蚂蚁可以追踪到这些痕迹。那些含有较多信息素的地方就是最佳发现路径的航点。图 7b 描述了在起点和目标位置之间有障碍物的情况下的这一概念。在这里，最佳路径就是最短的路径。按照同样的策略，虚拟蚂蚁可以在网格上移动，根据它们与目标之间的状态留下更多或更少的信息素 [118,119]。为了避免陷入局部最小值，一些研究将这种方法与启发式函数相结合 [120,121]。Che 等人[122]也通过采用灰狼方法中使用的规则解决了这一问题。Luo 等人[123]对 ACO 做了一些改进，不仅避免了死锁，还缩短了收敛所需的时间。还利用 DEM 对该算法进行了模拟，以最小化时间[124]和能量[125]。Sangeetha 等人的研究[126]也在避开动态障碍物的同时实现了后者。这项研究将 ACO 与模糊控制相结合。受自然启发的方法还有很多。为避免过多扩展，表 2 列出了其中一些。此外，还有将两种模型相结合的情况。Saraswathi 等人提出的方法就是这种情况[127]，其中对 Cuckoo 算法和 Bat 算法的混合进行了测试。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011025329.png" alt="image-20240201102500187"></p>
<h3><span id="42-artificial-intelligence">4.2. Artificial Intelligence</span></h3><p>软计算算法可使用其他可配置运算符集，如模糊规则或神经网络。Seraji 和 Howard [140] 演示了在一个实验性移动平台上使用模糊逻辑在非结构化地形中导航。Zavlangas 和 Tzafestas [141]提供了一个基于模糊逻辑的系统，旨在使移动机器人在动态环境中自主导航，避开途中的障碍物。Wang 等人[142]的研究重点是防止机器人陷入局部最小点，如 U 形障碍物产生的最小点。Pandey 等人[143] 还提供了模糊逻辑避障的模拟测试结果。关于神经网络的使用，&#x3D;&#x3D;Yan 和 Li [144] 也在一个平台上使用了模糊逻辑，重点是尽量减少计算资源和穿越包含动态障碍物的环境。&#x3D;&#x3D;Pandey 和 Parhi [145] 将模糊逻辑与一种名为 “风驱动优化 “的群体算法相结合，对模糊规则进行了调整。关于神经网络的使用，Zou 等人[146] 在 2000 年代初简要介绍了这类算法的应用。Engedy 和 Horváth [147] 为必须避开静态和动态障碍物的移动机器人介绍了一种使用神经网络的路径规划器。Zhang 等人[148] 使用这种技术在迷宫场景中寻找最短路径。这种方法还与遗传算法结合使用 [149,150]。</p>
<p>文献中的其他作品则将模糊逻辑与神经网络相结合 [151-154]。这方面有不同的方法。例如，Mohanty 和 Parhi [155] 将许多此类系统用于自主导航。Mac 等人[8]对相关混合方法进行了更深入的了解和更广泛的调查。此外，人们还研究了如何利用强化学习（RL）来控制机器人的运动 [156,157]。Faust 等人[158] 将强化学习与概率路线图法 (PRM) 相结合，这也是接下来详细介绍的算法之一。有关基于 RL 的规划算法的更多信息，请参阅 Sun 等人的研究 [21]。</p>
<h2><span id="5-c-space-search-based-path-planning-algorithms">5. C-Space-Search-Based Path Planning Algorithms</span></h2><p>这类算法将路径规划器的工作空间视为机器人可到达的所有状态或配置的空间。因此，这类算法中的大多数作品都将这一工作空间称为 C 空间。这些算法背后的主要思想是使用属于 C 空间一部分的离散样本集。换句话说，C 空间是离散的。这组样本包括初始状态和目标状态，或至少是相对接近这两个状态的样本。这样，这些算法就会执行搜索操作，访问这组样本。在某一点上，算法会找到并返回连接初始状态和目标状态的某个样本子集，该子集代表所产生的路径。换句话说，构成路径的每个航点都与 C 空间中的一个样本相对应。这意味着生成的路径在很大程度上取决于这些样本的分布、连接和访问方式。事实上，由于这种依赖性，有些方法需要进行后处理，以平滑生成路径的形状。</p>
<p>根据 C 空间离散化的方式，C 空间搜索类别又分为两类算法。图搜索算法是通过预先存在的图（如图 2 所示）来实现离散化的。该图中的每个节点都代表一个 C 空间样本，并与附近的其他节点（即其邻居）相连。基于采样的算法侧重于在 C 空间内以迭代方式创建和&#x2F;或修改样本。即使在找到一条可行路径后，它们还能继续工作，找到更好的路径。</p>
<h3><span id="51-graph-search">5.1. Graph Search</span></h3><p>&#x3D;&#x3D;如前所述，C 空间可以以图的形式离散化。图搜索算法会全部或部分访问该图，直到找到连接初始状态和目标状态的路径。这类算法的第一种返回路径是将航点置于相邻样本之上。换句话说，路径上连续航点之间的连接与图边重合。&#x3D;&#x3D;图 8a 是一个示意图，显示了在第一种情况下，路径的形状是如何由这些边决定的。因此，本综述将生成此类路径的图形搜索算法归类为边缘受限算法。因此，这些路径取决于图的结构。正如第 2.2.1 节所述，有多种单元分解和路线图形式的图结构。另一种图搜索算法 “任意角度”（Any-angle）就是为了解决这个问题而创建的，它对图的边进行了限制。之所以使用这个名称，是因为限制边缘规划器生成的路径只能使用特定的方向值。例如，在八邻规则网格中，如图 8a 所示，限制边缘的路径只能有 0、±45、±90、±135 和 180 度的方向。任意角度算法生成的路径不受限于这些方向，因为它们的航点不一定要放置在相邻节点上。图 8b 展示了这方面的一个例子。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011027069.png" alt="image-20240201102701980"></p>
<p>图 8. 限边算法（a）和任意角度算法（b）生成的路径（红色）的主要区别：在第一种情况下，航点只能放置在连续（相邻）的节点上。</p>
<p>关于限边算法，图 9 展示了文献中&#x3D;&#x3D;最具代表性的限边算法示意图&#x3D;&#x3D;。最著名、最基本的限边路径规划算法是 Dijkstra 算法 [159]。该算法的第一步是选择一个节点，即起点或目标节点。此后，它开始向其邻居传播信息。这些信息可以是从起点出发所需的成本值，也可以是到达目标所需的成本值。算法会迭代访问已访问节点的邻居。关于成本的信息会不断传播，算法会为每个访问过的节点分配一个父节点。如果环境允许，即目标和起点之间没有障碍物，算法最终会同时访问这两个节点。此时，通过回溯父节点来检索路径。换句话说，路径从最后访问的节点开始，通过父节点返回。多年后，&#x3D;&#x3D;哈特等人[160] 实现了启发式版本 A<em>，&#x3D;&#x3D; 以加快计算速度。后来，又有了进一步的改进。D</em> 也被称为动态 A* ，是 A* 的增量版本，由 [161] 提出。增量版的意思是，每当分配给网格节点的成本发生变化时，该算法就会重复之前的计算。这就避免了算法从头开始执行全新的计算。例如，当机器人在行进过程中遇到新的障碍物时，这种计算量的减少允许快速重新规划。名为 Focussed D* 的改进版本进一步缩短了 D* 的计算时间[162]。Koenig 和 Likhachev [163] 提出使用终身规划 A* (LPA*) 作为 A* 的另一种直接增量扩展。他们以此为参考，开发出了更简单的 D* 版本，称为 D* -Lite [164,165]。Colas 等人[166] 在搜索和救援应用中的移动机器人上采用了这种算法。由于 A* 和 D* 算法，包括它们的版本，&#x3D;&#x3D;都使用了启发式函数，因此得出的路径可能是次优的。&#x3D;&#x3D;Likhachev 等人[167]提出了这些算法的随时版本，使用可配置的固定时间。在给定时间内找到的最佳路径由这些随时版本生成。多尔戈夫等人[168]提出了一种 A* 算法，即混合 A*，该算法在找到路径后通过重新排列节点，优先考虑所生成路径的可行性，以换取最优性和完整性的损失；从某种程度上说，该路径在运动学上是可行的。</p>
<p>关于任意角度算法，最早的算法之一是 Field-D* [169]。这是一种众所周知的算法，主要是因为美国国家航空航天局（NASA）的火星探测器自 Spirit 和 Opportunity 开始就采用了这种算法 [170]。与 D* 和 D* -lite 类似，它也是一种增量算法，因此会在后续执行中重复之前的计算。虽然 Field-D* 是克服路径受限于边的问题的杰出方法，但仍有改进的余地，可以找到更多最优路径。多年后，以 A* 为基础，更多的任意角算法被创造出来，它们都专注于在避开障碍物的同时寻找最短路径的问题。纳什等人[171]为此创造了 Theta* 。他们将其分为两个版本：一个是计算成本较低的 Base-Theta* ，另一个是成本较高但结果更接近全局最优最短路径的 Angle-Propagation Theta* 。Theta* 的主要前提是考虑障碍物拐角处的航向变化，与 Field-D* 相比，减少了路径上的航向变化 [172]。基础 Theta* 算法的增量版本后来被命名为增量 Phi* 算法 [173]。纳什等人[174]推出了更快的 Theta* 版本，即 Lazy-Theta<em>。Theta</em> 算法也得到了改进，能更好地处理非均匀代价图，即越接近障碍物，代价越高[175]。Šišlák 等人提出了加速 A* 算法[176]。它找到的路径比 Theta* 短，但速度较慢（尽管仍比 A* 快）。Yap 等人[177] 还引入了另一种名为 Block A* 的算法，并将其性能与 A* 和 Theta* 进行了比较。Nash 和 Koenig [11] 提供了另一项比较研究，其中包括加速 A<em>、Block A</em>、Field-D* 和 Theta* ，还包括后一种算法的变体。同一作者后来还将这种算法与可见性图的使用进行了比较[178]。Muñoz 和 R-Moreno [179] 建议使用 S-Theta* 算法生成平滑航向变化的路径。&#x3D;&#x3D;3DANA 用于生成高程图上的路径[180,181]&#x3D;&#x3D;。与 Theta* 和许多其他任意角算法相比，其他算法的结果有所改进，包括任意角子目标图 [182,183] 和 Anya [184,185]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011031915.png" alt="image-20240201103059674"></p>
<h3><span id="52-sampling-based">5.2. Sampling-Based</span></h3><p>基于采样的路径规划算法会按照不同的策略在 C 空间中创建一个又一个样本 [12,186]。之后，在满足特定条件或条件集（如达到时间限制）后，从创建的样本中检索路径。这种算法是渐进最优的。这意味着它们可以创建越来越多的样本，试图随着时间的推移找到更好的解决方案。一般来说，这些算法通常用于高维空间的搜索。然而，为了接近全局最优解，样本数量可能会相对较多 [14]，这就需要使用大量内存资源来存储所有样本。</p>
<p>如果只考虑两个点（起始位置或状态和目标），该算法就是单查询算法，而如果在同一环境下选择更多的点，该算法就被归类为多查询算法。关于单查询，最著名的算法之一是快速随机树（RRT）算法，它也是快速确定树（RDT）的一个特例[187]。该算法模拟了树的生长过程，即从一个起点开始，动态地创建样本，就像创建树枝一样。图 10a 描述了一个总结这一过程的方案。当其中一个样本与目标的距离超过一定距离时，就可以通过向后跟踪的方式找回路径，直至到达原点。如前所述，为了找到更好的路径，还可以执行更多的迭代。文献中可以找到对 RRT 的进一步修改。Kuffner 和 LaValle [188] 提出了一个双向版本，命名为 RRT-Connect。后来，Yershova 等人[189] 提出了 RRT 的改进版本，称为动态域 RRT，它能在树扩展过程中意识到环境中存在的障碍。Arslan 和 Tsiotras [190] 从图形搜索算法 LPA 中汲取灵感，提出了 RRT#，这是 RRT 的改进版本，收敛速度更快。Karaman 和 Frazzoli [186] 引入了一种名为启发式 RRT（RRT* ）的启发式 RRT 版本，以加快计算速度，同时仍能达到渐近最优。有关 RRT* 变体的广泛综述，请参阅 Noreen 等人的著作[14]。一种名为 “知情 RRT* “的改进版本在 RRT* 的基础上进行了改进，当找到一条可行路径时，将起点和目标位置围成一个椭圆[191]。接下来改进路径的迭代就在这个椭圆内进行，而不是让算法探索其他可能不会影响结果的选项。Gammell 等人[192]提出了另一种改进方法，称为批量有信息树（BIT<em>），并进行了比较，证明其性能优于 RRT</em>、有信息 RRT* 和 FMT<em>。BIT</em> 还借鉴了图搜索算法 LPA* 的一些步骤。区域加速批量有信息树（AIT<em>）在 BIT</em> 的基础上进行了改进，尤其是在存在狭窄走廊的情况下[193]。Adaptively Informed Trees (AIT* ) 和 Advanced Batch Informed Trees (ABIT* ) 算法在 BIT* 算法的基础上进行了改进，并被集成到 NASA 的一个实验性漫游车中 [194,195]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011032108.png" alt="image-20240201103211195"></p>
<p>关于基于采样的多重查询算法，最著名的是概率路线图法（Probabilistic Roadmap Method，PRM）[196]。这种算法从一系列已经分散在 C 空间中的样本开始。在此基础上，创建新样本，从每个初始样本创建一棵新树。图 10b 展示了这一过程背后的概念。之后，使用 A* 等图形搜索方法，利用 PRM 创建的图形检索路径。Karaman 和 Frazzoli [186] 提出了 PRM 的启发式版本。Park 等人[197]提出的改进方法采用了分层结构，减少了样本数量。Alenezi 等人[1]在模拟室内场景中对机器人进行了 PRM 测试。Ichter 等人[198] 提出了临界 PRM 算法，该算法将 PRM 与强化学习相结合，用于确定狭窄走廊等临界位置。</p>
<p>为了降低 RRT 和 PRM 的收敛速度，另一种基于采样的算法被命名为快速行进树（FMT* ）算法。它不仅借鉴了这两种算法的特点，还借鉴了一种名为 FMM 的优化控制算法，详情如下。FMT* 的主要目标是在涉及大量自由度的问题中找到避开障碍物的路径。Reid 等人[50]提出的铰接车辆运动规划就是一个例子。Ichter 等人[199]提出使用分组行进树（GMT<em>），这是一种与 FMT</em> 相似的算法，但其重点是通过 GPU 的并行化来加快计算速度。最后值得一提的是，有一些路径规划算法将动态采样方法与模型预测控制（MPC）技术相结合，以考虑动力学约束[57,200,201]。</p>
<h2><span id="6-optimal-control-based-path-planning-algorithms">6. Optimal-Control-Based Path Planning Algorithms</span></h2><p>基于控制方法的算法的基本原理是创建一个控制函数，将机器人从 C 空间的初始状态带向目的地。顾名思义，这里使用的是最优控制方法来解决路径规划问题[202]。与软计算方法的主要区别在于没有可配置的参数；这里的问题必须是完全封闭的。这里有两个不同的子类别。第一类是 PDE 求解，算法基于动态编程原理 (DPP)，在网格上求解偏微分方程 (PDE)[203]。第二个子类别，即数值优化，包括根据机器人的动力限制优化已有路径，使其可行的算法。</p>
<h3><span id="61-pde-solving-based">6.1. PDE-Solving-Based</span></h3><p>这里的优化控制方法基于动态编程原理，通过使用网格解决汉密尔顿-雅各比-贝尔曼方程 [204]。由于这是一个偏导数方程 (PDE)，这一子类被命名为 PDE 求解。它可以看作是计算波在网格上传播问题的数值解。波到达时间的值分配给每个网格节点。波的传播方式将取决于 HJB 方程的表达方式，包括代价函数。这种算法的主要缺点是通常无法处理不连续形式的约束。</p>
<p>HJB 方程的一个特殊情况是 Eikonal 方程。它不仅是静态的，而且还考虑了成本函数，只根据地图上的位置返回一个标量值。这意味着波在节点上的传播速度仅取决于分配的标量值。这样一来，特征方向就与总成本函数的梯度相吻合，因此只需使用梯度下降法就能检索出路径。多年来，人们提出了一整套方法，以较低的计算要求计算这一问题公式的解，因此这些方法被命名为快速方法 [18]。其中最著名的是由 Sethian [205] 提出的快速行进法 (FMM)。该算法采用与 Dijkstra 相同的策略访问网格节点。与 Dijkstra 不同的是，FMM 通过求解 Eikonal 算法为每个节点分配成本值。这样得到的路径是平滑、连续和最优的。Chiang 等人[206]将该算法与 A* 进行了比较，结果表明，由于路径不受网格限制，FMM 得到的路径更短。目前有许多使用 FMM 进行路径规划的研究 [207-210]。Gómez 等人[18]在综述中介绍了 FMM 的一些变体，其中大部分都降低了 FMM 的计算能力要求，同时还介绍了其他 Eikonal 求解器。它们是二进制 FMM、斐波纳契 FMM、简化 FMM 和不整齐 FMM。Eikonal 使用的成本值决定了计算波的传播速度。Petres 等人[24] 证明了这些成本值的梯度如何影响所产生路径的曲率半径。他们的研究还引入了启发式快速行进 (FM* ) 的理念，并将其与其他图搜索算法进行了比较。为了顺利避开障碍物，快速行进方阵（FMS）[74] 计算两次 FMM，首先在障碍物周围形成一个排斥场。图 11a 描述了由于障碍物附近的成本值较高（颜色较深），路径如何平稳地远离障碍物。Liu 和 Bucknall [211] 使用 FMS 以及对初始位置周围的成本进行修改，以考虑车辆的初始方向。研究人员还致力于提出 FMM 的增量版本，如 E* [212-214]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011034842.png" alt="image-20240201103456553"></p>
<p>要处理汉密尔顿-雅各比-0 贝尔曼（HJB）方程更一般的表达式，必须使用其他类型的方法。如果使用与方向相关（各向异性）的代价，FMM 会产生次优结果[215]。这种代价意味着，相对于节点的矢量代价而言，波的传播方向不同。在某些特殊情况下，FMM 可以在一定程度的各向异性条件下得出准确的结果，例如，成本函数的计算方式使其主要在与参考轴平行的方向上变化[24,216]。图 11b 描述的就是这种情况。Sethian 和 Vladimirsky [215] 建议使用一种名为有序上风法 (OUM) 的算法来处理静态 HJB 方程，Shum 等人[217] 证实了该算法的收敛速度。其主要缺点是计算成本的增加与场景中存在的各向异性成正比。Shum 等人[31]使用 HJB 进行各向异性路径规划，考虑了能量最小化和稳定性，并考虑了斜坡的方向和幅度。快速扫描法（FSM）也被证明适用于一般的静态 HJB 方程 [218]。它的工作原理是访问网格上的所有节点，沿着特定方向反复进行，这意味着它需要大量的迭代。Takei 和 Tsai [37] 使用 FSM 拟定 HJB 方程，以符合转弯半径约束条件。对于 Eikonal 情况，Bak 等人[219]对 FSM 进行了改进，以在成本变化过大时加快计算速度，Detrixhe 等人[220]则推出了并行版本。Jeong 和 Whitaker [221] 提出了一种名为快速迭代法 (FIM) 的算法，同样可以在并行架构上求解 Eikonal 方程。</p>
<h3><span id="62-global-optimization">6.2. Global Optimization</span></h3><p>该子类包含优化现有初步可行路径的路径规划算法。与第 3.1 节中介绍的局部优化方法不同，&#x3D;&#x3D;全局优化方法是以投入更多计算负荷来换取路径的全局最优。&#x3D;&#x3D;例如，Ratliff 等人[222]提出的方法首先使用基于采样的方法，如 RRT 或 PRM。第二步是使用梯度优化技术，从这条可行路径中逼近最优解。Van Den Berg 等人[223]也是从使用 RRT 计算出的轨迹开始，&#x3D;&#x3D;随后将 jt 应用于基于差分动态编程（DP）的优化过程&#x3D;&#x3D;。Plonski 等人[70]考虑到机器人会收获太阳能，因此使用 DP 计算了太阳地图中动态变化的路径。Ajanovi ́ c 等人 [224] 将 DP 与模型预测控制 (MPC) 相结合，计算出能量最小的路径。其他技术包括砰砰方法 [225] 和混合整数线性规划 (MILP) [226]。最后，Kogan 和 Murray[227]提出了一种独特的方法，他们使用非线性优化来规划长度在 20 米至 70 米之间的时间最优路径。</p>
<h2><span id="7-summary-and-conclusions">7. Summary and Conclusions</span></h2><p>根据本文提出的分类系统（见图 1），表 3 总结了每个路径规划类别的主要特征。表 3 分析了这些算法是否需要一个初步的环境模型、是否具有确定性（即在相同的初始条件下总能提供相同的解决方案）、是否能处理动态环境并重新规划、是否是最优的以及是否完整（即如果可行，总能返回一条路径）。考虑到最终路径规划应用的范围，有些算法会比其他算法更适合。此外，规划器的覆盖范围和重新规划能力（即处理环境信息更新的能力）将决定一种算法更适合局部规划还是全局规划。局部规划通常需要快速的在线计算，在环境数据发生变化时需要这种反应行为来规划新的路径。全局规划甚至可以离线计算，目的是在有静态初始环境的情况下，生成长距离穿越的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011037997.png" alt="image-20240201103702845"></p>
<p>基于反应式计算的算法似乎很适合局部避障路径规划，因为这些算法易于实现且成本低廉。此外，对于不确定性较高的场景或使用传感能力非常有限的机器人时，反应式机动方法也是一个不错的选择。局部优化甚至可以考虑使用 TEB 的动力学约束，尽管它们不能确保完整性。必须特别注意这两个子类别，以避免陷入局部最小值。软计算算法使用多个可配置的运算符生成路径，这些运算符的灵感可以来自自然界，也可以基于模糊规则和&#x2F;或神经网络。它们适用于涉及大量变量的问题或难以建模的问题，例如高度动态的环境。在包含移动元素的情况下，在远距离（全局路径规划）情况下，使用进化法就足够了。最新的人工智能方法，包括 DL 和 RL 方法，还需要进一步研究才能得出可靠的结论，Sun 等人也指出了这一点[21]。基于模糊规则或神经网络的人工智能方法可用于快速局部规划，以替代反应式机动方法。C 空间搜索算法利用样本来表示机器人的不同配置。这些样本可以事先以图形的形式提供，也可以动态创建。图形搜索算法适用于全局路径规划，考虑到了高级图形（如可见度图或空间网格图），但需要投入时间来构建这些图形（这在离线规划中是允许的）。不过，这种算法在处理高维度问题时扩展性较差，因此需要使用基于采样的算法。事实证明，基于采样的算法也适用于此类操作和高维度问题。优化控制算法在获得全局最优结果方面表现突出。基于各向同性成本函数或各向异性成本函数的 PDE 求解算法在很大程度上依赖于所配制的 PDE，并且可以使用网格形式的地图模型。全局优化算法必须从已定义的路径开始，并根据机器人的运动限制进行调整。在不确定性较低的静态情况下，PDE 求解算法可提供最优路径，而无需重新规划，因此适合离线计算长距离穿越。最后，需要注意的是，所有这些规划算法都依赖于描述环境和机器人的可用信息。必须尽可能准确地模拟这些信息，才能改善路径规划器的结果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011043554.png" alt="image-20240201104312676"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011043220.png" alt="image-20240201104327334"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-30T00:43:22.000Z" title="2024/1/30 08:43:22">2024-01-30</time>发表</span><span class="level-item"><time dateTime="2024-02-01T02:57:44.844Z" title="2024/2/1 10:57:44">2024-02-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">43 分钟读完 (大约6455个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/30/Autonomous-land-vehicle-path-planning-algorithm-based-on-improved-heuristic-function-of-A-Star/">Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star</a></p><div class="content"><h1><span id="autonomous-land-vehicle-path-planning-algorithm-based-on-improved-heuristic-function-of-a-star">Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300902671.png" alt="image-20240130090211867"></p>
<h2><span id="abstract">Abstract</span></h2><p>自主陆地车辆的路径规划已成为近年来的研究热点。本文提出了一种新型的自主陆地车辆路径规划算法。根据自主陆地车自主运动的特点，设计了一种改进的 A-Star 路径规划算法。使用 A-Star 算法进行路径规划的缺点是，A-Star 算法规划的路径包含许多不必要的转弯点，不够平滑。自主陆地车辆需要在每个转弯点调整姿态，这将大大浪费时间，也不利于自主陆地车辆的运动控制。针对这些不足，本文提出了一种新的启发式函数，结合人工势场方法，其中包含距离信息和障碍物信息。我们提出的算法在提高执行效率和减少转弯点数量方面表现出色。仿真结果表明，与传统的 A-Star 算法相比，所提出的算法能使路径更加平滑，使自主陆地车辆更易于控制。</p>
<h2><span id="introduction">Introduction</span></h2><p>近年来，陆地自动驾驶汽车（ALV）被广泛应用于应急救援、港口货运、物流配送等领域。1 路径规划在自动驾驶汽车领域占据核心地位，路径规划算法的效率直接影响自动驾驶汽车的寻路效率，而规划能力的实现决定了自动驾驶汽车能否高效、安全地完成任务。例如，在自动驾驶中不同车辆之间充分共享环境信息，不仅有利于实现更充分的路径规划，还能确保更高的安全等级。近几十年来，人们提出了许多路径规划算法，如 Floyd 算法、 Dijkstra 算法、 A-Star 算法、 蚁群算法、 粒子群算法 和人工势场等。</p>
<p>由于搜索速度快的特点，A-Star 算法已被广泛应用于解决静态路网的最短路径问题。A-Star 算法源于 Dijkstra 算法，引入了启发式函数以实现快速的节点搜索速度。然而，A-Star 算法的启发式函数只考虑了距离信息，导致寻路过程中出现多余的扩展节点。鉴于 A-Star 算法的不足，大量学者提出了相应的改进算法。洪斌等人提出了一种将改进的 A-Star 算法和动态窗口法相结合的混合算法，在复杂动态环境下具有良好的性能。Chen 等人将估值函数定义为指数衰减法，以减少冗余扩展。Wang 等人提出了一种基于网格映射的高效全区域覆盖路径规划算法。Zhang 等人考虑了无人艇的实际应用场景，通过增加角损耗项改进了评估函数，使最终路径具有最小的角，减少了路径上的损耗。Wu 等人通过建立禁忌表改进了 A-Star 的评价函数，从而快速有效地实现路径规划。Lin 等人通过引入父节点的影响来改进 A-Star 的实时性，但在对评价函数进行加权时没有考虑权重值的影响。</p>
<p>然而，上述算法在路径规划过程中只考虑了障碍物在全局地图中的位置，而没有考虑ALV周围的障碍物数量和距离，对地图信息的利用不够充分。针对 A-Star 算法路径不平滑的问题，我们提出了一种新的启发式函数，结合人工势场优化路径，提高搜索效率。在计算启发式项目时，我们的方法不仅考虑了当前位置到目标位置的距离，还考虑了当前位置周围的障碍物信息。仿真实验表明，我们的算法比 A-Star 算法性能更好。在网格地图环境下，比较 A-Star 算法和本文提出的算法，结果验证了我们的方法更有利于运动控制，规划的路径更平滑。</p>
<h2><span id="establishment-of-environment-model-for-alv-path-planning">Establishment of environment model for ALV path planning</span></h2><p>对于路径规划而言，环境建模是至关重要的一步。根据建立的环境模型，真实的环境场景被转换成机器人可以处理的抽象场景，方便机器人进行路径规划。常见的地图表示方法包括拓扑建模法、轮廓地图法和网格地图法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300908036.png" alt="image-20240130090834038"></p>
<p>我们使用网格图法建立网格图，记录 ALV 的障碍物网格和路径信息。我们定义网格的属性，存储轨迹的父节点和网格是否为障碍物等信息，并使用矩阵将每个节点的信息映射到网格图中。然后对网格图进行二值化处理，将 0 定义为可通过的网格，1 定义为障碍物网格，从而得到二值化后的网格图。图 1 显示了网格图的一个示例。黑色网格代表障碍物，白色网格为可通过区域。在栅格化模型的环境地图中，地图被划分为多个紧密相连的小网格，每个网格代表地图的一个节点。地图中的每个节点只与相邻的八个节点构成一条路径。因此，在网格地图中，ALV 的移动方向一般只有 8 个，即网格地图中 8 个相邻节点的方向。</p>
<h2><span id="background">Background</span></h2><h3><span id="a-star-algorithm">A-Star algorithm</span></h3><p>A-Star 算法由 Hart 等人提出(Hart PE, Nilsson NJ, and Raphael B. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans Syst Sci Cybern 1968; 4(2): 100–107.)，现已广泛应用于最短路径问题领域。作为一种典型的启发式搜索算法，A-Star 算法通过启发式搜索对节点进行评估，提高了节点搜索的效率，具有更好的性能和精度。启发式搜索使用估值函数，估值函数表示如下 其中，$f(n)$ 表示从起始位置经过当前位置 n 到目标位置的估计总成本, $g(n)$表示从起始位置到当前位置的实际路径成本，$h(n)$ 表示从位置 n 到目标位置的估计成本。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300910261.png" alt="image-20240130091029260"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300910156.png" alt="image-20240130091049003"></p>
<h3><span id="artificial-potential-field">Artificial potential field</span></h3><p>Khatib 于 1986 年提出了人工势场法。人工势场法以目标位置为中心构建引力势场。引力势场的值随着自动驾驶汽车与目标之间距离的增加而增加，方向是从自动驾驶汽车到目标。吸引力势场函数的数学表达式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300912895.png" alt="image-20240130091203978"></p>
<p>$f_a(x, y)$ 是吸引力势场函数，$\epsilon$ 是比例因子。</p>
<p>以 ALV 的当前位置为中心，构建一个排斥力场，该力场随着障碍物与 ALV 之间距离的增加而减小，方向是从障碍物到 ALV。排斥力场函数的数学表达式如下：	</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300913059.png" alt="image-20240130091311957"></p>
<p>其中，$\rho(x, y) $为当前点$(x, y)$到障碍物的距离，$d_0$为距离阈值。当当前点到最近障碍物的距离大于 $d_0$ 时，不会产生排斥力。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300915511.png" alt="image-20240130091529455"></p>
<p>这两个势场共同构成一个抽象的人工势场。人工势场法的势场力计算如图 3 所示 在人工势场中，对于空间中的某一点，ALV 将受到一个具有一定大小和方向的力的作用。人工势场法将 ALV 的运动抽象为受该虚拟力拖动的运动。</p>
<h2><span id="method">Method</span></h2><p>在应用场景中，ALV 首先在环境地图中规划路径，然后沿着路径前进。然而，在使用传统的 A-Star 算法进行路径规划时，规划的路径包含太多的转折点，路径不够平滑。因此，在路径跟踪过程中，ALV 需要进行许多不必要的姿态调整，以调整 ALV 的移动方向。当车辆沿着蜿蜒曲折的路径行驶时，会减慢 ALV 的速度，而且过多的姿态调整很容易破坏 ALV 的平衡。为了解决上述问题，本文结合人工势场方法的思想对 A-Star 算法进行了改进，并提出了一种新的启发式函数构造方法。在我们的方法中，周围障碍物和目标点对 ALV 的影响也包含在估算成本中。新的估值函数表达如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300916932.png" alt="image-20240130091631698"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300917496.png" alt="image-20240130091701261"></p>
<p>其中，$f(n)$表示从起始位置到当前位置再到终点位置的总估计成本，$g(n)$ 表示从起始位置到当前位置的路径移动成本[22]，我们使用 $h(n)&#x3D;h’(n)+v(n)$ 作为改进的启发式函数，$h’(n)$ 表示传统 A-Star 中的距离成本，$v(n)$ 表示潜在场地成本，包含周围障碍物的信息。</p>
<h3><span id="improved-distance-heuristics-hn">Improved distance heuristics $h’(n)$</span></h3><p>启发式函数的启发项 $h’(n)$ 对算法的计算效率有重要影响。它在总估计成本中的权重与 A-Star 的搜索速度呈正相关。启发式函数具有信息性。所谓启发式函数的信息量是指评估节点时的约束条件。信息量越大（即约束条件越多），被排除的节点就越多。</p>
<p>对于启发式项$h’(n)$的选择，有如下结论，其中$H(n)$为节点n到目标的实际路径长度。如果$h’(n)&lt;H(n)$，算法可以找到最优路径，但搜索节点较多，搜索效率很低；如果 $h’(n) &#x3D; H(n)$，这是最理想的情况，算法可以以最高的效率搜索到最优路径；而如果 $h’(n)&gt; H(N)$，此时算法虽然搜索速度较快，但很难得到最优路径：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300921857.png" alt="image-20240130092118946"></p>
<p>如果能找到更接近实际损失的启发式函数，就能提高搜索效率。A-Star 算法估计路径代价的函数一般取曼哈顿距离，此外还有欧氏距离和对角线距离。</p>
<p>假设矩形坐标中有两点 P 和 Q，P 点坐标为 $(X_{P}, Y_{P})$，Q 点坐标为 $(X_{Q}, Y_{Q})$，则 P 和 Q 之间的曼哈顿距离可表示为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300922205.png" alt="image-20240130092257451"></p>
<p>考虑到正方形网格地图有八个移动方向，存在对角线移动，对角线距离更接近实际路径代价。为了简单验证这三种距离选择方法对 A-Star 算法的影响，我们通过实验仿真比较了不同距离选择方法下 A-Star 算法的搜索速度和搜索网格节点数。我们在大小为 40x40 的网格图上进行了验证实验，结果如图 4 和表 1 所示</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300936449.png" alt="image-20240130093643452"></p>
<p>实验结果表明，由于使用曼哈顿距离法计算出的估计成本大于实际路径中的成本，因此搜索时间最快，搜索网格数最少。但搜索范围最小，未能搜索到最短路径，这样规划的路径长度最长。用欧氏距离法计算的估计成本小于实际路径中的成本，所以网格节点数是三者中最大的；可以搜索到最短路径，但搜索时间是最长的。对角线距离更接近实际长度。因此，如实验所示，与曼哈顿距离和欧氏距离相比，使用对角线距离搜索的网格节点数量适中。</p>
<p>对角距离可以找到最短路径，而运行时间适中。因此，我们使用对角距离作为距离启发式 $h’(n)$。$h’(n)$的计算公式如下：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300938223.png" alt="image-20240130093829304"></p>
<p>其中，$x_n$表示当前位置 n 的横座标，$y_n$ 表示当前位置 n 的纵座标，$x_e$ 表示目标的横座标，$y_e$ 表示目标的纵座标。</p>
<h3><span id="obstacle-heuristics-vn">Obstacle heuristics $v(n)$</span></h3><p>根据人工势场法的原理，障碍物会产生排斥力，排斥力随障碍物与节点之间距离的增加而减小，而目标位置会产生吸引力，吸引力与节点到目标的距离成正比。本文将环境图构建为网格图，每个网格的位置用坐标表示。因此，势场力的计算方法与人工势场方法不同。</p>
<p>在栅格化地图环境中，斥力的计算公式如下，方向是从障碍物 i 到节点 k:</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300940340.png" alt="image-20240130094057381"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300941259.png" alt="image-20240130094124214"></p>
<p>其中，k 表示当前位置，坐标为$(x_k, y_k)$；i 表示包含障碍物的第 i 个网格，坐标为$(x_i, y_i)$；n ~r 表示从障碍物 i 到节点 k 的矢量；e ~x 和 e ~y 分别表示 X 轴方向和 Y 轴方向的单位矢量。考虑到只有靠近 ALV 的障碍物才会影响 ALV 的工作，为了减少计算量，本文限制了障碍物的范围。其中，$\rho(x_i, y_i)$是当前节点 k 到第 i 个障碍物的距离，$d_0$ 是距离阈值，本文中 $d_0 &#x3D; 10$。</p>
<p>吸引力大小的计算公式如公式 (11) 所示，方向是从节点 k 到目标点 d</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300943994.png" alt="image-20240130094353821"></p>
<p>其中，k 表示当前位置，坐标为 $(x_k, y_k)$；d 表示目标点，坐标为 $(x_d, y_d)$；$\vec{v_r}$表示从节点 k 到目标点 d 的矢量。</p>
<p>得出吸引力和排斥力后，可以计算吸引力和排斥力的合力，从而得出当前网格节点 k 所受的势场力。计算公式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300946721.png" alt="image-20240130094648606"></p>
<p>这里的 $\alpha$ 和 $\beta$ 分别代表吸引力和排斥力的权重。在本文中，$\alpha &#x3D; 5$，$\beta &#x3D; 4$。</p>
<p>在人工势场法中，局部最小值问题是不可避免的。当计算出的 $\vec{F}(k)$ 为 0 时，为了避免算法回到传统的 A-Star 算法，我们将在此时放弃斥力。此时 $\vec{F}(k)$ 的计算公式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300949949.png" alt="image-20240130094905025"></p>
<p>由于 A-Star 算法基于光栅化地图信息，因此在搜索节点时采用八邻搜索法，在搜索路径时只考虑八个方向的网格。上节计算的势场力是任意方向的。因此，在计算 $v(n)$ 时，我们将势场力投影到邻近节点的八个方向，即前、左前、左、左后、后、右后、右、前右。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300950453.png" alt="image-20240130095007335"></p>
<p>计算过程如下： 首先计算从点 k 到相邻节点 n 的单位向量，如下式所示</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300951059.png" alt="image-20240130095058973"></p>
<p>图 5 显示了当前位置 k 在扩展其相邻节点 n 时的计算示意图。首先计算障碍物 S1~S3 的排斥力$\vec{F}<em>{r}(k, S_i)$; SiÞ和目标位置 d 的吸引力 $\vec{F}</em>{a}(k)$，然后计算所有排斥力和吸引力的结果力 $\vec{F}(k)$。在计算当前位置 k 右侧节点 n 的 $\vec{v}(n)$时，首先计算方向矢量 $\vec{e_n}$，然后计算结果力在方向矢量上的投影，得到 $\vec{v}(n)$。根据这种方法，计算节点 k 相邻八个扩展节点（不包括障碍物节点）的  $\vec{v}(n_i)$。然后计算 $h’(n)$、$g(n)$ 和 $f(n)$，得到扩展节点的代价函数，并进行路径搜索。</p>
<p>算法步骤如下： </p>
<p>步骤 1：创建开放列表 O 和关闭列表 C，O 用于记录已生成但尚未访问的节点，C 用于记录已访问的节点；将起点添加到 O 中；</p>
<p>步骤 2：将 O 中代价 f 最小的节点 k 添加到 C 中，并检查该节点是否为目标节点，如果是目标节点，路径规划结束；否则，进入下一步；</p>
<p>步骤 3：扩展节点 k 的所有相邻节点。计算所有相邻节点 n 的 $v(n)$、$g(n)$、$h’(n)$ 和 $f(n)$。如果节点 $n$ 既不在 O 中，也不在 C 中，则将节点 n 添加到 O 中；如果节点 n 在 O 中，但计算出的 $f(n)$ 小于 O 中的旧值，则更新节点 n 在 O 中的 $f(n)$，然后根据 $f(n)$ 的值对 O 中的所有节点重新排序；如果节点 n 在 C 中，则跳过这一点。重复以上步骤，直到节点 k 的所有相邻节点都扩展完毕；</p>
<p>步骤 4：检查目标点是否在 C 中，O 是否为空。如果目标点在 C 中或 O 为空，则算法结束；否则，重复步骤 2~4。</p>
<h3><span id="path-smoothing">Path smoothing</span></h3><p>要获得平滑的路径，常用的方法包括样条函数和贝塞尔函数。B 样条曲线是贝塞尔曲线的扩展。B 样条曲线的多项式阶数可以与控制点的数量无关，而贝塞尔曲线的阶数与控制点密切相关。因此，我们使用四元 B-样条曲线来平滑规划路径。给定 n þ 1 个控制点，四次 B 样条曲线的方程如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300957746.png" alt="image-20240130095731591"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300957704.png" alt="image-20240130095746470"></p>
<h2><span id="experiment">Experiment</span></h2><p>本节设计了三组网格图进行实验验证，网格图中的每个网格代表 10 厘米 10 厘米的实际环境。仿真所用的计算机配置为 i7-6700HQ，16 GB 内存。</p>
<p>在第一张地图中，给定的起始位置坐标为(1, 1)，目标位置坐标为(20, 17)。原始规划路径如图 6（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 6(b) 显示的是平滑后的路径。表 2 列出了 A-Star 算法和我们提出的算法规划路径的比较。其中，算法消耗的时间是经过 30 次重复实验后得到的平均值。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300959256.png" alt="image-20240130095922174"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300959887.png" alt="image-20240130095938606"></p>
<p>如图 6 所示，A-Star 算法从靠近终点的一片障碍物之间穿过。改进后的 A-Star 算法避免穿越障碍物，而是选择从侧面绕行。计划路径中几乎没有不必要的转弯点。从表 2 中可以看出，路径长度都是 323.1 厘米，但 A-Star 算法规划的路径总共需要转弯 540 次，而我们提出的算法只需要转弯 315 次，大大降低了转弯成本。路径平滑后，A-Star 的路径缩短为 294.4 厘米，转弯角度减小到 219.09。我们的方法规划的路径缩短到 303.3 厘米，转弯角度减小到 140.86。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3.8 毫秒，而我们的算法耗时 5.2 毫秒。</p>
<p>在第二组实验中，我们选择了一个更为复杂的环境。ALV 需要多次绕过障碍物才能到达给定的目标点。给定的起始位置坐标为（24,17），目标位置坐标为（4,16）。</p>
<p>原计划路径如图 7(a) 所示。图 7(b) 显示了平滑后的路径。表 3 列出了 A-Star 与我们提出的算法规划路径的比较。</p>
<p>如图 7 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，两者规划的路径长度都是 906.7 厘米，但 A-Star 规划的路径总共需要转弯 1080 次，而我们提出的算法只需要转弯 540 次。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 99.6 毫秒，而我们的算法耗时 110.1 毫秒。</p>
<p>我们还对活性氧算法进行了实验。使用 Gmapping 方法创建网格地图，如图 8 所示，地图分辨率为 5 厘米&#x3D;像素，膨化安全距离设置为 15 厘米。我们使用基于阿克曼模型的四轮驱动汽车，尺寸为 20 厘米 18 厘米 13 厘米。给定的起始位置坐标为（3.6 米，2.15 米），目标位置坐标为（4 米，15 米）。</p>
<p>原始规划路径如图 8（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 8(b) 显示的是平滑后的路径。表 4 列出了 A-Star 算法和我们提出的算法规划路径的比较。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301007055.png" alt="image-20240130100757892"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301008717.png" alt="image-20240130100815423"></p>
<p>如图 8 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，我们规划的路径长度为 1558.9 厘米，但 A-Star 规划的路径总共需要转弯 1755 °，而我们提出的算法只需要转弯 495 次。经过路径平滑处理后，A-Star 的路径缩短为 1516.5 厘米，转弯角度减小到 687.46。我们的方法规划的路径缩短到 1534.9 厘米，转弯角度减小到 237.84。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3332.7 毫秒，而我们的算法耗时 6657.4 毫秒。随着地图复杂度的增加，所消耗的计算时间也在增加。如图 8 所示，A-Star 算法规划的路径有许多锯齿状的转折点。这使得路径不够平滑，不利于 ALV 的运动控制。由于 ALV 在每个拐点都要调整角度，这势必会降低速度，影响运行效率。</p>
<p>实验仿真结果表明，与传统的 A-Star 算法相比，我们的改进算法转弯损耗更低、路径更直。我们的算法规划的路径长度与 A-Star 算法相似。但是，与 A-Star 算法相比，总转弯角度减少了 4060%。不过，我们的算法更为复杂，计算时间也比 A-Star 算法长。特别是在障碍物较多的环境中，计算时间会明显增加，算法效率仍有待进一步提高。我们的算法减少了拐点，让 ALV 更容易调整姿态，实现 ALV 的自主移动。当 ALV 在运行过程中遇到转弯时，它会降低速度并调整角度，以确保安全运行。在这个过程中，ALV 的效率会降低，控制难度会增加，而且会消耗大量时间。我们的方法虽然增加了规划时间成本，但提高了运行效率，减少了 ALV 的运行时间和控制难度。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301009825.png" alt="image-20240130100951777"></p>
<h2><span id="conclusion">Conclusion</span></h2><p>本文提出了一种新的启发式功能设计方法，以改进广泛使用的 A-Star 算法。考虑了周围障碍物对小车运行的影响。在启发式函数中加入了人工势场力，加强了算法的搜索方向信息，从而提高了 A-Star 算法的性能。与传统的只考虑距离的启发式函数相比，我们的方法考虑了周围的障碍物信息，更适用于障碍物较多的环境；改进后的算法规划的路径更直，有效减少了不必要的拐点，使小车能尽可能少地调整角度，减少了路径损耗，更有利于小车的运动控制。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-10T16:53:51.000Z" title="2024/1/11 00:53:51">2024-01-11</time>发表</span><span class="level-item"><time dateTime="2024-01-16T13:49:43.746Z" title="2024/1/16 21:49:43">2024-01-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约10053个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/11/Classical-and-Heuristic-Approaches-for-Mobile-Robot-Path-Planning-A-Survey/">Classical and Heuristic Approaches for Mobile Robot Path Planning A Survey</a></p><div class="content"><h1><span id="classical-and-heuristic-approaches-for-mobile-robot-path-planning-a-survey">Classical and Heuristic Approaches for Mobile Robot Path Planning: A Survey</span></h1><p>作者：Jaafar Ahmed Abdulsaheb and Dheyaa Jasim Kadhim *</p>
<p>摘要： 机器人学最重要的研究领域是导航算法。机器人路径规划（RPP）是指在移动机器人移动前为其选择最佳路径的过程。寻找理想或接近理想的路径被称为 “路径规划优化”。其目标是找到满足单个或多个目标（如最短、最平滑和最安全的路径）的最佳解决方案值。本研究旨在概述移动机器人的导航策略，这些策略采用了三种经典方法，即 路线图方法（RM）、单元分解（CD）和人工势场（APF），以及十一种启发式方法，包括遗传算法（GA）、蚁群优化（ACO）、人工蜂群（ABC）和灰狼优化（GWO）、 蛙跳算法 (SFLA)、鲸鱼优化算法 (WOA)、细菌觅食优化 (BFO)、萤火虫算法 (FF)、布谷鸟搜索 (CS) 和蝙蝠算法 (BA)。本研究中介绍的不同文章涉及多个问题，包括动态目标、静态和动态环境、多机器人、实时模拟、运动学分析和混合算法。在本作品的最后将进行讨论，并提供详尽的表格和图表，以帮助读者了解开发了哪些类型的路径规划策略，可用于各种生态环境。因此，本作品的主要贡献在于，它为机器人路径规划提供了一个广阔的视角，这将为科学家们在不久的将来研究这一课题提供更多便利。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>机器人是一种能够对周围环境做出反应，并（通过传感器）收集环境信息，从而安全执行各类任务的机器。自主机器人可以在没有人类直接控制的情况下自行操作和移动。与制造工厂中使用的机器人不同，在制造工厂中，机器人所处的环境受到严格控制且完全已知，而自主机器人则不可能总是通过编程来执行预定义的动作，因为机器人不可能预测可能遇到的各种情况。此外，环境可能是不可预测的，也可能随着时间的推移而发生变化，这就意味着机器人的动作必须在线快速改变[1]。自主机器人的应用包括医院的快递员、保安、军事监控、航空航天研究、环境监测、清洁工和割草机。一般来说，最重要的应用之一是在危险领域（如雷区或核电站内部）使用自主移动机器人。由于移动机器人与生俱来的自主性，必须克服一系列挑战，包括不确定性、感知误差、规划、学习、可靠性和实时响应[2]。机器人需要动态响应变化并适应环境。</p>
<p>机器人路径规划学科的雏形可以追溯到 20 世纪 60 年代中期。机器人路径规划问题，通常称为机器人路径规划（RPP），是移动机器人导航领域的一个重要问题。&#x3D;&#x3D;其目标是确定在指定环境中，从预定位置出发，以目标目的地为终点，没有任何碰撞的最佳路径。&#x3D;&#x3D;一般来说，机器人有无数条路线可以到达目的地，但最佳路线实际上是根据一系列规则来选择的。最广泛使用的标准是距离最短、耗能最少或时间最短、距离最短。由于路径规划的目标是找到最短路径，同时牢记给定环境和无碰撞运动等约束条件，&#x3D;&#x3D;因此可以将其视为一个优化问题[3]&#x3D;&#x3D;。移动机器人的地图、定位和导航可以通过环境模型来实现。然而，这些模型中的数据量必须易于管理，并能满足实时计算的要求。机器人领域一个非常棘手的问题是机器人路径的规划。主要目标是在不撞到任何东西的情况下，找到一条从起点到终点的路线。&#x3D;&#x3D;在解决机器人导航问题时，必须考虑三个关键问题：效率、安全性和准确性。效率要求算法避免让机器人多走几步或反复停下来转弯，这样会浪费时间和精力，以便在最短的时间内确定最短的距离。安全性和准确性取决于找到一条不会撞到任何东西的路径，同时保持在该路径附近[4]。&#x3D;&#x3D;机器人导航问题可分为定位、路径规划、运动控制和认知映射，如图 1 所示。路径规划可能是机器人导航最重要的方面 [5]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401110955430.png" alt="image-20240111013711561"></p>
<p>根据其所在位置[6]，区域淘汰计划可分为两类：</p>
<p>(a) 在静态环境中遇到固定障碍物时的 RPP。<br>(b) 在动态环境中面对静止和移动障碍物时的 RPP。</p>
<p>这两类中的每一类又可细分为一个子群。&#x3D;&#x3D;全局路径规划&#x3D;&#x3D;，即环境中的机器人可以在开始移动之前（离线）规划好整体路径，因为它们掌握了静止障碍物的完整信息，而移动障碍物的轨迹也是事先已知的。由于设置新地图具有挑战性，因此全局导航中环境变化的成本非常高，尤其是在动态环境中。无法利用完整的环境知识规划本地路线是本地路径规划的一个局限。移动机器人在环境中移动时，会使用传感器收集信息（在线）。机器人必须反复移动到新的位置，感知周围环境，更新地图，规划下一步行动路线，从而绘制出周围环境的地图。局部路径规划面临着一系列挑战，包括传感器读数误差、传感器约束、多变的环境条件、机器人动力学、位置估计和机器人运动限制等[6]。在极其复杂和广阔的环境中，本地路径规划可能无法确定通往目标的路径。出现这种情况的主要原因是传感器无法提供足够的数据，将机器人送至理想位置[7]。机器人的基本位置、旋转以及整个链路的旋转或平移称为机器人的配置。所有可能配置的集合构成了配置空间或 c 空间，它需要几个元素：</p>
<ol>
<li><p>描述机器人的形状，如是否有腿、轮子或没有四肢（运动）。</p>
</li>
<li><p>解释机器人所处的环境，包括其几何形状（二维或三维工作空间）。</p>
</li>
<li><p>环境必须有一个起点和目标配置，必须在这两个配置之间规划机器人的路径。</p>
</li>
</ol>
<p>一些参数用于描述机器人的工作空间配置。例如，两个参数（通常称为 x 和 y）可用于描述机器人的配置，将其转换为二维工作空间。机器人工作区内的障碍物会阻止某些配置的使用。例如，配置为 C 的机器人如果与工作区的任何障碍物发生碰撞，就会被禁止使用。由此，配置空间 C 被划分为一组禁止配置 C forbited 和一组允许配置 C free。一般来说，路径被定义为一个连续函数 π : [ 0, L ] → C，以路径的长度 L 为参数。路径规划问题是在给定的起点配置 s∈C 和目标配置 g∈C 之间找到一条无（碰撞）路径。就配置空间 C 而言，通过找到一条路径 π，使 π ( 0 ) &#x3D; s 和 π ( L ) &#x3D; g，并且 ∀(t∈ [ 0, L ] :π ( t )∈C f ree ) [8]。绘制地图是构建环境模型的过程。为了绘制出足够精确的地图，显示机器人沿途所见，必须准确显示地形。有不同类型的地图可用于表示环境。其中一些使用栅格，栅格中的单元格要么是空的，机器人可以在其中自由行进，要么是被占满的，以表示障碍物，如图 2 所示。如图 3 所示，其他人使用二维（或三维）矩形或正方形工作空间，障碍物为多边形。</p>
<p>许多研究人员都提交了有关移动机器人导航的调查论文[9-11]；然而，这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在发现特定领域的研究空白和创新范围。它深入分析了静态环境中的单个算法、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合，以及在三维（3D）环境中的应用。</p>
<p>调查还强调了传统方法和反应式方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。在参考文献[9]中，该方法仅限于路径计算。[9]中，该方法仅限于三维路径规划，而参考文献 [10]综述了适用于各种机器人类型（包括空中、地面和水下机器人）的多机器人路径规划方法和决策策略。参考文献 [11 [11]主要研究了移动机器人路径规划的多目标优化算法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001404.png" alt="image-20240111100109345"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001670.png" alt="image-20240111100135547"></p>
<p>本综述编排如下： 第 2 节讨论机器人路径规划技术，第 3 节讨论移动机器人导航建模，第 4 节是讨论。</p>
<h2><span id="2-robot-path-planning-techniques">2. Robot Path Planning Techniques</span></h2><p>机器人的路径需要优化以满足某些标准，因此路径规划问题是一种优化问题。过去几十年来，优化算法的研究吸引了众多研究人员的关注。优化方法和算法分为确定性和随机性两类 (12]。&#x3D;&#x3D;随机方法更善于发现各种目标函数的全局最优解，而确定性方法则依赖于问题的数学属性。&#x3D;&#x3D;相反，随机方法并不依赖于特定函数的数学属性，如参考文献[13]所述。然而，最初的方法也存在一些局限性，包括依赖梯度、容易出现局部最优、在&#x3D;&#x3D;搜索大规模空间时效率低下&#x3D;&#x3D;，以及无法处理离散函数。基于随机过程的技术被认为具有更高的用户友好性。由于现实世界中许多优化问题的复杂性，特别是在优化无差别、多模态和离散复杂函数时，随机方法是必要的–这些算法已被发现优于基于梯度的经典方法。这些受自然启发的范式目前正被广泛应用于众多工程领域 [14]。这些技术已被证明是可靠而强大的搜索方法。</p>
<p>多年来，众多科学家和研究人员提出了各种导航方法。移动机器人的导航方法大致可分为两类：经典方法和启发式方法（图 4）。&#x3D;&#x3D;经典方法存在一些缺陷，导致其在实际应用中效果不佳，包括高维度下的高时间复杂性问题和陷入局部极小值的现象，这些都是该领域的重大问题。&#x3D;&#x3D;启发式方法优于传统方法，并因 PP 问题的 NP 难度而广受欢迎。启发式技术在解决涉及多维度、复杂工作空间和局部极小值的问题方面也取得了成功，因此越来越受欢迎[15]。在下面的研究小节中，我们将考察一组使用经典方法和启发式方法寻找最佳单目标或多目标路径规划的科研成果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160852835.png" alt="image-20240116085249597"></p>
<h2><span id="21-classical-approaches">2.1. Classical Approaches</span></h2><p>我们将在下文中讨论用于寻找最佳单目标或多目标路径的三种经典方法：</p>
<ol>
<li>路线图（可视图 [16]；沃罗诺图 [17]）： 如图 5 所示，路线图方法（RM）涉及将自由 C 空间重新制定、缩小或映射到一维工作空间。Salzman 研究了 RM 在自主移动机器人导航中的应用[18]。在规划阶段，机器人的配置空间是随机生成的，会产生特定数量的节点。然后，在确保路径不与任何障碍物相交的前提下，通过直线连接节点对来构建路线图。根据规划阶段获得的结果，查询阶段设计出一条连接初始配置和目标配置的路径。如参考文献[19]所述，对 Voronoi 图的有效路径规划进行了改进，以优化其性能并减少突然转向和扩展环路等问题。如参考文献[20]所述，通过采用一种混合方法，将可视图、沃罗诺伊图和势场技术相结合，确定最佳路径。学者们强调，这种方法无法确定最佳路径，在实施过程中也面临挑战。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160857115.png" alt="image-20240116085749819"></p>
<p>Yang 等人（21）采用骨架图和维诺图等技术，有效地制定了路线战略。Wein 等人[22]提出了一种新方法，它将可视图和维诺图整合在一起，以确定最佳路线。&#x3D;&#x3D;Kavraki 等人在他们的工作（23）中展示了概率在机器人运动中的应用，目的是理解和产生路径规划解决方案。然而，该方法在获得理想路径长度方面效果不佳。Sanchez 等人（24）利用概率路线图方法对概率路径规划稍作修改，改进了最短路径确定方法（PRM），提出了懒碰撞检查策略作为实际路径规划问题的解决方案。&#x3D;&#x3D;Yan 等人（25）成功测试了无人飞行器在三维环境中的导航能力。这种方法同时使用概率公式和路线图来确定飞行路径。一种在动态环境中避开障碍物的创新路径规划算法被称为 “时间-PRM”（26）。通过在原始概率路线图（PRM）中加入时间概念，该算法创建了一个可有效查询的增强结构。</p>
<p>Huang 等人在（27）中介绍了利用启发式机器人在线路径规划（HIRO）的方法，与传统方法相比，无论机器人是否事先了解环境，该方法都能显著加快发现无碰撞路径的速度。为了快速寻找路径，HIRO 同时采用了知情启发式和确定性路线图。概率路线图（PRM）因其简单易行而被广泛应用于移动机器人导航。&#x3D;&#x3D;当环境中存在狭窄通道时，概率路线图的效率就会大大降低。&#x3D;&#x3D;Zhang 等人 [28] 提出了一种改进的基于势场的概率路线图算法。在具有大量复杂约束和高维度的环境中，概率路线图（PRM）可以成功地解决路径规划问题。其缺点是在狭窄空间和动态环境中的路径规划质量和效率较差。最后，You 等人[29] 建议使用动态 PRM 混合势场来规划移动机器人在多维环境中的路径。</p>
<ol start="2">
<li>单元分解（Cell decomposition CD）[30]： 为了确定连接初始配置和目标配置的路径，无障碍配置空间被划分为一系列单元格。如图 6 所示，在开始单元和终止单元之间建立连接以及随后通过一系列中间单元建立连接决定了单元关系。Samet [31] 和 Noborio [32] 提出了利用四叉树进行分解的方法。大的栅格单元分割环境；然而，当一个栅格单元只填满一部分时，它就会被分解成四个相同大小的小部分，直到填满为止。该系统的缺陷在于，当有新信息（如障碍物的位置）出现时，它无法更新程序，因此在动态环境中效果不佳。&#x3D;&#x3D;Lingelbach [33] 证明了路径规划的高维静态配置问题是存在的&#x3D;&#x3D;。他为类似链条和迷宫的机器人平台找到了路径规划问题的解决方案。利用基于 CAD 的数据，Sleumer 等人[34]提出了一种移动机器人的路径规划策略。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161004274.png" alt="image-20240116100419776"></p>
<p>Cai 等人 [35]的研究表明，使用传感器的粗糙 cell decomposition 可以将复杂环境中的许多固定目标分成不同的组。在静态环境中，所开发的方法效果最佳，因为它能选择最短的路线并覆盖整个环境。Dugarjav 等人（36）利用基于传感器的 CD 模型仍然适用于处理移动机器人不熟悉的直线工作空间。他们利用 CD 策略和激光扫描机制绕过了不熟悉的位置和物体。&#x3D;&#x3D;Glavaski 等人[37]提出了一种混合方法，以解决路径规划问题中理论进展与实际考虑之间的差异。为了减少计算费用，他们开发了一种基于 APF 方法的精确 CD 路径规划器。&#x3D;&#x3D;Tunggal 等人 [38] 介绍了如何利用 CD 和模糊逻辑来实现不确定性环境中的实时运行。</p>
<p>Mark 等人[39]的论文旨在阐明贪婪深度优先搜索算法和利用遗传算法 (GA) 的 CD 技术的机理，目的是规划机械手系统的三维路径。Gonzalez 等人[40] 通过改变图权重、航点计算方法和 CD，对路径进行了定量分析。Wahyunggoro 等人[41]介绍了利用 CD 方法探索三维环境在空中导航问题上的应用。在该方法中，CD 方法和模糊逻辑一起用于引导和控制航空飞行器。[42] 与垂直（VCD）算法相比，径向 CD（RCD）算法能产生更短的路径。&#x3D;&#x3D;杂乱环境和走廊环境都能从 RCD 算法中受益。RCD 在路径长度和处理时间方面的有效性得到了仿真结果的支持。&#x3D;&#x3D;</p>
<ol start="3">
<li>人工势场（APF）： 如图 7 所示，本方法涉及一个配置空间，该空间由两种不同的力组成，一种是排斥力，其作用方式是将机器人从障碍物中驱逐出去；另一种是吸引力，其作用方式是将机器人引向所需的目标配置。Khatib (43) 是 1986 年将 APF 方法引入移动机器人导航的先驱。按照他的说法，目标和障碍物就像通电的表面，机器人受到由它们的势能总和产生的假想力的作用。这个假想力（如图 7 所示）将机器人推向所需的方向，使其不会冲向障碍物。在这里，机器人沿着负梯度绕过障碍物，到达理想位置。Garibotto 等人[44]介绍了这种方法在移动机器人导航中的应用。Kim 等人（45）讨论了一种利用 APF 在未开发环境中避开障碍物的新技术。为了绕过局部最小值的问题，他们使用了谐函数。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161017039.png" alt="image-20240116101702985"></p>
<p>Borenstein 等人[46] 提供了另一种解决局部最小条件问题的方法。他们在研究中考虑了机器人的动态导航特性。在参考文献[47,48]中，对动态避障背景下的 APF 进行了研究。通过利用静电定律，APF 方法在某些方面得到了改进[49]，利用静电可以产生势函数并即时确定无碰撞路径。在实时环境中，移动时避开障碍物是一项艰巨的任务；因此，Huang [50] 开发了一种控制速度的方法，以确定障碍物的位置和移动方式。&#x3D;&#x3D;Shi 等人[51] 提出的 “超强势能 “和 “超强排斥势能 “指的就是这两种功能，以防止局部最小值并达到全局最大值。&#x3D;&#x3D;Sfeir 等人[52]研究了移动机器人的导航问题，该问题可通过采用振荡和冲突等 APF 技术来解决。他们改变了 APF，使其在目标靠近障碍物时不易发生振荡和产生问题。</p>
<p>Pradhan 等人[53]使用 ROBOPATH 仿真工具测试了人工势场的适用性。人工势场法被认为是最流行的路径规划技术之一。为了解决无法到达目标的问题，文章[54]增强了斥力场函数。当它陷入陷阱时，它会选择一个虚拟目标点来帮助它解脱。文章[55]的主题是将人工势场方法应用于环境数据不可知的静态障碍物。通过 MATLAB 仿真证明，改进后的人工势场方法偶尔可以绕过局部极小值，顺利到达目的地。Shi 等人[56]涉及多智能体编队避障控制，研究了步长对路径规划的影响，并提出了两种使路径更高效的方法。&#x3D;&#x3D;知情快速探索随机树星（RRT*）算法会进行质量检查，并重新优化采样路径&#x3D;&#x3D;。Liu 等人提出了一种更有效的 APF 局部避障路径规划算法[57]。根据仿真结果，该算法提高了动态避障的稳定性，改进后的势场法得到的航向角变化减少了 84%。该算法可应用于车辆的实时避障。</p>
<p>随后，又有人尝试改进这些经典方法，如概率路线图（PRM）和快速探索随机树（RRT*）。此外，还出现了结合经典方法和启发式方法的混合方法，以利用两种技术的优势（模拟退火（SA）与人工势场（APF）[58]）。&#x3D;&#x3D;启发式方法旨在克服传统方法的局限性，如陷入局部最小值的问题。&#x3D;&#x3D;以下各小节列出了其中一些启发式方法：</p>
<h2><span id="22-heuristic-approaches">2.2. Heuristic Approaches</span></h2><p>我们将在下文中讨论十一种用于寻找最佳单目标或多目标路径的启发式方法：</p>
<ol>
<li>遗传算法（GA）： 这是一种著名的基于搜索的优化工具，秉承了 1958 年布雷默曼[59]对遗传学和自然选择的发现。1975 年，Holland [60] 首次将其引入计算机科学领域。机器人导航只是目前广泛应用的众多科技领域之一。机器人导航是科学和技术领域的一项普遍应用。该主题涉及复杂问题的优化，这些问题要求在遵守预先设定的约束条件的同时，实现目标函数的最大化或最小化。这种方法涉及将由具有独特遗传特征的个体组成的群体分配到特定问题中。随后，种群中的每个成员都会被分配一个由目标函数决定的适应度分数。根据个体的适应度值选择个体，并允许个体与后代进行交叉，以确保遗传物质的传递。变异可防止过早趋同，并保持群体的多样性。</li>
</ol>
<p>如果种群已经收敛，则算法结束。&#x3D;&#x3D;遗传算法具有一定的随机性，但由于它也可以使用历史数据，因此其性能优于随机局部搜索。&#x3D;&#x3D;GA 的一般流程图如图 8 所示。机器人技术的难点之一是多机器人路径规划。&#x3D;&#x3D;Kala [61] 借助 GA 探讨了多移动机器人的路径规划策略。通过他的研究，研究人员开发出一种有效的方法来协调多个机器人，以避免在静止环境中发生碰撞。参考文献[62]对静态环境下的多目标策略进行了说明。&#x3D;&#x3D;[62] 针对静态环境，类似于多机器人路径规划。Yang 等人[63] 解决了动态环境中多移动机器人系统导航的问题。他们展示了在存在静态和移动障碍物时的结果。一些研究表明，&#x3D;&#x3D;GA 具有一定的局限性，如收敛速度慢、无法保证获得最优解、选择突变率和种群规模参数的方法繁琐等。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161034489.png" alt="image-20240116103439016"></p>
<p>Hong 等人[64]提出了改进的遗传算法路径规划器，其中包含了基于种群的机器人导航协同评估机制。通过应用改进的遗传算法，作者证明了在陌生环境中运行的多机器人系统在避障和路径优化方面的仿真结果得到了增强。建军等人[65] 提出了一种不同的用于路径优化的改进型遗传算法，为了达到最佳效果，他们的方法修改了染色体的长度。GA 方法被用于仿人机器人（66）的二维路径规划以及水下机器人（67）和空中机器人（68）的三维路径规划问题，因为它能有效地适应环境（包括已知环境和未知环境）。&#x3D;&#x3D;Patle 等人 [69] 针对单机器人和多机器人系统，开发了一种利用二进制代码的基于矩阵的 GA（MGA）来解决移动目标问题。&#x3D;&#x3D;在这种方法中，机器人可以快速、轻松地跟随移动目标和障碍物到达目的地。</p>
<p>Creaser 等人（70）展示了一个结合了模糊逻辑和 GA 方法的导弹控制演示。在为导弹创建制导法则的过程中，GA 起着至关重要的作用。Lin 等人（71）介绍了一种基于 GA 的军事和海洋监测创新方法。在 GA 的帮助下，他们能够确保关键军事资产的安全，并确定水下传感器网络的最佳定位策略。[72]的作者试图找到一种机器人路径规划问题的解决方案，以解决收敛速度慢和局部最优容易衰减的问题，并提出了一种基于种群多样性水平评估的自适应选择技术。为了证明该算法的可行性和有效性，我们在栅格环境中进行了多次仿真。在改进种群初始化方法后，(73) 采用双向 RRT 算法替换部分种群，以创建精英种群。结果表明，本文提出的精英种群遗传算法弥补了传统遗传算法的缺陷。</p>
<ol start="2">
<li>蚁群优化（ACO）： 1992 年，马可-多里戈（Marco Dorigo）在论文中提出了这一群体智能算法（74]。为了解决组合优化问题，该算法采用了基于种群的方法。蚂蚁群从巢穴到食物来源的有效导航是 ACO 算法的灵感来源（图 9）。ACO 算法已在许多科学和工程领域得到应用，包括图着色、二次赋值问题、车辆路由、旅行推销员问题、作业车间调度等。关正等人[75]将 ACO 应用于移动机器人的实时路径规划。与 GA 等其他算法相比，ACC 算法在动态收敛行为、解的变化、收敛速度和计算效率等方面都有所提高。Liu 等人（76）介绍了 ACO 在多移动机器人导航中的应用。他们为静止环境中的不同机器人系统提供了一种避免碰撞的方法。为了增强选择性策略，他们使用了一个特殊函数。当蚂蚁遇到死角时，会对轨迹强度施加惩罚函数，以防止机器人的路径无法移动。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161039669.png" alt="image-20240116103909463"></p>
<p>Castillo 等人[77] 提出了一种基于 ACO-模糊的混合方法，用于移动机器人在静态环境中的导航。Kumar 等人(78) 提出了一种基于 RA-ACO 的方法，用于仿人机器人在杂乱环境中的导航。他们使用 Petri 网测试了所提出的用于多个仿人机器人实时导航的方法，发现仿真结果与实时结果之间具有良好的一致性。Liu 等人[79]就如何调整当前的 ACO 方法以便在静态环境中更好地工作提出了建议。当蚂蚁趋向于更高的效率子空间时，模式的搜索空间会缩小，沿当前路径的信息素会向势场力的方向扩散。他们结合信息素扩散和几何局部优化找到了最佳路径。Rajput 等人（80）针对动态环境提出了另一种修改方法。为了防止无意义的循环并实现更快的收敛，他们还提出了一种新颖的信息素更新技术。Purian 等人（81）将 ACO 算法应用于未知动态环境中的移动机器人导航。在模糊规则的选择和优化方面，他们使用了 ACO。</p>
<p>Brand 等人在（82）中比较了模拟和真实世界中移动机器人在相同环境下的运行情况。Liu 等（83）提出的水下机器人三维路径规划方案使用了一种基于 ACO 的搜索算法来寻找从一个位置到另一个位置的无碰撞路径。Chen 等人也提出了 ACO 算法（84）。利用强化学习可以解决无人驾驶飞行器在战场上确定最佳路径的问题，从而解决原始蚁群算法搜索速度慢和停滞不前的问题。蚁群算法还被应用于军事硬件。Gao 等人[85]将蚁群算法用于导弹路线规划时，发现其性能有所提高，包括最优路线长度和更快的收敛速度。Zong 等人(86) 建议使用改进的蚁群算法为移动机器人规划路径。该算法的信息素更新机制具有加速收敛的能力。大量模拟实验的结果表明。 </p>
<p>通过修改通往目标点的路径，可以显著提高蚁群算法的收敛性 [87]。节点数量减少，更能满足机器人运动的需要。焊接路径的长度直接影响自动线的工作时间和生产效率 [87]。针对传统路径规划方法不适合多目标点的问题，提出了一种基于（ACO）算法的路径规划方法。虽然路径太长，转弯太多 [88]，但基本的蚁群算法（ACO）很容易进入局部最优。改进后的 ACO 会在地图上没有障碍物的区域随机设置可行走的位置点。对于移动机器人，提出了一种基于进化优化的自主路径规划方法。</p>
<ol start="3">
<li>粒子群优化（PSO）： 这种元优化方法从野生动物（如鱼群和鸟群）中获取群体动力学的线索。它是由 Eberhart 和 Kennedy 于 1995 年开发的[89]，是一种用户群迅速增长的优化工具，用于解决各种工程和科学问题。PSO 模仿社会性动物行为，但不需要群体领导者来完成工作。鸟群在寻找食物时不需要领导者，而是跟随离食物最近的成员（图 10）。通过这种方式，鸟群成功地与种群中的其他成员沟通，从而找到所需的解决方案。PSO 算法由一系列粒子组成，每个粒子都代表一个潜在的解决方案。PSO 现已成为移动机器人导航领域广泛使用的工具。Tang 等人[90]利用多智能体粒子过滤器，处理了移动机器人在未知环境中导航的测绘和定位问题。之所以使用 PSO，是因为它具有更稳定的收敛特性，有助于减少计算量。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161059605.png" alt="image-20240116105911079"></p>
<p>为了获得精确的轨迹并防止陷入局部最优，Xuan 等人[91]采用了 PSO 算法与 MADS（网格自适应直接搜索）算法相结合的方法。PSO-MADS 算法与 GA 算法和 EKF 算法相结合，产生了有效的结果（扩展卡尔曼滤波器）。Atyabi 等人[92]创建了区域扩展 PSO（AEPSO）。此外，受时间和变化限制的移动机器人导航问题也可以用 PSO 来解决，该算法结合了基本 PSO 算法和其他优化技术。AEPSO 策略已成功应用于炸弹拆除和幸存者搜救。Tang 等人的[93]挑战环境下的合作运动路径规划解决了多移动机器人系统导航问题。在将 PSO 和多体系统动力学（由加速度、质量、力和惯性等机器人属性组成）都考虑在内的情况下，对所提出方法的容错性进行了研究。对于现实世界中众多移动机器人的导航，Couceiro 等人[94]做了一些修改。他们改变了 PSO 和达尔文 PSO（DPSO）系统，以解决通信和避障问题。他们发现，由 12 个物理机器人组成的系统可将最佳总体性能和最大通信距离提高 90%。</p>
<p>Chen 等人[95]利用多类别分类器为不确定环境制定了可学习的人类专家控制策略。在此背景下，粒子群优化（PSO）算法被用于及时有效地提高精度。与传统的栅格搜索法相比，它具有更高的精度。Li 等人提出的自适应学习粒子群优化（SLPSO）技术，旨在解决复杂环境中机器人路径规划的难题，同时满足各种约束条件。作者最初将路径规划问题转化为多目标优化问题，目的是满足路径长度和碰撞风险最小化以及平稳性最大化的导航目标。在实现这些目标之后，他们又加入了自适应学习机制，以增强粒子群优化（PSO）探索具有众多约束条件的环境的能力。Das 等人[96]为创建有效的路径规划提供了一种混合方法。他们提出了一种使用改进引力搜索算法（IGSA）和 PSO 的混合方法，用于评估杂乱环境中众多移动机器人的最佳行动路线。He 等人的研究[97]探讨了如何利用粒子群优化（PSO）来应对在多元、三维环境中水下环境导航的挑战。该研究采用了 PSO-UFastSLAM 组合方法来提高估计精度和限制粒子大小，从而取得了更好的结果。</p>
<p>粒子群优化（PSO）方法已被用于各类机器人的导航，包括水下机器人、三维未知环境中的空中机器人[98]、仿人机器人[99]和工业机器人[100]。值得注意的是，这些机器人都取得了成功的导航结果。Algabri M 等人[101] 对 GA、PSO、NN 和 FL 等各种导航控制技术进行了比较分析，以确定最佳方法。研究人员得出的结论是，FL 和 PSO 的融合产生了与穿越距离相关的最佳结果。&#x3D;&#x3D;粒子群优化（PSO）在移动机器人导航领域之外也有潜在的应用，特别是在国防领域。Banks 等人[102]研究了 PSO 在非确定性无人机导航中的应用及其促进无人机间协作的潜力，以保护广大地区免受空中威胁。&#x3D;&#x3D;文献[103]采用栅格法对环境进行划分，以实现粒子群优化。路径的距离由目标函数来衡量，避开途中的障碍物会受到惩罚。利用粒子群优化解决了涉及紧急车辆和普通车辆的两个路径规划问题。路径规划是当前机器人领域最活跃的研究领域之一。Chen 等人[104]提到了粒子群的局部搜索性能不达标这一问题；因此，可以更快地规划出理想路径，该算法可以在前期和后期提高粒子搜索的质量。Sarkar 等人[105]开发了一种自适应适配函数，解决了三个重要问题，包括避开障碍物和选择更短、更平滑的路径。该适应度函数通过使用粒子群优化（PSO）算法进行优化。</p>
<p>[103] Yuan, D. Research on path-planning of particle swarm optimization based on distance penalty. In Proceedings of the 2021 2nd International Conference on Computing and Data Science (CDS), Stanford, CA, USA, 28–29 January 2021; pp. 149–153.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">1</a></li><li><a class="pagination-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SUNX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SUNX</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/null"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_43571647?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">C++学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MATLAB/"><span class="level-start"><span class="level-item">MATLAB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/excel%E6%93%8D%E4%BD%9C/"><span class="level-start"><span class="level-item">excel操作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E5%88%9B/"><span class="level-start"><span class="level-item">原创</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路径规划</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="level-start"><span class="level-item">路径规划启发式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">路径规划算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-03T10:45:41.000Z">2024-03-03</time></p><p class="title"><a href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T06:17:52.000Z">2024-03-01</time></p><p class="title"><a href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T08:06:51.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T07:45:43.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/">Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-28T15:35:45.000Z">2024-02-28</time></p><p class="title"><a href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%AD%A6%E4%B9%A0/"><span class="tag">C++学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLion%E5%AE%89%E8%A3%85/"><span class="tag">CLion安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GDAL/"><span class="tag">GDAL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hierachical/"><span class="tag">Hierachical</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MAPF/"><span class="tag">MAPF</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Q1/"><span class="tag">Q1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XTDrone/"><span class="tag">XTDrone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pandas/"><span class="tag">pandas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82/"><span class="tag">分层</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"><span class="tag">分层方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"><span class="tag">原文翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"><span class="tag">可视图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="tag">启发式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">图论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"><span class="tag">多智能体</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="tag">离散数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"><span class="tag">维诺图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%BC%E8%BF%B0/"><span class="tag">综述</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a><p class="is-size-7"><span>&copy; 2024 SUNX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>