<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SUNX的记录</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SUNX的记录"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SUNX的记录"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天的天气不错"><meta property="og:type" content="blog"><meta property="og:title" content="SUNX的记录"><meta property="og:url" content="https://duohangsun.gitee.io/"><meta property="og:site_name" content="SUNX的记录"><meta property="og:description" content="今天的天气不错"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duohangsun.gitee.io/img/og_image.png"><meta property="article:author" content="SUNX"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://duohangsun.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://duohangsun.gitee.io"},"headline":"SUNX的记录","image":["https://duohangsun.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"SUNX"},"publisher":{"@type":"Organization","name":"SUNX的记录","logo":{"@type":"ImageObject","url":"https://duohangsun.gitee.io/img/logo.svg"}},"description":"今天的天气不错"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?69225dadb01d44aae3f8c4f29649a59d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-19T03:00:28.000Z" title="2023/12/19 11:00:28">2023-12-19</time>发表</span><span class="level-item"><time dateTime="2023-12-19T05:25:48.310Z" title="2023/12/19 13:25:48">2023-12-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C-%E5%AD%A6%E4%B9%A0/">C++学习</a></span><span class="level-item">4 分钟读完 (大约604个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8std-fstream%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/">C++学习：使用std::fstream处理文件</a></p><div class="content"><h1><span id="c学习使用stdfstream处理文件">C++学习：使用std::fstream处理文件</span></h1><p>参考来源：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/io/basic_fstream">std::basic_fstream - cppreference.com</a></p>
<p><code>fstream</code>类定义在<code>&lt;fstrea &gt;</code>头文件中。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="symbol">CharT,</span></span><br><span class="line"><span class="symbol">    <span class="symbol">class</span></span> <span class="symbol">Traits</span> = <span class="symbol">std::<span class="symbol">char_traits</span></span>&lt;<span class="symbol">CharT</span>&gt;</span><br><span class="line">&gt; <span class="symbol">class</span> <span class="symbol">basic_fstream</span> : <span class="symbol">public</span> <span class="symbol">std::<span class="symbol">basic_iostream</span></span>&lt;<span class="symbol">CharT, <span class="symbol">Traits</span></span>&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="使用fstream">使用fstream</span></h2><p>既然<code>fstream</code>是一个类，就需要初始化一个类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">//需要包含的头文件</span></span></span><br></pre></td></tr></table></figure>

<p>初始化对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">std::fstream read_file;		<span class="comment">//初始化类对象</span></span><br><span class="line">read_file.<span class="built_in">open</span>(filename, openmode)  <span class="comment">//filename-文件名，openmode-文件打开方式</span></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="function">std::fstream <span class="title">read_file</span><span class="params">(filename, openmode)</span></span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一初始化</span></span><br><span class="line">std::fstream myFile; </span><br><span class="line">myFile.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, std::ios_base::in | std::ios_base::out | std::ios_base::trunc); </span><br><span class="line"><span class="comment">//方式二初始化</span></span><br><span class="line"><span class="function">std::fstream <span class="title">read_file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, read_file.in | read_file.out| read_file.trunc)</span></span></span><br><span class="line"><span class="function">std::fstream <span class="title">read_file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, std::ios_base::in | std::ios_base::out | std::ios_base::trunc)</span></span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>openmode</strong>&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>常量值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>app</td>
<td>添加模式（在每次进行写文件时，将指针指向文件末尾再开始写入）</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制方式打开</td>
</tr>
<tr>
<td>in</td>
<td>读取文件</td>
</tr>
<tr>
<td>out</td>
<td>写文件</td>
</tr>
<tr>
<td>trunc</td>
<td>打开文件时，丢弃流中原来的内容</td>
</tr>
<tr>
<td>ate</td>
<td>打开后立即搜索到流的末尾</td>
</tr>
<tr>
<td>noreplace(C++23)</td>
<td>以独占模式打开</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;<strong>类函数</strong>&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>构造函数</td>
<td>构造文件流</td>
<td>std::fstream read_file(“test.txt”, read_file.in</td>
</tr>
<tr>
<td>析构函数~</td>
<td>销毁basic_fstream和关联的缓冲区，关闭文件</td>
<td></td>
</tr>
<tr>
<td>operator&#x3D;(C++11)</td>
<td>赋值&#x3D;，应该是可以用文件流对fstream对象赋值</td>
<td></td>
</tr>
<tr>
<td>sawp(C++11)</td>
<td>交换两个文件流</td>
<td></td>
</tr>
<tr>
<td>rdbuf</td>
<td>返回基础原始文件设备对象</td>
<td></td>
</tr>
<tr>
<td>native_handle(C++26)</td>
<td>返回基础实现定义的句柄</td>
<td></td>
</tr>
<tr>
<td>is_open()</td>
<td>检查流是否具有关联的文件，如果文件成功打开，返回true，否则是false</td>
<td></td>
</tr>
<tr>
<td>open()</td>
<td>打开文件并将其与流关联</td>
<td>read_file.open(filename, openmode)</td>
</tr>
<tr>
<td>close()</td>
<td>关闭关联的文件</td>
<td>read_file.close()</td>
</tr>
</tbody></table>
<h2><span id="读文件错误处理">读文件错误处理</span></h2><p>使用<code>is_open()</code>函数，判断<code>fstream</code>是否成功打开文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::fstream <span class="title">read_file</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, read_file.in | read_file.out| read_file.trunc)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(!read_file.is_open())</span></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; &quot;failed to open file&quot; &lt;&lt; &#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h2><span id="一个完整的例子">一个完整的例子</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_size</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> &amp;xSize, <span class="type">int</span> &amp;ySize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">ReadFile</span><span class="params">(filename, std::ios_base::in|std::ios_base::trunc)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    TestEOL test&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    std::string buf;</span><br><span class="line">    std::<span class="built_in">getline</span>(ReadFile, buf);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;buf is: &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; buf.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; buf[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            n++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="type">size_t</span> count = std::<span class="built_in">count_if</span>(std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(ReadFile),</span><br><span class="line">                                      std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(),</span><br><span class="line">                                      test);</span><br><span class="line">    ySize = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test.last != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    xSize = <span class="built_in">int</span>(count);</span><br><span class="line">    ReadFile.<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-18T05:57:15.000Z" title="2023/12/18 13:57:15">2023-12-18</time>发表</span><span class="level-item"><time dateTime="2023-12-18T14:48:00.448Z" title="2023/12/18 22:48:00">2023-12-18</time>更新</span><span class="level-item">6 分钟读完 (大约870个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/18/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a></p><div class="content"><h1><span id="算法分析">算法分析</span></h1><p>参考书籍：</p>
<p>《算法》，作者：Robert Sedgewick，Kevin Wayne</p>
<p>对大多数程序的第一个定量观察就是计算性任务的困难程度可以用<strong>问题的规模</strong>来衡量。</p>
<p>什么是问题规模？一般来说，问题规模可以是输入的大小，也可以是命令行的某个参数值。例如，对一个排序算法来说，问题的规模就是需要排序的数据，其数据量的大小。</p>
<p>直观上讲，随着问题规模的逐步增长，程序的运行时间也会增长。</p>
<p>幂次法则公式猜测<br>$$<br>T(N)&#x3D;a N^b<br>$$<br>Knuth观点：一个程序的运行的总时间主要和两点有关</p>
<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>
<p>前者取决于计算机、编译器和操作系统，后者取决于程序本身和输入。如果知道所有这些形式，可以将它们相乘并将程序中所有指令的成本相加得到总运行时间。</p>
<p>通常来说，我们考虑的算法时间复杂度为程序中语句的频率。即通过程序中语句执行条数来衡量运行时间。</p>
<p>&#x3D;&#x3D;一般用到的近似方式都是$g(N)$~$af(N)$，其中$f(N)&#x3D;N^{b}(logN)^{c}$&#x3D;&#x3D;，其中$a$，$b$，$c$均为常数。将$f(N)$称为$g(N)$增长的数量级。</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>常数级别</td>
<td>$1$</td>
</tr>
<tr>
<td>对数级别</td>
<td>$logN$</td>
</tr>
<tr>
<td>线性级别</td>
<td>$N$</td>
</tr>
<tr>
<td>线性对数级别</td>
<td>$NlogN$</td>
</tr>
<tr>
<td>平方级别</td>
<td>$N^2$</td>
</tr>
<tr>
<td>立方级别</td>
<td>$N^3$</td>
</tr>
<tr>
<td>指数级别</td>
<td>$2^N$</td>
</tr>
</tbody></table>
<p>对于一个程序来说，通常是执行最频繁的指令决定了程序执行的总时间——我们称这些指令为程序的内循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)<span class="comment">//循环N次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)<span class="comment">//i的每一个值都进行三次</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;<span class="comment">//3N次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这段程序，<code>count++</code>是执行最频繁的语句，总共执行了$3N$次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Three_sum</span>(<span class="params">arr</span>):</span><br><span class="line">	N = length(arr)</span><br><span class="line">	cnt = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, N):</span><br><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>, N):</span><br><span class="line">				<span class="keyword">if</span> arr[i]+arr[j]+arr[k] == <span class="number">0</span>:</span><br><span class="line">					cnt ++;</span><br><span class="line">	<span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>



<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312181515777.png" alt="image-20231218151547102"></p>
<p>书中提及使用一个&#x3D;&#x3D;<strong>成本模型</strong>&#x3D;&#x3D;来评估算法的性质，这个模型定义了我们所研究的算法中的基本操作。</p>
<p>对于上述图片ThreeSum程序，书中给出一个成本模型是访问数组元素的次数。</p>
<p>书中使用术语&#x3D;&#x3D;<strong>命题</strong>&#x3D;&#x3D;来表示某个成本模型下，算法的数学性质。</p>
<p>例如针对ThreeSum程序，成本模型为访问数组元素的次数。提出如下命题：</p>
<p><strong>命题：ThreeSum程序的暴力算法使用了~$N^{3} &#x2F; 2$ 次数组访问来计算N个整数中和为0的整数三元组的数量。</strong></p>
<p>证明：显而易见，三层循环共执行if块为~$N^{3}&#x2F;6$，if块中共访问3次数组。</p>
<p>对于大部分程序，得到其运行时间的数学模型所需的步骤如下：</p>
<ul>
<li>确定<strong>输入模型</strong>，定义问题的规模</li>
<li>识别内循环</li>
<li>根据内循环中的操作确定成本模型</li>
<li>对于给定的输入，确定这些操作的执行频率</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-13T05:26:34.000Z" title="2023/12/13 13:26:34">2023-12-13</time>发表</span><span class="level-item"><time dateTime="2023-12-13T13:27:49.473Z" title="2023/12/13 21:27:49">2023-12-13</time>更新</span><span class="level-item">7 分钟读完 (大约1014个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/13/Ubuntu-anaconda%E4%BD%BF%E7%94%A8%EF%BC%88%E6%96%B0%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85Tensorflow%EF%BC%89/">Ubuntu anaconda使用（新建环境、最小化安装Tensorflow）</a></p><div class="content"><h1><span id="ubuntu-anaconda使用新建环境-最小化安装tensorflow">Ubuntu anaconda使用（新建环境、最小化安装Tensorflow）</span></h1><p>清华源地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>pip安装使用的时候，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xxx(库名) -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>请先安装好anaconda，再继续下面步骤。</p>
<p><strong>tensorflow, tensorflow-gpu, tensorflow-cpu的区别</strong></p>
<p>有必要说明一下tensorflow的这些版本的区别了。</p>
<p>首先说明：&#x3D;&#x3D;TensorFlow 1.x版本 与 TensorFlow 2.x版本有非常多的不同&#x3D;&#x3D;</p>
<p>tensorflow， tensorflow-gpu只有在tensorflow 1.x版本进行区分！！！（官网说的）</p>
<p>旧版TensorFlow，即tensorflow 1.x版本， CPU和GPU软件包是分开的。</p>
<p>例如：</p>
<ul>
<li>tensorflow&#x3D;&#x3D;1.15 仅支持CPU的版本</li>
<li>tensorflow-gpu&#x3D;&#x3D;1.15 支持GPU版本</li>
</ul>
<p><strong>没有tensorflow-cpu这个说法</strong></p>
<p>TensorFlow 2.x版本就不进行区分了，tensorflow 2.x 同时支持CPU和GPU。</p>
<p>例如：</p>
<ul>
<li>tensorflow&#x3D;&#x3D;2.5.0 同时支持CPU和GPU</li>
</ul>
<p>这里给一个tensorflow 和 CUDA  和 cudnn的对应关系（针对Ubuntu系统），尽量是版本对应的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312132126101.png" alt="image-20231213212642950"></p>
<p><strong>新建虚拟环境</strong></p>
<p>打开terminal（请先安装好anaconda）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n xxxx(名字) python=x.xx(版本号)</span><br></pre></td></tr></table></figure>

<p>指定名字xxxx，指定python版本。例如想建一个名为tensorflow的虚拟环境，python版本为3.11</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.11</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>新建虚拟环境不代表安装了tensorflow！只是创建了一个虚拟环境，方便各种库统一管理，以后再tensorflow环境下安装的库，可以统一管理和删除</strong>&#x3D;&#x3D;</p>
<p><strong>pip安装Tensorflow</strong></p>
<p>也可以源码安装，官网<a target="_blank" rel="noopener" href="https://tensorflow.google.cn/install/source?hl=zh-cn">从源代码构建  | TensorFlow (google.cn)</a>给方法了，比较麻烦。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow==x.x.x(版本) -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>例如想安装Tensorflow 2.14。&#x3D;&#x3D;（安装尽量用pip，方便管理和打包，打包的时候，如果版本不一致会报错）&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow==2.14.0 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p><strong>启动虚拟环境&#x2F;切换虚拟环境</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate xxx(环境名字)</span><br></pre></td></tr></table></figure>

<p>例如，启动tensorflw。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow</span><br></pre></td></tr></table></figure>

<p><strong>验证是否安装成功</strong></p>
<p>查看自己安装的tensorflow是不是自己想要的版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<p>我的环境中显示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...shell</span><br><span class="line">smach                         2.5.2</span><br><span class="line">smach-ros                     2.5.2</span><br><span class="line">smclib                        1.8.6</span><br><span class="line">stack-data                    0.2.0</span><br><span class="line">tensorboard                   2.14.1</span><br><span class="line">tensorboard-data-server       0.7.2</span><br><span class="line">tensorflow                    2.14.0</span><br><span class="line">tensorflow-estimator          2.14.0</span><br><span class="line">tensorflow-io-gcs-filesystem  0.34.0</span><br><span class="line">termcolor                     2.4.0</span><br><span class="line">tf                            1.13.2</span><br><span class="line">tf-conversions                1.13.2</span><br><span class="line">tf-slim                       1.1.0</span><br><span class="line">tf2-geometry-msgs             0.7.7</span><br><span class="line">tf2-kdl                       0.7.7</span><br><span class="line">tf2-py                        0.7.7</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>表明安装的是tensorflow 2.14.0，然后在tenminal中输入到<code>python</code>，启动python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow</span><br></pre></td></tr></table></figure>

<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131352478.png" alt="image-20231213135201785"></p>
<p>tensorflow安装成功。输入quit()，退出python。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>quit()</span><br></pre></td></tr></table></figure>

<p><strong>退出当前虚拟环境</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>



<h2><span id="使用conda打包虚拟环境">使用conda打包虚拟环境</span></h2><p>情景：想要把某台设备上已经配置好的环境，打包好，放到另一台设备上运行。例如，在自己的电脑上配好环境，然后放置到服务器环境下运行。可以省去配置环境时间，有时候，服务器是离线的，可以在自己电脑上配置好，然后再放到离线服务器上。</p>
<p><strong>安装打包工具</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install conda-pack -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p><strong>打包环境</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda pack -n env_name -o xxxx.tar.gz(输出地址)</span><br></pre></td></tr></table></figure>

<p>例如，我想打包tensorflow环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda pack -n tensorflow -o tensorflow.tar.gz </span><br></pre></td></tr></table></figure>



<h2><span id="查看已创建的环境">查看已创建的环境</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>

<p>会输出自己已创建的虚拟环境名，以及各自的位置。</p>
<h2><span id="删除虚拟环境">删除虚拟环境</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n xxx(环境名) --all</span><br></pre></td></tr></table></figure>

<p>例如删除上面安装好的虚拟环境tensorflow。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n tensorflow --all</span><br></pre></td></tr></table></figure>



<h2><span id="命令下运行ipynb文件">命令下运行.ipynb文件</span></h2><p>利用ipython来运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipython -c <span class="string">&quot;%run test.ipynb&quot;</span></span><br></pre></td></tr></table></figure>

<p>或者jupyter自带的功能（但是得安装）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jupyter nbconvert --to notebook --execute test.ipynb --output test.ipynb</span><br><span class="line"><span class="comment"># 跳过部分有错的cell继续执行</span></span><br><span class="line">jupyter nbconvert --to notebook --execute mynotebook.ipynb --output mynotebook.ipynb</span><br><span class="line"><span class="comment"># cell执行超时</span></span><br><span class="line">jupyter nbconvert --to notebook --execute --allow-errors --ExecutePreprocessor.timeout=<span class="number">180</span> mynotebook.ipynb </span><br><span class="line"><span class="comment"># 原地运行文件</span></span><br><span class="line">jupyter nbconvert --to notebook --execute --inplace mynotebook.ipynb</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-13T00:20:11.000Z" title="2023/12/13 08:20:11">2023-12-13</time>发表</span><span class="level-item"><time dateTime="2023-12-14T15:25:22.832Z" title="2023/12/14 23:25:22">2023-12-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/">路径规划算法</a></span><span class="level-item">37 分钟读完 (大约5588个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/13/Path-Planning-for-Lunar-Surface-Robots-Based-on-Improved-Ant-Colony-Algorithm/">Path Planning for Lunar Surface Robots Based on Improved Ant Colony Algorithm</a></p><div class="content"><h1><span id="path-planning-for-lunar-surface-robots-based-on-improved-ant-colony-algorithm">Path Planning for Lunar Surface Robots Based on Improved Ant Colony Algorithm</span></h1><p>作者：SONG Ting，SUN Yuqi，YUAN Jianping，YANG Haiyue，WU Xiande*</p>
<h2><span id="abstract">Abstract</span></h2><p>摘要： 在现实世界中，月球任务的规模和地形因不同的作业区域或工作表而各不相同，这就需要一种更灵活、更高效的算法来生成任务路径。针对月球空间尺度大、地形复杂的特点，设计了一种月球机器人多尺度蚁群规划方法。在该算法中，实际的月球表面图像被网格化为一个栅格图，路径规划算法在此基础上建模，然后将实际路径投影到原始的月球表面和任务中。经典的蚁群规划算法利用多尺度方法重新编写，以解决多样化任务问题。此外，还考虑了路径的平滑性，以减小转向角的大小。最后，介绍了几种典型条件，以验证所提算法的效率和可行性。</p>
<p>作者改进蚁群算法，以适应月球表面大尺度、复杂地形的路径规划。该方法应用于月球表面栅格化地图，并在栅格化地图完成路径规划后，重新投影到经纬度地图上。</p>
<h2><span id="introduction">Introduction</span></h2><p>月球基地建设和资源开发是未来人类拓展太空乐园的重要方面。月面机器人将是宇航员开发利用月球资源的重要助手和重要工具。随着机器人数量的不断增加，月面机器人任务分配和路径规划将成为大规模规划问题。&#x3D;&#x3D;随着机器人性能的提高和规划规模的扩大，路径规划应用场景和地形条件的不确定性进一步增加。&#x3D;&#x3D;多样化的规划场景要求搜索算法具有适应各种尺度的灵活性和适应复杂地形的高计算能力。因此，为机器人规划一条短小、安全、平滑的路径以到达月球表面的目标位置尤为关键。</p>
<p>对路径规划的深入研究已有几十年的历史，主要分为两类，一类是基于理论模型的规划方法，另一类是基于随机搜索算法的规划方法。在基于随机搜索的规划方法方面，李［1］ 提出了一种改进的 A* 算法。该方法将 AGV 状态与模糊逻辑规则相结合作为启发式信息，并动态调整启发式功能权重。Alireza 等［2］改进了变异杜鹃优化算法（MCOA），该算法具有处理多个未映射对象的能力，且耗时少于GA 和A* 算法。Li等人提出了一种基于路径网络的新遗传算法［3］，在更大规模上比A*算法效率更高。为了提高计算效率，减少节点数量，徐晓明等［4］讨论了概率路标算法（PRM）和基于概率的双向快速探索随机树（P-BiRRT）的组合算法。</p>
<p>蚁群算法以其稳定性和可靠性被广泛应用于最优路径的搜索。蚁群算法通过模仿蚂蚁的觅食行为，提高了优化能力的智能性、高效性、准确性和适用范围。与 A* 算法、GA 算法和其他随机搜索算法相比，蚁群算法具有正反馈性，且该算法可采用分布式计算框架⁃ 工作和启发式概率搜索方法，使其更容易、更高效地找到全局最优解。因此，蚁群算法被广泛应用于解决路径规划问题。Shi 等［5］提出了一种分段和全局路径规划的融合方法，利用势能蚁群算法进行全局搜索，利用改进的人工势能场（APF）方法进行局部搜索。方法进行全局搜索。Chen等人［6］的文章提出，蚁群优化算法可以解决无人机（UAV）路径规划问题，具有突出的鲁棒性和可扩展性。在蚁群算法的基础上，赵晓东等［7］通过在启发式函数中增加自适应调整，提高了计算效率。Shao等［8］提出设置信息素衰减系数的dy⁃namical限值可以提高搜索效率，降低局部最优解出现的概率。而对于复杂地形的大规模路径规划问题，目前的蚁群算法仍存在初始阶段盲目搜索和搜索规模受限的问题。</p>
<p>本文提出了一种多尺度改进蚁群算法，结合平滑性方法用于月球机器人智能路径规划，以适应大规模复杂月面，提高路径搜索效率、算法适应灵活性和路径安全性。提出的算法能够适应各种搜索尺度，降低局部最优概率，提高收敛效率。与现有方法相比，本文主要有以下三个方面的贡献：<br>&#x3D;&#x3D;（1）将全局空间矩阵映射为具有相应地形复杂度的新矩阵，以提高蚁群算法的搜索规模；&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;（2） 提出快速摆脱局部优化的多尺度方法；&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;（3） 提出蚁群算法可以满足月球表面大规模复杂地形的要求。&#x3D;&#x3D;</p>
<p>本文的结构安排如下。第 1 节介绍了多尺度蚁群模型的基本思想。第 2 节详细介绍了多尺度蚁群模型的算法设计。第 3 节，将所提出的算法用于月面路径规划，并将结果与 A* 算法的结果进行比较，以说明多尺度蚁群算法的有效性。最后，在第 4 节中得出一些结论。</p>
<p>作者提出了多尺度改进蚁群算法，估计平滑方法主要是在后期优化路径时使用。算法的特性是能够适应各种搜索尺度，估计是地图规模？多尺度的具体含义是什么？，提高收敛效率。</p>
<h2><span id="conclusion">Conclusion</span></h2><p>本文提出了一种基于蚁群算法的多尺度方法。其基本思想是路径映射法和空间分割法。本文进行了多次仿真，证明了理论结果的有效性。多尺度蚁群算法提高了搜索速度，有效地找到了全局最优解。多尺度蚁群算法有利于高效、稳定地规划月球机器人的路径。多尺度蚁群算法有利于高效、稳定地规划月球机器人的路径，未来可推广应用于不同领域复杂地形要求的大规模路径规划问题。</p>
<h2><span id="1-problem-description">1 Problem Description</span></h2><p>（1）符号设计</p>
<p> 为了解释路径规划问题，设计了一个模拟数学模型，如图 1 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131032233.png" alt="image-20231213103104112"></p>
<p>在坐标 $XOY$ 中，路径节点表示为一个集合 $Node &#x3D; { node_i }$，$node_i $是第 $i$ 个节点，$nodei &#x3D; { node_{x_{i}}，node_{y_{i}}}$，其中 $node_{x_{i}}$ 和 $node_{y_{i}}$ 是节点 $i$ 的位置。第一个节点 $node_0$ 也记为 S，最后一个节点 $node_n$ 也记为 T，其中 $n$ 表示最后的节点数。</p>
<p>相邻节点之间的路径分段记为一个集合 $R_t &#x3D; { R_{tij}}$，其中 $R_{tij}$ 是第 $i$ 个节点与第 $j$ 个节点之间的路径分段。这里 $j &#x3D; i + 1，0 ≤ i &lt; n$。</p>
<p>路径段角度表示为一个集合 $Ang &#x3D; { θ_i }，θ ∈ [ 0，π )$，其中 $θ_i$ 是 $R_{tij}$ 与 $R_{t( i- 1)i}$ 的延长线之间的钢化角。</p>
<p>障碍物表示为一个集合 $Obs &#x3D; { O_i }$，其中 $O_i$ 是第 $i$ 个障碍物。$O_i$ 表示为第三个元组集合 $O_i &#x3D; { O_{xi}，O_{yi}，R_{Oi} }$，其中 $O_{x_i}$ 和 $O_{y_i}$ 是 $O_i$ 的位置，$R_{O_i}$ 是 $O_i$ 的边长。</p>
<p>搜索空间为 $R_{search}$。$R$ 搜索的平均高度为 $A_R$，月球机器人的运动高度极限为 $A_{lim}$。</p>
<p>（2）Path planning model</p>
<p>月球机器人路径规划问题可定义为寻找从 $S$ 到 $T$ 的最优或最佳路径，如图 2 所示。路径规划模型可以用 $S，T，R_t，Ang，Obs$ 等来描述。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131047620.png" alt="image-20231213104733501"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131049225.png" alt="image-20231213104907499"></p>
<p>路径点不与障碍物不相交，且路径点与障碍物点保持一定的距离。并且要找一条更短的平滑路径，计算时间更短，且转向角度更小。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131101413.png" alt="image-20231213110137438"></p>
<p>&#x3D;&#x3D;( 2 )将月球图像网格化为不同尺度的栅格地图。&#x3D;&#x3D;文章说将月球地表栅格化为不同尺度的栅格图，多尺度的意思是，对于同一个栅格图，每个栅格大小是不一样的意思，还是栅格化了多个尺度？但是，看图3，并没有看出来栅格大小不一致的情况，也没看出存在多个不同尺度的栅格图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131103096.png" alt="image-20231213110335584"></p>
<p>经典的蚁群算法存在初始阶段搜索效率低的缺点，尤其是在大空间中。由于月球任务的区域尺度可能很大，$L$ 可能包含大量元素。蚂蚁信息素参数 $\tau$ 难以在几个周期内以巨大的计算量扩散到整个空间。因此，在大规模问题中，计算效率会大大降低。在算法中利用改变初始矩阵元素个数和缩小搜索范围来降低尺度的影响。</p>
<p>在路径规划之前，将每一堆元素 $h × h$ 映射为一个元素。换言之，将初始矩阵 $L$ 拆分为一组矩阵 $L_{small}$，并将每个矩阵整合为新矩阵 $L_{New}$ 中的一个元素。$L_{small_m}$ 是 $L_{small}$ 中的第 $m$ 个矩阵，它与 $L_{New_m}$ 即 $L_{New}$ 中的第 $m$ 个元素相关联。矩阵 $L_{New}$ 由地形复杂度 TC 的新元素组成，用不同的灰度表示，如图 4 所示。起点 $S$ 和目标点 $T$ 也被映射到 $L_{New}$ 中。</p>
<p>用新矩阵 $L_{New}$ 规划路径，让经过的元素映射到初始矩阵，在 $L_{small}$ 中找到经过的矩阵 $L_{pass}$。如图 5 所示，用传递矩阵 $L_{pass}$ 规划路径 $R_{t_small}$，依次将它们相互组合，成长为初始路径 $R_t$。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131114717.png" alt="image-20231213111430839"></p>
<p>&#x3D;&#x3D;使用卷积来检测矩形范围是否有意义？&#x3D;&#x3D;</p>
<p>初始路径 $R_t$ 仍需使用蚁群算法进行优化。首先，通过随机方法收集路径分段 $R_{t_seg}$，得到相应的矩阵 $M_{New}$。其次，在不改变起点和终点的情况下，优化 $M_{New}$中的路径 $R_{t_seg}$，得到优化结果 $R_{t_New}$。最后，用 $R_{t_New}$ 替换 $R_{t_seg}$，并更新上述局部优化后的路径 $R_t$，如图 6 所示。</p>
<p><img src="/Path-Planning-for-Lunar-Surface-Robots-Based-on-Improved-Ant-Colony-Algorithm.assets/image-20231213155837176.png" alt="image-20231213155837176"></p>
<p>实际的月球机器人无法在多⁃线路径上行驶，因此栅格图中生成的路径仍需平滑处理。该算法利用曲线平滑方法完成平滑度控制，最终路径的可行性和效率都得到了提高，如图 7 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312131626639.png" alt="image-20231213162631656"></p>
<h2><span id="2-algorithm-design">2 Algorithm Design</span></h2><h3><span id="2-1-image-process">2. 1 Image process</span></h3><p>首先，将彩色月亮图像转换成灰度图像，然后获取图像的像素，得到每个像素 MG 的灰度值矩阵。计算像素的平均值 $mean_{rgb}$，它反映的是平均海拔。将 $mean_{rgb}$ 作为像素参考值，设置值比例范围 $p_{rgb}$。最后，生成全局矩阵 $L &#x3D; { l_{rc} }$，其中 $l_{rc}$ 为第 $r$ 行第 $c$ 列的元素。根据月面环境假设，全矩阵可定义为<br>$$<br>high_{rgb} &#x3D; floor ( ( max_{rgb} - mean_{rgb} )× p_{rgb} + mean_{rgb} )<br>\tag{2}<br>$$</p>
<p>$$<br>low_{rgb} &#x3D; floor(mean_{rgb} -( mean_{rgb} - min_{rgb} )× p_{rgb})<br>\tag{3}<br>$$</p>
<p>$$<br>l_{rc} &#x3D;<br>\begin{cases}<br>0 &amp; low_{rgb}\le MG_{\tau} \le high_{rgb}\<br>1 &amp; else\<br>\end{cases}<br>\tag{4}<br>$$</p>
<p>其中，0 表示可访问，1 表示不可访问；$max_{rgb}$ 和 $min_{rgb}$ 分别表示 MG 中的最大值和最小值；$high_{rgb}$ 和 lowrgb 分别表示 MG 中的上界和下界，对应 $p_{rgb}$。 floor ($A$) 将 $A$ 中的元素舍入为小于等于 $A$ 的整数。</p>
<h3><span id="improved-ant-colony-algorithm">Improved ant colony algorithm</span></h3><p>表示启发式函数 $\eta_{ij}(t)$ 与下一节点 $j$ 到目标的距离成正比［9］。<br>$$<br>\eta_{ij}(t) &#x3D; \frac{1}{d(j, T)}<br>\tag{5}<br>$$<br>设置 $\tau_{ij}$ 的下限，以模拟蚁群中的错误概率，增加搜索多样性。<br>$$<br>\tau_{ij}&#x3D;<br>\begin{cases}<br>\tau_{ij} &amp; \tau_{ij} \gt \tau_{min} \<br>\tau_{min} &amp; \tau_{ij} \le \tau_{min} \<br>\end{cases}<br>\tag{6}<br>$$<br>取消信息素的记录［10-11］。只记录到达 T 的蚂蚁的信息素，这些蚂蚁在第 t 代的集合为 $arrive_{t，T}$。这里 $L_k$ 表示第 $k$ 只蚂蚁在 $arrive_{t，T}$ 中走过的路径长度。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312132205792.png" alt="image-20231213220545479"></p>
<p>在传统的蚁群算法中，信息素的值在每次迭代中都会下降。然而，改进蚁群算法的主要思想是随机选择路径段进行优化，从而获得全局优化结果。由于这种随机性，这一假设并不适用于改进的蚁群算法。</p>
<p>&#x3D;&#x3D;Note：这个形式很像蚁周模型（好久之前看得）&#x3D;&#x3D;</p>
<h3><span id="2-3-path-mapping-method">2. 3 Path mapping method</span></h3><p>采用路径映射法生成初始解，提高计算效率。其总体思路是将全局栅格分割成若干小串矩阵 $L_{small}$，并将 $L_{small}$ 中的每个矩阵映射为矩阵 $L_{New}$ 中的每个元素，其地形复杂度为 TC。在 $L_{New}$ 中生成最优路径 $R_{t_New}$ 后，映射对应的矩阵 $L_{pass}$，并依次将最优路径 $R_{t_small}$ 互相组合，生成初始路径 $R_t$。</p>
<p>区域分割过程如下<br>（1）确认 $L$ 中元素 $M_1×M_2$ 的个数。<br>（2）设定 $L$ 中元素 $h × h$ 的数量 $L_{small_m}$。<br>（3） 在 $L_{small}$ 中将 $L$ 分成 $ceil (\frac{M_{1}}{h}) × ceil(\frac{M_2}{h})$ 矩阵。 $ceil(A)$ 将 A 中的元素舍入到与 A 最接近的大于或等于 $A$ 的整数。<br>（4） 矩阵 $L_{New}$ 由新元素组成，每个元素的取值范围为 $[ 0，1 ]$。$L_{New}$ 中的元素与 $L_{small}$ 中的矩阵之间的映射关系由 TC、起点 $S$ 和目标点 $T$ 反映出来。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312132222180.png" alt="image-20231213222213807"></p>
<p>其中，$num_{obs}$ 是 $L_{small}$矩阵中的障碍物数量，$num_{total}$ 是 $L_{small}$ 矩阵中的栅格总数。</p>
<p>在 $L_{New}$ 中生成 $R_{t_New}$ 的过程中，取消蚂蚁运动的自由度（DOF） 在 $L_{New}$ 中生成 $R_{t_New}$ 的过程中，取消左上、左下、右上和右下的自由度（DOF），以确保 $L_{small}$ 中相邻矩阵之间存在无障碍路径。然后，将 $R_{t_New}$ 节点映射到矩阵 $L_{pass}$ 中。</p>
<p>在 $L$ 中从 $S$ 到 $T$ 生成 $R_t$ 的映射方法如下。</p>
<p>（1） 遍历 $L_{pass}$ 中的每一对相邻矩阵，选择相邻矩阵之间的可达路径。$L_{pass_n}$ 和 $L_{pass_m}$ 指 $L_{pass}$ 中的上矩阵和后矩阵。$J_n$ 和 $J_m$ 是 $L_{pass_n}$ 和 $L_{pass_m}$ 中的连边集合。</p>
<p>（2） 选取 $J_{nm}$ 中值为 0 的元素，将其作为可访问集合放入 $J_{nm0}$ 中。通过随机方法选择 $J_{nm0}$ 中的后元素 $J_{pos}$。$L_{pass_n}$ 中的目标位置为 $T_{pass_n}$，$T_{pass_n}$ &#x3D; $J_{n} \cap J_{pos}$，$L_{pass_m}$ 中的起始位置为$S_{pass_m}$，$S_{pass_m} &#x3D; J_m \cap J_{pos}$。</p>
<p>（3） 根据流程 (1) 和 (2) 计算每个 $L_{pass}$ 矩阵中的起始位置和目标值。</p>
<p>（4）在 $L_{pass}$ 矩阵中生成路径，并逐一拼接。然后，在全局矩阵 $L$ 中得到 $R_t$，如图 8 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312132241160.png" alt="image-20231213224127044"></p>
<p>&#x3D;&#x3D;PathMapping Method的目的是：有点分段优化的意思，把一个nxn的栅格图，收缩为mxm的栅格图，且$m &lt; n$，每个收缩的栅格，都包含原nxn栅格的一部分，然后针对这每个部分进行重新路径生成。收缩栅格后，需要生成新的路径，并且还要映射到最初的nxn的栅格。&#x3D;&#x3D;</p>
<h3><span id="2-4-space-splitting-optimal-method">2. 4 Space splitting optimal method</span></h3><p>空间分割优化法可以利用随机方法优化 $R_t$，降低局部最优解的概率，提高计算效率。空间分割最优法的整体过程如下。</p>
<p>（1） 设置路径段优化参数：$O_{num}$ 为优化次数，$Pmax(0 &lt; Pmax &lt; 1)$为路径段与 Rt 的比值上限；$P_{min}(0 &lt; P_{min} &lt; P_{max})$为路径段与 Rt 的比值下限；$N_{Opt0}$ 为初始代数；$M_{Opt0}$ 为算法中蚂蚁的初始数量。</p>
<p>&#x3D;&#x3D;第一步：限制了分割比例，具体来说，并不是把最初的路径$R_t$分为固定的段数，而是每次分的路径段$P_{min} &lt; (R_{seg_i} &#x2F; R_t) &lt;P_{max}$&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141127299.png" alt="image-20231214112710365"></p>
<p>在区域路径优化过程中，这一步设置了禁区列表。使用过的 $S_{Opt}$ 位置被记录在 Tabu 列表中，Tabu &#x3D; { $S_{small} (1)$，$S_{small}(2)$，⋯，$S_{small}(N_{small})$ }。如果新的起始位置已经在 Tabu 中，则重新选择。</p>
<p>&#x3D;&#x3D;步骤2提出具体的截断$R_t$的方式，优化次数$N_{opt}$和每次优化的蚁群数$M_{opt}$，是由截断方式来决定的。$num$是一个变值，其他都是定值。&#x3D;&#x3D;</p>
<p>（3）得到 $R_{t_Seg}$ 对应的矩阵 $M_{Seg}$。遍历 $R_{t_Seg}$ 中的每个节点，找出 x⁃ 轴和 y⁃ 轴上的最大值和最小值。根据上述最大值和最小值得到 $M_{Seg}$。在 $M_{Seg}$ 中实施路径规划，得到解 $R_{t_Opt}$。</p>
<p>（4） 用 $R_{t_Seg}$ 替换 $R_{t_Opt}$，并通过上述局部优化更新路径 $R_t$。</p>
<p>（5）重复步骤（2-4），直到达到 $O_{num}$。</p>
<h3><span id="2-5-path-smoothing-process">2. 5 Path smoothing process</span></h3><p>经过路径映射和空间分割方法⁃ od，得到需要平滑的 $Node &#x3D; { node_i }$。本文采用文献 ［12-14］ 提出的平滑方法，减小转向角的大小，提高路径安全性。</p>
<h2><span id="3-simulation-and-result-analysis">3 Simulation and Result Analysis</span></h2><p>月面图像如图 9 所示。 将图 9 转为栅格图 L，其中包含 658 × 800 个元素。然后，将 L 分割为 $L_{small}$ 矩阵。（a） 表示 $L_{small}$ 中矩阵的尺度为 50 × 50，（b）表示 $L_{small}$ 中矩阵的尺度为 20 × 20，如图 10-15 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141413337.png" alt="image-20231214141327275"></p>
<p>设置 $TC_{max} &#x3D; 0.4$，栅格水平与 $L_{New_m}$ 的值成正比。$L_{New}$ 中的路径规划参数为：$N &#x3D; 30$，$M &#x3D; 60$，$\tau_{min} &#x3D; 0.1$。如图 11 所示，$L$ 的起始位置在第 150 行第 1 列，目标位置在第 350 行第 375 列。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141417168.png" alt="image-20231214141739296"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141419290.png" alt="image-20231214141944972">	</p>
<p>$L_{pass}$中的路径规划参数为：$N &#x3D; 10$，$M &#x3D; 50$，$\tau_{min} &#x3D; 0.1$。初始路径$R_{t}$如图12所示。</p>
<p>区域优化参数设置为： $O_{num} &#x3D; 200$，$P_{max} &#x3D; 0.085$，$P_{min} &#x3D; 0.05$，$N_{small0} &#x3D; 60$，$M_{small0} &#x3D; 50$，其他常量参数与 $L_{pass}$ 中的参数相同。路径长度与区域最优值之间的关系如图13所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141436012.png" alt="image-20231214143626747"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141437237.png" alt="image-20231214143733976"></p>
<p>平滑前的最佳路径如图14所示，其中平均转向角 $\bar \theta &#x3D; 14.408 867$，大角度转向个数为122。本工作将大于20°的转向角视为大角度，如图14所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141439203.png" alt="image-20231214143907401"></p>
<p>经过路径平滑处理后，$\bar \theta &#x3D; 1.981138$，大角度的个数为0，如图15所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141441795.png" alt="image-20231214144129688"></p>
<p>路径映射方法中 $L_{small}$ 的大小是一个可调整的参数，应根据任务确定。在这种情况下，其他参数与上述参数相同。<br>$L_{small}$ 的大小从 15 × 15 到 50 × 50。在8组仿真中去除最高值和最低值后的平均结果如图16—21所示。<br> 从实验数据来看，在$L_{New}$中生成路径的计算时间与$L_{small}$的大小成反比，在$L_{pass}$中生成初始路径的计算时间与$L_{small}$的大小成正比。当 $L_{small}$ 的大小为 19 × 19 时，总计算时间具有最小值。<br>$L_{small}$的大小与空间分割最优方法计算时间的关系如下。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141448107.png" alt="image-20231214144826133"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141449269.png" alt="image-20231214144903335"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141456781.png" alt="image-20231214145649032"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141457018.png" alt="image-20231214145723008"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312141459377.png" alt="image-20231214145935909"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-12T03:16:24.000Z" title="2023/12/12 11:16:24">2023-12-12</time>发表</span><span class="level-item"><time dateTime="2023-12-12T07:24:06.725Z" title="2023/12/12 15:24:06">2023-12-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a></span><span class="level-item">8 分钟读完 (大约1205个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/12/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%861/">图论知识1</a></p><div class="content"><h1><span id="图论知识1">图论知识1</span></h1><p>本文参考书籍：《离散数学》作者：左萧凌等</p>
<p><strong>图定义</strong>：一个图是一个三元组$&lt;V(G), E(G), \varphi_{G}&gt;$，其中$V(G)$是一个非空集合，$E(G)$是边集合。$\varphi_{G}$是从边集合$E$到结点无需偶（有序偶）集合上的函数。</p>
<p>简言之：一个图是由顶点、边和边的指向关系构成的。顶点对应顶点集合，边对应边集合，边的指向关系指的是$\varphi_{G}$，即序偶关系。</p>
<ul>
<li><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312121400612.png" alt="image-20231212140004231"></li>
</ul>
<p>​																</p>
<p>如图所示，顶点集合为$V(G) &#x3D; {A, B, C, D, E }$，边集合为$E(G) &#x3D; {e1, e2, e3, e4, e5, e6 }$，由于该图是无向图，故$\varphi(e1)&#x3D;(A, B)$，$\varphi(e2)&#x3D;(A, E)$，$\varphi(e3)&#x3D;(B, E)$，$\varphi(e4)&#x3D;(B, C)$，$\varphi(e5)&#x3D;(C, D)$，$\varphi(e6)&#x3D;(D, E)$。同样由于是无向图，$\varphi(e1)&#x3D;(B, A)$，$\varphi(e2)&#x3D;(E, A)$，$\varphi(e3)&#x3D;(E, B)$，$\varphi(e4)&#x3D;(C, B)$，$\varphi(e5)&#x3D;(D, C)$，$\varphi(e6)&#x3D;(E, D)$这样写也可以。</p>
<p><strong>有向边与无向边：</strong></p>
<p><strong>无向边</strong>：若边$e_{i}$与结点无序偶$(v_j,v_k)$相关联，则称该边为无向边。</p>
<p><strong>有向边</strong>：若边$e_{i}$与结点有序偶$&lt;v_j,v_k&gt;$相关联，则称该边为有向边。</p>
<p>&#x3D;&#x3D;简言之&#x3D;&#x3D;：有向边表示边有明确的指向关系。$&lt;v_j, v_k&gt;$表示从$v_j$指向$v_k$。</p>
<p><strong>有向图、无向图和混合图</strong></p>
<p><strong>无向图</strong>：若图中的每一条边都是无向边，则称该图为无向图。如第一张图所示。</p>
<p><strong>有向图</strong>：若图中的每一条边都是有向边，则称该图为有向图。</p>
<p><strong>混合图</strong>：若图中既存在无向边，又存在有向边称为混合图。</p>
<p><strong>孤立结点</strong></p>
<p>在一个图中不与任何结点相邻接的结点，称为孤立结点。即如果一个结点没有任何边，则该结点为孤立结点。</p>
<p><strong>自回路或环</strong>：关联于同一结点的一条边称为自回路或环。如上图所示$(E,E)$是环。</p>
<h2><span id="结点的度">结点的度</span></h2><p><strong>定义</strong>：在图$G&#x3D;&lt;V, E&gt;$中，与结点$v(v \in V)$关联的边数，称作该节点的度数，记作$deg(v)$。</p>
<p>如上图所示，结点A的度数为2，结点B的度数为3，结点E的度数为5（约定，每个环在其对应的结点上度数加2）。</p>
<p><strong>定理</strong>：每个图中，结点的度数总和是边数的两倍。即<br>$$<br>\sum \limits_{v \in V} deg(v) &#x3D; 2|E|<br>$$<br>显而易见，一条边有两端点，每个端点都会使度数加1。</p>
<p><strong>定理</strong>：在任何图中，度为奇数的结点必定是偶数个。</p>
<p>显而易见，对于每个图，其结点的度数总和必定为偶数。故，度为奇数的结点必定有偶数个，其和才为偶数。</p>
<p><strong>入度和出度</strong></p>
<p><strong>定义</strong>：在一个&#x3D;&#x3D;<strong>有向图</strong>&#x3D;&#x3D;中，射入一个结点的边数称为该结点的入度，由一个结点射出的边数称为该结点的出度。结点的出度与入度之和就是该结点的度数。</p>
<p><strong>定理</strong>：在任何图中，所有结点的入度之和必然等于所有结点的出度之和。</p>
<p>显而易见，一个有向图的每条边必有一个入度和出度。（双箭头的边？双箭头边应该不能作为最基本组成元素，双箭头边可以被拆解为两条单箭头边）</p>
<p><strong>定义</strong>：含有平行便的任何一个图称为多重图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312121502110.png" alt="image-20231212150252212"></p>
<p>如该图所示，$e1$、$e2$、$e3$是一组平行边，$e4$、$e5$是一组平行边。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312121506680.png" alt="image-20231212150608476"></p>
<p>如该图所示，$e1$、$e3$是一组平行边，而$e4$和$e5$并不是平行边，原因是：$e1$、$e3$的序偶关系一致，都是$&lt;B,A&gt;$，而$e4$和$e5$的序偶关系并不一致，分别为$&lt;B,D&gt;$和$&lt;D,B&gt;$。</p>
<p>&#x3D;&#x3D;<strong>简单图</strong>&#x3D;&#x3D;：把不存在平行边和环的图称为简单图。</p>
<p>&#x3D;&#x3D;<strong>完全图</strong>&#x3D;&#x3D;：简单图$G&#x3D;&lt;V,E&gt;$中，若对每一对结点间都有边相连，则称该图为完全图。</p>
<p><strong>定理</strong>：$n$个结点的无向完全图的边数为$\frac{1}{2}n(n-1)$</p>
<p>显而易见，对于有$n$个结点的无向完全图，每个结点都与其他$(n-1)$个结点存在一条边，故有$n(n-1)$条边，由于一半是重复的，$\frac{1}{2}n(n-1)$。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-10T13:38:50.000Z" title="2023/12/10 21:38:50">2023-12-10</time>发表</span><span class="level-item"><time dateTime="2023-12-10T13:40:23.107Z" title="2023/12/10 21:40:23">2023-12-10</time>更新</span><span class="level-item">1 分钟读完 (大约219个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/10/%E6%9F%A5%E6%89%BE%E6%96%87%E6%9C%AC%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%BF%AB%E6%96%B9%E6%B3%95/">查找文本行数的最快方法</a></p><div class="content"><h1><span id="c语言查找文本行数的最快方法">C语言查找文本行数的最快方法</span></h1><h1><span id="转载">转载</span></h1><p>来源：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000042727069">c++ - 查找文本行数的最快方法 (C) - SegmentFault 思否</a></p>
<p>请记住，所有 fstream 都是缓冲的。因此，它们实际上确实以块的形式读取，因此您不必重新创建此功能。所以你需要做的就是扫描缓冲区。不要使用 getline() ，因为这会迫使你调整字符串的大小。所以我只会使用 STL std::count 和流迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestEOL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        last    = c;</span><br><span class="line">        <span class="keyword">return</span> last == <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>    last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::fstream  <span class="title">file</span><span class="params">(<span class="string">&quot;Plop.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    TestEOL       test;</span><br><span class="line">    std::<span class="type">size_t</span>   count   = std::<span class="built_in">count_if</span>(std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(file),</span><br><span class="line">                                          std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(),</span><br><span class="line">                                          test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test.last != <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">// If the last character checked is not &#x27;\n&#x27;</span></span><br><span class="line">    &#123;                       <span class="comment">// then the last line in the file has not been</span></span><br><span class="line">        ++count;            <span class="comment">// counted. So increement the count so we count</span></span><br><span class="line">    &#125;                       <span class="comment">// the last line even if it is not &#x27;\n&#x27; terminated.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-10T13:28:48.000Z" title="2023/12/10 21:28:48">2023-12-10</time>发表</span><span class="level-item"><time dateTime="2023-12-10T13:37:56.937Z" title="2023/12/10 21:37:56">2023-12-10</time>更新</span><span class="level-item">2 分钟读完 (大约296个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/10/Cooperative-Path-Planning-of-Multi-Agent-Based-on-Graph-Neural-Network/">Cooperative Path Planning of Multi-Agent Based on Graph Neural Network</a></p><div class="content"><h1><span id="cooperative-path-planning-of-multi-agent-based-on-graph-neural-network">Cooperative Path Planning of Multi-Agent Based on Graph Neural Network</span></h1><h2><span id="摘要">摘要</span></h2><p>多智能体合作规划问题的目标是为每个智能体提供一条无障碍、高效率、无碰撞的路径，关键是智能体之间的有效沟通与合作。本文的研究范围是提出一种新颖的多智能体协调规划的合作方法。我们提出了一种在未知环境中进行多智能体路径规划的组合架构，每个智能体只有本地通信和本地观测，可以与其他智能体协作并分享感知信息。该架构由一个从本地感知中提取适当特征的卷积神经网络（CNN）、一个在智能体之间融合特征的图形采样和聚合门（GraphSAGE）以及一个将 GraphSAGE 的输出解码为行动原语的多层感知器（MLP）组成。我们对组合神经网络进行了训练和测试，并通过在未知环境中的多次模拟结果对所提出方法的整体功效进行了全面评估。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-06T04:54:22.000Z" title="2023/12/6 12:54:22">2023-12-06</time>发表</span><span class="level-item"><time dateTime="2023-12-06T11:05:29.515Z" title="2023/12/6 19:05:29">2023-12-06</time>更新</span><span class="level-item">10 分钟读完 (大约1524个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/06/Markdown-%E5%85%AC%E5%BC%8F%E4%B9%A6%E5%86%99/">Markdown 公式书写</a></p><div class="content"><h1><span id="markdown-公式书写">Markdown 公式书写</span></h1><h2><span id="公式风格">公式风格</span></h2><p>Markdown公式方面主要是用的Latex数学公式的写法（也是不完全相同，比Latax少了一些内容）。</p>
<p>Latex数学公式主要有两种，一种是行内公式（公式与文字相连，并被包裹），一种是行间公式（公式单独成行），例如$c^2 &#x3D; a^2 + b^2$就是行间公式，而：<br>$$<br>\begin{aligned}<br>c^2&#x3D;a^2 + b^2<br>\end{aligned}<br>$$<br>就是行间公式。<br>$$<br>\begin{equation}<br>c^2 &#x3D; a^2 + b^2<br>\end{equation}<br>$$<br>可以看到两种行间公式，一种是无编号行间公式，一种是有编号行间公式。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">行内公式使用$...$方式书写，如$c^2 = a^2 + b^2$</span><br><span class="line">无编号行间公式</span><br><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">...</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br><span class="line">有编号公式：</span><br><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">$$</span><br><span class="line">或者</span><br><span class="line">$$</span><br><span class="line">...</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>



<h2><span id="上下标以及希腊字母">上下标以及希腊字母</span></h2><p>上一段中可以看到公式是有上标的，即$c^2$，同样一个式子也可以有下标$c_i$。</p>
<p>Latex中使用“^+{…}”符号表示上标，并使用“__{…}”表示下标。具体来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$c^2 = a^2 + b^2$</span><br><span class="line">$C_i$</span><br></pre></td></tr></table></figure>

<p>记住“^”和“__”只对其后面的一个单位产生效果，所以什么是一个单位对象？a是一个单位对象，2也是一个单位对象，{2222}也是一个单位对象。例如，对于一个 3x3 矩阵的第一个矩阵元素来说，其下标写法应该是 </p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a_</span>&#123;<span class="number">11</span>&#125;<span class="variable">$</span>而不是<span class="variable">$a_11</span><span class="variable">$</span></span><br></pre></td></tr></table></figure>

<p>效果：$a_{11}$、$a_11$，这两个是完全不同的。同理对于上标符号也是一样的。&#x3D;&#x3D;一个良好的习惯（个人建议）是：尽量加{}，尽管这样编辑公式的时候可能看起来很长，且复杂，但是在显示的时候效果一样，而且不会出错，项与项之间最好也空一格。&#x3D;&#x3D;</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a<span class="emphasis">_&#123;11&#125;^&#123;2&#125; = a_</span>&#123;12&#125;^2 + a<span class="emphasis">_&#123;13&#125;^2</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>a_{11}^{2} &#x3D; a_{12}^2 + a_{13}^2<br>$$</p>
<p>上述式子也展示了，多个符号一同使用的效果，实际上，“^”和“__”对于同一对象并不强调使用顺序：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a^&#123;2&#125;<span class="emphasis">_&#123;11&#125; = a^2_</span>&#123;12&#125; + a^2<span class="emphasis">_&#123;13&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>a^{2}<em>{11} &#x3D; a^2</em>{12} + a^2_{13}<br>$$</p>
<p>$$</p>
<p>$$</p>
<p><strong>希腊字母表</strong>：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\alpha$</td>
<td>\alpha</td>
<td>$\lambda$</td>
<td>\lambda</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td>$\beta$</td>
<td>\beta</td>
<td>$\mu$</td>
<td>\mu</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\gamma$</td>
<td>\gamma</td>
<td>$\nu$</td>
<td>\nu</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\delta$</td>
<td>\delta</td>
<td>$\xi$</td>
<td>\xi</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
<tr>
<td>$\epsilon$</td>
<td>\epsilon</td>
<td>$\omicron$</td>
<td>\omicron</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\zeta$</td>
<td>\zeta</td>
<td>$\pi$</td>
<td>\pi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\eta$</td>
<td>\eta</td>
<td>$\rho$</td>
<td>\rho</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\theta$</td>
<td>\theta</td>
<td>$\sigma$</td>
<td>\sigma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\iota$</td>
<td>\iota</td>
<td>$\tau$</td>
<td>\tau</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\kappa$</td>
<td>\kappa</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>上述代码均是希腊字母小写，当把每一个代码的第一个字母大写后，就会得到它们的大写方式</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\Alpha$</td>
<td>\Alpha</td>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\Phi$</td>
<td>\Phi</td>
</tr>
<tr>
<td>$\Beta$</td>
<td>\Beta</td>
<td>$\Mu$</td>
<td>\Mu</td>
<td>$\Chi$</td>
<td>\Chi</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\Nu$</td>
<td>\Nu</td>
<td>$\Psi$</td>
<td>\Psi</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\Omega$</td>
<td>\Omega</td>
</tr>
<tr>
<td>$\Epsilon$</td>
<td>\Epsilon</td>
<td>$\Omicron$</td>
<td>\Omicron</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\Zeta$</td>
<td>\Zeta</td>
<td>$\Pi$</td>
<td>\Pi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\Eta$</td>
<td>\Eta</td>
<td>$\Rho$</td>
<td>\Rho</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\Iota$</td>
<td>\Iota</td>
<td>$\Tau$</td>
<td>\Tau</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\Kappa$</td>
<td>\Kappa</td>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>也存在希腊字母的变量写法</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\varepsilon$</td>
<td>\varepsilon</td>
<td>$\varGamma$</td>
<td>\varGamma</td>
</tr>
<tr>
<td>$\vartheta$</td>
<td>\vartheta</td>
<td>$\varDelta$</td>
<td>\varDelta</td>
</tr>
<tr>
<td>$\varkappa$</td>
<td>\varkappa</td>
<td>$\varTheta$</td>
<td>\varTheta</td>
</tr>
<tr>
<td>$\varpi$</td>
<td>\varpi</td>
<td>$\varLambda$</td>
<td>\varLambda</td>
</tr>
<tr>
<td>$\varrho$</td>
<td>\varrho</td>
<td>$\varXi$</td>
<td>\varXi</td>
</tr>
<tr>
<td>$\varsigma$</td>
<td>\varsigma</td>
<td>$\varPi$</td>
<td>\varPi</td>
</tr>
<tr>
<td>$\varphi$</td>
<td>\varphi</td>
<td>$\varSigma$</td>
<td>\varSigma</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varUpsilon$</td>
<td>\varUpsilon</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varPhi$</td>
<td>\varPhi</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varPsi$</td>
<td>\varPsi</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\varOmega$</td>
<td>\varOmega</td>
</tr>
</tbody></table>
<h2><span id="分式根式等结构">分式根式等结构</span></h2><table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\frac{abc}{xyz}$</td>
<td>\frac{abc}{xyz}</td>
<td>$\overline{abc}$</td>
<td>\overline{abc}</td>
<td>$\overrightarrow{abc}$</td>
<td>\overrightarrow{abc}</td>
</tr>
<tr>
<td>$\sqrt{abc}$</td>
<td>\sqrt{abc}</td>
<td>$\underline{abc}$</td>
<td>\underline{abc}</td>
<td>$\overleftarrow{abc}$</td>
<td>\overleftarrow{abc}</td>
</tr>
<tr>
<td>$\sqrt[n]{abc}$</td>
<td>\sqrt[n]{abc}</td>
<td>$\widehat{abc}$</td>
<td>\widehat{abc}</td>
<td>$\overleftrightarrow{abc}$</td>
<td>\overleftrightarrow{abc}</td>
</tr>
<tr>
<td>$a&#x2F;b$</td>
<td>&#x2F;</td>
<td>$\widetilde{abc}$</td>
<td>\widetilde{abc}</td>
<td>$\underrightarrow{abc}$</td>
<td>\underrightarrow{abc}</td>
</tr>
<tr>
<td>$\mid_{3}^{2}$</td>
<td>\mid_{3}^{2}</td>
<td>$\overbrace{abc}$</td>
<td>\overbrace{abc}</td>
<td>$\underleftarrow{abc}$</td>
<td>\underleftarrow{abc}</td>
</tr>
<tr>
<td>$\mathop{lim} \limits_{n \to \infty}$</td>
<td>\mathop{lim} \limits_{n \to \infty}（极限符号）</td>
<td>$\underbrace{abc}$</td>
<td>\underbrace{abc}</td>
<td>$\underleftrightarrow{abc}$</td>
<td>\underleftrightarrow{abc}</td>
</tr>
</tbody></table>
<h2><span id="函数名">函数名</span></h2><table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\arccos$</td>
<td>\arccos</td>
<td>$\arcsin$</td>
<td>\arcsin</td>
<td>$\arctan$</td>
<td>\arctan</td>
<td>$\arg$</td>
<td>\arg</td>
</tr>
<tr>
<td>$\cos$</td>
<td>\cos</td>
<td>$\cos$</td>
<td>\cos</td>
<td>$\cot$</td>
<td>\cot</td>
<td>$\inf$</td>
<td>\inf</td>
</tr>
<tr>
<td>$\csc$</td>
<td>\csc</td>
<td>$\deg$</td>
<td>\deg</td>
<td>$\det$</td>
<td>\det</td>
<td>$\dim$</td>
<td>\dim</td>
</tr>
<tr>
<td>$\exp$</td>
<td>\exp</td>
<td>$\gcd$</td>
<td>\gcd</td>
<td>$\hom$</td>
<td>\hom</td>
<td>$\max$</td>
<td>\max</td>
</tr>
<tr>
<td>$\ker$</td>
<td>\ker</td>
<td>$\lg$</td>
<td>\lg</td>
<td>$\lim$</td>
<td>\lim</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\limsup$</td>
<td>\limsup</td>
<td>$\ln$</td>
<td>\ln</td>
<td>$\log$</td>
<td>\log</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\min$</td>
<td>\min</td>
<td>$\Pr$</td>
<td>\Pr</td>
<td>$\sec$</td>
<td>\sec</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sin$</td>
<td>\sin</td>
<td>$\sup$</td>
<td>\sup</td>
<td>$\tan$</td>
<td>\tan</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2><span id="运算符">运算符</span></h2><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oYinHeZhiGuang/article/details/119943358">Markdown 数学符号大全_markdown数学符号-CSDN博客</a></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$+$</td>
<td>+</td>
<td>$&#x3D;$</td>
<td>&#x3D;</td>
<td>$&lt;$</td>
<td>&lt;</td>
<td>$\ast$</td>
<td>\ast</td>
</tr>
<tr>
<td>$-$</td>
<td>-</td>
<td>$\simeq$</td>
<td>\simeq</td>
<td>$&gt;$</td>
<td>&gt;</td>
<td>$\star$</td>
<td>\star</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
<td>$\cong$</td>
<td>\cong</td>
<td>$\leqslant$</td>
<td>\leqslant or \leq</td>
<td>$\circ$</td>
<td>\circ</td>
</tr>
<tr>
<td>$\div$</td>
<td>\div</td>
<td>$\sim  $</td>
<td>\sim</td>
<td>$\geqslant$</td>
<td>\geqslant or \geq</td>
<td>$\bullet$</td>
<td>\bullet</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
<td>$\approx $</td>
<td>\approx</td>
<td>$\ll$</td>
<td>\ll</td>
<td>$\bigcirc$</td>
<td>\bigcirc</td>
</tr>
<tr>
<td>$\pm$</td>
<td>\pm</td>
<td>$\doteq $</td>
<td>\doteq</td>
<td>$\gg$</td>
<td>\gg</td>
<td>$\diamond$</td>
<td>\diamond</td>
</tr>
<tr>
<td>$\mp$</td>
<td>\mp</td>
<td>$\equiv $</td>
<td>\equiv</td>
<td>$\prec$</td>
<td>\prec</td>
<td>$\circledast$</td>
<td>\circledast</td>
</tr>
<tr>
<td>$\centerdot$</td>
<td>\centerdot</td>
<td>$\not &#x3D;$</td>
<td>\not &#x3D;</td>
<td>$\succ$</td>
<td>\succ</td>
<td>$\circledcirc$</td>
<td>\circledcirc</td>
</tr>
<tr>
<td>$\divideontimes$</td>
<td>\divideontimes</td>
<td>$\ne$</td>
<td>\neq</td>
<td>$\propto$</td>
<td>\propto</td>
<td>$\circleddash$</td>
<td>\circleddash</td>
</tr>
<tr>
<td>$\amalg$</td>
<td>\amalg</td>
<td>$\triangleq$</td>
<td>\triangleq</td>
<td>$\cap$</td>
<td>\cap</td>
<td>$\lhd$</td>
<td>\lhd</td>
</tr>
<tr>
<td>$\odot$</td>
<td>\odot</td>
<td>$\models$</td>
<td>\models</td>
<td>$\cup$</td>
<td>\cup</td>
<td>$\rhd$</td>
<td>\rhd</td>
</tr>
<tr>
<td>$\ominus$</td>
<td>\ominus</td>
<td>$\approxeq$</td>
<td>\approxeq</td>
<td>$\subseteqq$</td>
<td>\subseteqq</td>
<td>$\triangleleft$</td>
<td>\triangleleft</td>
</tr>
<tr>
<td>$\oplus$</td>
<td>\oplus</td>
<td>$\backsimeq$</td>
<td>\backsimeq</td>
<td>$\supseteqq$</td>
<td>\supseteqq</td>
<td>$\triangleright$</td>
<td>\triangleright</td>
</tr>
<tr>
<td>$\otimes$</td>
<td>\otimes</td>
<td>$\doteqdot$</td>
<td>\doteqdot</td>
<td>$\Supset$</td>
<td>\Supset</td>
<td>$\unlhd$</td>
<td>\unlhd</td>
</tr>
<tr>
<td>$\Box$</td>
<td>\Box</td>
<td>$\fallingdotseq$</td>
<td>\fallingdotseq</td>
<td>$\supset$</td>
<td>\supset</td>
<td>$\unrhd$</td>
<td>\unrhd</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\risingdotseq$</td>
<td>\risingdotseq</td>
<td>$\supseteq$</td>
<td>\supseteq</td>
<td>$\bigtriangledown$</td>
<td>\bigtriangledown</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\leqq$</td>
<td>\leqq</td>
<td>$\in$</td>
<td>\in</td>
<td>$\bigtriangleup$</td>
<td>\bigtriangleup</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\lessapprox$</td>
<td>\lessapprox</td>
<td>$\ni$</td>
<td>\ni</td>
<td>$\perp$</td>
<td>\perp</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\lll$</td>
<td>\lll</td>
<td>$\notin$</td>
<td>\notin</td>
<td>$\parallel$</td>
<td>\parallel</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\geqq$</td>
<td>\geqq</td>
<td>$\nsubseteq$</td>
<td>\nsubseteq</td>
<td>$\Join$</td>
<td>\Join</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\geqslant$</td>
<td>\geqslant</td>
<td>$\nsupseteq$</td>
<td>\nsupseteq</td>
<td>$\ltimes$</td>
<td>\ltimes</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\gtrapprox$</td>
<td>\gtrapprox</td>
<td>$\nsubseteqq$</td>
<td>\nsubseteqq</td>
<td>$\blacktriangleleft$</td>
<td>\blacktriangleleft</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\ggg$</td>
<td>\ggg</td>
<td>$\nsupseteqq$</td>
<td>\nsupseteqq</td>
<td>$\blacktriangleright$</td>
<td>\blacktriangleright</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
<th>符号</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\infty$</td>
<td>\infty</td>
<td>$\forall$</td>
<td>\forall</td>
<td>$\cdots$</td>
<td>\cdots</td>
<td>$\angle$</td>
<td>\angle</td>
</tr>
<tr>
<td>$\therefore$</td>
<td>\therefore</td>
<td>$\exists$</td>
<td>\exists</td>
<td>$\vdots$</td>
<td>\vdots</td>
<td>$\measuredangle$</td>
<td>\measuredangle</td>
</tr>
<tr>
<td>$\because$</td>
<td>\because</td>
<td>$\nexists$</td>
<td>\nexists</td>
<td>$\ldots$</td>
<td>\ldots</td>
<td>$\sphericalangle$</td>
<td>\sphericalangle</td>
</tr>
<tr>
<td>$\nabla$</td>
<td>\nabla</td>
<td>$\empty \emptyset$</td>
<td>\empty or \emptyset</td>
<td>$\ddots$</td>
<td>\ddots</td>
<td>$\int$</td>
<td>\int</td>
</tr>
<tr>
<td>$\bigstar$</td>
<td>\bigstar</td>
<td>$\clubsuit$</td>
<td>\clubsuit</td>
<td></td>
<td></td>
<td>$\oint$</td>
<td>\oint</td>
</tr>
</tbody></table>
<h2><span id="矩阵写法">矩阵写法</span></h2><p>$$<br>\left[<br>\begin{matrix}<br>1 &amp; 2 \<br>3 &amp; 4 \<br>\end{matrix}<br>\right]<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[ </span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 \\</span><br><span class="line">3 &amp; 4 \\</span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right]</span><br><span class="line">\tag&#123;4&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>语法解释：{matrix} 矩阵标签值，一个标签必须有开始和结束， &amp; 对齐空格符， <code>\\</code>表示换行符。<code>\tag&#123;4&#125;</code>表示公式标号。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$<span class="string">\left\&#123;</span></span><br><span class="line"><span class="string">\begin&#123;matrix&#125;</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">3</span><span class="string">\\</span></span><br><span class="line"><span class="number">4</span> &amp; <span class="number">5</span> &amp; <span class="number">6</span> <span class="string">\\</span></span><br><span class="line"><span class="number">7</span> &amp; <span class="number">8</span> &amp; <span class="number">9</span></span><br><span class="line"><span class="string">\end&#123;matrix&#125;</span></span><br><span class="line"><span class="string">\right\&#125;</span></span><br><span class="line"><span class="string">\tag&#123;4&#125;</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>\left{<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right}<br>\tag{4}<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line"><span class="code">    \begin&#123;array&#125;&#123;c|cc&#125;</span></span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\ \hline</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">    \end&#123;array&#125;</span></span><br><span class="line"><span class="code">\right]</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>    \begin{array}{c|cc}<br>    1 &amp; 2 &amp; 3 \<br>    4 &amp; 5 &amp; 6 \<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\left[</span><br><span class="line"><span class="code">    \begin&#123;array&#125;&#123;l&#125;</span></span><br><span class="line"><span class="code">    1 &amp; 2 &amp; 3 \\ \hline</span></span><br><span class="line"><span class="code">    4 &amp; 5 &amp; 6 \\</span></span><br><span class="line"><span class="code">    7 &amp; 8 &amp; 9</span></span><br><span class="line"><span class="code">    \end&#123;array&#125;</span></span><br><span class="line"><span class="code">\right]</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>    \begin{array}{l}<br>    1 &amp; 2 &amp; 3 \ \hline<br>    4 &amp; 5 &amp; 6 \<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>$$</p>
<h2><span id="行列式写法">行列式写法</span></h2><p>$$<br>\left|<br>\begin{matrix}<br>1 &amp; 2 \<br>3 &amp; 4 \<br>\end{matrix}<br>\right|<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left|</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 \\</span><br><span class="line">3 &amp; 4 \\</span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right|</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\left(</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 \\</span><br><span class="line">3 &amp; 4 \\</span><br><span class="line">\end&#123;matrix&#125; </span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>



<h2><span id="多行公式">多行公式</span></h2><p>$$<br>\begin{cases}<br>a &#x3D; 1 \<br>b &#x3D; 2 \<br>cc &#x3D; 3 \<br>\end{cases}<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">a = 1 \\</span><br><span class="line">b = 2 \\</span><br><span class="line">cc = 3 \\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>如果希望等号可以对齐，则<br>$$<br>\begin{cases}<br>a &amp;&#x3D;&amp; 1 \<br>b &amp;&#x3D;&amp; 2 \<br>cc &amp;&#x3D;&amp; 3 \<br>\end{cases}<br>$$</p>
<p>不需要括号括起来的多行式子<br>$$<br>\begin{array}{l}<br>a &#x3D; 1 \<br>b &#x3D; 2 \<br>\end{array}<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;l&#125;</span><br><span class="line">a = 1 \\</span><br><span class="line">b = 2 \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p><strong>右大括号</strong><br>$$<br>\left.<br>\begin{array}{l}<br>a &#x3D; 1 \<br>b &#x3D; 2 \<br>\end{array}<br>\right }<br>$$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left. </span><br><span class="line">\begin&#123;array&#125;&#123;l&#125;</span><br><span class="line">a = 1 \\</span><br><span class="line">b = 2 \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right \&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<h2><span id="空格">空格</span></h2><table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$123~123$</td>
<td>123~123</td>
<td>空格距离：3&#x2F;18 em</td>
</tr>
<tr>
<td>$123\quad123$</td>
<td>123\quad123</td>
<td>空格距离：1 em</td>
</tr>
<tr>
<td>$123\qquad123$</td>
<td>123\qquad123</td>
<td>空格距离：2 em</td>
</tr>
</tbody></table>
<p>上表中的em是指当前文本中文本的字体尺寸</p>
<h2><span id="数学字母样式">数学字母样式</span></h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathcal&#123;A&#125;$</span><br></pre></td></tr></table></figure>

<p>$\mathcal{A}$、$\mathcal{B}$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathbb&#123;A&#125;$</span><br></pre></td></tr></table></figure>

<p>$\mathbb{A}$、$\mathbb{B}$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathbf&#123;A&#125;$</span><br></pre></td></tr></table></figure>

<p>$\mathbf{A}$、$\mathbf{B}$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathfrak&#123;A&#125;$</span><br></pre></td></tr></table></figure>

<p>$\mathfrak{A}$、 $\mathfrak{B}$</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\mathsf&#123;A&#125;$</span><br></pre></td></tr></table></figure>

<p>$\mathsf{A}$、$\mathsf{B}$</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-06T01:16:46.000Z" title="2023/12/6 09:16:46">2023-12-06</time>发表</span><span class="level-item"><time dateTime="2023-12-06T08:41:10.202Z" title="2023/12/6 16:41:10">2023-12-06</time>更新</span><span class="level-item">33 分钟读完 (大约4898个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/06/Overview-of-Multi-Agent-Path-Finding/">Overview of Multi-Agent Path Finding</a></p><div class="content"><h1><span id="overview-of-multi-agent-path-finding-mapf-翻译">Overview of Multi-Agent Path Finding (MAPF) 翻译</span></h1><p>作者：Wolfgang Hönig,∗ Jiaoyang Li, Sven Koenig — University of Southern California</p>
<h2><span id="1-introduction">1 Introduction</span></h2><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061621353.png" alt="image-20231206162124798"></p>
<p>多智能体路径搜索（MAPF）对于包括自动化仓储在内的许多应用都非常重要。例如，亚马逊订单执行中心（图 1）在仓库周边设有库存站（图中仅左侧显示），中心设有存储点。每个存储点可以存储一个库存舱。每个库存舱可存放一种或多种货物。大量仓库机器人在仓库中自主运行。每个仓库机器人一次可以拾取、搬运和放下一个库存吊舱。仓库机器人将库存吊舱从其存储位置移动到库存站，从库存吊舱中取出所需的货物（装箱并最终运送给客户），然后返回相同或不同的空存储位置，将库存吊舱归还[8]。亚马逊在其订单执行中心的地板上贴上贴纸，以划定栅格，实现机器人的稳健导航。然而，机器人的路径规划非常棘手，因为大部分仓库空间都用于存储位置，导致走廊狭窄，运载库存吊舱的机器人无法相互通过。准时化生产是自动化仓储的延伸，但迄今为止还没有商业安装。在准时化生产中，仓库的四周都是生产设备，而不是库存站。机器人在仓库和制造机器之间来回穿梭，一个方向运送原材料，另一个方向运送制成品。准时制生产增加了将所有所需原材料几乎同时运送到生产设备的重要性。<br>MAPF 问题是这些问题和许多其他多机器人或多智能体路径规划问题的简化版本，可描述如下： 在数字地图，一些单元被堵塞。所有阻塞单元的位置和数量已知，并且当前所有智能体的位置和数量也是已知的。为每个智能体分配一个不同的未堵塞单元作为其目标单元。问题是在离散的时间步长内，将智能体从当前单元移动到各自的目标单元，并让它们在那里等待。优化目标是最大限度地减少智能体的移动时间总和，直到它们到达目标小区（并能永远停留在那里）。在每个时间步长内，每个智能体可以在当前小区等待，也可以从当前小区向四个主要罗盘方向之一的未受阻邻近小区移动。一个智能体的路径是一系列移动和等待动作，这些动作将智能体从它的起始单元引向它的目标单元，或者，等同于它在每个时间步（从时间步 0 开始）执行这些动作时的单元序列。路径的长度就是智能体到达目标单元（之后永远停留在那里）之前的行进时间。一个解决方案由 n 条路径组成，每个智能体有一条路径。其成本是所有路径长度的总和。不允许智能体与环境或彼此发生碰撞。只有当且仅当两个智能体在同一时间步都位于同一单元时，它们才会发生碰撞（称为顶点碰撞或同义词顶点冲突），或者在同一时间步都移动到另一个智能体的当前单元时，它们才会发生碰撞（称为边碰撞或同义词边冲突）。(当另一智能体从 y 单元移动到与 x 和 y 单元不同的单元时，允许该智能体在同一时间步从其当前单元 x 移动到另一智能体的当前单元 y）。寻找无碰撞的最优解是 NP 难的 [9]。</p>
<h2><span id="2-mapf-example">2 MAPF Example</span></h2><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061428313MAPF.png" alt="image-20231206142849732"><br>图 2：我们的 MAPF 实例。圆圈代表起始单元。正方形代表目标单元。<br>图 2 显示了一个有两个智能体的 MAPF 实例，其中智能体 1 需要从当前单元 A 导航到目标单元 E，而智能体 2 需要从当前单元 B 导航到目标单元 D。其中一个最优无碰撞解（代价为 5）由智能体 1 的路径 [A, C, E]（长度为 2）和智能体 2 的路径 [B, B, C, D]（长度为 3）组成。另一个最优无碰撞解（成本也是 5）由智能体 1 的路径 [A, A, C, E]（长度为 3）和智能体 2 的路径 [B, B, C, D]（长度为 2）组成。</p>
<h2><span id="3-planning-in-joint-location-space">3 Planning in Joint Location Space</span></h2><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061429370MAPF.png" alt="image-20231206142931377"><br>图 3：我们的 MAPF 实例的联合位置空间，其中包含 20 个顶点和 36 条边。每个圆形顶点中的两个字母分别代表智能体 1 和 2 的单元。红圈和红线代表最优解，即智能体 1 的路径 [A、A、C、E]（长度为 3）和智能体 2 的路径 [B、C、D]（长度为 2）。<br>理论上，我们可以通过为所有智能体同时规划联合位置空间来找到 MAPF 实例的最佳无碰撞解决方案，方法是在一个图上找到一条最短路径，该图的顶点与单元元组相对应，即每个智能体有一个单元元组。图 3 显示了 MAPF 实例的图。然而，图的顶点数随智能体的数量呈指数增长，这使得这种搜索算法在实际应用中速度太慢。因此，我们需要开发能更好地利用问题结构的搜索算法，以提高效率。我们现在讨论两种这样的搜索算法，即优先规划和基于冲突的搜索。</p>
<h2><span id="4-prioritized-planning">4 Prioritized Planning</span></h2><p>优先级规划 [1] 通过为每个智能体分配不同的优先级，对智能体进行完全排序。然后，它按照优先级递减的顺序，一个接一个地为智能体规划路径。它为每个智能体找到一条不会与环境或所有优先级更高的智能体的（已规划的）路径相撞的路径（可以快速完成）。优先级规划虽然速度快，但却是次优的（也就是说，它并不总是能找到最优的无碰撞解决方案），甚至是不完整的（也就是说，即使存在无碰撞解决方案，它也并不总是能找到）。如果它找到了一个解，那么这个解是无碰撞的，但解的代价在很大程度上取决于智能体的优先级。关于优先级规划的更多信息，请参阅 [3]。<br>考虑我们的 MAPF 实例，假设智能体 1 的优先级高于智能体 2。那么，优先级规划首先为智能体 1 找到最短路径 [A、C、E]（长度为 2），之后为智能体 2 找到不与智能体 1 的路径相撞的最短路径 [B、B、C、D]（长度为 3）（结果是成本为 5 的无碰撞解）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061520492.png" alt="image-20231206152040980"><br>图 4：在我们的 MAPF 实例中，如果智能体 1 的优先级高于智能体 2，且智能体 1 的路径为 [A，C，E]，则智能体 2 的时空 A* 搜索树。每个椭圆形节点中的一对代表一个单元和一个时间步长。节点的 f 值是其 g 值（等于时间步长）和 h 值（等于其单元到环境中目标单元 D 的距离）之和。节点 (C,1) 被剪枝是因为智能体 1 在时间步长 1 时占据了单元格 C，而智能体 2 必须防止与智能体 1 发生顶点碰撞。红色节点和边代表智能体 2 的最优解，即路径 [B, B, C, D]。</p>
<p>优先规划使用时空 A* [7] 为每个智能体规划路径。顶点（x, t）与顶点（x, t + 1）之间有一条有向边，条件是且仅当智能体在时间步长为 t 时可以在单元 x 处等待。可以从时间步长 t 到时间步长 t + 1 从单元 x 移动到单元 y 6&#x3D; x。图 4 显示了在我们的 MAPF 实例中，智能体 2 的时空 A* 搜索树。</p>
<h2><span id="5-conflict-based-search">5 Conflict-Based Search</span></h2><p>基于冲突的搜索（CBS）[5, 6]首先为所有智能体独立规划最短路径（可以快速完成）。这些路径不会与环境发生碰撞，但允许与其他智能体的路径发生碰撞。如果这样做的结果是无碰撞解，那么它就找到了最佳无碰撞解。否则，它就会选择两个智能体之间的碰撞（例如，智能体 a 和 b 在时间步长 t 时都在 x 小区），并递归考虑两种情况，即一种是（负）约束条件禁止智能体 a 在时间步长 t 时出现在 x 小区，另一种是（负）约束条件禁止智能体 b 在时间步长 t 时出现在 x 小区。希望 CBS 在施加完所有可能的约束条件之前，就能找到无碰撞解。CBS 的速度比优先规划慢，但完整且最优。CBS 是一种两级搜索算法。下面我们将详细介绍它的运行过程。</p>
<p>高层 CBS 搜索二叉约束树。约束树的每个节点 N 包含 (1) 对智能体施加的一组约束，其中对智能体 a 施加的约束要么是（负）顶点约束〈a，x，t〉，即禁止智能体 a 在时间步长为 t 时出现在单元 x 中，要么是（负）边约束〈a，x，y，t〉，即禁止智能体 a 在时间步长为 t 时从单元 x 移动到单元 y； (2) 满足所有约束条件但不一定无碰撞的解决方案；以及 (3) 解决方案的成本。约束树的根节点包含一组空约束和一个由 n 条最短路径组成的解。高层对约束树执行最佳优先搜索，总是选择约束树中代价最小的边缘节点进行下一步扩展。如果节点之间的路径碰撞较少，则会打破平局，优先选择该节点<br>CBS 选择节点 N 进行扩展后，会检查节点 N 的解是否无碰撞。如果是，那么节点 N 就是目标节点，CBS 会返回它的解。否则，CBS 会选择其中一个碰撞节点，并通过拆分节点 N 来解决它。假设 CBS 选择解决一个顶点碰撞，在该碰撞中，智能体 a 和 b 在时间步长 t 时都在单元 x 中。在任何无碰撞解中，最多有一个智能体在时间步长 t 时在单元 x 中。因此，必须满足至少一个约束条件〈a，x，t〉（禁止智能体 a 在时间步骤 t 出现在单元格 x 中）或〈b，x，t〉（禁止智能体 b 在时间步骤 t 出现在单元格 x 中）。因此，CBS 通过生成节点 N 的两个子节点来拆分节点 N，每个子节点都有一个约束集，将这两个约束中的一个添加到节点 N 的约束集中。现在假设 CBS 选择解决边缘碰撞，即在时间步长 t 时，智能体 a 从单元 x 移动到单元 y，智能体 b 从单元 y 移动到单元 x。那么，新增的两个约束条件就是两条边约束条件〈a，x，y，t〉（禁止智能体 a 在时间步长 t 时从单元 x 移动到单元 y）和〈b，y，x，t〉（禁止智能体 b 在时间步长 t 时从单元 y 移动到单元 x）。<br>对于每个子节点，CBS 的低层都会根据新施加的约束条件为智能体找到一条新的最短路径，这可以通过时空 A* 快速完成（如前所述，在 [6] 中也有解释）。例如，顶点约束只是修剪搜索树中的一个特定节点。这条路径不会与环境发生碰撞，必须遵守子节点中对智能体施加的所有约束，但允许与其他智能体的路径发生碰撞。<br>请看我们的 MAPF 实例。图 5 显示了相应的约束树。其根节点 N 包含空约束集，低级 CBS 为智能体 1 找到最短路径 [A、C、E]（长度为 2），为智能体 2 找到最短路径 [B、C、D]（长度为 2）。因此，节点 N 的成本为 2 + 2 &#x3D; 4。节点 N 的解有一个顶点碰撞，即智能体 1 和 2 在时间步骤 1 时都在单元 C 中。因此，CBS 拆分了节点 N。节点 N 的新左子节点 N1 增加了约束条件〈1, C, 1〉。低级 CBS 在节点 N1 中为智能体 1 找到了长度为 3 的新的最短路径 [A，A，C，E]（其中包括一个等待动作），而智能体 2 的最短路径与节点 N 的路径完全相同，因为没有对智能体 2 施加新的约束。因此，节点 N1 的成本为 3 + 2 &#x3D; 5。同样，节点 N 的新右子节点 N2 增加了约束条件〈2, C, 1〉。低级 CBS 在节点 N2 中为智能体 2 找到了长度为 3 的新最短路径 [B, B, C, D]（其中包括一个等待动作），而智能体 1 的最短路径与节点 N 的路径完全相同，因为没有对智能体 1 施加新的约束条件。因此，节点 N2 的成本为 2 + 3 &#x3D; 5。现在，CBS 高层的最佳优先搜索选择约束树中成本最小的边缘节点进行下一步扩展。假设它打破了节点 N1 和 N2 之间的平局，选择了节点 N1。由于节点 N1 的解是无碰撞的，因此它是目标节点，CBS 返回其无碰撞解（代价为 5），该解由智能体 1 的路径 [A, A, C, E]（长度为 3）和智能体 2 的路径 [B, C, D]（长度为 2）组成。</p>
<h2><span id="6-additional-information">6 Additional Information</span></h2><p>Additional information on the MAPF problem and solution approaches can be found at http: &#x2F;&#x2F;mapf.info, a website that contains tutorials, publications, data sets, and additional software for MAPF.</p>
<h2><span id="记录">记录</span></h2><p>Just-in-time manufacturing：实时生产，实时加工</p>
<p>什么是实时生产？它是自动化仓储物流的一个延申，目前还没有商业实施。实时生产的场景：在一个仓库基地，原材料统一放置在仓库中，实时生产的机器就放置在货架的外围，自动化的机器人可以从货架上取出所需原材料，然后运送到生产机器上，生产机器进行加工包装，完成生产。该问题的实时性在于，原材料被取下后，能同时送到加工机器上。</p>
<p>多智能体路径规划定义：在一个栅格地图中，某些格子处于阻塞状态，并且，地图中阻塞格子和智能体的数量均是已知的，所有处于未被阻塞状态的格子均可以作为通行格，来分配给智能体，成为智能体由起始状态通向目标状态的路径的一部分，即 如果$cell_i$可通行，那么$cell_i$可以是智能体$Agent_i$的路径$path_i$的一部分。也即 $path_i &#x3D; [cell_i, cell_{i+1},…, cell_{i+x}]$。多智能体路径规划的解则是$n$条路径$solution &#x3D; [path_1, path_2, …, path_n]$，每个智能体都有自己的一条路径$path_i$。每个智能体不能产生碰撞，即智能体与智能体之间，智能体与障碍物都不会发生碰撞。$path_i(t) \cap path_i(t) \cap …\cap path_n(t) &#x3D;  \empty$</p>
<p>$num_blocked_cell$</p>
<p>MAPF问题的优化目标包括所有Agent的运行时间总和、路径距离总和等。在每个时间步中，每个智能体的状态转移包括：移动和原地等待。</p>
<p>什么是联合位置空间规划？</p>
<p>理论可行，并且能够实现同时性。人们可以在联合位置空间上同时为所有的智能体规划出一条无碰撞最优路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061428313MAPF.png" alt="image-20231206142849732"></p>
<p>联合位置空间图</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061429370MAPF.png" alt="image-20231206142931377"></p>
<p>联合位置空间图，由顶点和边组合，顶点是所有智能体当前所在网格组成的元组，边则表示可行的转移规则，即如果所有智能体可以由当前状态转移到另一个状态，则两个顶点之间存在一条边。</p>
<p>什么是优先级规划？</p>
<p>为智能体设置一个优先级（次序），按照这个优先级来进行路径规划。优先级规划可以为每一个智能体一个接一个的规划出一个无碰撞路径（智能体与智能体之间，智能体与障碍物之间）。</p>
<p>优点：相对较快。</p>
<p>缺点：</p>
<ul>
<li>路径是次优（并不总是能找到最优无碰撞解）</li>
<li>不完整性（即使存在最优无碰撞解，也不总是可以找到该解）</li>
</ul>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312061520492.png" alt="image-20231206152040980"></p>
<p>以上图为例，对智能体1设置一个更高的优先级，智能体2的优先级低于智能体1，那么优先级算法就会先给智能体构建一个路径[A, C, E]，随后智能体2进行搜索。</p>
<p>什么是基于冲突的搜索？基于冲突的搜索，首先为每个智能体规划出一条路径（这些路径不会与环境发生碰撞，但是可能会与其他智能体发生碰撞），规划好后，如果路径不存在冲突，则已经找到最优吴鹏路径，否则，解决冲突。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-06T00:45:30.000Z" title="2023/12/6 08:45:30">2023-12-06</time>发表</span><span class="level-item"><time dateTime="2023-12-06T01:07:07.075Z" title="2023/12/6 09:07:07">2023-12-06</time>更新</span><span class="level-item">3 分钟读完 (大约496个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/06/Windows%E4%B8%8Bboost%E5%AE%89%E8%A3%85/">Windows下boost安装</a></p><div class="content"><h1><span id="windows下boost库安装">Windows下boost库安装</span></h1><p><strong>Boost库</strong></p>
<p>Boost是一个功能强大、构造精巧、跨平台、开源并且完全免费的C++程序库，在1998年由Beman G.Dawes发起倡议并建立。使用了许多现代C++编程技术，内容涵盖字符串处理、正则表达式、容器与数据结构、并发编程、函数式编程、泛型编程、设计模式实现等许多领域，极大地丰富了C++的功能和表现力，能够使C++软件开发更加简洁、优雅、灵活和高效</p>
<p>在这里提前放一个Visual studio版本号 MSVC版本的对应表，后面可能用到</p>
<p>IDE	发布时间	工具集版本	MSC_VER	MSVC++	<br>Visual C++6.0	1998	V60	1200	MSVC++ 6.0	<br>Visual Studio 2002	2002	V70	1300	MSVC++ 7.0	<br>Visual Studio 2003	2003	V71	1310	MSVC++ 7.1	<br>Visual Studio 2005	2005	V80	1400	MSVC++ 8.0	<br>Visual Studio 2008	2008	V90	1500	MSVC++ 9.0	<br>Visual Studio 2010	2010	V100	1600	MSVC++ 10.0	<br>Visual Studio 2012	2012	V110	1700	MSVC++ 11.0	<br>Visual Studio 2013	2013	V120	1800	MSVC++ 12.0	<br>Visual Studio 2015	2015	V140	1900	MSVC++ 14.0	<br>Visual Studio 2017	2017	V141	1910	MSVC++ 14.1	<br>Visual Studio 2019	2019	V142	1920	MSVC++ 14.2	<br>Visual Studio 2022	2022	V143	1930	MSVC++ 14.3</p>
<p>Boost库下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/boost/files/boost-binaries/">Boost C++ Libraries - Browse &#x2F;boost-binaries at SourceForge.net</a></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312060858894.png" alt="image-20231206085806304"></p>
<p>msvc版本应该与自己的visual studio的版本相对应，比如说我的visual studio版本是2022，我会下载msvc 14.3的.exe文件。</p>
<h2><span id="linux系统下安装">Linux系统下安装</span></h2><p>也可以自己下载编译：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/boost/files/">Boost C++ Libraries - Browse Files at SourceForge.net</a></p>
<p>我在Linux系统下是这么做得，下载一个版本的tar文件，在Ubuntu系统下解压安装。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312060901208.png" alt="image-20231206090143539"></p>
<p>解压命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf boost*.tar.gz</span><br></pre></td></tr></table></figure>

<p>编译安装，–prefix 表示安装到&#x2F;usr目录下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd boost_1_80_0/</span><br><span class="line">./bootstrap.sh --with-libraries=all --with-toolset=gcc</span><br><span class="line">./b2 install --prefix=/usr</span><br></pre></td></tr></table></figure>

<p>配置环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile                               ## 打开环境配置文件， 在该文件最后增加如下两句</span><br><span class="line">export BOOST_PATH=&quot;/usr/local/include&quot;</span><br><span class="line">export BOOST_LIBS=&quot;/usr/local/lib&quot;</span><br></pre></td></tr></table></figure>

<p>source 一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source  /etc/profile                      ## source环境变量文件， 使其生效</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SUNX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SUNX</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/null"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_43571647?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">C++学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MATLAB/"><span class="level-start"><span class="level-item">MATLAB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/excel%E6%93%8D%E4%BD%9C/"><span class="level-start"><span class="level-item">excel操作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E5%88%9B/"><span class="level-start"><span class="level-item">原创</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路径规划</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="level-start"><span class="level-item">路径规划启发式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">路径规划算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-03T10:45:41.000Z">2024-03-03</time></p><p class="title"><a href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T06:17:52.000Z">2024-03-01</time></p><p class="title"><a href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T08:06:51.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T07:45:43.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/">Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-28T15:35:45.000Z">2024-02-28</time></p><p class="title"><a href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%AD%A6%E4%B9%A0/"><span class="tag">C++学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLion%E5%AE%89%E8%A3%85/"><span class="tag">CLion安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GDAL/"><span class="tag">GDAL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hierachical/"><span class="tag">Hierachical</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MAPF/"><span class="tag">MAPF</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Q1/"><span class="tag">Q1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XTDrone/"><span class="tag">XTDrone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pandas/"><span class="tag">pandas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82/"><span class="tag">分层</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"><span class="tag">分层方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"><span class="tag">原文翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"><span class="tag">可视图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="tag">启发式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">图论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"><span class="tag">多智能体</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="tag">离散数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"><span class="tag">维诺图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%BC%E8%BF%B0/"><span class="tag">综述</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a><p class="is-size-7"><span>&copy; 2024 SUNX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>