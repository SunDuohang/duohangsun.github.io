<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SUNX的记录</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SUNX的记录"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SUNX的记录"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天的天气不错"><meta property="og:type" content="blog"><meta property="og:title" content="SUNX的记录"><meta property="og:url" content="https://duohangsun.gitee.io/"><meta property="og:site_name" content="SUNX的记录"><meta property="og:description" content="今天的天气不错"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duohangsun.gitee.io/img/og_image.png"><meta property="article:author" content="SUNX"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://duohangsun.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://duohangsun.gitee.io"},"headline":"SUNX的记录","image":["https://duohangsun.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"SUNX"},"publisher":{"@type":"Organization","name":"SUNX的记录","logo":{"@type":"ImageObject","url":"https://duohangsun.gitee.io/img/logo.svg"}},"description":"今天的天气不错"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?69225dadb01d44aae3f8c4f29649a59d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-16T11:37:59.000Z" title="2024/2/16 19:37:59">2024-02-16</time>发表</span><span class="level-item"><time dateTime="2024-02-25T03:50:25.197Z" title="2024/2/25 11:50:25">2024-02-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">29 分钟读完 (大约4312个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/16/A-review-On-path-planning-strategies-for-navigation-of-mobile-robot/">A review: On path planning strategies for navigation of mobile robot</a></p><div class="content"><h1><span id="a-review-on-path-planning-strategies-for-navigation-of-mobile-robot">A review: On path planning strategies for navigation of mobile robot</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402161939446.png" alt="image-20240216193925254"></p>
<h2><span id="abstract">Abstract</span></h2><p>本文对迄今为止使用的移动机器人导航技术进行了深入研究。本文对经典方法和反应式方法进行了逐步研究，以了解各种环境条件下路径规划策略的发展，并找出研究差距。经典方法包括单元分解法（CD）、路线图法（RA）和人工势场法（APF）； 研究考虑了遗传算法 (GA)、模糊逻辑 (FL)、神经网络 (NN)、萤火虫算法 (FA)、粒子群优化 (PSO)、蚁群优化 (ACO)、细菌觅食优化 (BFO)、人工蜂群 (ABC)、布谷鸟搜索 (CS)、洗牌蛙跳算法 (SFLA) 和其他杂项算法 (OMA) 等反应式方法。对静态和动态条件下的导航进行了分析（针对单个和多个机器人系统），结果表明，与传统方法相比，反应式方法更加稳健，在所有地形下均表现良好。同时还发现，作为一种混合算法，反应式方法可用于提高经典方法的性能。因此，反应式方法在移动机器人的路径规划中更为流行和广泛。本文最后以表格数据和图表的形式比较了各种导航策略的使用频率，这些策略可用于机器人技术中的特定应用。</p>
<h2><span id="introduction">Introduction</span></h2><p>最初，移动机器人的应用仅限于制造业。但如今，它已普遍应用于娱乐、医疗、采矿、救援、教育、军事、太空、农业等领域。在执行导航任务时，机器人配备了许多智能设备，这些设备需要对环境进行建模、定位、控制运动、检测障碍物，并利用导航技术避开障碍物。从初始位置到目标位置的安全路径规划（通过检测和避开障碍物）是任何导航技术最重要的功能。因此，在简单和复杂的环境中工作时，正确选择导航技术是机器人路径规划中最重要的一步。目前，不同研究人员在移动机器人导航领域开发了许多技术，是当今研究最多的课题。移动机器人导航分为三类：全局导航、局部导航和个人导航。全局导航能够确定环境中各元素相对于参考轴的位置，并朝着预先确定的目标前进。局部导航涉及环境动态条件的识别和各种元素之间位置关系的建立。通过考虑环境中各种元素的位置，处理它们之间的相对关系，这就是个人导航。机器人运行的基本步骤[1]如图 1 所示。</p>
<p>本文根据路径规划所需的先验环境信息对导航策略进行了分类。大致可分为全局导航和局部导航。在全局导航中，移动机器人必须先获得环境、障碍物位置和目标位置的信息，而在局部导航中，移动机器人不需要先获得环境信息。全局导航策略处理的是完全已知的环境。局部导航策略处理的是未知和部分已知的环境。已知环境下的路径规划算法基于传统方法，如 CD、RA 和 APF。这些算法都很传统，智能性有限。本地导航方法被称为反应式方法，因为它们更加智能，能够自主控制和执行计划。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162036016.png" alt="image-20240216203638727"></p>
<p>许多研究人员都提交了有关移动机器人导航的调查论文[2-3]，但这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在找出特定领域的研究空白和创新范围。它深入分析了静态环境、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合、在三维（3D）环境中的应用以及在军事或国防设备中的应用等方面的单项算法。调查还强调了经典方法和反应方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。参考文献[2]的重点是 “在特定的环境中”。2]主要关注基于本地传感器信息的反应式方法、滑动模式控制和基于分散式 MPC 的方法，而参考文献[3]则仅限于三维环境。[3] 则仅限于三维路径规划。</p>
<p>第 2 节将导航策略分为传统方法和被动方法。第 3 节讨论文献调查，第 4 节为结论。</p>
<h2><span id="2-navigational-techniques-used-for-mobile-robot-navigation">2. Navigational techniques used for mobile robot navigation</span></h2><p>几十年来，各类研究人员和科学家提供了大量导航方法。用于移动机器人导航的各种方法大致分为两类，即经典方法和反应方法（图 2）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162044040.png" alt="image-20240216204419104"></p>
<h3><span id="21-classical-approaches">2.1. Classical approaches</span></h3><p>最初，经典方法在解决机器人导航问题方面非常流行，因为当时还没有开发出人工智能技术。使用经典方法执行任务时，要么会得到结果，要么会确认结果不存在。这种方法的主要缺点是计算成本高，无法对环境中存在的不确定性做出反应，因此不太适合实时执行。本文将对 CD、RA 和 APF 等经典方法进行综述。</p>
<h4><span id="211-cell-decomposition-cd-approach">2.1.1. Cell decomposition (CD) approach</span></h4><p>这种方法将区域划分为不重叠的网格（单元），并使用连接图从一个单元穿越到另一个单元，以实现目标。在遍历过程中，考虑纯单元（无障碍单元），以实现从初始位置到目标位置的路径规划。在确定从初始位置到目标位置的最佳路径时，路径中存在的损坏单元格（包含障碍物的单元格）会被进一步分割成两个新单元格，从而得到一个纯单元格，这个纯单元格会被添加到序列中。在 CD 方法中，初始位置和目标位置分别由起点和终点单元表示。连接这两个位置的纯单元序列表示所需的路径 [4-5]。CD 方法分为自适应、近似和精确三种。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162051037.png" alt="image-20240216205137828"></p>
<p>在图 3 所示的精确单元分解法[6-7]中，单元没有特定的形状和大小，但可以根据环境地图、形状和其中障碍物的位置来确定。这种方法以多种方式使用规则网格。首先，将环境中可用的自由空间分解成小元素（梯形和三角形），然后为每个元素编号。环境中的每个元素都是连接图的一个节点。相邻的节点可以在配置空间中连接起来，该图中的一条路径相当于自由空间中的一条分道线，由连续的条纹单元勾勒出来。该图中的一条路径与自由空间中的一个网络相连，该网络由连续的条纹单元格勾勒而成。然后，通过通道中相邻单元格交叉点的中点，将底层布置与目标设计连接起来，从而将该通道转换为自由通道。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162053916.png" alt="image-20240216205302554"></p>
<p>在近似单元分解法[8-9]中，规划空间被用来定义具有特定形状和大小的规则网格，因此很容易实现。在空间中，物体的边界不应与之前确定的单元边界相匹配，因此被称为近似。在这种导航方法中，如果物体占据了网格空间，就会被视为障碍物，否则就会被视为空白空间。在搜索区域的寻路过程中，每个单元格的中心被假定为一个节点。图 4 显示了 4 节点和 8 节点连接系统，机器人必须在它们之间以对角线方式行进。自适应单元分解可以理解自由空间中存在的信息，并遵循常规单元分解中避开自由空间的基本概念。Samet [10] 和 Noborio [11] 提出了一种四重自适应分解法。它将环境划分为大尺寸的单元格，但当网格单元被部分占用时，它会将单元格划分为四个相等的子部分，直到单元格变空为止。图 5 显示了在不同大小的网格单元触及障碍物边界时产生的工作空间地图。该系统有一个缺点，即在获得新数据（障碍物的新位置）时无法更新程序，因此在动态环境中会失效。Lingelbach [12] 对高维静态配置空间中的路径规划问题进行了论证。他解决了链状机器人平台和迷宫环境的路径规划问题。Rosell 等人[13] 将谐函数应用于 C 形障碍物环境中的单元分解，而 Sleumer 等人[14] 则提出了基于 CAD 信息的移动机器人路径规划策略。Cai 等人[15] 提出了一种基于传感器的近似单元分解策略，用于对复杂环境中的多个固定目标进行分类。该方法在静态环境中的表现优于最短路径，并能完全覆盖环境。Dugarjav 等人[16] 提出了同样的基于传感器的单元分解模型，用于处理移动机器人任务中的未知直线工作空间。他们将 CD 方法与激光扫描机制结合使用，以避开未知环境中的物体。Glavaski 等人[17] 提出了一种混合方法，以填补路径规划问题中理论成果与实际考虑之间的差距。他们开发了一种基于 APF 的精确单元分解路径规划器，以降低计算成本。为了在不确定的环境中执行，Tunggal 等人[18]提出了实时运行的 FL 和 CD。为了在三维环境中同时处理多个活动，Mark 等人[19] 提出了一种贪婪深度优先搜索算法和基于 GA 的单元分解方法，用于机械手的路径规划。Gonzalez 等人[20]通过改变所涉及的单元分解、图权重和计算航点的程序，对轨迹进行了定量研究。Wahyunggoro 等人[21]将单元分解方法应用于探索三维环境的空中导航问题。在这种方法中，模糊逻辑与单元分解方法相结合，用于引导和控制航空飞行器。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162102538.png" alt="image-20240216210253583"></p>
<h3><span id="212-roadmap-approach-ra">2.1.2. Roadmap approach (RA)</span></h3><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402162103361.png" alt="image-20240216210342486"></p>
<p>RA 也被称为高速公路方式。它是从一个地方到达另一个地方的方法，自由空间之间的连接用一组一维曲线来表示[22]。当路线图绘制完成后，规划者就可以将其作为同质道路的排列方式，从而发现理想的排列方式。在这里，节点在为机器人找到理想路径中扮演着重要角色。RA用于寻找从机器人初始位置到目标位置的最短路径；Voronoi图和可见性图用于绘制路线图。可见度图法将初始位置和目标位置与地图上的节点连接起来。图 6 表示可见度图，其中暗区表示障碍物，虚线表示从初始位置到最终位置的相应路径 [23]。这种方法也可用于多边形障碍物环境，其中多边形的顶点由节点表示，边则是节点之间的连接[24]。Voronoi 图 [2527] 是另一种用于机器人路径规划的路线图算法。这种方法将区域划分为若干子区域，图中的所有边都是利用障碍物边界上相邻两点的等距点来构建的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402242119612.png" alt="image-20240224211934401"></p>
<p>图 7 显示了 Voronoi 图的工作原理。文献[28-30]介绍了 Voronoi 图在移动机器人绕障碍物导航领域的应用。为了提高性能，消除 Voronoi 图中的急转弯和长循环等缺点，对有效路径规划进行了一些改进[31]。混合方法是通过结合可见度图、沃罗诺图和势场方法 [32] 来实现路径优化。据观察，该方法无法获得最佳路径，且执行过程复杂。为了成功利用 Voronoi 图进行路径规划，Yang 等人[33]采用了骨架图等多种策略。Wein 等人[34]提出了一种结合使用可见性图和 Voronoi 图的方法，以获得最佳路径。Kavraki 等人[35]提出将概率应用于 RA，以理解和生成路径规划的解决方案。然而，这种方法在获得最佳路径长度方面效率较低。为了改进寻找最短路径的过程，Sanchez 等人[36] 对概率路线图方法（PRM）进行了细微的改进。在他们的方法中，将懒碰撞检查策略与 PRM 结合起来，以解决真实环境中的路径规划问题。Yan 等人[37]成功测试了无人飞行器在三维环境中的导航。在该方法中，路线图方法采用概率公式来控制飞行路线。</p>
<h3><span id="213-artificial-potential-field-apf-approach">2.1.3. Artificial potential field (APF) approach</span></h3><p>Khatib [38] 于 1986 年提出了用于移动机器人导航的 APF 方法。他认为，目标和障碍物就像带电表面，总电势会对机器人产生假想力。如图 8 所示，这种假想力会吸引机器人朝目标前进，并使其远离障碍物。在这里，机器人沿着负梯度避开障碍物，到达目标点。Garibotto 等人[39]介绍了这种方法在移动机器人导航中的应用。Kim 等人[40] 利用 APF 讨论了在未知环境中的一种新的避障策略。他们使用谐函数来避免局部最小值问题。Borenstein 等人[41] 也提出了局部最小值条件问题的解决方案。在这项研究中，他们考虑了机器人导航的动态特性。文献[42-43]对动态环境中的避障 APF 进行了分析。利用静电定律对 APF 方法进行了一些改进 [44]。静电法的实施有助于产生势函数和实时确定无碰撞路径。在实时环境中移动避障并非易事，因此 Huang [45] 开发了一种速度控制机制，以便在实现目标的同时了解障碍物的位置和速度。为了避免局部最小值并实现全局最优，Shi 等人[46] 引入了上位势函数和上位斥势函数。Sfeir 等人[47] 通过振荡和冲突等 APF 方法解决了移动机器人导航中的观测问题。他们提出了一种改进版的 APF，当目标靠近障碍物时，可将振荡和冲突最小化。为了测试 APF 的适用性，Pradhan 等人 [48] 使用了 ROBOPATH 仿真工具。他们考虑了各种环境条件下的多个移动机器人，观察到在无碰撞的情况下，协调策略的效果更好。为了提高 APF 路径规划器的性能，它与许多技术结合使用，如 BFO [49]（如图 9 所示）、GA[50]、PSO [51] 和 FL [52]。在三维空中和水下条件下导航是一项具有挑战性的任务，但 Cetin 等人[53]和 Li 等人[54]分别使用 APF 方法取得了成功。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-05T00:53:17.000Z" title="2024/2/5 08:53:17">2024-02-05</time>发表</span><span class="level-item"><time dateTime="2024-02-14T15:31:24.484Z" title="2024/2/14 23:31:24">2024-02-14</time>更新</span><span class="level-item">2 小时读完 (大约16162个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/05/The-2-k-Neighborhoods-for-Grid-Path-Planning/">The 2^k Neighborhoods for Grid Path Planning</a></p><div class="content"><h1><span id="the-2k-neighborhoods-for-grid-path-planning">The 2k Neighborhoods for Grid Path Planning</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050854007.png" alt="image-20240205085418878"></p>
<h2><span id="abstract">Abstract</span></h2><p>网格路径规划是人工智能领域的一个重要问题。对它的理解是开发自主导航系统的关键。在有关这一问题的大量文献中，一个有趣而又令人惊讶的事实是，在评估这些算法时，只使用了少数几个邻域。事实上，通常只考虑 4 邻域和 8 邻域，很少考虑 16 邻域。本文介绍了三方面的贡献，这些贡献使得我们能够为扩展的 2k 邻域（即每个状态有 $2^k$ 个邻域，其中 k 是一个参数）构建有效的网格路径规划器。首先，我们根据 2k-1 邻域为 2k 邻域提供了一个简单的递归定义。&#x3D;&#x3D;其次，我们推导出任意 k ≥ 2 的距离函数，从而提出了完美适用于无障碍网格的可接受启发式方法，这些方法概括了著名的曼哈顿距离和奥克蒂尔距离&#x3D;&#x3D;。第三，&#x3D;&#x3D;我们定义了 2k 邻域的典型路径概念；这使我们能够将邻域纳入两个版本的 A* 中，即典型 A* 和跳点搜索（JPS）。&#x3D;&#x3D;与 $2^k$ 邻域一起使用时，Canonical A* 和 JPS 在许多配置下，无论在解决方案质量还是运行时间方面，都优于任意角度路径规划器 Theta∗。在某些配置下，我们的规划器与任意角度路径规划器 ANYA 的一种实现具有竞争性。我们的主要实践结论是，标准的、广为人知的网格路径规划技术可以为任意角度网格路径规划提供有效的方法。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>网格路径规划是人工智能领域最著名的问题之一。当把二维空间中的目标导航问题建模为网格上的图搜索问题时，它就自然而然地产生了。</p>
<p>网格路径规划在机器人（Lee &amp; Yu，2009 年）和视频游戏（Bj ̈ornsson, Enzenberger, Holte, &amp; Schaeffer，2005 年）等领域都有大量应用。此外，它仍然吸引着人工智能界的大量关注。值得注意的是，最近已经举办了三届网格路径规划竞赛（GPPC）（Sturtevant 等人，2015 年），对该领域的最新进展进行了检验（Botea 和 Harabor，2013 年；Harabor 和 Grastien，2011 年；Uras、Koenig 和 Hern ́andez，2013 年）。</p>
<p>有关网格路径规划的研究主要集中在简单的 4 邻网格（其中允许进行心形移动）和 8 邻网格（通过对角线移动扩展 4 邻移动）。造成这种情况的主要原因可能是这些邻域易于实现，而且人们对它们有很好的启发式方法。事实上，曼哈顿距离和 Octile 距离 (Sturtevant &amp; Buro, 2005) 分别是 4 邻域和 8 邻域无障碍网格的完美启发式方法。虽然计算机视觉领域的研究人员已经发现并研究了 16 邻域的距离函数（Marchand-Maillet &amp; Sharaiha, 1997），但据我们所知，对 16 邻域网格路径规划的评估（如 Nash, 2012; Aine &amp; Likhachev, 2016）从未考虑过这些启发式方法，而是使用了欧氏距离 (ED)。</p>
<p>针对无障碍网格的完美启发式方法可以让 A* 等规划者更快地找到解决方案。它们经常是其他网格路径规划技术的关键推动因素。其中一个例子是 Uras 等人（2013 年 GPPC 最佳轨迹奖得主）的方法，该方法主要依靠 Octile 距离计算子目标图，然后利用子目标图进行快速路径规划。另一个例子是 FRIT（Rivera, Illanes, Baier, &amp; Hern ́andez，2014 年），这是一种最先进的实时启发式搜索路径规划算法，其性能依赖于构建所谓的理想树，并使用 Octile&#x2F;Manhattan 启发式。</p>
<p>在使用 4 个和 8 个相邻网格寻找路径时，一个重要的问题是任意角度路径的次优性。这个问题也被称为数字化偏差（Tsitsiklis，1995；Hew，2017）。直观地说，由于只允许少数棋步产生后继棋子，因此路径无法弯曲到实现最优所需的角度。事实上，Bailey、Tovey、Uras、Koenig 和 Nash（2011 年）对 4 邻角和 8 邻角路径规划的次优化问题进行了详细研究，并确定 4 邻角和 8 邻角最优解的成本与任意角度最优解的成本最多分别相差 $\sqrt{2} \approx 1.414$倍和$ \sqrt{4 - 4 \sqrt{2}} \approx 1.08$ 倍(These results are obtained by Bailey et al. (2011) when the vertices of the search graph are placed at the corners of the grid cells.)。</p>
<p>为了在应用图搜索算法的同时找到质量更好的解决方案，研究人员对 A* 进行了扩展，使其能够找到具有更大角度多样性的移动（如 Daniel、Nash、Koenig 和 Felner，2010 年），并提出了可以直接考虑利用任意角度的路径的算法（如 Harabor、Grastien、Oz 和 Aksakalli，2016 年）。另一个文献中尚未深入考虑的方案是增加邻域的大小。</p>
<p>在本文中，我们将研究 2k 邻域上的网格路径规划，即在给定参数 k 的情况下，定义 2k 次移动的邻域。我们的第一个贡献是定义了这种邻域。我们证明的一个显著特性是，包含移动的最小正方形的半径由斐波那契数列给出。此外，我们还推导并证明了一种算法的正确性，该算法可以返回 2k 邻域上无障碍网格中任意两点之间的距离。我们的证明和构造适用于任意 k，从而推广了曼哈顿距离、Octile 距离以及 Marchand-Maillet 和 Sharaiha 的距离函数。不过，我们的证明似乎比 Marchand-Maillet 和 Sharaiha 对 16 邻域的证明要短得多，也简单得多。最后，我们定义了 2k 邻域的规范排序（Harabor &amp; Grastien, 2011; Sturtevant &amp; Rabin, 2016）。典型排序是跳点搜索（JPS）（Harabor &amp; Grastien，2011 年）的核心技术，是 8 连接网格路径规划最快的搜索算法之一。</p>
<p>我们实现了三种 2k 路径规划器：常规 A<em>、带有我们的规范排序的 A</em>，以及 2k 版本的 JPS。我们通过标准基准对它们进行了评估。我们测试了不同的 k 值，并将我们的 2k-tile 启发式与 ED 进行了比较。Canonical A* 和 JPS 的运行时间随 k 值变化，而常规 A* 则不然。与 ED 相比，我们的启发式搜索在常规 A* 的每个邻域以及 Canonical A* 的 8 邻域中都更快。我们还比较了任意角度路径规划器 Theta* （丹尼尔等人，2010 年）和 ANYA 的两个实现（Harabor 和 Grastien，2013 年；Harabor 等人，2016 年）：Uras 和 Koenig（2015 年）的版本以及 Harabor 等人报告的版本（2016 年）。ANYA 的优化版本（Harabor 等人，2016 年）在运行时优于我们的实现，而我们在许多配置中优于 Theta*。</p>
<p>我们在本文中报告的研究包括并扩展了之前发表的 AAAI17 论文（Rivera, Hern ́andez, &amp; Baier, 2017）。以下项目描述了 AAAI 出版物中未包含的材料。</p>
<ul>
<li><p>我们提出了一个新的迭代启发式函数，并证明了其正确性。该函数之前已在另一份会议出版物中发表（Hormaz ́abal, Dı ́az, Hern ́andez, &amp; Baier, 2017）。</p>
</li>
<li><p>我们讨论并评估了 2k 版本的 JPS。</p>
</li>
<li><p>我们考虑的是智能体站在单元格四角而非中间时的路径规划问题。我们之所以采用这种不同的观点，是因为在 4 联接和 8 联接的网格中，这样会产生成本更低（最优）的解决方案（Bailey 等人，2011 年）。</p>
</li>
<li><p>我们扩展了实验结果，展示了不同类型基准（游戏地图、房间和随机）的性能。</p>
</li>
<li><p>我们用一个关于我们提出的启发式 h2k 的一致性的附加定理（定理 10）扩展了理论结果。此外，我们还提供了所有定理的完整证明。</p>
</li>
<li><p>在所有基准测试中，我们将任意角度路径规划器 Theta* 和 ANYA 进行了比较。</p>
</li>
</ul>
<p>接下来，我们介绍背景信息，然后定义 $2^k$ 邻域。然后，我们推导出 2k-tile 启发式。我们将继续提出我们的典型排序，最后给出我们的经验评估和结论。</p>
<h2><span id="2-background">2. Background</span></h2><p>在本节中，我们将回顾网格路径规划的基础知识，并介绍最常用的邻域。</p>
<h3><span id="21-grid-path-planning">2.1 Grid Path Planning</span></h3><p>N × M 网格是一个元组（C, O），其中 C &#x3D; {(i, j) ∈ N × N | 0 ≤ i &lt; N, 0 ≤ j &lt; M } 是单元格集合，O ⊆ C 是障碍单元格集合。单元格 (i, j) 的四个角分别是 (i, j) （左下角）、 (i + 1, j) （右下角）、 (i, j + 1) （左上角）、 (i + 1, j + 1) （右上角）。</p>
<p>在网格路径规划文献中，对于智能体在网格中移动时可能位于的位置有两种假设。第一种是更传统的假设，即智能体位于单元的中心。第二种假设是，智能体位于某个单元的某个角落。在本文的其余部分，我们采用第二种观点，因为（1）在考虑扩展邻域时，这种观点简化了表述；（2）在 4 连网格和 8 连网格中，使用这种假设找到的路径更短，更接近真正的最优路径（Bailey 等，2011 年）。持这种观点的另一个重要原因是，Kramm、Rivera、Hern ́andez 和 Baier（2018）最近的研究表明，当 k 增大且顶点位于单元的角落时，最优路径的代价可以证明更接近于任意角度最优路径，而顶点位于单元中心时则不是这种情况。当然，这种观点的一个后果是，智能体的移动非常接近障碍物单元格；事实上，它 “触及 “了障碍物。虽然这可能被视为一个缺点，但它与传统的任意角度文献是一致的（参见图 2；Harabor 等人，2016 年）。</p>
<p>与网格（C，O）相关联的搜索图中，C 中每个单元的每个角都有一个顶点。搜索图的边由智能体可以执行的移动决定。每个移动都是一对有序整数。移动的集合称为邻域。</p>
<p>在本文的其余部分，我们使用有序对来表示二维中的移动和点。我们将这些对解释为二维向量。因此，我们假设以下等式成立：$(x, y) + (x′′, y′) &#x3D; (x + x′, y + y′)$，以及 c(x, y) &#x3D; (cx, cy)。我们用黑体表示有序对。我们用符号 [a, b] 来表示实数区间 ${x∈R | a ≤ x ≤ b}$，用 ]a, b[ 来表示 ${x∈R | a &lt; x &lt; b}$ 。单元格 c 的内部是点 ${c + μ(0, 1) + ν(1, 0) | μ, ν ∈ ]0, 1[}$ 的集合。单元 c 的边界是 ${c + μ(0, 1) + ν(1, 0) | μ, ν ∈ [0, 1]}$ 中不在 c 内部的点。最后，如果存在两个非负数 α 和 β，使得 $(x, y) &#x3D; αm + βm′$，那么我们说 (x, y) 被两个移动 m 和 m′ 所包含。 	</p>
<p>在 p 中应用移动 m 所访问的点的集合是 {p + λm | λ∈ ]0, 1[}。在以下情况下，移动 m 适用于顶点 u：</p>
<ol>
<li><p>$u + m$ 是图形的一个顶点，并且</p>
</li>
<li><p>m 在 u 中应用时访问的点不包含：</p>
<p>(a) 障碍单元内部的点</p>
<p>(b) 两个单元格边界的交点(2. Note that the intersection of the borders of two cells can be nonempty only if those cells are adjacent.)</p>
</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050933606.png" alt="image-20240205093349456"></p>
<p>一个 3 × 3 的网格，显示了适用的棋步（蓝色）和不适用的棋步（红色）。移动（1，3）不适用于顶点（0，0），因为它访问了单元格（0，1）内部的点。此外，移动（0，1）也不适用于顶点（1，1），因为它访问的点位于单元格（0，1）和（1，1）边界的交叉点上。</p>
<p>关于适用和不适用移动的说明，请参见图 1。顶点 u 的后继集定义为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050934688.png" alt="image-20240205093439758"></p>
<p>N 上从 u 到 v 的路径是顶点 v1v2 - - vn 的序列，其中 v1 &#x3D; u，vn &#x3D; v，并且对于每个 i∈ {1, . , n - 1}，vi+1∈SuccN (vi)成立。请注意，这个定义意味着路径可以挤过对角线上的障碍物；在图 1 中，路径 (1, 0)(2, 1)(2, 2) 是合法的。对于每个 i∈ {1, . . . , n - 1}. 如果在 N 上存在一条以 v1 为起点、以 v2 为终点的路径，那么两个顶点 v1 和 v2 在 N 上是可到达的。</p>
<p>路径 σ &#x3D; v1 - - vn 的成本为 c(σ) &#x3D; ∑n-1 i&#x3D;1 ‖vi+1 - vi‖。如果 N 上从 u 到 v 的每条路径 σ′ 都满足 c(σ) ≤ c(σ′)，那么 N 上从 u 到 v 的路径 σ 就是最优路径。</p>
<p>网格路径规划问题是一个元组 P &#x3D; (C, O, N , ustart , ugoal )，其中 (C, O) 是一个网格，N 是一个邻域，ustart ∈ G 和 ugoal ∈ G 分别是邻域 N 中与 (C, O) 相关的搜索图的起始顶点和目标顶点。P 的解（或最优解）是 N 上从 ustart 到 ugoal 的路径（或最优路径），其中只包含 N 中的移动。</p>
<p>下面一个有用的概念是障碍物的凸角。一对（x，y）在以下任一条件下是障碍物的凸角：</p>
<p>1.（x，y）是某个障碍单元的左下角或右上角，且移动（1，-1）和（-1，1）适用于（x，y），或</p>
<p>2.（x，y）是某个障碍单元的左上角或右下角，移动（1，1）和（-1，-1）适用于（x，y）。</p>
<p>上述定义并不假定对角线上的移动，如（1，-1），是邻域的一部分。因此，这一定义也适用于 4 连网格。</p>
<h3><span id="22-the-4-and-8-connected-neighborhoods-and-their-heuristics">2.2 The 4- and 8-Connected Neighborhoods and Their Heuristics</span></h3><p>传统上，4 连接邻域和 8 连接邻域被用于评估网格路径规划算法。4 连接邻域的定义如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050938403.png" alt="image-20240205093820347"></p>
<p>实际上只允许垂直和水平移动。此外，8 连邻域通过对角移动扩展了 4 连邻域。其定义如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050938045.png" alt="image-20240205093852044"></p>
<p>两个网格单元 u 和 v 之间的曼哈顿距离是 u 和 v′之间 N4 最佳路径的成本，假设网格中没有障碍物。它的定义是 |∆x| + |∆y|，其中 ∆x 和 ∆y 满足 (∆x, ∆y) &#x3D; v - u。同样，给定两对单元格 u 和 v 的 Octile 距离返回的是假设障碍物集为空的 N8 上最优路径的成本。其定义为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050939113.png" alt="image-20240205093924164"></p>
<p>其中 ∆x 和 ∆y 的定义同上。我们将 u 和 v 之间的曼哈顿距离和 Octile 距离分别记为 h4（u，v）和 h8（u，v）。</p>
<h3><span id="23-the-any-angle-neighborhood">2.3 The Any-Angle Neighborhood</span></h3><p>任意角度网格路径规划允许智能体移动到网格中任何视线可及的点。因此，任意角度邻域包含了到达搜索图中每个顶点的移动。</p>
<h2><span id="3-the-2k-neighborhoods">3. The 2k Neighborhoods</span></h2><p>下面，我们将定义 2k 邻域，使其概括网格路径规划领域传统上使用的 4、8 和 16 连接邻域。对于每 k ≥ 2，我们定义 N2k 为一个序列 Q0、Q1、…，其中 Qi 是一个包含 N2i+2 第一象限移动的序列。它的第一个元素 Q0 包含第一象限（即正象限）上的 4 邻域移动；因此，Q0 &#x3D; 〈（1，0），（0，1）〉。现在，如果 Qi &#x3D; 〈 a0, . , an〉，Qi+1 是由 Qi 构建的，方法是在每个连续元素 aj 和 aj+1 之间插入总和 aj + aj+1。形式上，Qi+1 &#x3D; 〈b0，b1，. ， b2n〉，其中</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050940373.png" alt="image-20240205094028421"></p>
<p>该系列的前三个要素是:</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050941418.png" alt="image-20240205094059454"></p>
<p>Q0、Q1、. , Q5 也如图 2 中的第一象限元素所示。</p>
<p>请注意，Qi 中的元素是成对线性独立的。这是一个重要的性质，因为它说明移动是唯一的，即无法通过重复邻域中的其他移动来模拟。我们可以通过归纳法证明这一事实。事实上，Q0 的两个元素是线性独立的。此外，加入 Qi+1 的每个新元素都与 Qi 中的每个元素线性独立，因为它是 Qi 中两个（线性独立）元素之和。我们将其形式化为</p>
<p><strong>命题 1</strong> 如果 u，v∈Qi，并且存在一个 k，使得 u &#x3D; kv，那么 u &#x3D; v。</p>
<p>为了定义第一象限移动的邻域，我们只需将每个移动映射到所有四个象限。因此，对于正交移动（（0，1）和（1，0）），我们会产生两个新的移动（（0，-1）和（-1，0）），而每个非正交移动（x，y）会产生 3 个额外的移动，对应于改变 x 和 y 的符号：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050942972.png" alt="image-20240205094210909"></p>
<p>因此，我们可以滥用符号，将 N2k 解释为一系列棋步 〈v0，v1，. . , v|N2k |-1〉。当我们这样做时，我们假设序列的第一个元素是（0，1），并且 vi 和 vi+1 是这样的，即对于每 i∈ {0, . , |N2k | - 2}；也就是说，N2k 中的移动是顺时针排序的。此外，如果对于某个 j，m &#x3D; vj，那么 m + 1 和 m - 1 分别表示紧接 m 的顺时针移动（即 v(j+1) mod 2k）和紧接 m 的逆时针移动（即 v(j-1) mod 2k）。最后，如果对于某个奇数 j，m &#x3D; vj，我们说 m 是奇数移动，而当 j 为偶数时，我们说 m 是偶数移动。</p>
<p><strong>命题 2</strong> 对于每 k ≥ 2，N2k 的万有性为 2k。</p>
<p>证明： 注意 |Q0| &#x3D; 2 和 |Qi+1| &#x3D; 2|Qi| - 1，这是一个递推方程，其解是 |Qi| &#x3D; 2i + 1。对于 Qi 中的每一步非正交棋（其中有 |Qi| - 2），N22+i 中就有四步棋。此外，N22+i 包含 4 步正交棋步，总共有 4(|Qi| - 2) + 4 步棋。这就产生了 |N22+i| &#x3D; 2i+2，对于每 i ≥ 0。</p>
<p>我们定义的一个特性是，Qi 中所有移动都可以被包围的最小正方形的大小–下文定义为邻域半径–呈指数增长（见图 2）；更确切地说，它随着斐波那契数字的增长而增长。在确定结果之前，让我们先正式定义邻域的半径。</p>
<p><strong>定义 3</strong> 邻域 N 的半径定义为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050943974.png" alt="image-20240205094359138"></p>
<p>现在，我们使用 Fib 函数定义斐波那契数列：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050944793.png" alt="image-20240205094425700"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050946033.png" alt="image-20240205094649882"></p>
<p><strong>定理 4</strong> radius(N2k ) &#x3D; Fib(k - 2)。</p>
<p>为了简化符号，下面我们用 Qk 表示序列 Q 中 k 位置上的元素，其中 k 的取值范围为 0 到 |Q| -1。要证明定理 4，首先要注意，当 k 为奇数时，Qik &#x3D; Q(k-1)&#x2F;2 i-1 + Q(k+1)&#x2F;2 i-1 成立。此外，观察 (k + 1)&#x2F;2 和 (k - 1)&#x2F;2 是连续的，因此其中一个是偶数。因此，如果 (k + 1)&#x2F;2 是偶数，那么通过等式 (1)：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050950627.png" alt="image-20240205095017641"></p>
<p>根据下面两个定理，定理 4 的证明非常简单。</p>
<p><strong>定理 5</strong> Qi 中任意一对的每个坐标都小于或等于 Fib(i)。</p>
<p>证明： 通过对 i 的归纳，我们可以检验出在基本情况下（i &#x3D; 0）这是真的。假设每 i ∈ {1, . , n - 1}. 下面我们稍微滥用一下符号，当 x ≤ k 和 y ≤ k 都成立时，我们说 (x, y) ≤ k。现在，我们证明对于每一个 k，Qkn ≤ Fib(n)。我们区分两种情况：k 为偶数和 k 为奇数。如果 k 是偶数，那么 Qkn &#x3D; Qk&#x2F;2 n-1。根据归纳假设，Qkn ≤ Fib(n-1)，因此我们得出结论 Qkn ≤ Fib(n)，因为 Fib 是非递减的。</p>
<p>现在假设 k 为奇数。那么就有两种情况（公式 (5) 和 (6)）可以类比证明。这两种情况的证明方法相同，因此我们只需假设：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050951911.png" alt="image-20240205095138962"></p>
<p>证明结束。</p>
<p><strong>定理 6</strong> 假设 Fi 是由 F0 &#x3D; 0 定义的数列，并且 Fi &#x3D; 2Fi-1 + (-1)i-1, 对于 i &gt; 0，则 QFi i 的第一个坐标等于 Fib(i)，对于每个 i。</p>
<p><strong>证明</strong> 首先要注意的是，对于每一个 i &gt; 0，Fi 都是由偶数加减 1 形成的 (2Fi-1)，因此是奇数。假设每 i ∈ {1, . , n - 1}. 现在我们证明 n 也成立。</p>
<p>现在有两种情况：n 为偶数和 n 为奇数。我们只关注前一种情况，因为后一种情况的证明与前一种情况类似。因为 n 是偶数、</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050952424.png" alt="image-20240205095250525"></p>
<p>进一步观察，根据公式 (8) 我们可以得到</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050953233.png" alt="image-20240205095316286"></p>
<p>另外，请注意这意味着 (Fn + 1)&#x2F;2 是奇数，因此 (Fn - 1)&#x2F;2 是偶数。现在，根据公式 (8)，</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050953349.png" alt="image-20240205095355500"></p>
<p>那么我们利用 Fi 的定义来写、</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050954318.png" alt="image-20240205095417294"></p>
<p>将等式 9 和 10 代入等式 (6) 可以写出</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050954189.png" alt="image-20240205095442223"></p>
<p>最后，通过归纳假设，我们得到了想要的结果。</p>
<p>我们对 N2k 的定义与法雷数列有关（Hardy &amp; Wright, 2008），其中，阶数为 n 的法雷数列 Fn 是分母不超过 n 的 0 到 1 之间的不可约分数序列，例如，F3 等于 0 1、1 3、1 2、2 3、1 1。这个数列的一个性质是，如果 a&#x2F;b、a′&#x2F;b′和 a′&#x2F;b′′ 是三个连续的法里分数，则 a′ &#x3D; a + a′′，b′ &#x3D; b + b′′（定理 29；Hardy &amp; Wright，2008 年）。</p>
<h2><span id="4-a-distance-for-the-2k-neighborhood">4. A Distance for the 2k-Neighborhood</span></h2><p>在网格路径规划中，使用信息丰富的启发式方法至关重要。在 4 邻网格和 8 邻网格中，曼哈顿距离和八分距离在节点扩展数量上分别优于欧氏距离。曼哈顿距离和八分距离都对应于任意位置与目标位置之间最短路径的成本，忽略任何障碍物。</p>
<p>在本节中，我们将为更一般的 2k 邻域建立曼哈顿距离和 Octile 距离的类似模型。我们将重点回答这样一个问题：给定任意 i 和两个非负数 x、y，当只能在 Qi 中移动时，（0，0）和（x，y）之间最短路径的成本是多少？</p>
<p>这个问题可以形式化为一个整数程序（IP）。事实上，如果 Qi &#x3D; 〈v0, . . . , vn〉，我们要解决下面的 IP，即 Pi：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050956566.png" alt="image-20240205095652702"></p>
<p>服从于：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402050957638.png" alt="image-20240205095739786"></p>
<p>对于每个 i∈ {0, . , n}，其中每个 αi 是一个整数变量，直观地表示移动 vi 的应用次数。</p>
<p>下面我们将证明 Pi 的线性规划（LP）松弛总是有一个整数解。在证明这一结果之前，我们将注意力转向 Pi 的 LP 松弛（我们将其命名为 Pi LP），研究它的性质和解。</p>
<h3><span id="41-a-solution-to-pi-_lp">4.1 A Solution to $P^{i} _{LP}$</span></h3><p>我们的第一个结果证明，我们可以专注于一个更简单的双变量问题，而不是原来的 n 变量问题。</p>
<p>定理 7 假设 Qi &#x3D; 〈v0，…。, vn〉，且设 j 为 vj 和 vj+1 所包含的 (x, y)。那么 Pi LP 等价于 ˆ Pi LP，其定义为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051024967.png" alt="image-20240205102438076"></p>
<p>证明 在剩下的证明中，给定 Pi LP 中每个变量 αi 的赋值 σ，我们用 D(σ) 表示 ∑n i&#x3D;0 αi‖vi‖ 的值。假设 $P^{i} _{LP}$ 的最优解是对所有变量 $α_i$ 的赋值 σ，使得 σ(αk) &gt; 0，对于某个 k，k &lt; j（下面的证明可以稍作修改，以适应 k &gt; j + 1 的情况，但为了简单起见，我们省略了这一点）。现在考虑将所有向量 vi 一个接一个，先放 vk 形成的曲线。因为这条曲线的终点是（x，y），起点是（0，0），所以它必须与向量 vj 产生的射线相交。这条曲线可以 “分割 “成两部分：相交前的部分和相交后的部分。</p>
<p>现在我们正式确定一个事实，即总和可以分为两部分，一部分包含相交前的向量，另一部分包含相交后的向量。这意味着 (x, y) 可以表示为两个不相交集合中的矢量之和： A- 和 A+，分别包含相交前后向量的索引。此外，索引 T 用于表示与射线实际相交的向量。T 不属于 A- 或 A+。注意 A- 是非空的，因为它包含 k。最后，对于某个正值 m 和某个非负值 β ≤ αT 我们有如下结论：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051026899.png" alt="image-20240205102559735"></p>
<p>图 3：定理 7 的证明示意图。在该图例中，我们假设 vj 和 vj+1 在 Q 中是连续的，且 (x, y) 包含在 vj 和 vj+1 中。(a) 我们假设最优解使用向量 vk1, . , vk4。在证明中，这意味着 A- &#x3D; {k1, k2}，T &#x3D; k3，A+ &#x3D; {k4}。我们注意到，对于某个 α，可以用 αvj 来 “替换”(a) 中 vj 左边的最优解曲线部分，从而得到更好的解 (b)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051026498.png" alt="image-20240205102630452"></p>
<p>前两个等式的示意图见图 3。</p>
<p>请注意，等式 19 会产生一个不同的赋值，即 σ′′，它满足 Pi LP 的所有约束条件，并将 i∈A- 的每个 αi 赋值为 0。此外，D(σ′) &lt; D(σ)。事实上，这个新赋值用一条直线取代了原解中的一条曲线。</p>
<p>上述论证适用于任何使用索引小于 j 或大于 j + 1 的向量的赋值。因此，我们得出结论，对于 0≤ i &lt; j 或 j + 1 &lt; i ≤ n 的每一个 i，最优解必须是 αi &#x3D; 0。</p>
<p>最后，请注意 ˆ Pi LP 只有一个可行的分配，即方程 (17) 的解，它必须使 αj 和 αj+1 都为正值。</p>
<p>根据定理 7，Pi LP 的解很容易计算，因为 ˆ Pi LP 只有一个可行点。具体来说，这就是求解方程 (17) 的两个线性方程组的 αj 和 αj+1 的赋值。因此，Pi LP 的解可以在恒定时间内计算出来。</p>
<p>下面的结果最终证明，对于每个 i ≥ 0，ˆ Pi LP 的解都有一个整数解，因此它就是 Pi 的解。</p>
<p><strong>定理 8</strong> 对于每个 i ≥ 0，Pi LP 都有唯一的整数最优解。</p>
<p>证明 对于基本情况，观察 i &#x3D; 0 时的解是 αj &#x3D; x 和 αj+1 &#x3D; y，因此是整数。</p>
<p>现在，我们假设 ˆ Pk LP 的解是整数。假设 ˆ P k+1 LP 的方程（17）为:</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051028971.png" alt="image-20240205102847835"></p>
<p>因为 vj 和 vj+1 在 Qk+1 中是连续的一对，所以其中一个在 Qk 中，而另一个是 Qk 中两个元素的和。在不失一般性的前提下，我们假设前者是 vj+1，后者是 vj。那么，我们可以将方程（20）重写为 αjvj-1 + αjvj+1 + αj+1vj+1 &#x3D; (x, y)，或者等价地重写为：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051029333.png" alt="image-20240205102927334"></p>
<p>其中 vj-1, vj+1 ∈ Qk。现在我们利用归纳假设得出结论：等式（21）给出的方程组有一个整数解；因此 αj 和 αj + αj+1 都是整数，这最终意味着 αj+1 也是整数。</p>
<p>下面的结果是定理 8 的直接结果，主要是说，要找到通往（x，y）的最优路径，我们只需在邻域中选择 “最近 “的移动，并将两者结合起来。我们由此推断出启发式方法和规范排序。</p>
<p><strong>推论 9</strong> 假设 Qk-2 &#x3D; 〈 v0, . , vm〉，且单元格 (x, y) 位于正象限。此外，设 j 使得（x，y）被 vj 和 vj+1 所包含。那么，在 N2k 上，使用 vj 和 vj+1 的整数组合，可以从（0，0）最优地到达（x，y）。</p>
<h3><span id="42-a-heuristic-for-n2k">4.2 A Heuristic for N2k</span></h3><p>根据定理 7 和 8，我们可以得到以下算法，计算 N2k 上从（0，0）到点（x，y）的最优路径长度，假设 N2k &#x3D; 〈v0，. . . , vm〉：</p>
<ol>
<li><p>确定一个 j，使得 vj 和 vj+1 包含（x，y）。要搜索这样的 j，我们可以进行顺序搜索或二进制搜索。</p>
</li>
<li><p>求解方程（20）给出的两个线性方程组，并返回 αj‖vj‖+αj+1‖vj+1‖ 。</p>
</li>
</ol>
<p>如果 P 是一个有目标顶点 g 的路径规划问题，而 c 是 P 的搜索图中的一个顶点，我们用 h2k (c) 表示上述过程在 g - c 上返回的值。</p>
<p><strong>定理 10</strong>  h2k 是 N2k 的一致启发式。</p>
<p>证明 假设 s′ 是 s 的后继，那么 h2k (s) ≤ c(s, s′) + h2k (s′)。</p>
<p>在给定 k 的情况下，不难生成完成第 1 步和第 2 步所需计算的伪代码。算法 1 显示了不同 k 值下的启发式算法。在这些算法中，第 1 步是通过顺序搜索解决的，因此在最坏情况下需要执行 O(2k-2) 次检查。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051047368.png" alt="image-20240205104706414"></p>
<h4><span id="421-a-2k-iterative-heuristic">4.2.1 A 2k Iterative Heuristic</span></h4><p>使用二进制搜索解决步骤 1 也是可行的。这意味着，对于特定的 k，我们可以编写一个伪代码，在最坏的情况下，该代码在执行过程中需要进行 O(k) 次 “if “检查。有趣的是，我们还可以构造一个以 k 为参数的函数，它的执行时间与 k 成线性关系，并且大小不变。</p>
<p>关键的一点是，计算启发式不需要执行上文第 4.2 节所述的两步方法。在抽象层面上，该算法可视为同时进行二进制搜索和方程组求解。伪代码如算法 2 所示。</p>
<p>算法的每个循环可以理解为一个 “因式分解回合”。每轮因式分解使用 N2k 的两次连续移动。为了说明这一点，假设我们想计算从（0，0）到（10，8）的 2k 距离。最初，我们从 4 连邻域开始，由于 (10, 8) &#x3D; 10(1, 0) + 8(0, 1)，10 是与移动 l &#x3D; (1, 0) 相关的因子，而 8 是与移动 r &#x3D; (0, 1) 相关的因子。对于第一轮因式分解（即主循环的第一次迭代），我们希望用 l + r &#x3D; (1, 1) 来表示 (10, 8)，因为我们知道这样的移动会出现在下一个邻域中。为此，我们取两个因数之间的最小值（本例中为 8），并将其作为 (1, 1) 的因数。为了使因式分解正确，我们观察到我们仍然需要使用棋步（1，0），而它的因数是 10 - 8 &#x3D; 2。因此，在第一轮因式分解结束时，我们将（10，8）表示为 2（1，0）+ 8（1，1）。在下一轮中，要引入的棋步是 (1, 0) + (1, 1) &#x3D; (2，1)，它的因数是 min{2, 8} &#x3D; 2，我们仍然需要使用因数为 8-2 &#x3D; 6 的棋步 (1，1)；因此，我们将 (10, 8) 表示为 2(2，1)+6(1，1)。随着我们不断迭代，我们会发现在 k 值不断增大的情况下，N2k 的棋步会有新的因式分解。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051048167.png" alt="image-20240205104826215"></p>
<p><strong>定理 11</strong> 函数 distance(a, b, k) 返回从（0，0）到达（a，b）的 N2k 邻域上最优路径的成本。</p>
<p>为了证明该定理，我们首先证明以下两个定理。</p>
<p><strong>定理 12</strong> 在算法 2 的循环迭代 p 次之后，l 和 r 是 Qp 的连续移动。</p>
<p>证明 我们通过对第 4 行循环迭代次数的归纳来证明这一点。基本情况是微不足道的，因为（0，1）和（1，0）是 Q0 的连续移动。现在我们假设经过 n 次迭代后，l 和 r 是 Qn 的两个连续移动。那么有两种情况。首先，第 5 行 if 语句的条件为真，那么在迭代 n+1 中，根据 Q 的定义，r 和 l 是 Qn+1 中的连续移动。</p>
<p><strong>定理 13</strong> (a, b) &#x3D; xl + yr, x ≥ 0, y ≥ 0 是调用 distance(a, b, k) 循环的不变量。</p>
<p>证明： 我们也可以用归纳法来证明。在零次迭代后，三个关系式成立（回想一下，输入使得 (x, y) 位于第一象限）。现在我们假设经过 n 次迭代后 (a, b) &#x3D; xl + yr。那么</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051050032.png" alt="image-20240205105038014"></p>
<p>对于任意 z，该算法的行为就好像 z &#x3D; min{x, y}。事实上，如果 x &gt; y，那么 x 将被重新定义为 x - min{x，y}，而 y 不会改变。否则，y 被重新定义为 y - min{x，y}。这保证了 x ≥ 0 和 y ≥ 0。此外，等式 (22) 加上 l 和 r 的更新方式保证了 (a, b) &#x3D; xl + yr 在迭代 n + 1 中成立。</p>
<p>现在，我们可以对定理 11 进行完整的证明了。</p>
<p><strong>定理 11</strong> 的证明 此外，在执行结束时，(a, b) &#x3D; xl + yr，而根据定理 12，r 和 l 是 Qk-2 的连续移动。因此，我们观察到 x 和 y 是定理 8 中方程组的解，这反过来意味着 x‖l‖+ y‖r‖ 是 N2k 上（0，0）到（x，y）的距离，这意味着算法 2 是正确的。</p>
<h2><span id="5-practical-grid-path-planning-with-n_2k">5. Practical Grid Path Planning with $N_{2^k}$</span></h2><p>&#x3D;&#x3D;以上我们正式描述了 N2k 的特征，并给出了一个一致的（可接受的）启发式，它非常适合无障碍网格。&#x3D;&#x3D;然而，如果我们计划使用 A* 进行路径规划，N2k 的一个重要问题就是分支因子的增加，它与 k 呈指数关系。事实上，每一次 A* 扩展，我们都需要生成 2k 个后继路径，其中许多路径都有可能被添加到打开列表中，这将产生大量的开销。</p>
<p>然而，一个相反的现象是，在无障碍的 2k 网格中，两个顶点之间的最优路径数量可能会随着 k 的增加而大幅减少。这是因为，在无障碍网格中，最优路径的任何重新排序移动也是最优路径。在有 2k 个邻域的情况下，最优路径可能会使用更长的移动，从而导致移动次数更少的路径。举例来说，我们可以考虑（0，0）和（4，2）之间的路径数。当 k &#x3D; 2（4 邻域）时，我们到达（4，2）的任意移动序列为 4 次垂直移动和 2 次水平移动，结果为 6！4!2! &#x3D; 15 条路径。当 k &#x3D; 3（8 邻域）时，我们需要 2 个对角线 (1,1) 移动加上 2 个垂直移动，得到 4.2! 2!2! &#x3D; 6 条最优路径。最后，当 k ≥ 4 时，只有一条最佳路径需要两次 (2, 1) 移动。</p>
<p>因此，即使分支因子随 k 的增加而呈指数增长，两点之间的最优路径数量也可能随 k 的增加而大幅减少。因此，至少在理论上，增加 k 并不会明显降低网格路径规划的性能。</p>
<p>在本节中，我们将展示如何在 2k 邻域中利用 8 邻域网格路径规划的最新进展。具体来说，我们将展示跳跃点搜索（JPS）和典型 A* 如何适用于 N2k 邻域。事实证明，JPS 和 Canonical A* 在 8 邻域和 4 邻域网格上都能提高普通 A* 的性能，因此，了解如何将其融入 2k 邻域非常重要，因为与普通 A* 相比，我们也希望看到性能的提高。</p>
<p>我们遵循 Sturtevant 和 Rabin（2016 年）对 JPS 的看法，他们指出，JPS 可以理解为两个概念的组合：网格路径的规范排序和特定的后继函数。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051103987.png" alt="image-20240205110340020"></p>
<p>图 4：左：16 邻域上的典型路径示意图。右图 S 和 G 之间的典型路径（灰色）和两条非典型路径（黑色）。</p>
<p>根据 Sturtevant 和 Rabin（2016）的定义，8 连网格上的典型路径是指通过使用 dncm 形式的棋步序列生成的路径，其中 d 是对角线棋步，c 是与 d 相邻的红心棋步： (i) 每对顶点之间最多只有一条典型路径，以及 (ii) 每条典型路径都是最优路径。性质（ii）源于我们的推论 9，性质（i）源于对两次移动顺序的限制。(关于 8 连接网格上的典型路径，请参见图 5a）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051344357.png" alt="image-20240205134456344"></p>
<p>如果我们能保证上述两个性质，将此定义应用于 N2k 并不困难。根据推论 9，我们知道对于任意 k，只需在 N2k 中连续移动两次，就能以最佳方式到达无障碍网格中的每个顶点。因此，要满足条件 (ii)，我们只需关注连续移动两次的路径。最后，为了满足条件 (i)，我们可以像 8 连网格一样，优先选择其中一个移动发生在另一个移动之前。在下面的定义中，我们首先选择奇数移动，因为这概括了 Sturtevant 和 Rabin（2016 年）针对 8 连网格给出的典型路径定义：</p>
<p><strong>定义 14</strong> 如果 N2k 上的一条路径是由棋步 vnum 序列生成的，其中 v 是 N2k 中的奇数棋步，v 是 v - 1 或 v + 1，且 n，m ≥ 0，那么这条路径就是一条典型路径。</p>
<p>作为说明，图 4 显示了从 16 个连接网格中的一个顶点出发的典型路径。请注意，（2，1）及其变体（1，2）、（1，-2）等是唯一的奇数移动。</p>
<h3><span id="52-canonical-a-for-n_2k">5.2 Canonical A* for $N_{2^k}$</span></h3><p>Canonical A* 是 A* 的一个版本，它直观上侧重于建立通往目标的典型路径。它在实践中的优势在于，搜索空间中的单个顶点无法通过另一条（同样好的）路径重新发现。为此，Canonical A* 使用 Harabor 和 Grastien（2011 年）提出的自然后继者和强制后继者概念来剪裁节点的后继者集合。直观地说，由于只考虑自然后继者，A* 自然只能建立规范路径。然而，由于并非所有可到达的节点对都可以通过典型路径到达，因此有必要定义强制后继者的概念，当搜索扩展的顶点是一个障碍物的凸角时，就可能需要强制后继者。</p>
<p>现在我们为这两类后继者提供正式定义。由于这些定义是在执行 Canonical A* 时使用的，因此我们在定义中提及扩展的概念。</p>
<p><strong>定义 15</strong> 给定搜索节点 u 是通过移动 m 从父节点扩展而来的。如果符合以下条件，则 u 的后继节点 v 在 N2k 上是自然的：</p>
<ol>
<li><p>如果 m 为奇数，则 v 位于 {u + (m - 1)，u + m，u + (m + 1)} 中。</p>
</li>
<li><p>否则，则 v &#x3D; u + m。</p>
</li>
</ol>
<p>u 的自然后继符用 natural (u) 表示。</p>
<p>此外，如果 v 是搜索的根节点（因此没有从任何节点扩展过），那么 SuccN2k (v) 就是 v 的自然后继节点。</p>
<p>如上所述，当关注自然后继时，搜索只会生成规范路径。示例见图 5(a)。现在，我们按照 Harabor 和 Grastien（2011）的方法定义强迫后继者的概念：</p>
<p><strong>定义 16</strong> 给定一个搜索节点 u 通过邻域 N2k 上的移动 m 从父节点 t 扩展而来，如果符合以下条件，则 u 的后继节点 v 是强制的：</p>
<ul>
<li><p>v 不是 u 在 N2k 上的自然后继，并且</p>
</li>
<li><p>路径 tuv 是 t 和 v 之间唯一的最优路径。</p>
</li>
</ul>
<p>u 的强制后继符用强制 (u) 表示。</p>
<p>只有在扩展作为障碍单元凸角的顶点时，才会出现强制后继。</p>
<p>现在我们要描述的是 N2k 的 Canonical A* ，它概括了 Sturtevant 和 Rabin（2016 年）针对 8 连接网格提出的 Canonical A<em>。Canonical A</em> 可以看作是一种算法，它在扩展节点时，会剪除所有不在其自然后继或强制后继之列的节点。更具体地说，当扩展根节点 r 时，SuccN2k (r) 中的所有节点都会被添加到开放列表中。</p>
<p>具有强制后继的节点只能对应于障碍物凸角的顶点。枚举这类强制后继节点非常简单。当通过移动 m 扩展到一个障碍物 v 的凸角时，直观的第一步是决定搜索应该 “转向 “哪里。为了确定这一点，我们可以观察到 v 有两个位于 o 边界上的后继棋子，一个是由应用于 o 的水平移动产生的，另一个是由应用于 o 的垂直移动产生的；让我们用 mh 和 mv 表示这两个移动。现在只有 mh 和 mv 中的一个与 m 形成最小角。强制后继是指 v 的所有非自然后继，它们是由 m 与 m′ 之间的移动产生的。mh 和 mv 分别是（-1，0）和（0，-1）。mv 是与 m 形成最小角度的移动，因此（4，2）的强制后继是包含在 mv 和（4，2）的自然后继中的所有后继。</p>
<p><strong>定理 17</strong> 如上所述，Canonical A* 可以为 $N_{2^k}$ 上的任何路径规划问题 P 找到最优解，且对每一个 k 都是如此。</p>
<p>定理 17 的证明直接来自lemmata 19 和 20，我们将在下文中解释。第一个结果是，总是存在一条由典型路径串联而成的最优路径。因此，我们假设，如果 σ1 是一条以顶点 v 为终点的路径，而 σ2 是一条以顶点 v 为起点的路径，那么 σ1 ◦ σ2 表示不重复 v 的 σ1 和 σ2 的连接。</p>
<p><strong>定义 18</strong> 给定路径规划问题 P，P 上典型路径的连接，σ1 ◦ σ2 ◦ . 对于每个 i∈ {1, … , n - 1}，如果 σi ◦ σi+1 不是一条典型路径，则 ◦ σn （n ≥ 1）是不可还原的。, n - 1}.</p>
<p><strong>定理 19</strong> 对于 N2k 上任何可解的路径规划问题 P，都存在一个最优解，它要么是一条典型路径，要么是两条或两条以上典型路径的不可还原连接。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051352897.png" alt="image-20240205135204645"></p>
<p><strong>定理 20</strong> 假设 P 是一个路径规划问题，其最优解是典型路径 σ1 ◦ σ2 ◦ … 的不可还原串联。◦ σn. 那么，对于每个 i∈{1, … , n - 1}，σi 的最后一个顶点（以及 σi+1 的第一个顶点）都是一个椭圆。, n - 1}，都是一个障碍单元的凸角。</p>
<p>证明： 为了证明矛盾，让我们假设 σJ 和 σJ+1 违反了两难的条件。我们用 a 表示 σJ 的第一个顶点，用 b 表示 σJ+1 的最后一个顶点。</p>
<p>图 6 展示了在一个特定网格中，两点之间的两条典型路径的所有可能连接，而这两点之间不能用一条典型路径连接。以 a 为起点的典型路径用绿色表示，以 b 为终点的典型路径用红色表示。请注意，由 “未被障碍物’切割’的最后一条典型路径 “定义的多边形（灰色阴影）3 是由 a 和 b 之间的所有典型路径连接而成的，即通过一条典型路径将 a 连接到阴影区域中的一个顶点，然后再将该顶点连接到 b。</p>
<p>我们希望证明，当连接两条典型路径的顶点恰好是多边形的角（实际上也是阻碍直接连接的障碍区域的角）时，a 和 b 之间就形成了最短路径。</p>
<p>为了说明为什么会出现这种情况，我们将任意角邻域的证明–它更容易理解–调整为 2k 邻域的证明。在任意角邻域中，最短路径也是紧绷的。非正式地讲，当 “把路径当作一根弦，拉其两端就无法使其’绷紧’”（Oh &amp; Leong，2017）时，路径就是绷紧的；换句话说，最优路径只在障碍物的拐角处 “弯曲”。利用三角形不等式很容易证明，绷紧的路径总是比不绷紧的路径短。图 7 显示了 a 和 b 之间的绷紧路径、绷紧路径 acb 和非绷紧路径 adb。为了证明绷紧路径更短，让 e 成为线段 ad 和 cb 向左延伸的交点。现在我们写出与三角形 ebd 相关的一个三角形不等式、</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051353343.png" alt="image-20240205135343277"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051354658.png" alt="image-20240205135406374"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051354919.png" alt="image-20240205135433580"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051355027.png" alt="image-20240205135522069"></p>
<p>请注意，由于两条路径并不完全重合，因此 (25) 实际上是一个严格的不等式。</p>
<p>现在我们来证明在 2k 邻域中也存在同样的关系，这次我们比较的是一条绷紧的典型路径和一条非绷紧的典型路径。在继续分析之前，我们先用 πxyz 来表示图中从 x 到 z 并访问 y 的路径。此外，我们用 πec 表示连接 e 和 c 的线段，其中 e 是 πadb 与路径 πcfb 向左延伸的交点。请注意，e 是一个可能是也可能不是顶点的点（在图 8 中，它实际上不是顶点）。</p>
<p>我们假设 πacb 和 πadb 都是典型路径的连接；但是前者是紧绷的，而后者不是。证明其余部分的关键在于我们可以写出与任意角情况类似的三角形不等式。事实上，根据定理 7，πecb 是用 16 邻域移动连接 e 和 b 的最短线段，因为它是用 16 邻域的连续移动生成的。因此我们可以写成</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051356620.png" alt="image-20240205135618756"></p>
<p> 请注意，这是一个严格的不等式，因为我们假设 $d \not &#x3D; c$。</p>
<p>最后，请注意，由于路径 πagc 是最优的，我们可以写成</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051357180.png" alt="image-20240205135734121"></p>
<p>将 (26) 和 (27) 相加，我们得到 c(πacb) &lt; c(πadb)。虽然我们以 16 邻域为例进行了证明，但同样的论证也可用于任何 2k 邻域。</p>
<p>为了完成证明，我们可以使用矛盾论证： 如果 σJ 和 σJ+1 使得 σJ 的最后一个元素不是角，那么一定有另一条路径 σ′ J ◦ σ′ J+1 确实在角上弯曲，而且 σ′ i ◦ σ′ i+1 应该比 σi ◦ σi+1 短（这一点可以用上面的论证来证明），这与原始路径是最优路径的事实相矛盾。</p>
<p>定理 17 的证明：从上面的分析中，我们可以看出，如果问题有解，那么就存在一条最优到达目标的典型路径的连接。此外，根据定理 20，我们知道在这些典型路径之间访问的顶点也是障碍物的一个角。由于 Canonical A* 完全扩展了障碍物的每个凸角，因此可以通过 Canonical A* 找到分区的每条典型路径。我们的结论是，Canonical A* 是完整和最优的。</p>
<h3><span id="53-jump-point-search">5.3 Jump Point Search</span></h3><p>跳点搜索（JPS）（Harabor &amp; Grastien，2011 年）是一种搜索策略，与 Canonical A* 一样，在扩展节点时，我们只计算自然后继和强制后继。不过，我们不会立即将这些后继节点直接添加到 “打开 “列表中，而是为每个节点计算一个所谓的跳转点，然后再将其添加到 “打开 “列表中。更准确地说，我们计算将后继者添加到开放列表的方法，借鉴了 Harabor 和 Grastien（2011 年）在算法 4 中描述的后继者生成器。在伪代码中，调用 jump(v, direction(v, n), g) 会计算从 v 向 direction(v, n) 方向的跳转点。最后，direction(v, n) 表示从 v 生成 n 的移动。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051358049.png" alt="image-20240205135852918"></p>
<p>节点 v 在 d 方向上的跳跃点直观上对应于沿着 d 方向前进所找到的节点，当我们到达目标或有强制后继的节点时就会停止。此外，如果 d 是奇数棋步，我们也会在找到一个节点后停止，而该节点在与 d 紧邻的两个方向中的任何一个方向上都有一个跳跃点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051359440.png" alt="image-20240205135923452"></p>
<p><strong>定义 21（2k 跳转点）</strong>如果 j &#x3D; v + kd，且 k 是大于 0 的最小自然数，则节点 j 是 v 在 N2k 中向 d 方向的跳转点：</p>
<ol>
<li><p>j 是目标，或</p>
</li>
<li><p>j 有强制继承人，或</p>
</li>
<li><p>&#x3D;&#x3D;如果 d 是奇数棋步，那么在方向 d + 1 或 d - 1 上存在一个 j 的跳跃点。&#x3D;&#x3D;</p>
</li>
</ol>
<p>计算跳跃点非常简单，只需改编 Harabor 和 Grastien（2011 年）的函数，并按算法 5 进行修改即可。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051400793.png" alt="image-20240205140055753"></p>
<h3><span id="6-empirical-findings">6. Empirical Findings</span></h3><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051413718.png" alt="image-20240205141310651"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051414433.png" alt="image-20240205141432385"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051416243.png" alt="image-20240205141636268"></p>
<p>我们的评估有两个目的。首先，我们想研究将 N2k 与最标准的启发式搜索算法 A* 结合使用对解决方案质量的影响，并将获得的解决方案与任意角度路径规划器 ANYA 和 Theta* 生成的解决方案进行比较。其次，我们想利用 h2k 启发式和欧氏距离研究 k 的增加对 A<em>、Canonical A</em> 和 JPS 运行性能的影响。此外，我们还将运行时间性能与 ANYA 和 Theta* 进行了比较。</p>
<p>我们在 Uras 和 Koenig 的 Subgoal graphs 实现（2015 年）之上实现了我们的算法，该实现使用标准二进制堆进行 Open。该实现包括 Theta* 以及 Harabor 和 Grastien（2013 年）描述的任意角度规划器版本，下文我们称之为 ANYA。我们还包括 Harabor 等人（2016 年）描述的同一任意角规划器优化版本的结果，除随机地图外，我们在下文中称之为 iANYA。所有实验均在主频为 2.20GHz 的 Intel(R) Xeon(R) CPU Linux 机器上运行，内存为 128GB。</p>
<p>&#x3D;&#x3D;我们对 JPS 的实现对最初的提议做了两处修改，这使得实现更加容易，同时保留了最初 JPS 的所有特性。首先，跳转点要么是目标，要么是障碍物的凸角；其次，跳转点在扩展时是完全扩展的，即其所有后继点都被添加到开放列表中。&#x3D;&#x3D;</p>
<p>在比较中，我们使用了来自 MovingAI 资源库（Sturtevant，2012 年）的三组游戏地图。第一组游戏地图来自《博德之门 II》（包含大小为 512 × 512 的地图）、《龙腾世纪：大小的起源》（包含大小为 512 × 512 的地图）和《龙腾世纪：大小的起源》（包含大小为 512 × 512 的地图）： 起源》中的地图，大小从 22 × 28 到 1260 × 1104 不等，以及《星际争霸》中的地图，大小从 384 × 384 到 1024 × 1024 不等。第二组是大小为 512 × 512 的随机地图，其中受阻单元的比例从 10% 到 40% 不等。最后，第三组是大小为 512 × 512 的房间地图，房间大小从 8 × 8 到 64 × 64 不等。</p>
<p>图 9-11 显示了不同邻域、ANYA、iANYA 和 Theta* 的常规 A* 的平均求解成本。这些图还显示了次优化的平均百分比，省略了 A*（k &#x3D; 8）以获得更好的绘图缩放效果。我们评估了 2k 的七个值：8、16、32、64、128、256 和 512。我们得出以下结论。</p>
<ul>
<li><p>在所有三个基准中，当 k 增加时，求解成本都会提高。当 k 增加到 6（64 邻域）以上时，改善幅度微乎其微。</p>
</li>
<li><p>与最优任意角规划器 ANYA（和 iANYA）相比，我们发现当 k 超过 6（64 邻域）时，A* 几乎能获得最优任意角路径。具体来说，在 64 邻域中，游戏图、房间图和随机图的次优率分别只有 0.19%、0.19% 和 0.10%。</p>
</li>
<li><p>与 Theta* 相比，我们发现在游戏地图和房间地图中，k 大于 4（16 个邻域）的 A* 能找到更好的解决方案。在随机地图中，当 k 大于 3（8 个邻域）时，A* 能获得更好的平均解成本。</p>
</li>
</ul>
<p>现在，我们将注意力转向运行时评估。在我们的实现中，Canonical A* 和 JPS 没有使用任何预计算或其他优化方法，如 Rabin 和 Sturtevant（2016 年）或 Harabor 和 Grastien（2014 年）所述的优化方法。我们认为优化方法的实施是未来工作的一部分。</p>
<p>为了了解不同算法对运行时间的影响，我们展示了图 12，图中显示了不同邻域下常规 A<em>、典型 A</em> 和 JPS 的平均运行时间。我们评估了每种算法的 h2k 启发式和欧氏距离 (ED)。我们评估了相同的七个 k 值。</p>
<ul>
<li><p><em><em>在常规 A</em> 上。</em>* 在游戏地图和房间地图上，运行时间随 k 的增加而增加。这是因为分支因子较大，而分支因子随 k 的增加呈指数增长。在 k 值较小的情况下，使用 h2k 启发式的 A* 比使用欧氏距离的 A* 运行速度更快。在 k 值中等和较高的情况下，使用 ED 的 A* 运行速度稍快，这是因为计算我们的启发式需要开销，而且当 k 值较大时，h2k 与欧氏距离更接近。在随机地图中，对于每个 k，使用 h2k 的 A* 都比使用欧氏距离的 A* 快。</p>
</li>
<li><p><em><em>关于 Canonical A</em> 。</em>* &#x3D;&#x3D;主要观察结果是，在游戏地图和房间地图中，对于大多数 k 值，使用欧氏距离的 Canonical A* 性能更好。在随机地图中，对于大多数 k 值，h2k 是最佳选择。&#x3D;&#x3D;</p>
</li>
<li><p><strong>关于跳点搜索。</strong> 在游戏地图中，对于大多数 k 值（k &#x3D; 3 除外），使用欧氏距离的 JPS 是最佳选择，但在 k &gt; 6 时，它的性能被 ANYA 和 iANYA 所超越，随机地图除外。在房间地图中，欧氏距离在 k &#x3D; 3 和 k &#x3D; 4 时性能最佳，在其他值时，使用 ED 的 JPS 略快。在随机地图中，h2k 启发式是最佳选择。</p>
</li>
<li><p><strong>在所有算法中。</strong> JPS 在 “游戏地图 “和 “房间地图 “中表现最佳（”游戏地图 “中 k &#x3D; 9 除外）。另一方面，JPS 在随机地图中的性能最差。这可以解释为，JPS 在扩展一个状态时，会生成从该状态出发的典型路径上的所有状态 Sturtevant 和 Rabin（2016）。</p>
</li>
</ul>
<p>即使在基本配置（k &#x3D; 2）中，优化后的 iANYA 规划器也优于我们的算法，但随机地图除外。在游戏、房间和随机地图中，Theta* 的运行时间分别为 14.49 毫秒、17.39 毫秒和 2.77 毫秒。在游戏地图和房间地图中，使用 2k 邻域的 Canonical A* 和 JPS 比 Theta* 更快，在每个 k 中都是如此。此外，如图 9-11 所示，还能获得更好的求解成本。在随机地图中，使用 ED 启发式（k &#x3D; 4）的 Canonical A* 比 Theta* 更快，并能获得更好的成本。在游戏图、房间图和随机图中，ANYA 的运行时间分别为 4.16 毫秒、7.20 毫秒和 35.03 毫秒。在 Game 和 Room 地图中，在 k 等于 6（64 邻域）之前，JPS 比 ANYA 快。当 k &#x3D; 7（128 邻域）时，运行时间相似。当 k &gt; 7 时，JPS（未进行优化）比 ANYA 更快，在解质量上也更有竞争力。&#x3D;&#x3D;在随机地图中，对于我们评估的所有 k 值，使用 2k 邻域的 Regular A<em>、Canonical A</em> 和 JPS 都比 ANYA 快。&#x3D;&#x3D;</p>
<p>此外，我们还列出了四个表格，显示了扩展次数、堆渗流和每次扩展的时间。表 1 显示了常规 A* 的结果。我们发现，当邻域大小增加时，每次扩展的搜索时间也会增加。此外，如表 2 所示，当使用 Canonical A* 时，我们观察到每次扩展的搜索时间会平稳增加。表 3 显示了 JPS 的结果。扩展次数对应的是以广度优先搜索方式进行的规范扩展次数，目的是识别插入到开放列表中的跳转点。这就解释了为什么扩展次数多，而渗滤次数少。在这里，每次扩展所需的搜索时间很少，但当邻域增大时，搜索时间就会增加。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051426568.png" alt="image-20240205142654470"></p>
<p>表 4 显示了 Theta* 和 ANYA 的结果。关于 Theta* 和 ANYA 中什么是扩展的解释，可以在解释我们使用的 Uras 和 Koenig 实现方法的论文中找到。由于算法的工作方式，在 k 值较小的情况下，Theta* 和 ANYA 与普通 A* 相比，每次扩展的开销较小。另一方面，如果考虑每次搜索扩展的时间和总搜索时间，Canonical A* 和 JPS 似乎是更好的选择。从表 1、表 2 和表 3 中的结果可以看出，在 k 值较小的情况下，h2k 启发式比欧氏启发式能获得更好的结果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051427102.png" alt="image-20240205142740072"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051427818.png" alt="image-20240205142755798"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402051428666.png" alt="image-20240205142819501"></p>
<h2><span id="7-summary-and-conclusions">7. Summary and Conclusions</span></h2><p>我们提出了在 2k 邻域上构建有效网格路径规划器的三个关键贡献。首先，我们正式&#x3D;&#x3D;定义了 2k 邻域&#x3D;&#x3D;；其次，我们定义了&#x3D;&#x3D;2k 距离函数&#x3D;&#x3D;，该函数可在 k 的多项式时间内计算，并可用作可接受的启发式。第三，我们定义了&#x3D;&#x3D;规范排序，最终使我们能够提出 2k 邻域的跳点搜索实现方法。&#x3D;&#x3D;我们的规划器能生成更好的解决方案，但运行时间的增加在使用跳点搜索或规范 A* 时较小。对于 32 邻域及更高邻域，我们的规划器比 Theta* 能生成更好的解，而对于 64 邻域及更高邻域，我们的规划器能获得低于 0.2% 的次优化。我们的规划器并没有进行特别优化，但在多达 64 次移动的邻域中，它的平均速度比任意角度规划器 ANYA 的实现要快，但并不比优化算法 iANYA 快。因此，我们的方法似乎值得推荐给那些寻求高质量解决方案，同时又希望使用标准或简单实现方法的实践者。</p>
<p>这项研究为未来的工作打开了一扇门，未来的工作可能会研究 2kneighborhoods 在任意角度增量搜索中的应用，这是一个与机器人相关的问题。与机器人应用相关的还有三维网格的 2k 邻域版本。这也是我们目前的研究课题之一。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-02T01:19:14.000Z" title="2024/2/2 09:19:14">2024-02-02</time>发表</span><span class="level-item"><time dateTime="2024-02-03T02:34:01.341Z" title="2024/2/3 10:34:01">2024-02-03</time>更新</span><span class="level-item">2 小时读完 (大约21783个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/02/A-Novel-Heuristic-Emergency-Path-Planning-Method-Based-on-Vector-Grid-Map/">A Novel Heuristic Emergency Path Planning Method Based on Vector Grid Map</a></p><div class="content"><h1><span id="a-novel-heuristic-emergency-path-planning-method-based-on-vector-grid-map">A Novel Heuristic Emergency Path Planning Method Based on Vector Grid Map</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020921988.png" alt="image-20240202092104376"></p>
<h2><span id="abstract">Abstract</span></h2><p>摘要： 应急路径规划技术是智能交通系统的研究热点之一。由于城市路网的复杂性和道路拥堵状况，应急路径规划非常困难。城市突发事件造成的道路拥堵会直接影响原有的路网结构。这样，原有路网的静态权重就不再适合作为路径推荐的依据。为了处理动态的态势路网，将设计一种等距网格应急路径规划框架。基于态势信息，提出了一种新的态势网格路网模型，并将其应用于等距网格应急路径规划框架。基于该模型，将提出一种态势网格启发式搜索方法，可用于检测拥堵区域网格周围的车辆通过情况，并在最短时间内找到通往目的地的道路。在路径规划方法中，加入了基于四元数函数的网格启发式搜索策略，可以使算法快速收敛到目标网格。本文提出了三种图加速算法，以提高路径规划算法的搜索效率。最后，本文将设置三个实验来验证我们提出的方法。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>近年来，随着城市路网越来越繁忙，应急绕行路径规划也变得越来越重要。在城市道路上经常会出现一些道路拥堵现象，尤其是在城市的早晚高峰时段，道路拥堵更为严重。针对这种情况，人们对如何成功地使汽车避开拥堵区域，以确保车辆能在最短时间内到达原定目的地进行了多项研究。因此，这种路径为车辆提供了一条绕行的紧急路径[1,2]。</p>
<p>目前，已有研究人员在此研究方向上提出了相关的疏散模型和疏散拥堵模型[3-7]。现有的路径规划研究主要集中在静态路网的动态路径规划上。Kim 等人[8]利用路网的空间结构提出了一种疏散路径规划（ERP）模型，以尽量减少计算时间。另一种是基于传统场景的紧急路径规划系统。Khalid 等人提出使用基于免疫的方法来解决动态路径规划问题[9]。该方法降低了元启发式方法的计算复杂度和最优解生成，启发式方法采用基于免疫的综合疏散规划（iEvaP+）方法，具有动态性。Zhang 等人[10]提出了一种人车协同情境模型。该模型是对大量混合流涉及绕行区域内的行人和车辆进行优化设计的综合线性模型。</p>
<p>其他研究侧重于道路交通的短期和长期预测[11]。Li 等人[12]研究了一种高效的时空神经结构搜索方法–自动搜索。该方法主要是更新各卷积层的时空相关性和层间条约学习的方法。Dai 等人[13]提出了一种混合时空图卷积网络（H-STGCN），它能够通过接收到的交通数据 “推断 “出未来的出行时间。例如，当信息受到干扰或缺失时，该方法可以参考上下文信息有效预测现有的道路交通流量。Lin 等人[14]提出了一种动态开关注意网络（DSAN），该网络具有新颖的多空间注意（MSA）机制，可明确测量输入和输出之间的相关性。该方法能有效过滤噪声，减少预测误差。该方法可有效预测短期和长期交通流量。</p>
<p>不过，上述方法都是对历史数据进行训练和计算。在应急场景下，通过历史数据无法有效预测现有交通流量。原因在于，应急场景中的随机性相对较大，因此无法通过概率计算出城市某一道路区域发生应急事件的概率。例如，从图 1 可以看出，当城市车辆遇到道路拥堵时，需要提前绕行。因此，本文的难点在于如何在路网图上给出具有态势动态的 top-k 绕行路径，使车辆能在最短时间内绕过紧急区域，驶向目的地。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020924038.png" alt="image-20240202092442938"></p>
<p>为解决这些问题，本文将介绍等距网格应急路径规划（EGEPP）框架。该框架是对我们之前工作[15]中提出的网格地图应急路径规划（GMEPP）框架的改进。GEMPP 框架主要应用于紧急路径的疏散路径规划，并不考虑绕行路径的规划。因此，在 EGEPP 框架中，我们主要以路网速度和道路通行能力作为路径选择和网格选择的依据。这里需要注意的是动态路网的特点，因为紧急时间的开始是随机的，但其发展过程是附近的交通流量随着时间的推移逐渐减少，也就是说拥堵区域的车辆数量符合正态分布[16]。</p>
<p>根据这种情况，将设计一种新颖的情境网格路网模型（SGRN），该模型将具有时空特征的路网映射成随时间变化的动态路网图。然后，将引入&#x3D;&#x3D;基于 SGRN 的情境网格启发式搜索算法（SGHS*）&#x3D;&#x3D;。该方法将使用时间消耗函数和时间启发式函数来决定路径选择。它还包含一种基于动态路网的剪枝策略。最后，我们提出了一种基于情况网格的路网加速算法，以优化查询路径。总之，本研究的贡献总结如下：</p>
<p>(1）本文介绍了一种紧急状况下的情景网格路网模型，称为 SGRN 模型； </p>
<p>(2）一种名为动态网格 PageRank（DGPR）的新方法可根据当前路网的交通容量对所有网格进行排序，并为每个网格分配不同的等级值； </p>
<p>(3) 引入时空动态地图的 SGHS* 算法，该方法根据排序后的网格规划绕行路径，并通过规划网格之间的两部分组成整体规划结果。根据 SGHS* 路径规划算法，提出了基于时间特征的剪枝策略，以确保在给定时间窗口内给出的路径结果使车辆行驶耗时最少；</p>
<p> (4）最后，将提出基于情境网格的三种路网加速算法情境收缩层次结构（SCH）、情境网格收缩层次结构（SGCH）和情境网格多重反向收缩层次结构（SGMRCH）。有三种方法可以建立路网收缩哈希表，并改变路网顶点后添加的捷径与原始边之间的关系[17]。</p>
<p>本文接下来的内容安排如下。第 2 节介绍了主要的相关工作。第 3 节介绍了应急路径规划的新模型。第 4 节详细介绍了基于网格图的网格排序 DGPR 算法。第 5 节介绍基于网格图的迂回路径查询 SGHS*，并根据给定的时间窗口 Tq 进行剪枝。第 6 节将介绍基于态势网格图的三种动态路网加速算法。第 7 节介绍了验证 EGEPP 效率的实验。第 8 节是本文的结论。</p>
<h2><span id="2-the-related-worked">2. The Related Worked</span></h2><p>启发式是在状态空间中进行搜索，对每个搜索位置进行评估，一次搜索即可获得最佳位置，并从给定的原点搜索到目标。这样可以省去很多不必要的搜索，提高效率。位置估值在启发式搜索中非常重要。使用不同的估值会产生不同的效果。&#x3D;&#x3D;启发式搜索有以下几个优点：(1) 从当前位置向目标搜索，向下搜索确保在同一层次中获得的解是最优解。这样就省去了很多不必要的搜索路径。(2）在搜索目标顶点的过程中，如果启发式函数设计合理，算法可以快速收敛。(3) 在一定的搜索区域内，保证了搜索顶点的广度，即获得尽可能多的搜索节点信息。&#x3D;&#x3D;</p>
<p>A* 算法擅长解决静态路径中的最短距离问题，不同于 Dijkstra 算法和 Floyd 算法，该算法结合了广度优先搜索（BFS）和 Dijkstra 算法的优点[18]： 在启发式搜索的同时，提升了算法的效率，可以保证找到最优路径（基于评价函数，如曼哈顿距离、欧氏距离），Floyd 算法[19]在机器人路径规划、游戏编程、卫星路径搜索等领域使用场景较多。</p>
<p>Singh 等人[20] 研究了一种用于在线搜索和优化的实时 A* （RTA* ）算法。建立了最小能耗函数。该方法实现了移动机器人在静态障碍物中的导航，并通过约束机器人向最优方向移动来生成能耗最小的路径。Khalidi 等人[5,21,22] 提出了一种基于启发式时间动态监控的路径规划方法 T* 。T* 算法的重点不在于路径最优，而在于减少寻找路径的计算时间。例如，基于采样的线性时序逻辑（LTL）运动规划算法能有效计算连续状态空间中的轨迹，但不能保证最优。Bhatia 等人 [23] 提出了一种基于多层的路径规划技术。这种方法的优势在于通过构建离散轨迹，在路径规划中尽可能缩小搜索空间，从而反过来减少路径规划的时间，提高搜索效率。Mashayekhi 等人 [24]研究了一种基于快速探索随机树的无人车 A* （RRT* ）算法，该算法增加了启发式策略和贪婪思想，在原有快速探索随机树（RRT）算法[25]的基础上，改进了父顶点的选择方式，利用代价函数在扩展顶点到父顶点的地域内选择代价最小的顶点，同时，每次迭代后都会重新连接树中已有的顶点，从而降低了计算的复杂度，逐步实现最优解。</p>
<p>其他研究也提出了基于广度搜索图的策略。Guo 等人[26]提出了基于动态路网的 Dijkstra 算法路径规划策略，并通过仿真实验分析了该算法在时间最短、距离最短、油耗最少等条件下的效果，保证了在人口不断增长的城市中提供合理的车辆路径规划策略。Fink 等人[18]采用了基于地形数据的 Dijkstra 算法的多目标变体，以实现三维表面的整体最优遍历。所获得的结果被用于全球漫游车水平优化规划器（GRHOP）自动化系统中，以快速、准确地同时设置多个约束条件下的优化路线。Souza 等人[27] 将 Dijkstra 方法应用于树状图分析，将采矿块作为树状图的节点进行分析，用于计算将采矿块运输至目的地的最低成本路线。运输成本在图的弧中被剔除，它可以使用欧氏距离或运输时间来计算最小路径。</p>
<p>在城市道路上进行紧急路径规划有两点需要考虑。一是基于路网态势的动态路径规划。态势信息首先是一个随时间变化的动态变量。在不同时间，情况变量的值会根据当前的相关信息发生变化。第二个因素是路径规划中的阶跃搜索（从当前节点到其他节点的搜索过程），考虑加入广度搜索节点的策略，尽可能满足交通拥堵地区的条件需求，使车辆道路通行条件更好。表 1 列出了本文提到的主要参数。表 2 列出了本文提到的方法缩写和全称。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020928150.png" alt="image-20240202092820209"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020928052.png" alt="image-20240202092841972"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020929192.png" alt="image-20240202092909178"></p>
<h2><span id="3-two-new-models-based-on-emergency-path-planning">3. Two New Models Based on Emergency Path Planning</span></h2><p>本节将介绍两种模型：时空路网模型和情景网格路网模型。这两个模型都是在图结构模式的基础上进行改进的。其中，SGRN 模型将原有的图结构模型改进为使用区域道路特征表示道路权重的模型。</p>
<h3><span id="31-spatial-temporal-road-network-model">3.1. Spatial-Temporal Road Network Model</span></h3><p>基于时空图的交叉口可表示为有向图 G &#x3D; &lt; V, E &gt;，其中 V 是交叉口集合，E &#x3D;&lt; vi, vj &gt; 是有序顶点对集合，表示 vi 到 vj 之间有一条路径，vi 和 vj ∈ V。一条路径 &lt; vs, vd &gt; 表示车辆从源点 vs 出发，到达点 vd，权重 w:&#x3D; &lt; vi, vj, Ta &gt; 定义为一对交叉点 i 到 j 的时间成本，w 为非负数，所有长度均为正数。</p>
<p>需要强调的是，时间 Ta 表示车辆通过两个交叉路口道路的平均时间，Ta 值是一个函数，表示为 Ta &#x3D; Len&#x2F;S，它不是固定不变的，Len 代表道路长度，S 是车辆的平均速度。路径规划方法考虑了查询时间窗口 Tq 处路网的速度 S。Tq 的目的是确保用户在这一时刻的最优路径，因为道路的 S 在不同的时间有不同的值。</p>
<h3><span id="32-a-situational-grid-road-network-model">3.2. A Situational Grid Road Network Model</span></h3><p>情景网格地图被建模为 Gn-map &#x3D; &lt;Pr, gridid, (v1, v2, … , vi)&gt;，其中 Gn-map 是以 ng × ng 表示的整个城市地图，gridid 代表地图中的 ID（ng 值将在实验部分详细给出），Pr 表示网格中交叉口数量与其他网格中交叉口数量的比率。该比率的值将被视为网格的换向能力。排序算法将采用基于 PageRank 的网格排序算法 GPR（该算法的实现将在第 4 节中详细介绍）。vi 代表网格中的所有顶点，一个网格中的交叉点越多，该网格与其他网格的通信能力就越强；另一个是包含每个网格中所有顶点的出度集 Vout ∈ V。</p>
<p>网格地图将整个地图划分为多个子地图，即 Gs ∈ Gn-地图。每个网格中都会有若干交叉路口和道路，在为网格赋值时会考虑到这些因素。将地图划分为多个区域后，框架可根据参数设置为每个区域赋值。这些数值为疏散路径规划提供了重要依据。这些数值的变化恰恰反映了区域的权重变化，同时在理论上也提供了可靠的依据，保证了该方法在以后算法搜索路径时，将交叉口和道路量化为可计算的权重问题。这正是在网格地图上进行路径搜索的优势所在。值得注意的是，城市地图的不规则形状会导致一些网格在我们的网格之后不包含交叉口或道路，因此这些网格 ID 将在预处理时从数据中删除。</p>
<p>在本文中，情景指的是路网路况的实时变化，即通常所说的路况变化[28,29]。城市路网的拥堵程度一般会随着时间的变化而变化，同时，由于地区差异，同一时间的拥堵程度也不尽相同。这种受时间和地理位置影响而变化的路网状况被称为具有时空特征的状况路网。之所以要考虑路网的态势信息，是因为拥堵区域不是固定不变的，拥堵程度也是不同的（本文将通过路网速度来表示道路拥堵程度，因此与拥堵程度不再相关）。</p>
<h2><span id="4-equidistant-dynamic-grid-map-based-on-situational-road-network">4. Equidistant Dynamic Grid Map Based on Situational Road Network</span></h2><p>本节将介绍等间距网格路网的动态方法。等间距网格指的是将整个路网映射成二维平面坐标，并将路网作为一个整体进行分割。图 2 显示了路网网格图层，图 2 中的蓝线代表城市道路，原始路网显示了路网结构，切割路网显示了整个路网进行切割后的等间距路网，划分为网格交叉的路网将网格路网（红圈）划分为不同的网格。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020932772.png" alt="image-20240202093159741"></p>
<h3><span id="41-grid-sorting-algorithm-gpr">4.1. Grid Sorting Algorithm GPR</span></h3><p>本文使用的排序算法是基于论文[15]中传统 PageRank 方法和 GPR 方法的改进 DGPR 算法。1999 年，Page 等人在论文[30]中提出了一种名为 PageRank 的算法。该算法的主要思想是，一个页面越 “有效”，该页面的链接质量就越高，也就越容易链接到其他 “有效 “的页面。因此，该算法充分利用网页之间的关系来计算网页的重要性。这种方法的独特之处在于它考虑到了所有实体之间的相关性。</p>
<p>网格图的目的是将整个城市绘制成不同的网格，并计算出交叉口的数量和网格的容量，作为网格的权重。图 3 显示，网格交叉口（蓝点）被划分为不同的网格。根据 GPR，有四个交叉口的网格 1 的排名高于有两个交叉口的网格 2，因为就交叉口数量而言，网格 1 的疏散能力优于网格 2。然而，实际情况还需要考虑道路的连通性，也就是每个交叉口和网格图中的入度和出度。为了解决这个问题，本文介绍了一种基于网格地图 GPR 的网格等级值算法。在该方法中，每个网格中的交叉口（网络中的顶点）和指定每个网格中顶点的数量定义为 ng，ng 的大小是整个道路网络中网格排序的一个因素。ng 的选择在网格排序中起着关键作用。考虑每对顶点的车道数。与车道数较少的道路相比，车道数越多的道路在某一时刻的汽车数量就越多。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020933255.png" alt="image-20240202093304300"></p>
<p>网格的秩值是通过 GPR 方法迭代计算得出的。GPR 将网格中与其他网格顶点相连的所有顶点视为边的数量。网格外的边数定义为网格内度数（GIDN）。该值将作为网格等级参数加入公式 (4)。每个网格的等级值可通过公式 (1)-(3) 计算得出。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020933463.png" alt="image-20240202093337443"></p>
<p>在公式 (1)-(3) 中，GPR(gridID) ∈ [0, 1) 的结果就是网格的秩值（GPR 的取值范围将在实验部分详细说明）。如果 GPR(grid1)&lt; GPR(grid2)，那么 GPR(grid2) 将被推荐，因为它的值更高。其中，k:&#x3D; 顶点直接相连的网格数，表示网格中的顶点不一定与相邻网格相连。Ri 是第 i 个网格的 GPR 值，i 代表网格的 ID，com 定义为一个网格中指向同一网格的不同顶点的集合，其值为边的数量。L 是道路的车道数。阻尼系数 e &#x3D; 0.85 是为了防止网格间的局部循环，提高收敛速度。Pi 为权重，Pi 越大，表示第 i 个网格中的交叉点数量越多，权重越大，gridi 代表第 i 个网格，V 为整个网络中的顶点总数。Vgridi 是第 i 个网格中的顶点总数，同时在导航时被选中的可能性越大。N 是网格数，所有网格都至少包含一个交叉点。</p>
<p>地图网格的数量决定了栅格化后算法的运行时间。算法 1 描述了网格的分布和排序，第 2-6 行将路网中的顶点依次划分到每个网格中，并计算每个网格的外度顶点。第 8-17 行计算每个网格的秩值，经过一定次数的迭代后，秩值趋于稳定，最后，第 18 行返回带有矢量值的城市网格道路网。在算法 1 的一次迭代中，算法需要依次计算每个网格的秩值，即 O(n)。在计算某个网格的秩值时，需要考虑相邻网格的秩值。以此类推，在计算每个网格的秩值时，必须再次计算其他网格的秩值，即 O(n - 1) 次，因此 GPR 算法的时间复杂度为 O(n(n - 1))，即 O(n2)，其中 n 为路网中的交叉口数量。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020934429.png" alt="image-20240202093422477"></p>
<h3><span id="42-dynamic-grid-sorting-algorithm-dgpr-based-on-situational-road-network">4.2. Dynamic Grid Sorting Algorithm DGPR Based on Situational Road Network</span></h3><h4><span id="421-road-network-speed">4.2.1. Road Network Speed</span></h4><p>A 小节首先介绍了 GPR 算法，然后将介绍一种新颖的动态网格 PageRank 算法（DGPR），即根据路网中各条道路的路网速度对区域交通容量进行排序。在介绍 DGPR 算法之前，先介绍本文使用的路网速度原理。</p>
<p>论文[31,32]介绍了路网速度的提取方法和计算方法。论文[31]研究了一种混合径向函数（RBF）神经网络算法来预测道路拥堵情况，以获得道路速度。然而，预测道路速度可能有助于正常交通条件下的路径规划，但已经不适用于紧急情况下的路径规划。论文[32]提出了一种机器学习机制，通过获取 OpenStreetMap 数据来估算路网速度。然而，估计出的路网速度仍然不是实时的，因此紧急路径规划需要对实时路网速度特别敏感。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020935044.png" alt="image-20240202093544730"></p>
<p>本文中的道路网络速度将用 $RS&#x3D; (\sum \limits_{n&#x3D;1}^k \frac{Distance(v_i, v_j)}{T_{ij}}) &#x2F; k $ 表示，其中 $T_{ij} $是车辆通过（vi, vj）的时间，RSn 代表车辆速度，$Distance(v_{i}, v_{j})$ 代表相邻两个交叉点的欧氏距离。值得注意的是，这里的速度是查询时间窗口 T 内所有通过车辆的平均速度。因此，整条道路的网络速度如公式 (4) 所示，其中 K 为 T 时间内通过（vi，vj）的车辆数。</p>
<h4><span id="422-dynamic-grid-pagerank">4.2.2. Dynamic Grid PageRank</span></h4><p>动态网格排序的目的是在城市道路发生交通拥堵或影响道路的区域发生紧急情况时，为受影响的车辆提供一些相对通畅的道路和区域，使其能够避开和绕过。</p>
<p>图 4 显示了不同时间戳下的情况。绿色实线表示道路畅通，黄色实线表示道路上车辆较多，红色实线表示道路拥堵。路网速度会随时间变化。例如，图中由路口 A 和路口 B 连接的道路（vA，vB）显示，在 t1 和 t2 时刻，道路状况良好。但随着时间的变化，当时间到达 t3 和 t4 时，道路（vA，vB）的路网交通流量较大，道路拥挤。然后，当时间戳为 t5 和 t6 时，路况变差，出现拥堵，换句话说，此时路网速度较低，车辆行驶缓慢。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020938059.png" alt="image-20240202093848999"></p>
<p>基于路网的实时动态变化，提出了动态网格排序 DGPR。本文对 GPR 算法进行了调整，以适应路网的实时变化。根据实时交通容量（路网速度）和道路承载能力，对整个城市路网进行区域排序。文中[15]提到了不同网格条件下 GPR 算法的收敛时间。本文仍将路网划分为六个分布区。因此，在不同的时间窗口下，每条道路的路网速度是不同的。DGPR 根据每个区域从内向外连接的道路（从两个不同区域连接的道路）的路网速度和区域内道路的承载能力对每个区域进行排序并作为点值。算法 2 描述了 DGPR 的运行机制。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020939860.png" alt="image-20240202093927921"></p>
<p>算法 2 中的 T 代表查询时间窗口。由于 DGPR 会不断迭代计算每个区域的容量值，因此当时间达到 T 时，算法会重新读取路网数据并对区域进行排序。第 4-7 行计算每条道路的平均路网速度（根据公式 (4)），并将计算出的路网速度分配给每条道路，作为每条道路排序计算的初始权重。值得注意的是，在计算网格间的排序值时，并非每条道路都会参与，这大大减少了计算开销。$R_i$ 代表非常网格的初始排序值并使用平均道路速度值，gridη 是一个网格中的边缘数。$DA_{matrix}$ 是实时动态变化的秩矩阵，每个网格的区域路网速度秩值都存储在矩阵中。$Ψi$为第 i 个网格的路网因子容量。第 9-19 行说明每个网格在每次迭代时都会计算自己的秩值，减去实际路网速度后得到的结果就是此时道路的最大松弛速度。$G_{n-map}$ 是一个 $n_g ∗ n_g$ 网格的道路网络。最后，将网格排序值存储在 HashMap(DGPR) 中，其中 $&lt; Grid_k, R_k &gt;$，$Grid_k$ 为第 k 个网格，$R_k$ 为第 k 个网格等级值。在实际道路网络中，如果道路越畅通，车流速度就会同时提高。相反，道路越不畅通，车流速度就越慢</p>
<p>本文指出，尽管从一个网格到另一个网格可能有不止一条路径，但传递的等级值仍会选择网格的整体网络速度值。由于拥堵往往是区域性的，当网格的网络速度较低时，附近网格的网络速度值会随着时间的推移而降低。因此，路网速度具有传递性。网格数量决定了算法的运行时间。在每次迭代中，算法仍需依次计算每个网格的秩值，即 $O(n)$。网格计算自己的秩值时，还需要计算相邻网格的秩值，即 O(n - 1) 次，所以 DGPR 算法的时间复杂度为 $O(n(n - 1))$ ，即 $O(n^2)$ 。</p>
<h2><span id="5-emergency-path-planning-algorithm-based-on-situational-road-network">5. Emergency Path Planning Algorithm Based on Situational Road Network</span></h2><p>应急路径规划的关键在于路网条件的突变和实时性。然而，传统的路径规划方法显然无法满足当前路网状况的变化。因此，本节提出了一种新颖的情景网格启发式搜索算法。该方法通过考虑当前路网的变化因素来规划车辆的路径。在介绍该算法之前，先介绍了具有时空特征的路网。</p>
<h3><span id="51-the-characteristics-of-road-network-with-spatio-temporal-characteristics">5.1. The Characteristics of Road Network with Spatio-Temporal Characteristics</span></h3><p>图 5 显示，路网被划分为不同的网格（图中虚线圈出的矩形代表一个网格）。在示例图中，绿色实线代表路网中车速相对较高的道路，即路况相对通畅，车速接近道路的最高限速；黄色实线代表道路上车辆较多的情况；红色实线代表道路拥堵的情况。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020944928.png" alt="image-20240202094409789"></p>
<p>在实际道路网络中，通常拥堵路段会导致附近区域的道路也跟着拥堵。随着时间 t 的变化，拥堵程度会通过道路交叉口相互传递。对于路网区域的划分，有利于紧急状态下车辆的实时动态路径规划。因此，本文通过对整个城市路网进行排序，比较各区域的通行能力。</p>
<p>根据图 4，路网随时间变化，拥堵状态具有持续性和随机性。因此，本文提出了一种新颖的 SGHS*，用于在紧急状况下对具有时空特征的路网进行路径规划。</p>
<h3><span id="52-heuristic-search-and-breadth-traversal-search-algorithm">5.2. Heuristic Search and Breadth Traversal Search Algorithm</span></h3><p>从图 6 中可以看出，绿色实线（source→h1→h2→h3→h4→h5→h6→h7→h8→destination）和蓝色实线（source→d1→d2→d3→d4→d5→d6→d7→destination）分别代表启发式搜索（代表算法为 A* 、RTA*  和 D*）[33,34]和广度优先遍历搜索（代表算法为 Dijkstra）[35,36]的结果。启发式搜索的优点是能快速有效地得到最优路径解（在静态有向正权重图的前提下），广度优先遍历搜索的搜索时间比启发式搜索长，但其优点是每次搜索都能得到相对全面的松弛边比较。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020946874.png" alt="image-20240202094608837"></p>
<p>在启发式搜索中，启发式函数通常与目标顶点有关。一般来说，车辆会选择最短路径作为备选路径，因此启发式因子会选择搜索当前顶点与目标顶点之间的欧氏距离或曼哈顿距离（实际搜索结果对路径的搜索结果影响不大）。然而，在紧急路径规划中，需要考虑两个因素：路网的动态性和最短时效性。一方面，突发事件的发生必然会造成一个或多个区域的道路拥堵。另一方面，一旦拥堵区域发生紧急事件，区域内的车辆需要立即驶出该区域和附近车辆，并以最短的时间成本驶向目的地。</p>
<p>但根据实际路网情况，两种搜索模式提供的路径都要驶向拥堵区域（通常车辆会选择路网等级较高的道路），因此避开拥堵区域有利于车辆以最短的时间驶向目的地。</p>
<h3><span id="53-situational-grid-heuristic-search-to-path-planning-based-on-dgpr">5.3. Situational Grid Heuristic Search to Path Planning Based on DGPR</span></h3><p>本节将介绍称为 SGHS* 的情境网格启发式搜索。在第 4 节中，我们提到了动态网格路网的原理，SGHS* 算法将根据这一原理为城市车辆进行紧急路径规划。</p>
<p>图 7 描述了 SGHS* 算法的路径规划结果。从图 7 中可以看出，SGHS* 算法在初始选择路径时，首先会确定当前顶点的网格 ID，然后根据网格 ID 对整个城市道路进行排序。DGPR 算法得到的整个城市路网区域的排序结果是基于路网速度的。网格的优势在于可以对城市路网进行区域管理。</p>
<p>源顶点的网格为 grid32。在第一次搜索中，SGHS* 将访问相邻的网格。值得一提的是，在最初的 GEMPP 框架中，网格搜索每次会搜索 8 个相邻网格。但在实际网格划分中，虽然有些网格相邻，但并没有实际的路网连接。我们称这些网格为虚拟网格（Virtual-Grid），而如果有部分路网与实际路网相连则称为实体网格（Entity-Grid）。不过，在 EGEPP 框架中只能访问实体网格。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020949624.png" alt="image-20240202094938139"></p>
<p>如图 5 和图 7 所示，绿色实线代表路网速度较高的道路，与 Grid32 直接相连的网格为 Grid22、Grid31、Grid33 和 Grid42。当 DGPR 算法为这四个网格赋值时，其顺序可以是（从轻度拥堵到严重拥堵）Grid42 &gt; Grid22 &gt; Grid31 &gt; Grid33。当 SGHS* 获得要搜索的网格 ID 时，会建议优先规划路径，即搜索通往 Grid42 的路径，因为 Grid42 的排名更高。但在实际定位时，会发现车辆的行驶方向与想法相反。此时，就会形成一种掉头的情况。在实际场景中，不建议这样做。如果车辆不及时改变方向，很可能会出现一种绕圈现象。</p>
<p>为了避免这种情况，设计了四元数函数 ∂{μ，φ，θ，υ}。μ 是激活函数，只有当 μ 为 TRUE 时，SGHS* 算法才会比较后三个函数值。φ 是网格间的最小步长。其结果等于当前搜索网格与目标网格之间的网格数。θ是当前顶点网格中心坐标与下一个搜索网格中心坐标之间的连线，也是下一个搜索网格中心坐标与目标顶点网格中心坐标之间的夹角。υ 的值是 DGPR 的结果。等式 (5) 描述了阶跃函数。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020950396.png" alt="image-20240202095023364"></p>
<p>其中，ξ 是搜索次数，Gridd 代表目标顶点的网格 ID，CountGridid 是源网格到目标网格的计数。公式 (6) 表示角度公式。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402020950355.png" alt="image-20240202095051327"></p>
<p>公式 (6) 是两条直线的夹角公式。其中 ι1 是当前顶点的网格中心坐标和下一个搜索网格的网格中心坐标的斜率函数，ι2 是下一个搜索网格的网格中心坐标和目标顶点的网格中心坐标的斜率函数（两个顶点构成一条直线）。</p>
<p>定义 1. 给定两个 φ1 和 φ2，且两个网格排序值相近，φ1 的步长值 &gt; φ2，φ2 所在的网格将优先作为网格候选集。</p>
<p>如图 8 所示，Grid22 和 Grid42 的通行能力都较好，但 Grid42 的步长比 Grid22 加了 2，即 G1 &lt; G2，因此在实际路径规划中，相当于车辆要绕远路，这在实际推荐路径中是不被接受的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021005997.png" alt="image-20240202100532025"></p>
<p>定理 1. 给定两个 ∂1 和 ∂2，当激活函数 μ1 和 μ2 都为真时，步长的优先级高于角度值，角度值高于 DGPR 值。</p>
<p>证明 假设 G5 是当前的起始网格，当只剩下 G2 和 G7 作为候选网格时，从图 8 中可以看出，θG2-1 &gt; θG7，但根据欧氏公式，φG2 &gt; φG7，G7 更接近 D。此时，无法确定哪个网格是最佳搜索网格。此时，需要根据 DGPR 的排序结果进行判断。DGPR 的值越高，网格中的道路通行能力就越好。DGPR 优先级较低的原因是，当 G1 和 G2 为候选网格时，假设只考虑两个网格的 DGPR 值，当 υ1 &lt; υ2 时，车辆将行驶到 G2 网格，从而导致返回或重复道路（例如，车辆之前从 G2 网格行驶到 S 网格）。</p>
<p><strong>定义 2.</strong> 给定两个 θ1 和 θ2，当 (θ1 &gt; θ2) ∧ (θ2 6&#x3D; 0) 时，则 θ1 的网格比 θ2 的网格更接近目标网格。</p>
<p>从图 8 可以看出，θG1 &gt; θG5 &gt; θG6 &gt; θG2，Grid22 与目标网格相邻，Grid33 与目标网格相差一个网格。然后比较网格 31 和网格 42。假设网格矩形的边长为 2，~ DG6 的长度为 4√2，~ DG2 的长度为 2√10，显然 4√2&lt;2√10。因此，网格 31 在空间上更接近网格 13。正方形网格的优点是便于进行几何计算。不过，本文不使用三角形的面积作为参考函数。</p>
<p><strong>定理 2.</strong> 给定两个 υ1 和 υ2 分别是两个三角形的面积值，如果 υ1 小于 υ2，候选网格不一定更接近目标网格。</p>
<p><strong>证明</strong>   根据图 8 可以看出，三角形 ∆ DSG2、∆ DSG6 和 ∆ DSG1 的面积相比较时等于 ∆ DSG1 的面积，因为三角形的面积可以通过底边的长和高来计算，如图 8 所示。线段 ~ G1S 和 ~ G2S 的长度相等，三角形 ∆ DSG1 和 ∆ DSG2 的高为线段 ~ DG3。因此，根据三角形的面积公式， ∆ DSG1 的面积等于 ∆ DSG2 的面积。然而，就物理距离而言，G1 网格比 G2 网格更靠近 D 网格。接下来，我们将比较三角形 ∆ DSG2 和 ∆ DSG6 的面积。根据定义 2，G6 网格更接近 D 网格。然而，∆ DSG6 的面积大于 ∆DSG1 的面积，而 ∆ DSG1 的面积等于 ∆ DSG2 的面积，所以 ∆ DSG6 大于 ∆ DSG6。</p>
<p><strong>定义 3</strong>. 给定两个候选网格 G1 和 G2，当 G1 中函数 ∂ 的步长和角度值为 φ1 &lt; φ2，θ1 &gt; θ2，则 G1 更接近目标网格。</p>
<p>根据图 8 所示的候选网格，φ1 &lt; φ6，θ1 &gt; θ6。然而，情况并不一定相反。例如，对于网格 G1 和 G4，假设 G1 和 D 之间没有实体-网格，θ1 &#x3D; θ4（根据平行四边形，对角线相等），但 φ4 &lt; φ1。同样，φ1 &#x3D; φ5，但θ1 &gt; θ5。根据矩形的对角线和边长，G1 更接近目标网格 G5。因此，φ1＜φ2，θ1＞θ2 是 G1 比 G2 更接近目标网格的必要条件和不充分条件，即（φ1＜φ2）∧（θ1＞θ2）-→G1＞G2（G1＞G2 表示推荐的 G1 高于 G2）。</p>
<p>下面将介绍网格内的路径规划。根据路网速度计算预计行驶时间的启发式函数。为此，搜索图需要根据不同的时间查询路径。情景路网的特点是随时间变化的路径权重不同。因此，我们的方法需要根据给定的时间窗口 Tq 查询当前路网，并返回 T′ qs 的最优路径。因此，为了满足要求，将设计一个搜索函数 F(n)，即公式（7）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021008598.png" alt="image-20240202100822397"></p>
<p>其中，G(n) 表示从源顶点到第 n 个顶点的实际时间，即公式 (8)。 vi 和 j 构成当前查询的道路，d 是目的地顶点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021008288.png" alt="image-20240202100852022"></p>
<p>其中，TR(vi,vj) 表示车辆通过两个交叉口 vi 和 vj 的实际时间，即公式 (9)。ε是道路的最大通行能力，取值范围为（0，1）（详见第 7 节），Len(vi,vj) 是 vi 到 vj 的距离，RS(vi,vj) 代表 vi 到 vj 之间道路的平均速度，该值从轨迹数据集中提取。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021009610.png" alt="image-20240202100921598"></p>
<p>其中 λ &#x3D; H(n) 是启发式因子，即等式 (10)。公式 (11) 使用曼哈顿距离除以车辆的平均速度 VSavg，即行驶距离除以总时间（VSavg 的值代表 G(n) 探索的所有候选路径加上车辆已行驶路径的总平均速度）。因此，使用这种估算方法可以更好地判断下一步要探索的路径。</p>
<p>SGHS* 方法根据道路的实际时间加上估计时间之和来选择道路。G(n) 的取值保证了车辆的经过时间是所有候选路径使用时间中最小的，这也是 BFS 搜索原理所保证的，即 G(n) ≤ G(n)*。启发式函数 H(n) 是单调递减的。</p>
<p><strong>定理 3</strong>. 给定查询时间窗口 Tq，采用启发式路径规划方法在 G 中找到时间窗口 Tq 内的最短路径子集，当 H(n)≤H(n)* 时，离目标顶点越近，扩展的顶点越少。</p>
<p><strong>证明</strong> 因此，必须在给定的查询时间 Tq 内找到最多路径的子集。根据启发式原理，搜索顶点离目标顶点越近，H(n) 的值就越小。当 H(n) ≤ H(n)* 时，它满足单调递减特性，因此在搜索顶点的过程中，可以避免重复搜索顶点。因此，H(n) 越小，需要搜索的顶点就越少。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021010493.png" alt="image-20240202101045592"></p>
<p>其中，MD 是两点 tn 到 d 之间的曼哈顿距离，$\vec {x}$和 $\vec{y}$ 分别代表纬度和经度，即公式 (11)。我们将使用估计时间作为启发式，因为车辆总是希望在最短时间内到达目的地。</p>
<p>BFS 搜索过程将执行 G(n) 函数 [36]。如果每次只向下搜索一个顶点，该方法就会变成 A* 搜索模式，搜索效率也不会提高。在 SGHS* 搜索过程中，唯一的限制是一个时间窗 Tq。根据公式 (12) 确定 G(n) 的停止条件。</p>
<p>其中，Tmps、Tmpd 是一个网格内的临时源顶点和临时目标顶点。值得注意的是，当 G(n) 中的 TRq &lt; Tq 时，搜索将继续进行。当 TR ≥ Tq 时，搜索将停止。在这种情况下，SGHS* 必须返回上一个顶点，因为当车辆行驶在两个交叉路口之间时，GPS 可能无法准确收集车辆的当前位置[35]，例如车辆进入隧道或在桥下行驶。算法 3 第 7-12 行描述了公式 (12) 的计算过程：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021012528.png" alt="image-20240202101217614"></p>
<p>算法 3 演示了 SGHS* 的路径规划过程。第 4 行和第 29 行用于确定源顶点和目标顶点是否在同一网格中。第 5-27 行描述了 SGHS* 的启发式搜索，其中包括剪枝策略，将在第 5.4 节中详细介绍。在优先队列存储中，每个顶点都需要搜索一次。第 20-23 行由公式 (7)-(10) 计算得出。第 30-41 行描述网格间的搜索。设置四元数函数 ∂ 的目的是在区域道路畅通时，尽可能选择离目标网格最近的网格作为候选网格。</p>
<p>算法 3 的时间复杂度分析如下。当从一个顶点开始搜索时，搜索开始，未访问的顶点被访问。在最坏的情况下，每个顶点至少被访问一次，每条边至少被访问一次。最坏的情况是，在搜索过程中，如果一个顶点被向下搜索，它的所有子顶点都被访问过，那么它就会回退。两点间 SGHS* 规划的时间复杂度为 O(n) &#x3D; n ∗ (v1 + n) + v2，其中 n 为顶点数，v1 为当前顶点，v2 为搜索顶点。因此，时间复杂度渐近为 O(n)，源顶点和目的顶点之间 SGHS* 的时间复杂度为 O(n2)。O(ng) &#x3D; ng ∗ ng 是搜索网格的时间复杂度，ng 是网格数。最后，SGHS* 的时间复杂度为 O(n2) + O(ng) &#x3D; O(n2)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021013710.png" alt="image-20240202101315664"></p>
<h3><span id="54-pruning-strategy">5.4. Pruning Strategy</span></h3><p>将详细介绍基于 SGHS* 的修剪策略。路况权重是不断变化的。图 9 显示了 SGHS* 算法的剪枝策略结果。假设车辆从顶点 S 出发，则可搜索的边分别为 ~ SV1、 ~ SV0 和 ~ SV3。根据 SGHS* 的搜索策略，车速最高的道路将优先被搜索到。但是，目前路网的情况正在发生变化，在紧急情况下，SGHS* 希望搜索更多的路径作为车辆的备选路径。因此，根据查询时间窗口 Tq，确定车辆可以到达的交叉点顶点集作为候选路径。换句话说，根据已知的道路长度和路网速度，可以获得实际的行驶时间，并将获得的时间与查询时间窗口 Tq 进行比较。如果不超过 Tq，算法继续向下搜索。如果 Tq 等于或超过时间 Tq，则停止搜索并返回候选顶点。此时，我们会从优先队列中删除未搜索到的顶点，这就是 SGHS* 的剪枝策略。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021014619.png" alt="image-20240202101400620"></p>
<p>例如，图 9 中无向图的 $S\vec{V}1$ 边速度较快，SGHS* 在搜索 V1vertex 时如果不超过查询时间窗口 Tq，就会继续向下搜索到 V2顶点。而 $S\vec{V}0$ 和 $S\vec{V}3$ 的速度较低，因此 SGHS* 判断这些路径的行驶时间超过了 Tq，所以不会搜索顶点 V0 的三条相邻边和顶点 V3 的一条边。这样，EGEPP 框架不仅能在紧急情况下搜索更多交叉路口，还能从候选路径中删除拥堵路段。公式 (12) 描述了 SGHS* 计算车辆行驶候选路径所需的时间是否超过给定的时间窗口 Tq。值得注意的是，SGHS* 会给每个搜索到的顶点分配一个标签，表明该顶点当时是放松的，这大大降低了搜索的时间成本。例如，如果图 9 中的顶点 V0 在搜索过程中被 SGHS* 访问，那么当 V2 被放松时，V0 将不会被搜索。</p>
<p>图 10 描述了 SGHS* 算法（紫色实线）、Dijkstra 广度优先遍历算法（蓝色实线）和 RTA* 算法（绿色实线）的路径规划结果。紫色实线（source→s1→s2→s3→s4→s5→s6→s7→s8→s9→s10→s11→s12→s13→destination）表示 SGHS* 算法的顶点通过数结果。虽然 SGHS* 通过的交叉点较多，这意味着行驶时间会比交叉点较少的路径长，但路径的选择性却优于其他两种算法。也就是说，车辆可以选择向其他方向行驶，绕过交叉路口的拥堵区域。因此，Dijkstra breath first 和 RTA* 规划的路径大于 SGHS* 规划的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021015533.png" alt="image-20240202101535346"></p>
<h2><span id="6-graph-acceleration-algorithm-based-on-situational-grid-road-network">6. Graph Acceleration Algorithm Based on Situational Grid Road Network</span></h2><p>本节将介绍基于路网速度的 SCH、SGCH 和 SGMRCH 三种顶点搜索算法。在 [15] 中，提出了两种基于交叉口类型的顶点收缩算法 RCH 和 MRCH。在全局路网顶点收缩的情况下，MRCH 优于 RCH。但在某种情况下，路网结构会随时间发生变化，因此并非所有顶点都需要计算收缩算法。因为在静态路网中，收缩顶点越多，搜索算法在路径规划时就会搜索尽可能少的顶点，从而提高搜索效率，减少路径规划时间。当然，增加的捷径越多，恢复边所需的时间可能就越长。</p>
<h3><span id="61-situational-contraction-hierarchies-algorithm">6.1. Situational Contraction Hierarchies Algorithm</span></h3><p>传统的 CH 算法会将顶点从高一级收缩到低一级 [17,37]。例如，假设图 G &#x3D; &lt; V, E &gt; 的顶点按重要性升序命名为 (1, 2, … , n)。只有当 &lt; u, v, w &gt; 是唯一一条从 u 到 w 的最短路径时，才需要 &lt; u, w &gt;。顶点的容量越大，收缩级别就越高。反之，顶点容量越小，收缩水平越低。因此，用传统方法收缩路网中的顶点是不需要的，所以需要改变收缩的顺序。虽然其他研究相对关注时间和转弯 [38,39]。</p>
<p>图 11 显示了分层收缩算法对路网结构的影响。从图 11a 中可以看出，没有相位图，也没有右图。假设只考虑经过节点的数量，V1 到 V5 和 V3 到 V6 将经过 V4，这表明 V4 的重要性很高。V2 也比 V1 和 V3 重要。因此，V2 和 V4 将在一次收缩中缩小。结果就是图 11b 的情况。删除了边 E1、E7、E2、E6、E3 和 E5。在图 11b 中添加了三条捷径，在还原道路网络时将转换为之前删除的边缘。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021017172.png" alt="image-20240202101716930"></p>
<p>算法 4 演示了 SCH 的计算过程，第 3 行读取所有道路网络的速度，并根据顶点所连接的一侧道路网络的速度赋值。第 4 行在全局路网中搜索双向最短路径。第 5-9 行用于判断顶点是否收缩以及收缩后的处理。值得注意的是，第 5 行中的 “小于良好 “表示 vi 的水平较低，因此将对其进行收缩。SCH 的时间复杂度主要是搜索每个顶点时的最短路径搜索时间等于 O(2logn)，其中 n 是顶点的个数。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021017455.png" alt="image-20240202101746296"></p>
<h3><span id="62-situational-grid-contraction-hierarchies-algorithm-and-situational-grid-multiple-reverse-contraction-hierarchies-algorithm">6.2. Situational Grid Contraction Hierarchies Algorithm and Situational Grid Multiple Reverse Contraction Hierarchies Algorithm</span></h3><p>下面将介绍基于网格图的顶点收缩加速方法的两种算法。网格图加速的思路是首先将网格作为顶点。如果网格之间有边相连，则会形成一条连接两个网格的边，这条边不加权。在 GDPR 算法中，会得到每个网格的网络容量排名值，该值的大小由网格内部的路网速度决定。如果一个网格内部出现拥堵，该网格就会连同其他网格的边一起从网格图中删除。捷径不会被保留或添加。这样，剩余的网格将形成一个新的网格网络图，并在此基础上执行 SCH 收缩。</p>
<p>与算法 4 相比，算法 5 增加了网格收缩过程，目的是收缩更多的顶点。由于不会推荐拥挤区域 SGHS* ，所以网格图收缩处理在 SGHS*  算法之前进行。第 3-9 行是网格图的广度优先遍历，即在搜索每个网格的拥堵情况后，将拥堵网格从图中删除，并断开与其他网格的连接边。第 10-18 行是对图中剩余的每个顶点进行分层排序，将符合收缩要求的顶点从图中删除，以减少图中顶点的数量。图搜索的时间复杂度为 $O(ng) &#x3D; n_g ∗ v1$，其中 ng 为网格数，顶点搜索的时间复杂度为 $2logn$，其中 n 为顶点数，因此 SGMRCH 的时间复杂度为 $O(ng) + 2logn &#x3D; O(n)$​。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021019696.png" alt="image-20240202101924746"></p>
<p>同样的原理，SGMCH 算法在原有 RCH 算法的基础上增加了栅格图收缩策略。这种方法的优点是可以收缩图中大量的 L - 交点交集，从而使路径规划算法在顶点搜索时可以最小化松弛边。需要注意的是，CH 算法和 MRCH 算法都是在图初始化时进行的，因此不会影响路径规划的计算时间。但是，在本文提出的 SGRN 模型中，路网速度会随着时间的变化而变化，因此情况路网收缩算法必须在每次路网变化时执行图预处理程序。这就要求图收缩算法必须在可接受的时间内完成。</p>
<p>算法 6 的第 3-9 行仍然是网格地图搜索。它首先删除拥堵区域的网格，然后断开连接的网格。这一步与 SGCH 流程相同。第 10-28 行是对整个道路网络的遍历查询。它收缩了所有阶数为 2 的顶点，并为删除顶点时相连的两个顶点添加了快捷连接。它将删除的边的权重相加，从而得到捷径。图搜索的时间复杂度为 O(ng) &#x3D; ng ∗ v1，其中 ng 是网格数，顶点搜索的时间复杂度为 n ∗ (v1 + m) + v2 &#x3D; O(n2)，其中 n 是顶点数，m 是边数，因此 SGMRCH 的时间复杂度为 O(ng) + O(n2) &#x3D; O(n2)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021020230.png" alt="image-20240202102017292"></p>
<p>其中突出的一个问题是 SCH、SGCH 和 SGRMCH 的权重加权。在以往的研究中，道路权重通常选择道路的长度，这样在收缩顶点时就可以加上相连边的权重。然而，本文的权重设计为道路网络速度，速度值不能相加，否则就意味着将错误的道路网络速度反馈给车辆。因此，以路网速度的平均值作为加权结果，将两条边的路网速度分配给一条边更为合理[40]。图 12 是 EGEPP 框架示意图。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021020059.png" alt="image-20240202102040969"></p>
<p>从图 12 中可以看出，在数据处理阶段，将现有路网数据和车辆轨迹数据进行融合，通过 DGPR 算法对整个城市路网进行网格动态划分，并对网格路网进行图收缩处理，在此过程中，本文共提出了三种图收缩策略。最后，利用收缩后的路网，通过 SGHS* 规划应急路径，最终返回一条最短的绕行路径。</p>
<h2><span id="7-experiment-and-verification">7. Experiment and Verification</span></h2><p>本节将详细介绍实验过程和参数设置。实验将尝试使用网格大小为 ng &#x3D; 288 [15]、网格顶点数和道路密度作为不同参数来测试路径查询效率的影响。我们将比较 GMEPP 框架和新提出的 EGEPP 框架下城市交通紧急情况下车辆的绕行路径和行驶时间，以及两种框架下应急路径规划算法的运行时间比较。同时，比较了 SGHS* 算法、GBD 算法、RTA* 算法、RRT* 算法、T* 算法、A* 算法和广度优先遍历算法。最后，本文还需要加入本文提出的图加速算法与其他图加速算法进行比较，从而验证加入图加速算法后对原图进行路径规划的效率，以及加入其他图加速算法对本文提出的 EGEPP 框架的影响。</p>
<h3><span id="71-experimental-settings">7.1. Experimental Settings</span></h3><p>本文的重点是基于北京路网的应急路径规划，因此不包括其他城市的网格划分。在实验验证阶段，会加入实验对比算法中不同上下尺寸、不同道路密度的行能量，而不同城市间的网格划分结果不会影响算法的效率。</p>
<p>在紧急场景下，车辆需要快速绕过紧急区域并驶向最终目的地，因此以最小的成本和时间绕过紧急区域非常重要。因此，本文的实验主要关注路径规划时间和车辆行驶时间，以验证 EGEPP 框架的可行性。EGEPP 将主要集中于快速将秩值较高的车辆导入网格，并获得最优路径，即车辆从源顶点到目的顶点所需的时间最短。本文接下来将进行三种实验。</p>
<ol>
<li>讨论了网格数对 DGPR 算法的影响。由于路网的不断变化，适当的查询窗口可以使车辆的行驶路径获得更高的速度。因此，根据轨迹数据的采样频率，选择合适的时间查询窗口 Tq 来测试和验证所提出的 SGHS* 算法；</li>
<li>设置不同长度的起点和终点，通过仿真实验比较不同算法的路径规划，得到不同算法下车辆行驶的规划路径时间；</li>
<li>设置不同的图大小来验证所提出的三种图加速算法和CH的效率，然后将图加速算法导入路径规划算法中比较算法效果，并设置单车工况和多车工况算法对比。</li>
</ol>
<p>实验环境为 16G 内存、64 位 Windows 10 操作系统、Intel i5 @3.30GHz CPU。算法编译语言为 Java 和 MATLAB，可视化工具为 QGIS。数据集是来自 OpenStreetMap（<a href="https://www.openstreetmap.org，访问日期：2020">https://www.openstreetmap.org，访问日期：2020</a> 年 12 月 5 日）的北京城市路网，经过处理细化后包含 83 884 个顶点和 222 778 条有向边，不包含悬浮点和悬浮线（悬浮点和悬浮线是指图中孤立的点和边，这类点和线通常出现在村庄的边上）。北京还有约 500 G 的车辆轨迹数据和微波数据，并使用网格大小为 ng &#x3D; 288 的 G288 地图（网格大小对路径规划算法的影响已在论文[15]中讨论）。本文将不再详细讨论）。</p>
<h3><span id="72-不同网格数下的查询时间窗口-tq-和-dgpr-有效性讨论">7.2. 不同网格数下的查询时间窗口 Tq 和 DGPR 有效性讨论</span></h3><p>在演示实验之前，先介绍一下城市路网的容量。首先，可以提取和处理 OpenStreetMap 数据集。可供车辆通行的道路可分为五类： 未分类道路、三级道路、一级道路和高速公路。其次，表 3 显示了城市道路的容量划分，指的是道路的交通状况。这些都是国家标准。CRG 是城市道路等级，其值与 SL 相对应。SL 代表道路限速，TC 代表道路通行能力。为便于计算，将其归一化并称为最大通过系数 ε，最后将 ε 值导入公式 (9)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021024932.png" alt="image-20240202102407963"></p>
<p>网格的秩计算可根据算法 2 的第 14 行进行。由于 OpenStreetMap 存储的是方向性道路结构，因此每个顶点都会有一条出站边和一条入站边。交叉点 ID 已经过预处理。由于轨迹数据的采集频率为 2 分钟，我们提出的 DGPR 算法应确保在这段时间内完成计算，并获得每个网格的排序值。由表 3 可以得出表 4。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021024444.png" alt="image-20240202102431451"></p>
<p>对表 3 中的路网速度中值取平均值后，可得到所有路网速度内的车辆容量，然后进行归一化处理，得到最终的 φ 值。DGPR 算法计算每个网格的 PR 排列值，与表 4 比较并赋值，得到每个网格的最终通行能力系数 φ。根据通行能力系数，本文规定当网格的通行能力系数为 0.02 时，为拥堵；0.09、0.12 和 0.14 为轻微-拥堵（即图 1 中颜色不断变化的道路）、 图 1 中颜色不断变化的道路，当网格得到这个值时，μ 的标志为 TRUE）；0.17、0.22 和 0.24 代表畅通无阻的道路，SHGS 算法在比较网格时，如果遇到相同标签的网格，就会比较二次函数，如果μ 为 TRUE，就会比较数值。</p>
<p>图 13 显示了 DGPR 算法和 GPR 算法的收敛性比较结果。图 13 的纵坐标表示每种算法的上一次迭代结果与当前迭代结果的插值，横坐标表示算法的迭代次数。随着迭代次数的增加，可以看出算法在逐渐收敛。从图 13 中可以看出，当迭代次数达到 15 次时，两种算法都接近收敛，但 DGPR 算法的收敛速度高于 GPR 算法，DGPR 在 15 至 20 次迭代之间趋于平稳。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021025581.png" alt="image-20240202102508231"></p>
<p>图 14 显示了 DGPR 和 GPR 的运行时间，两种算法在迭代次数达到 50 次时出现了明显的变化，DGPR 的增长趋势较为平缓，但 GPR 的加速度出现了明显变化。由于图 13 显示两种算法在迭代次数为 30 后都收敛为 0，因此与图 14 所示的运行时间结果相比，DGPR 算法的运行时间为 570 ms &lt; 120,000,000 ms，满足轨迹数据的刷新频率条件。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021025053.png" alt="image-20240202102540719"></p>
<p>由于本文中轨迹数据集的采集频率为 2 分钟，但根据情景刷新率指定时间窗口可能并不合适。例如，短时间内路网的变化并不明显，不会对路网造成影响。因此，我们使用 Tq &#x3D; [2, 5, 15, 30, 45, 60] [41] 作为时间窗口，并使用 500、1000、2000、3000 个起始端顶点对，缩写（SEVP）如表 5 所示。RV(avg)表示 SGHS* 中不同起止顶点对的平均松弛顶点数，RT(avg)表示 SGHS* 一次迭代的运行时间，IT(avg)表示 SGHS* 每次运行的平均迭代时间。</p>
<p>表 5 显示了不同查询时间窗口 Tq 对不同起点-终点顶点对的 SGHS* 算法的影响。根据不同的起点和终点对，当查询时间 Tq 一定时，放松顶点的数量没有太大差别，然后随着查询时间的增加，放松顶点的数量逐渐变多。但是，当查询时间小于 15 时，因为每次搜索的顶点都是根据路网的速度进行查询的，所以在迭代计算中有很多顶点在一次搜索中因为给定的行驶时间太短而没有访问到，最终导致算法无法搜索到这些顶点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021026712.png" alt="image-20240202102626913"></p>
<p>然而，当查询时间窗口 Tq &lt; 15 时，松弛顶点的数量也逐渐减少，但变化值不大。比较不同查询时间窗口下的算法运行时间结果，可以得出结论：当查询时间窗口 Tq &#x3D; 60 时，算法的一次迭代时间过长，这是因为算法在一次探索中放松了大量顶点，几乎是在对静态图进行全局搜索。此外，45 分钟和 30 分钟也显示了相同的结果，都是由于放松了大量顶点。当查询时间窗 Tq &#x3D; 5 和 Tq &#x3D; 2 时，运行时间有所减少，但变化并不明显，主要原因是到达的顶点离目标点太远，而 SGHS* 在计算启发式函数时必须计算候选顶点到目标顶点的曼哈顿距离，因此 SGHS* 算法花费了大量时间开销。</p>
<h3><span id="73-算法运行效率验证">7.3. 算法运行效率验证</span></h3><p>本小节将设置不同长度的路径来比较每种算法的运行效率。本文提出的 SGHS* 基于动态态势栅格地图，因此在本节的实验设置中加入了路网速度的概念。首先，根据提出的四元数函数∂ { μ、φ、θ、υ }，验证四元数函数与各参数∂ { μ } 的组合、 ∂ { φ }, ∂ { θ }, ∂ { υ }, ∂ { φ, θ }, ∂ { φ, υ }, ∂ { θ, υ }, ∂ { φ, θ, υ }, 和欧氏距离 (ED) 分别进行验证。</p>
<p>我们模拟了一个 ng × ng &#x3D; 34 × 54 的网格图，测试的目的是验证所提出的二次函数 ∂ 在更新网格搜索时的效率。为了防止算法在同一网格中搜索，会给经过的网格设置一个标签，当标签为 False 时，表示该栅格已被选为候选路径网格；当标签为 True 时，表示算法可以继续访问该网格。如果栅格在搜索过程中进入了无法通过的栅格（如图 15 中的红色栅格），算法可以将搜索逆转到前一个栅格并重新搜索。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021027748.png" alt="image-20240202102747613"></p>
<p>图 15. 针对构成四元数函数的参数，测试了不同参数对路径规划算法的影响。(a) ∂{φ} 对路径规划的影响。(b) ∂{θ} 对路径规划的影响。(c) ∂{υ} 对路径规划的影响。(d) ∂{φ，θ} 对路径规划的影响。(e) ∂{φ，υ} 对路径规划的影响。(f) ∂{θ, υ} 对路径规划的影响。(g) ∂{φ，θ，υ} 对路径规划的影响。(h) 仅根据欧氏距离进行路径规划。</p>
<p>在本实验中，设置了163个红色网格代表拥堵网格，即禁止车辆行驶的网格，以验证参数对路径规划和车辆的影响程度，只要是相邻的网格都可以行驶，包括对角相邻的网格。蓝色网格是从源点 s 到目的地 d 的路径，灰色网格为非拥堵网格，实验设置随机分配灰色网格的容量值，2 分钟改变一次，所有灰色网格均为车辆可通行的网格，且 μ 始终为 TRUE。这里需要注意的是，当算法在重复网格中不断搜索时，会增加搜索网格与目标网格之间的曼哈顿距离，以便算法能够搜索到其他已经搜索过的网格。</p>
<p>不同参数对搜索栅格的影响结果如图 15 所示。图 15a 仅以∂{φ} 的步长作为从源网格到目的网格的路径规划时搜索网格的条件。从图 15a 可以得出结论，算法在开始时对网格的搜索是有效的，当遇到 L 型障碍区时，算法在绕过拥堵区之前会进入死胡同，在后面的规划中，同样遇到 T 型障碍区和 L 型障碍区时，算法需要回溯。从图 15b 可以看出，通过角度∂{θ}时，选择最多的依据仍然是需要绕过大量的障碍区。</p>
<p>图 15c 显示，只有以 GDPR 值作为路径规划的条件，算法规划的结果是车辆走过许多重复区域，甚至在同一区域内循环搜索不同的网格，这种现象被称为绕行，在紧急场景下是不允许的。图 15d-f 显示了明显的改进，算法规划的路径可以让车辆通过更少的网格，但仍有少量迂回。图 15g 增加了三个元素∂{φ, θ, υ}，算法规划的路径明显优于其他路径。虽然在网格周围也有少量迂回，但整体规划路径的结果是进入障碍区的路径没有迂回，而且路径向目标网格的整体方向性较好。图 15h 显示的是只考虑欧氏距离的路径规划结果，搜索路径在 L 形拥堵区域出现了大量光栅迂回，这是因为算法只考虑了整体方向性，而没有考虑会遇到的拥堵区域。</p>
<p>其次，实验测试的自行车在不同路径长度下的算法对比，有说明路网密度问题，因为测试选择的路径长度不同，所以路径跨度的路网密度也不同，所以这点保证了算法在不同路网密度条件下的测试。因此，表 6 将涉及四种不同的道路长度 P1 &#x3D; 5.3 公里、P2 &#x3D; 17.5 公里、P3 &#x3D; 30.4 公里和 P4 &#x3D; 49.8 公里（曼哈顿距离）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021029156.png" alt="image-20240202102930036"></p>
<p>表 6 中，NGS 表示搜索到的网格数，NVS 表示搜索到的顶点数，runtime（RT）表示算法的有效性，∗ 为空。Dijkstra 算法作为路径规划中的广度优先遍历算法，随着路径长度的增加，搜索顶点的数量呈指数增长，当搜索路径为 49.8 km 时，访问顶点的数量高达 19 311 个。</p>
<p>A* 算法在搜索路径中访问的顶点数量要少得多，这是因为我们将启发式函数设为搜索顶点到目标顶点的欧氏距离，以此作为判断访问候选顶点的依据。T* 算法访问的顶点数量会比 A* 算法少一些。RTA* 是实时 A* 算法的一个变种，它增加了实时搜索路径的功能，但其搜索顶点的数量与 A* 算法基本相同。不过，RRT* 算法在搜索顶点时增加了路径剪枝策略，目的是在规划路径时增加尽可能剪枝路径的捷径，但与 A* 相比，其访问的顶点数量相近</p>
<p>GBD 算法和 SGHS* 算法都加入了栅格判断，因此两种算法比较的是栅格数。开始时，规划路径 P1 搜索的栅格数相同，因为路径长度不大，且路径长度跨越两个栅格。但是，随着规划路径距离的增加，算法搜索网格的差异就会显现出来。由于 SGHS* 算法增加了一个二次函数来决定网格的选择，这使得算法在搜索网格之前，只能选择容量相近的网格进行比较。因此，随着路径长度的变化，SGHS* 算法在减少网格数量方面有显著变化。GBD 算法和 SGHS* 算法由于受到网格的限制，所以在搜索距离为 49.8 km 时，搜索顶点数分别为 3482 个和 3369 个，因此与其他算法相比明显减少。不过，这种趋势在短距离路径规划中并不明显，因为在短距离路径规划中，相当于所有算法都在网格上搜索，所以搜索顶点数几乎相同。除了 Dijkstra 算法的运行时间稍长之外，其他六种算法的运行时间相近。虽然 GBD 算法和 SGHS* 算法搜索的顶点数基本相同，但增加了搜索网格的时间，而且 GBD 每次都需要比较相邻网格，SGHS* 比较的网格数比 GBD 少，但由于要计算二次函数∂{μ，φ，θ，υ}，SGHS* 和 GBD 算法的运行时间相近（347.5 ms 和 340.9 ms）。</p>
<p>第三，我们将验证算法在不同道路情况下的模拟实验使用情况。表 7 显示了不同算法在非拥堵（道路速度范围为 45 km&#x2F;h 至 120 km&#x2F;h）和拥堵（道路速度范围为 10 km&#x2F;h 至 80 km&#x2F;h）情况下进行的对比实验，并通过车辆的行驶时间进行验证（在不超过速度范围的情况下，为每条道路分配一个随机值）。实验路径选择 p1（5.3 公里）、p2（17.5 公里）、p3（30.4 公里）和 p4（49.8 公里）作为查询路径。根据路径的长度，可以对郊区和城区的路径规划进行比较。由于城市的道路密度大，郊区的道路密度小，因此算法的运行结果可以在不同道路密度的情况下进行验证，并根据车辆行驶时间（时间单位，分钟）进行比较。</p>
<p>从表 7 的模拟实验结果可以看出，当车辆以较高的速度在道路网络上行驶时，所需的时间并不因路径的长短而有太大的变化。当路况不拥堵时，Dijkstra 算法通过搜索两顶点之间的最短距离作为路径规划的基础，所提供的道路往往是两点之间的最短路径。不过，其他算法也是一样，A<em>、T</em>、RTA* 和 RRT* 也是以两点间的最短路径为基础进行规划的。对于 A* 和 T* 只是简单地加入了启发式函数，所以在规划路径时搜索时间较快，RTA* 是实时动态规划，但在路网速度较大时规划结果与 A* 相同。RRT* 只是在搜索时增加了剪枝策略，剪枝策略并不影响路径的规划结果。GBD算法虽然有网格，但其最终规划路径仍是基于两点间的最短路径，SGHS*算法是基于路网速度进行道路规划，由于城市路网整体速度相近，所以车辆行驶算法提供的路径耗时相差不大。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021031227.png" alt="image-20240202103115191"></p>
<p>在拥堵条件下，对不同算法规划的路径结果进行了比较。结果发现，与非拥堵情况相比，Dijkstra 算法规划的路径随着路径长度的增加而变长，这是因为该算法只能规划最短路径，无法绕过拥堵地区的道路。A* 算法和 T* 算法的结果相同。虽然 RTA* 和 RRT* 都是实时的，但算法的实时刷新频率大于路网的实时刷新频率，只能在下一步搜索路径，不能有效判断区域内的整体交通状况。GBD 算法和 SGHS* 算法规划的路径可以减少车辆的行驶时间。GBD 根据区域的最大容量为车辆规划路径，但由于不能保证车辆能有效避开区域内的拥堵区域，因此路径规划仍以区域内的最短路径为基础。但是，SGHS*算法选择路网速度较高的网格为区域间的车辆提供服务，并选择路网速度较高的道路供车辆在网格内行驶，因此这种策略在一定程度上避免了车辆驶入拥堵路段。</p>
<h3><span id="74-impact-of-graph-acceleration-algorithms-on-path-planning">7.4. Impact of Graph Acceleration Algorithms on Path Planning</span></h3><p>本节将比较几种图加速算法对路径规划的影响。首先比较了不同顶点大小的不同图收缩方法。实验使用六种图大小进行验证，顶点数分别为 500、1000、3000、5000、10000、20000 和 83884。根据算法的运行时间和收缩顶点的数量对算法进行评估。顶点代表顶点数；边代表边数；网格代表网格数；CV 和 CG 分别是收缩顶点数和收缩网格数；快捷方式代表连接两个新顶点的边；RT 代表算法运行时间。</p>
<p>从表 8 中可以得出图加速算法的结果。从表 8 中可以看出，CH 算法随着图的大小变大，搜索的顶点数也在不断增加，运行时间也呈指数增长，∗为空。SCH算法是根据路网速度来收缩顶点的，可以看出SCH收缩算法的数量没有CH算法多，但这是可以接受的，因为在实际路径规划中搜索算法不需要搜索整个图，只需要根据路网速度大小搜索顶点即可。</p>
<p>SGCH 算法和 SGMRCH 算法都对网格进行了收缩，因此增加了对网格的比较。由于这两种算法都是根据路网的速度进行收缩的，因此根据 DGPR 结果首先进行网格收缩，然后再进行顶点收缩，这使得算法的计算开销大于 CH 和 SCH。不过，从收缩结果可以看出，SGCH 以及 SGCH 和 SGMRCH 算法都收缩了大量网格和顶点。由于 SGMRCH 是基于网格收缩的 MRCH 算法，因此在 SGMRCH 算法多次迭代后，收缩的顶点数量比 SGCH 算法多。SGCH 和 SGMRCH 都根据网格容量值收缩网格，因此这两种算法的收缩网格数差别不大。值得注意的是，SCH、SGCH 和 SGMRCH 的运行时间均小于路网刷新频率的 2 分钟（120,000,000 ms）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021033125.png" alt="image-20240202103300071"></p>
<p>图 16a 比较了每种算法在不同路径长度下的运行效率，随着路径长度的增加，运行效率呈指数增长。图 16b 采用了传统的收缩分层算法，该算法根据交叉点的访问度对图进行收缩。从图中可以明显看出，该算法的运行效率有所下降，但随着长度的增加，算法的运行时间仍呈指数增长。图 16c 为 SCH 图搜索算法，与图 16b 相比，可以看出该算法的运行效率有所提高，因为 SCH 算法主要根据路网速度收缩交叉口，所以当路网速度变化不明显时收缩的顶点很少。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021034212.png" alt="image-20240202103400857"></p>
<p>图 17 显示了在查询量的基础上添加不同图形加速算法的效率，旨在提高多车辆情况下路径规划算法的运行效率。图 17a 显示，算法的运行时间随着文本量的增加而增加。当查询文本量达到 70 KB 时，SGHS* 算法的运行时间比其他算法稍慢。图 17b,c 分别添加了 CH 和 SCH 图收缩算法，但路径规划算法的运行时间指标仍随着查询量的增加而快速上升。图 17d,e 中分别加入了 SGCH 和 SGMRCH 算法。可以看出，GBD 和 SGHS* 算法的增长趋势明显减弱。</p>
<p>最后，图加速算法明显提高了路径规划算法的搜索效率。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402021034326.png" alt="image-20240202103451400"></p>
<h3><span id="75-discussion">7.5. Discussion</span></h3><p>首先，DGPR 算法是对原有 GPR 算法的改进，它需要搜索网格中的每个顶点。DGPR 改进了权重的计算方法，使其更符合实时路网情况。顶点所在的网格会被分配和排序，每个顶点仍然需要被遍历。DGPR 的收敛速度比 GPR 快约 5 次迭代，这主要是由于简化了网格排序的计算过程，且相同迭代次数下 DGPR 的运行时间更短。</p>
<p>其次，与 GBD 算法相比，SGHS* 算法的空间复杂度更高，因为 GBD 算法是双向搜索顶点，而 SGHS* 算法是单向搜索顶点，主要原因是为了避免搜索拥挤的顶点。SGHS* 算法尽可能排除了不必要搜索的道路和交叉口。这样的处理提高了算法的计算效率，缩短了算法的运行时间。剪枝策略是减少一次迭代中对顶点的搜索，因此 SGHS* 的计算时间比 GBD 少，当测试路径距离为 49.8km 时，在拥堵情况下，使用 SGHS* 的车辆所用时间比 GBD 快 6.6 分钟。同样的原理也适用于 T<em>、RTA</em> 和 RRT* 算法。T<em>、RTA</em>和RRT<em>的目的是为了快速收敛路径规划算法，并考虑路网的实时动态变化，但这三种算法并没有考虑探索尽可能多的可能性，而SGHS</em>加入了剪枝策略，有效排除了冗余路径的可能性。此外，当搜索路径长度为 5 km 左右时，SGHS* 算法的搜索时间高于 RTA<em>、RRT</em> 和 GBD 算法，但随着计划长度的增加，SGHS* 算法的运行时间小于它们。因此，主要原因是随着路径长度的增加，SGHS* 算法搜索的顶点数远远少于其他算法。</p>
<p>第三，本文提出的三种图加速算法的时间复杂度不同。与基线算法 CH 相比，SGCH 和 SGMRCH 收缩网络的结果显示路径规划有明显改善。不过，从收缩结果来看，SCH 和 CH 的差异并不明显，这主要是因为 SCH 考虑的交点情况与 CH 考虑的交点重要性情况相似，因此两种算法收缩的顶点数量也相似。由于在图搜索中使用了双向策略，SCH 算法的时间复杂度较小，因此为 O(2logn)。SGCH 增加了单向图遍历，所以它的时间复杂度为 O(n)，SGMRCH 算法需要遍历一次路网中的所有顶点，然后根据情况信息进行网格收缩和顶点收缩，所以 SGMRCH 的时间复杂度为 O(n2)。但与其他图加速算法相比，SGMRCH 由于进行了多次路网收缩处理，收缩顶点数量最多，计算时间小于网络采样频率的 2 min，是整体路径规划时间和计算成本的最佳选择。CH 只单一考虑了顶点的通达度情况，没有结合实际路网交通流量，因此收缩了一些不重要的交叉口，影响了计算效率。而 SGCH 和 SGMRCH 加入了网格的收缩，在一定程度上增加了搜索顶点的数量（一个网格包含多个顶点），使得路径规划时不再搜索拥堵区域。这样就提高了路径规划的效率。</p>
<h2><span id="8-conclusions">8. Conclusions</span></h2><p>总之，通过对比实验可以得出，当道路行驶条件发生变化时，SGHS* 算法提供的路径使车辆行驶到目的地的时间更短，当路径小于4 km时，SGHS*+SGCH算法的效率更高，当查询路径大于4 km时，SGHS* +SGMRCH的运行效率更高。而且，SGCH 和 SGMRCH 算法的运行时间小于态势信息的刷新时间，因此满足了 DGPR 对网格进行排序后的图加速处理。此外，SGHS* 算法在加入四元数函数∂{μ，φ，θ，υ} 作为网格判断后，加快了搜索目标网格的收敛时间。</p>
<p>在这项工作中，我们利用对北京路网数据和车辆轨迹数据的分析，并在路网网格为 ng &#x3D; 288 的情况下，对提出的 EGEPP 框架进行了验证。在紧急情况下，我们在态势图 SGRN 模型的基础上，增加了 SGHS* + SGCH 和 SGHS* + SGMRCH 算法来规划路径，并为车辆提供容量较大的道路，使车辆绕行到达目的地。仿真结果表明，路径规划的最佳查询时间窗为 Tq &#x3D; 15 min。当查询时间窗口小于 Tq &#x3D; 15 分钟时，需要重复路径规划搜索。当查询时间窗口大于 Tq &#x3D; 15 分钟时，算法规划的路径往往会进入拥堵区域。最后，通过大量实验发现，在城市道路上发生紧急情况时，EGEPP 框架比 GMEPP 框架能提供更好的绕行路径。 在今后的工作中，我们仍将重点关注路网权重（如道路坡度或最大车辆承载能力）等态势信息的影响，以及城市路网通行之间的相关因素对路径规划的影响。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-01T02:04:35.000Z" title="2024/2/1 10:04:35">2024-02-01</time>发表</span><span class="level-item"><time dateTime="2024-02-25T16:30:29.548Z" title="2024/2/26 00:30:29">2024-02-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">2 小时读完 (大约16605个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/01/Path-Planning-for-Autonomous-Mobile-Robots-A-Review/">Path Planning for Autonomous Mobile Robots: A Review</a></p><div class="content"><h1><span id="path-planning-for-autonomous-mobile-robots-a-review">Path Planning for Autonomous Mobile Robots: A Review</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011006947.png" alt="image-20240201100645752"></p>
<h2><span id="abstract">Abstract</span></h2><p>摘要：为移动机器人提供自主能力是有好处的。它使人们可以免去人类操作员的干预，这可能会在经济和安全方面带来好处。在大多数情况下，自主性要求使用路径规划器，使机器人能够考虑如何从其所在位置在某一时刻移动到另一时刻。鉴于文献中存在大量的方法，根据用户的要求寻找最合适的路径规划算法可能具有挑战性。此外，本文所分析的过去的综述作品只涵盖了其中的一些方法，遗漏了一些重要的方法。因此，我们的论文旨在作为一个起点，对迄今为止的研究进行清晰而全面的概述。本文介绍了路径规划算法的总体分类，重点关注与自主地面车辆一起使用的方法，但也可扩展到在表面上移动的其他机器人，如自主船只。此外，还从路径规划的角度探讨了用于表示环境的模型以及机器人的移动性和动力学。对分类中提出的每个路径规划类别都进行了披露和分析，并在最后对其适用性进行了讨论。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>自主导航是移动机器人的宝贵财富。它有助于减轻机器人对人工干预的依赖。然而，它也需要解决许多任务或问题，例如路径规划。这项任务在于找到最佳行动方案，使机器人从当前状态到达理想状态。例如，这两个状态可以分别是目标和初始位置。这一行动路线以路径的形式出现，在许多其他著作中也被称为路线。路径的作用是引导机器人到达所需的状态。然而，考虑到机器人可移动的自由空间，可能会有无数条可能的路径。路径规划算法通常试图获得最佳路径，或至少是其可接受的近似值。&#x3D;&#x3D;这里的最佳路径指的是最优路径，即通过最小化一个或多个目标优化函数得到的路径。&#x3D;&#x3D;例如，这条路径可能是耗时最少的路径。这在搜救等任务中至关重要[1]：灾难受害者可能会在生死关头请求帮助。另一个需要考虑的优化功能可能是机器人的能量。在行星探索中，这一点至关重要，因为漫游车可用的能源资源有限[2]。同时，规划器生成的路径必须遵循任何强加的限制。这些限制可能来自于机器人对某些地形的适应性限制。机器人的运动能力和现有地形的特点限制了可执行的操作类型。这就减少了路径规划器可生成的可行路径的数量。</p>
<p>在文献中，有大量的路径规划方法，而且这种方法的数量近年来还在不断增加。因此，根据特定要求（例如上述运动限制）选择最合适的方法是一项具有挑战性的任务。此外，如下文所述，有关路径规划的最新评论和调查并未对大多数现有路径规划解决方案进行全面概述。这就是撰写本综述论文的主要动机：它详细描述了不同的路径规划类别，并针对其中的每一类，介绍了文献中具有代表性的相关参考文献，重点关注那些针对在表面上（地面、水面等）移动的机器人的算法。本文的结构如下。第 2 节介绍本文提出的对现有路径规划算法进行分类的方法。根据该方法，本文还明确指出了之前的工作存在重要疏漏的事实。此外，本节还分析了用于处理环境和运动信息的方法。接下来的章节将分别讨论这一分类中的一个类别： 反应计算（第 3 节）、软计算（第 4 节）、C 空间搜索（第 5 节）和最优控制（第 6 节）。最后，第 7 节总结了本文的内容，并对上述类别中包含的路径规划算法进行了讨论。</p>
<h2><span id="2-path-planning-algorithms">2. Path Planning Algorithms</span></h2><p>图 1 描述了路径规划的四个类别，每个类别又分为两个子类别。这种分类基于构建和返回路径的原则和基本机制。下一小节将更详细地介绍这些类别以及为何如此分类。第二小节将介绍环境建模和机器人与地形交互建模的不同方法。我们认为有必要增加这一内容，因为对于许多算法，尤其是 C 空间搜索类算法，有必要事先构建这些模型。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011012260.png" alt="image-20240201101204048"></p>
<p>图 1. 现有路径规划方法分类示意图。共有四个主要类别，每个类别包含两个子类别。不同类别中相邻的两个子类别具有共同特征。该示意图还显示了某些子类别更倾向于全局规划或局部规划。</p>
<h3><span id="21-general-classification">2.1. General Classification</span></h3><p>建议的分类考虑了路径规划算法的功能。在过去的许多综述中，人们对路径规划算法进行了两种区分：一是根据环境是否动态来区分；二是根据在线和离线路径规划算法来区分[3]；三是根据环境的大小来区分，是局部环境还是全局环境。通常，”在线 “与 “本地 “相关，而 “离线 “与 “全局 “相关。这其中的主要问题是，有一些算法可以同时归为这两类。没有重新规划能力的算法由于计算速度快，可以在线使用。相反的情况也可能发生。例如，一种名为动态窗口法（DWA）的反应式计算算法通常用于局部规划[4]，但也可用于全局规划[5]。Vagale 等人[6]提出了一种有趣的算法划分方法，即需要初步地图表示的算法（经典算法）[7] 和不需要初步地图表示的算法（高级算法）。经典算法包括图搜索方法，而高级算法则包括软计算和基于采样的算法。Souissi 等人[7]提出了几种清晰合理的路径规划分类：根据机器人模型（整体动力学、非整体动力学、动力学）；根据地图模型要求（需要或不需要）；根据重新规划能力（离线或在线）；根据初步配置参数（确定性或概率性），根据算法是否总是计算出相同的解决方案。</p>
<p>本文提出的分类（如图 1 所示）有两个主要目的。首先，与以往的综述相比，本分类旨在涵盖更多种类的算法。过去的许多综述都提出或声称要对路径规划进行综述，但从表 1 中可以看出，大多数综述都存在重大遗漏。在本表中，”是 “表示对相关算法进行了重要讨论。仅提及表示出版物承认至少存在一种或多种该类算法。如果括号之间有一两个算法，则表示这些算法只被简单提及。其次，在某些情况下，路径规划类别的命名方式并不明确。例如，其他一些综述对经典方法和启发式方法进行了区分 [8,9]。Patle 等人[10] 将后者称为 “反应式”。然而，”经典 “一词可能是一个相当模糊的术语，因为大多数规划算法都是基于已有数十年历史的方法。这一类算法还包括许多运作方式完全不同的算法。&#x3D;&#x3D;启发式这一术语不仅用于指进化算法和人工智能算法 [8]，也用于指基于图搜索的规划算法 [4]。&#x3D;&#x3D;有鉴于此，我们&#x3D;&#x3D;建议使用四个类别（见图 1）进行一般分类： 反应计算、软计算、C 空间搜索和最优控制&#x3D;&#x3D;。此外，图 1 显示了这些类别中的每个类别在一般情况下是如何主要用于局部或全局规划的。此外，每个子类别与其他类别的子类别在功能上也会有一些共同点，例如使用数值方法、存在用于事先调整算法的参数、要求用图形对地图进行建模或使用随机迭代过程。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011013062.png" alt="image-20240201101344831"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011014363.png" alt="image-20240201101410215"></p>
<h3><span id="22-path-planning-workspace-modeling">2.2. Path Planning Workspace Modeling</span></h3><p>路径规划器需要获得描述环境的信息。例如，这些信息可以描述是否存在障碍物或与规划相关的表面特征。此外，用于计算路径的标准还与机器人与环境的交互方式有关。例如，只需尽量缩短路径长度，或许还能获得哪些区域可以穿越、哪些区域不可以穿越的信息就足够了，而要尽量减少能量消耗，则应考虑到地形力学和机器人的转向方式。</p>
<h4><span id="221-environment-modeling">2.2.1. Environment Modeling</span></h4><p>表面移动机器人是在空间的某个区域内从一个位置移动到另一个位置。因此，有必要考虑运动模型将如何与该表面交互，以及路径规划器将如何处理。例如，有些算法需要构建一个图形，以某种方式代表机器人移动的环境。&#x3D;&#x3D;图搜索算法（属于 C 空间搜索范畴）大多属于这种情况&#x3D;&#x3D;。蚁群优化算法（ACO）等进化算法也可以使用图形。这种资产可以表示影响机器人导航的地形特征在场景中的空间排列方式。特别是，本文假定有关图形是建立在度量图的基础上，同时也承认本文讨论范围之外存在其他类型的地图，如拓扑图和语义图[22]。根据 Souissi 等人的研究[7]，有多种构建图的方法，如图 2 所示。Nash 和 Koenig [11] 的研究也对这种分类方法有所启发。他们对单元分解和路线图进行了区分。第一种方法是将曲面分割成单元格。这些单元格可以使用规则网格[3,4,7,11]或不规则网格[7,11]进行排列。图 2a-c 展示了如何使用正方形、三角形和六边形三种多边形中的一种来构建规则网格。它的主要优点是每个节点的索引简单，可以快速访问其中任何一个节点，并以优化的方式将其存储在内存中[23]。&#x3D;&#x3D;不规则网格（如图 2d 所示）可以使网格更好地适应不同分辨率值的地形特征，但代价是可能获得较差的路径[24]。&#x3D;&#x3D;单元格分解的其他形式还有导航网格和基于圆的航点图，如 Nash 和 Koenig 所解释的那样[11]。如前所述，环境的另一种表示形式是使用路线图。路线图是由边连接的节点构成的图形。每个节点代表机器人的一种可能状态，而每条边则表示如何从另一种状态到达该状态。路线图的例子包括&#x3D;&#x3D;沃罗诺图[25]&#x3D;&#x3D;（见图 2e）、&#x3D;&#x3D;可视图[26]&#x3D;&#x3D;和&#x3D;&#x3D;状态网格图（见图 2f）&#x3D;&#x3D;。后者包括根据运动基元制作边，因此在机器人移动限制条件下，所产生的路径确保是可行的，尤其是在使用图搜索算法时，如 Likhachev 和 Ferguson [27] 以及 Bergman 等人 [28] 的研究。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011015051.png" alt="image-20240201101538891"></p>
<p>图 2. 不同类型的环境单元分解图（a-d）和路线图（e-f）。(a) 正方形网格。(b) 使用三角形的棋格图。(c) 使用六边形的网格。(d) 不规则网格。(e) Voronoi 路线图。(f) 状态网格图。</p>
<p>这些图中的单元或节点可以静态或动态元素的形式存储其所在位置的地表信息[10]。例如，这可以是高程信息。数字高程图（DEM）是一个网格，其中每个节点都有一个相关的高程值。高程图也可以用多边形表示，&#x3D;&#x3D;但常规网格图更受欢迎[29]&#x3D;&#x3D;。与形状相关的特征，&#x3D;&#x3D;如坡度或表面粗糙度，可通过卷积矩阵提取 [30]。&#x3D;&#x3D;核的大小和 DEM 的分辨率将决定提取的特征类型。此外，这种分辨率还决定了地图中所包含要素的详细程度。如图 2d 所示，这种分辨率可以是非均匀的，也可以是多重的。网格的大小可以根据规划的规模来选择： 在覆盖机器人周围环境的情况下（或多或少是机载传感器可触及的距离），网格的大小为本地网格；而在覆盖范围大于本地网格的情况下，网格的大小为全球网格，通常使用卫星或无人机等外部来源的信息。</p>
<p>关于如何定义规划器工作区的成本，有不同的方法。首先，&#x3D;&#x3D;我们将成本理解为机器人在移动过程中累积的度量。路径规划器的目标是通过生成最优路径，最大限度地减少这种累积。&#x3D;&#x3D;有关成本可以是统一的，即机器人可以进入的区域始终具有相同的值。这种方法可用于避免碰撞的路径规划，在这种规划中，诸如二维平面上的路径长度等指标都会被最小化。&#x3D;&#x3D;非均匀成本地图可用于为不同的可访问区域分配不同的成本值。例如，这对确定机器人在每个位置的能量性能非常有用。&#x3D;&#x3D;此外，成本还可以根据方向向量来定义。这意味着，机器人将根据其航向具有不同的成本值。在这种情况下，&#x3D;&#x3D;成本被归类为各向异性[31]&#x3D;&#x3D;，而在相反的情况下，成本则是各向同性的。此外，机器人的转向动作也会根据其运动情况产生不同的成本值。最后，值得注意的是，环境可以是完全已知的，也可以是部分已知的，甚至是完全未知的。</p>
<h4><span id="222-robotsurface-interaction-modeling">2.2.2. Robot–Surface Interaction Modeling</span></h4><p>地面移动机器人与脚下的地表相互作用，推动自身前进。为了实现这一功能，有许多不同的运动执行器，例如轮子、履带、腿，甚至全向轮。图 3 展示了三个使用不同配置执行器的地面移动机器人的实际例子。这些致动器以及将它们连接到机器人本体的关节决定了机器人的运动结构和动态行为。换句话说，它们决定了机器人的运动配置。Zhang 等人[20]总结了一些众所周知的不同配置的运动学和动力学模型： 差动驱动[32]（见图 3a 中的 Koguma 机器人[33]为例和图 4a 中的模型描述）、阿克曼转向[34]（见图 4b、d）、滑行转向[35]（见图 4c）和全向[36]。其中一些模型包含与路径规划相关的约束条件，如前阿克曼转向机器人的最小转弯半径[37]（见图 4b）或滑行转向机器人在转弯动作中的高能耗[38]。此外，还有一种称为 “蟹行 “的模式（见图 4e）。由于所有车轮的顶部都有转向关节，这种模式允许机器人朝不同的方向行驶 [39]。此外，某些运动学配置还允许机器人进行点转向操作，使其在不平移的情况下旋转。值得一提的是，有一些铰接式机器人能够重新配置自己，以获得某种好处，并执行多种类型的运动（图 3c 中的 SherpaTT 就是一个例子）。例如，带有履带的铰接式机器人可以在崎岖地形上行驶时主动控制其稳定性[40,41]。还有一些机器人使用脚轮配置来执行一种名为 “轮行”（Wheelwalking）的运动模式 [42,43]。这种模式旨在克服机器人可能被卡住的松软地形。与此类似，推拉式运动模仿毛毛虫的运动方式，以增加在此类地形中的牵引力[44-46]。承认这种重构能力的路径规划算法是这类机器人必须具备的，因为这些算法可以找到利用其高度适应性的路径。在全局规划方面，Rohmer 等人[47] 使用了一种名为 Dijkstra 的图搜索算法，首先生成一条路径，然后通过仿真工具评估哪种运动模式更适合驱动每个部件。我们，这篇综述文章的作者，提出了使用 PDE 求解方法，在规划时使用各向同性成本函数考虑多种运动模式 [48,49]。据作者所知，目前还没有很多局部规划方法可以解决具有多种运动模式的机器人的动力学约束问题。Reid 等人[50]提出使用基于采样的算法–快速行进树（FMT*）–来解决带轮腿的可重构混合机器人的运动规划问题。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011018540.png" alt="image-20240201101840941"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011019926.png" alt="image-20240201101902693"></p>
<p>机器人的运动适应性好坏取决于地形特征，这在前面已经简要提到过。这些特征可能与地形的形态（形状）或构成有关。其中之一就是地形的倾斜度或坡度[51]。坡度会影响机器人的滚动角和俯仰角，这对于保持机器人的稳定性非常重要 [41,52,53]。此外，坡度还会根据方向影响机器人的能量表现。这种对方向的依赖性是由于重力的影响，使机器人在爬坡、下坡、横向或斜向穿越斜坡时消耗不同的能量[29,54-57]。另一个相关的地形特征是粗糙度。这是对法线矢量多样性的衡量 [58,59]，可能会影响机器人所经历的振动。根据机器人的底盘，它还可以克服其他地形。例如，机器人可以利用机身间隙（即机身下表面与地形表面之间的空间）克服岩石[60,61]。洞或沟等负面障碍物的存在可能会造成问题，因为它们很难被机器人的传感器捕捉到 [62]。至于地形的构成，它对机器人与地表交互的基本动态有影响。这种表面可能更坚硬，也可能更容易变形 [63]。这会影响机器人附着在表面上的方式，甚至限制其运动 [64]。一般来说，滑移是衡量机器人实际速度与指令速度之间差异的指标，通常通过计算两者之间的比率来实现 [65,66]。一些研究同时考虑了滑移和地形坡度，以便在穿越崎岖地形时对机器人进行更精确的估算 [67,68]。重力大小也会影响机器人与地形之间的动态交互 [30,69]。最后，路径规划器通常使用包含与形状和组成相关的多种地形特征的成本函数。例如，Ishigami 等人[2] 引入了动态移动指数，包括稳定性、滑移、经过时间和能耗。此外，与地形没有直接关系的其他因素也可能影响机器人的导航性能。其中之一就是太阳辐射 [66,70]，可将其建模为动态函数 [71]。Groves 等人[72]绘制了可能对机器人造成伤害的其他辐射类型，如在核拆除场景中。此外，风险概念对于防止机器人陷入危险境地也非常重要 [73]，例如，随着机器人靠近障碍物，成本也会增加 [74]。</p>
<p>图 4 轮式地面移动机器人的运动模型 轮式地面移动机器人使用的运动模型以及路径规划器： 差速驱动 (a)、前阿克曼 (b)、滑移转向 (c)、全阿克曼 (d)、抓取 (e) 和点转向 (f)。</p>
<h2><span id="3-reactive-computing-based-path-planning-algorithms">3. Reactive-Computing-Based Path Planning Algorithms</span></h2><p>这类算法包括路径规划算法，在这类算法中，环境（通常是一张区分障碍物和非障碍物区域的地图）只显示现有障碍物的位置和形状。&#x3D;&#x3D;反应式计算算法通常被用作局部路径规划算法&#x3D;&#x3D;（覆盖机器人周围环境并进行动态重新规划），因为它们有能力快速处理新信息（例如，以新发现障碍物的形式），这些信息通常来自有限的机载传感器。作为局部规划算法，&#x3D;&#x3D;这些算法通常会在遵循另一种算法制定的全局规划的同时，规划下一条直接路径或机动动作，以避开附近的障碍物。&#x3D;&#x3D;不过，&#x3D;&#x3D;这些算法可能会计算出局部最小路径，甚至导致机器人被卡住，因此必须特别小心。&#x3D;&#x3D;反应式计算算法有两个子类别： 反应式机动方法，即由障碍物的存在决定机器人的下一步行动；局部优化方法，即根据障碍物的存在修改现有路径。</p>
<h3><span id="31-reactive-manoeuvre">3.1. Reactive Manoeuvre</span></h3><p>本文介绍的算法依赖于定义机器人在每一时刻对障碍物的存在做出的反应。这种反应可以根据处理现有障碍物位置的公式来定义。不同表述方法的共同特点是产生反应所需的计算量较低，通常以转向或速度指令的形式出现。由于这种表述方式缺乏全局信息，因此这些技术通常被用作局部规划器。这种方法可以利用场来确定障碍物的位置，也可以通过检测障碍物边界来绕过障碍物，还可以在评估可用自由空间或移动障碍物的速度后发出速度指令。</p>
<p>&#x3D;&#x3D;势场法方法包括人工势场（APF）和矢量场直方图（VFH）算法。&#x3D;&#x3D;在人工势场算法中，机器人的运动可以来自障碍物等外部元素产生的虚拟力的总和。这样，机器人会离这些障碍物越来越远，并避免与它们发生碰撞，因为来自它们的力是排斥性的 [75]。目标位置产生的吸引力会使机器人朝目标位置前进。从图 5a 中可以看出这一点。Ge 和 Cui [76] 提出了 APF 在包含动态障碍物环境中的应用。不过，这种策略的主要缺点是容易导致机器人陷入局部最小点。因此，进一步研究工作的方向是克服这一问题。这正是 Vadakkepat 等人[77]研究的主要目标。他们将 APF 与遗传方法（进化算法）相结合，以克服这种情况。这一组合还被用于规划模拟六轮漫游车的运动[78]。另一个混合版本包括使用 PSO 算法 [79]。Triharminto 等人[80] 提出了一种非混合解决方案，即在漫游车周围添加一个斥势场。不过，该方案尚未在 U 形障碍物上进行过测试。其他研究通过在检测到机器人处于局部最小点时创建自定义逃逸路径来解决这一问题 [81]。此外，Bayat 等人[82] 提出了一种受静电势场启发的解决方案，即用所谓的标量势场来引导机器人，而不是使用虚拟力的总和。Borenstein 等人[83]提出的 VFH 可创建极直方图来评估机器人周围的障碍物密度，从而选择障碍物密度最低的转向角。几年后，VFH 又有了一些改进 [84,85]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011020319.png" alt="image-20240201102053094"></p>
<p>&#x3D;&#x3D;Bug 算法，即 Bug1 和 Bug2，可使机器人绕过途中发现的任何障碍物，直至到达目标[86]。&#x3D;&#x3D;它们的主要区别在于，Bug1 能让机器人绕过所有障碍物（见图 6a），而 Bug2 只能绕过部分障碍物 [19]。Bug1 和 Bug2 都不追求最优性，而是追求简单易用和计算量极少。它们可以用在只配备传感器的机器人上，这些传感器只能探测到机器人附近的障碍物。这样，这些机器人要么朝着目标行驶，要么沿着它们发现的障碍物的边界行驶。Buniyamin 等人[87] 和 Campbell 等人[19] 的研究提到了改进这种算法的一些变体，总体上减少了机器人的行驶距离。Xu 等人[88] 使用的 Bug 算法考虑了转弯半径限制，可生成平滑转弯的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011021497.png" alt="image-20240201102138305"></p>
<p>图 6. Bug 算法（a）和带气泡边界的弹性带（b）算法中使用的概念的图形表示。(a) 使用 Bug1 算法后的路径。(b) 经历拉伸后的路径。</p>
<p>以下方法主要是为机器人生成速度指令。速度障碍法考虑到智能体和任何其他移动障碍物的速度矢量，计算出一条安全轨迹[89,90]。这种计算方法会评估一个碰撞锥，如图 5b 所示。Chen 等人[91]将速度障碍与另一种称为快速行进方阵（FMS）的算法混合使用。Wilkie 等人[92]考虑了汽车的 Front-ackermann（见图 4b）运动模型。Chakravarthy 和 Ghose [93] 建议使用碰撞锥算法，该算法与速度障碍类似，但考虑到了任意形状的障碍。Qu 等人[94]介绍了该算法与汽车模型（如图 4b 所示，采用 Front-ackermann 配置）的结合使用。最后，动态窗口法（DWA）是一种在速度空间中搜索速度指令以遵循无碰撞圆形轨迹的算法，该轨迹由可接受速度值和时间窗口限定[95]。该方案可能不是全局最优方案，而是局部最优方案 [4]。DWA 甚至可用于高速航行的机器人 [96]。Feng 等人[97] 提出了一种改进版本，通过减少搜索速度空间来降低复杂性。其他方法将该算法用于能量最小化路径规划 [98,99]。虽然该算法通常被用作局部规划算法，但 Zhang 等人[5]提出将其作为全局路径规划算法在全球范围内使用。</p>
<h3><span id="32-local-optimization">3.2. Local Optimization</span></h3><p>&#x3D;&#x3D;这些算法通常从预先存在的路径出发，根据现有障碍对其进行修改。&#x3D;&#x3D;在这种情况下，优先考虑的是将计算量保持在最低水平，而不是牺牲最优性甚至完整性。修改路径有多种选择，从在速度空间内选择速度曲线，到在人造力作用下拉伸和拉长路径，不一而足。</p>
<p>在路径规划中使用弹性带是由 Quinlan 和 Khatib [100] 提出的。该方法根据障碍物的情况对现有的无碰撞路径进行变形，拉伸（见图 6b）或拉长。根据路径中的一组点，创建一组重叠的子区域，称为 “气泡”。这些 “气泡 “覆盖了无碰撞区域，其大小以与障碍物的距离为界。这就意味着，在路径中靠近障碍物的部分，气泡更小、数量更多。该方法可用于动态环境中，但较大的变化可能会导致方法失效 [100]。此外，该方法还通过遵守曲率约束 Khatib 等人[101]和使用贝塞尔曲线[102]适用于非自主车辆。弹力带的扩展包括时间约束，被命名为定时弹力带（TEB）。这一扩展版本解决了机器人的动力学约束 [103]。</p>
<h2><span id="4-soft-computing-based-path-planning-algorithms">4. Soft-Computing-Based Path Planning Algorithms</span></h2><p>&#x3D;&#x3D;这类算法的目的不是找到精确的最优解，而是近似最优解，并能容忍一定范围内的不精确。&#x3D;&#x3D;一般来说，这些算法需要用户调整某些参数，以便根据环境特征正常工作。这些算法甚至可以处理动态环境，适用于涉及大量变量和高自由度的问题[8]。不过，一般来说，它们需要大量的计算资源。本综述沿用 Mirjalili 和 Dong 提出的分类方法[104]，将其分为进化法、模糊控制法和机器学习法。第一种方法使用受生物学和自然界启发的技术：它们从一个由个体组成的系统开始，随着时间的推移而变化，即进化。模糊控制和机器学习方法属于人工智能的一个子类别。它们分别使用模糊规则和神经网络来生成控制器。这些控制器对于在最初的未知场景中导航非常有用，一般来说，它们会根据机器人探测到的障碍物生成路径。总之，软计算算法允许对一系列重复性元素（自然个体、模糊规则或人工神经元）进行调整，以生成路径。</p>
<h3><span id="41-evolutionary-computation">4.1. Evolutionary Computation</span></h3><p>&#x3D;&#x3D;进化算法也被称为元启发式或自然启发式 [105]&#x3D;&#x3D;。这些算法通过种群的进化产生一条路径。种群由智能个体组成，其行动仿照自然界中的行为[104]。这些行为可能涉及修改自身和&#x2F;或与其他个体交互。在某些情况下，这些操作意味着个体在环境的自由空间（即机器人可到达的空间）中进行运动。在执行一系列这些操作后，算法会逼近最优解。最终的路径和收敛所需的时间取决于分配给个体的行为策略、场景的性质以及用户分配给某些可配置参数的值。后者的一个例子就是填充路径规划问题的个体数量。进化算法包括遗传方法和蜂群优化器。第一种方法使用染色体模型，而第二种方法则以生物的行为为模型。</p>
<p>如前所述，遗传算法是以染色体为模型的个体[106]。这些个体包含基因，就像染色体一样，以二进制数字的形式存在。这些数字编码了一个解决方案，即在解决路径规划问题的特定情况下形成路径的一组航点。换句话说，群体中的每个染色体都代表一条路径。图 7a 展示了一个使用网格的例子。网格由单元格组成，每个单元格都标有一个数字。遗传算法从一组随机染色体开始。这组染色体通过三个过程进化： 繁殖、交叉和突变 [107]。复制通过复制最好的染色体来产生新的染色体。同时也会删除最差的染色体。交叉是染色体交换基因的过程。突变在基因中引入随机变化，以鼓励探索搜索空间并避免局部最小值。不断重复这些过程，算法就会收敛。Zhang 等人[4]提到，遗传算法在接近最优解时收敛速度会越来越慢。Han 等人[108] 使用遗传算法在有动态障碍物的环境中寻找最短路径。Tuncer 和 Yildirim [109] 对突变过程进行了修改。这包括检查即将发生突变的位置周围的空闲节点。这项工作将结果与之前的变异方法进行了比较。另一项研究工作使用了遗传算法以及高达 2000 × 2000 节点的大型网格[110]。用于路径规划的遗传算法也在一个实验平台上进行了测试[111]。更多的改进包括初始选择航点时，考虑那些位于障碍物附近的航点[112]。Elhoseny 等人[113]考虑到染色体的多样性，在突变过程中引入了更为规范的探索策略。此外，&#x3D;&#x3D;这项研究不仅优化了路径长度，还利用贝塞尔曲线保持了平滑度。&#x3D;&#x3D;最后，Lamini 等人的研究[114]还对交叉过程进行了改进，使解决方案收敛得更快，并减少了机器人转弯的次数。Patle 等人[10]的综述中介绍了许多基于遗传方法的路径规划应用。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011024879.png" alt="image-20240201102408753"></p>
<p>图 7. 进化算法示例： 遗传算法 (a) 和蜂群优化算法 ACO (b)。(a) 用于执行路径规划的遗传算法的功能。图中的路径为染色体形式，基因为 21-08-03-06。(b) ACO 算法的功能。模拟蚂蚁在最短路径上沉积更多的信息素。最终，大多数蚂蚁会沿着这条路径前进。</p>
<p>与基于遗传方法的算法不同，蜂群优化器使用在自由空间中移动和行动的智能体。在大多数情况下，这些个体是以动物为模型的。经过一系列迭代后，这些个体朝向目标的运动会形成一种模式，最终收敛到产生的路径上。表 2 介绍了文献中使用的一些模型。粒子群优化（PSO）算法因其简单性而脱颖而出。它的灵感来源于某些动物群体的行为，如鱼群[115]。它创建了一系列粒子，这些粒子会随着时间的推移自行重新定位，直到算法收敛。这些算法寻找最佳位置，并根据以往经验相互交流 [116]。Mac 等人[117]提出了一种路径规划器，将 PSO 与 Dijkstra 算法（下文将讨论的一种图搜索规划器）相结合。另一种著名的算法是蚁群优化器（ACO），顾名思义，它是模拟蚂蚁的行为。这些昆虫在寻找食物的过程中会留下信息素的痕迹。其他蚂蚁可以追踪到这些痕迹。那些含有较多信息素的地方就是最佳发现路径的航点。图 7b 描述了在起点和目标位置之间有障碍物的情况下的这一概念。在这里，最佳路径就是最短的路径。按照同样的策略，虚拟蚂蚁可以在网格上移动，根据它们与目标之间的状态留下更多或更少的信息素 [118,119]。为了避免陷入局部最小值，一些研究将这种方法与启发式函数相结合 [120,121]。Che 等人[122]也通过采用灰狼方法中使用的规则解决了这一问题。Luo 等人[123]对 ACO 做了一些改进，不仅避免了死锁，还缩短了收敛所需的时间。还利用 DEM 对该算法进行了模拟，以最小化时间[124]和能量[125]。Sangeetha 等人的研究[126]也在避开动态障碍物的同时实现了后者。这项研究将 ACO 与模糊控制相结合。受自然启发的方法还有很多。为避免过多扩展，表 2 列出了其中一些。此外，还有将两种模型相结合的情况。Saraswathi 等人提出的方法就是这种情况[127]，其中对 Cuckoo 算法和 Bat 算法的混合进行了测试。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011025329.png" alt="image-20240201102500187"></p>
<h3><span id="42-artificial-intelligence">4.2. Artificial Intelligence</span></h3><p>软计算算法可使用其他可配置运算符集，如模糊规则或神经网络。Seraji 和 Howard [140] 演示了在一个实验性移动平台上使用模糊逻辑在非结构化地形中导航。Zavlangas 和 Tzafestas [141]提供了一个基于模糊逻辑的系统，旨在使移动机器人在动态环境中自主导航，避开途中的障碍物。Wang 等人[142]的研究重点是防止机器人陷入局部最小点，如 U 形障碍物产生的最小点。Pandey 等人[143] 还提供了模糊逻辑避障的模拟测试结果。关于神经网络的使用，&#x3D;&#x3D;Yan 和 Li [144] 也在一个平台上使用了模糊逻辑，重点是尽量减少计算资源和穿越包含动态障碍物的环境。&#x3D;&#x3D;Pandey 和 Parhi [145] 将模糊逻辑与一种名为 “风驱动优化 “的群体算法相结合，对模糊规则进行了调整。关于神经网络的使用，Zou 等人[146] 在 2000 年代初简要介绍了这类算法的应用。Engedy 和 Horváth [147] 为必须避开静态和动态障碍物的移动机器人介绍了一种使用神经网络的路径规划器。Zhang 等人[148] 使用这种技术在迷宫场景中寻找最短路径。这种方法还与遗传算法结合使用 [149,150]。</p>
<p>文献中的其他作品则将模糊逻辑与神经网络相结合 [151-154]。这方面有不同的方法。例如，Mohanty 和 Parhi [155] 将许多此类系统用于自主导航。Mac 等人[8]对相关混合方法进行了更深入的了解和更广泛的调查。此外，人们还研究了如何利用强化学习（RL）来控制机器人的运动 [156,157]。Faust 等人[158] 将强化学习与概率路线图法 (PRM) 相结合，这也是接下来详细介绍的算法之一。有关基于 RL 的规划算法的更多信息，请参阅 Sun 等人的研究 [21]。</p>
<h2><span id="5-c-space-search-based-path-planning-algorithms">5. C-Space-Search-Based Path Planning Algorithms</span></h2><p>这类算法将路径规划器的工作空间视为机器人可到达的所有状态或配置的空间。因此，这类算法中的大多数作品都将这一工作空间称为 C 空间。这些算法背后的主要思想是使用属于 C 空间一部分的离散样本集。换句话说，C 空间是离散的。这组样本包括初始状态和目标状态，或至少是相对接近这两个状态的样本。这样，这些算法就会执行搜索操作，访问这组样本。在某一点上，算法会找到并返回连接初始状态和目标状态的某个样本子集，该子集代表所产生的路径。换句话说，构成路径的每个航点都与 C 空间中的一个样本相对应。这意味着生成的路径在很大程度上取决于这些样本的分布、连接和访问方式。事实上，由于这种依赖性，有些方法需要进行后处理，以平滑生成路径的形状。</p>
<p>根据 C 空间离散化的方式，C 空间搜索类别又分为两类算法。图搜索算法是通过预先存在的图（如图 2 所示）来实现离散化的。该图中的每个节点都代表一个 C 空间样本，并与附近的其他节点（即其邻居）相连。基于采样的算法侧重于在 C 空间内以迭代方式创建和&#x2F;或修改样本。即使在找到一条可行路径后，它们还能继续工作，找到更好的路径。</p>
<h3><span id="51-graph-search">5.1. Graph Search</span></h3><p>&#x3D;&#x3D;如前所述，C 空间可以以图的形式离散化。图搜索算法会全部或部分访问该图，直到找到连接初始状态和目标状态的路径。这类算法的第一种返回路径是将航点置于相邻样本之上。换句话说，路径上连续航点之间的连接与图边重合。&#x3D;&#x3D;图 8a 是一个示意图，显示了在第一种情况下，路径的形状是如何由这些边决定的。因此，本综述将生成此类路径的图形搜索算法归类为边缘受限算法。因此，这些路径取决于图的结构。正如第 2.2.1 节所述，有多种单元分解和路线图形式的图结构。另一种图搜索算法 “任意角度”（Any-angle）就是为了解决这个问题而创建的，它对图的边进行了限制。之所以使用这个名称，是因为限制边缘规划器生成的路径只能使用特定的方向值。例如，在八邻规则网格中，如图 8a 所示，限制边缘的路径只能有 0、±45、±90、±135 和 180 度的方向。任意角度算法生成的路径不受限于这些方向，因为它们的航点不一定要放置在相邻节点上。图 8b 展示了这方面的一个例子。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011027069.png" alt="image-20240201102701980"></p>
<p>图 8. 限边算法（a）和任意角度算法（b）生成的路径（红色）的主要区别：在第一种情况下，航点只能放置在连续（相邻）的节点上。</p>
<p>关于限边算法，图 9 展示了文献中&#x3D;&#x3D;最具代表性的限边算法示意图&#x3D;&#x3D;。最著名、最基本的限边路径规划算法是 Dijkstra 算法 [159]。该算法的第一步是选择一个节点，即起点或目标节点。此后，它开始向其邻居传播信息。这些信息可以是从起点出发所需的成本值，也可以是到达目标所需的成本值。算法会迭代访问已访问节点的邻居。关于成本的信息会不断传播，算法会为每个访问过的节点分配一个父节点。如果环境允许，即目标和起点之间没有障碍物，算法最终会同时访问这两个节点。此时，通过回溯父节点来检索路径。换句话说，路径从最后访问的节点开始，通过父节点返回。多年后，&#x3D;&#x3D;哈特等人[160] 实现了启发式版本 A<em>，&#x3D;&#x3D; 以加快计算速度。后来，又有了进一步的改进。D</em> 也被称为动态 A* ，是 A* 的增量版本，由 [161] 提出。增量版的意思是，每当分配给网格节点的成本发生变化时，该算法就会重复之前的计算。这就避免了算法从头开始执行全新的计算。例如，当机器人在行进过程中遇到新的障碍物时，这种计算量的减少允许快速重新规划。名为 Focussed D* 的改进版本进一步缩短了 D* 的计算时间[162]。Koenig 和 Likhachev [163] 提出使用终身规划 A* (LPA*) 作为 A* 的另一种直接增量扩展。他们以此为参考，开发出了更简单的 D* 版本，称为 D* -Lite [164,165]。Colas 等人[166] 在搜索和救援应用中的移动机器人上采用了这种算法。由于 A* 和 D* 算法，包括它们的版本，&#x3D;&#x3D;都使用了启发式函数，因此得出的路径可能是次优的。&#x3D;&#x3D;Likhachev 等人[167]提出了这些算法的随时版本，使用可配置的固定时间。在给定时间内找到的最佳路径由这些随时版本生成。多尔戈夫等人[168]提出了一种 A* 算法，即混合 A*，该算法在找到路径后通过重新排列节点，优先考虑所生成路径的可行性，以换取最优性和完整性的损失；从某种程度上说，该路径在运动学上是可行的。</p>
<p>关于任意角度算法，最早的算法之一是 Field-D* [169]。这是一种众所周知的算法，主要是因为美国国家航空航天局（NASA）的火星探测器自 Spirit 和 Opportunity 开始就采用了这种算法 [170]。与 D* 和 D* -lite 类似，它也是一种增量算法，因此会在后续执行中重复之前的计算。虽然 Field-D* 是克服路径受限于边的问题的杰出方法，但仍有改进的余地，可以找到更多最优路径。多年后，以 A* 为基础，更多的任意角算法被创造出来，它们都专注于在避开障碍物的同时寻找最短路径的问题。纳什等人[171]为此创造了 Theta* 。他们将其分为两个版本：一个是计算成本较低的 Base-Theta* ，另一个是成本较高但结果更接近全局最优最短路径的 Angle-Propagation Theta* 。Theta* 的主要前提是考虑障碍物拐角处的航向变化，与 Field-D* 相比，减少了路径上的航向变化 [172]。基础 Theta* 算法的增量版本后来被命名为增量 Phi* 算法 [173]。纳什等人[174]推出了更快的 Theta* 版本，即 Lazy-Theta<em>。Theta</em> 算法也得到了改进，能更好地处理非均匀代价图，即越接近障碍物，代价越高[175]。Šišlák 等人提出了加速 A* 算法[176]。它找到的路径比 Theta* 短，但速度较慢（尽管仍比 A* 快）。Yap 等人[177] 还引入了另一种名为 Block A* 的算法，并将其性能与 A* 和 Theta* 进行了比较。Nash 和 Koenig [11] 提供了另一项比较研究，其中包括加速 A<em>、Block A</em>、Field-D* 和 Theta* ，还包括后一种算法的变体。同一作者后来还将这种算法与可见性图的使用进行了比较[178]。Muñoz 和 R-Moreno [179] 建议使用 S-Theta* 算法生成平滑航向变化的路径。&#x3D;&#x3D;3DANA 用于生成高程图上的路径[180,181]&#x3D;&#x3D;。与 Theta* 和许多其他任意角算法相比，其他算法的结果有所改进，包括任意角子目标图 [182,183] 和 Anya [184,185]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011031915.png" alt="image-20240201103059674"></p>
<h3><span id="52-sampling-based">5.2. Sampling-Based</span></h3><p>基于采样的路径规划算法会按照不同的策略在 C 空间中创建一个又一个样本 [12,186]。之后，在满足特定条件或条件集（如达到时间限制）后，从创建的样本中检索路径。这种算法是渐进最优的。这意味着它们可以创建越来越多的样本，试图随着时间的推移找到更好的解决方案。一般来说，这些算法通常用于高维空间的搜索。然而，为了接近全局最优解，样本数量可能会相对较多 [14]，这就需要使用大量内存资源来存储所有样本。</p>
<p>如果只考虑两个点（起始位置或状态和目标），该算法就是单查询算法，而如果在同一环境下选择更多的点，该算法就被归类为多查询算法。关于单查询，最著名的算法之一是快速随机树（RRT）算法，它也是快速确定树（RDT）的一个特例[187]。该算法模拟了树的生长过程，即从一个起点开始，动态地创建样本，就像创建树枝一样。图 10a 描述了一个总结这一过程的方案。当其中一个样本与目标的距离超过一定距离时，就可以通过向后跟踪的方式找回路径，直至到达原点。如前所述，为了找到更好的路径，还可以执行更多的迭代。文献中可以找到对 RRT 的进一步修改。Kuffner 和 LaValle [188] 提出了一个双向版本，命名为 RRT-Connect。后来，Yershova 等人[189] 提出了 RRT 的改进版本，称为动态域 RRT，它能在树扩展过程中意识到环境中存在的障碍。Arslan 和 Tsiotras [190] 从图形搜索算法 LPA 中汲取灵感，提出了 RRT#，这是 RRT 的改进版本，收敛速度更快。Karaman 和 Frazzoli [186] 引入了一种名为启发式 RRT（RRT* ）的启发式 RRT 版本，以加快计算速度，同时仍能达到渐近最优。有关 RRT* 变体的广泛综述，请参阅 Noreen 等人的著作[14]。一种名为 “知情 RRT* “的改进版本在 RRT* 的基础上进行了改进，当找到一条可行路径时，将起点和目标位置围成一个椭圆[191]。接下来改进路径的迭代就在这个椭圆内进行，而不是让算法探索其他可能不会影响结果的选项。Gammell 等人[192]提出了另一种改进方法，称为批量有信息树（BIT<em>），并进行了比较，证明其性能优于 RRT</em>、有信息 RRT* 和 FMT<em>。BIT</em> 还借鉴了图搜索算法 LPA* 的一些步骤。区域加速批量有信息树（AIT<em>）在 BIT</em> 的基础上进行了改进，尤其是在存在狭窄走廊的情况下[193]。Adaptively Informed Trees (AIT* ) 和 Advanced Batch Informed Trees (ABIT* ) 算法在 BIT* 算法的基础上进行了改进，并被集成到 NASA 的一个实验性漫游车中 [194,195]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011032108.png" alt="image-20240201103211195"></p>
<p>关于基于采样的多重查询算法，最著名的是概率路线图法（Probabilistic Roadmap Method，PRM）[196]。这种算法从一系列已经分散在 C 空间中的样本开始。在此基础上，创建新样本，从每个初始样本创建一棵新树。图 10b 展示了这一过程背后的概念。之后，使用 A* 等图形搜索方法，利用 PRM 创建的图形检索路径。Karaman 和 Frazzoli [186] 提出了 PRM 的启发式版本。Park 等人[197]提出的改进方法采用了分层结构，减少了样本数量。Alenezi 等人[1]在模拟室内场景中对机器人进行了 PRM 测试。Ichter 等人[198] 提出了临界 PRM 算法，该算法将 PRM 与强化学习相结合，用于确定狭窄走廊等临界位置。</p>
<p>为了降低 RRT 和 PRM 的收敛速度，另一种基于采样的算法被命名为快速行进树（FMT* ）算法。它不仅借鉴了这两种算法的特点，还借鉴了一种名为 FMM 的优化控制算法，详情如下。FMT* 的主要目标是在涉及大量自由度的问题中找到避开障碍物的路径。Reid 等人[50]提出的铰接车辆运动规划就是一个例子。Ichter 等人[199]提出使用分组行进树（GMT<em>），这是一种与 FMT</em> 相似的算法，但其重点是通过 GPU 的并行化来加快计算速度。最后值得一提的是，有一些路径规划算法将动态采样方法与模型预测控制（MPC）技术相结合，以考虑动力学约束[57,200,201]。</p>
<h2><span id="6-optimal-control-based-path-planning-algorithms">6. Optimal-Control-Based Path Planning Algorithms</span></h2><p>基于控制方法的算法的基本原理是创建一个控制函数，将机器人从 C 空间的初始状态带向目的地。顾名思义，这里使用的是最优控制方法来解决路径规划问题[202]。与软计算方法的主要区别在于没有可配置的参数；这里的问题必须是完全封闭的。这里有两个不同的子类别。第一类是 PDE 求解，算法基于动态编程原理 (DPP)，在网格上求解偏微分方程 (PDE)[203]。第二个子类别，即数值优化，包括根据机器人的动力限制优化已有路径，使其可行的算法。</p>
<h3><span id="61-pde-solving-based">6.1. PDE-Solving-Based</span></h3><p>这里的优化控制方法基于动态编程原理，通过使用网格解决汉密尔顿-雅各比-贝尔曼方程 [204]。由于这是一个偏导数方程 (PDE)，这一子类被命名为 PDE 求解。它可以看作是计算波在网格上传播问题的数值解。波到达时间的值分配给每个网格节点。波的传播方式将取决于 HJB 方程的表达方式，包括代价函数。这种算法的主要缺点是通常无法处理不连续形式的约束。</p>
<p>HJB 方程的一个特殊情况是 Eikonal 方程。它不仅是静态的，而且还考虑了成本函数，只根据地图上的位置返回一个标量值。这意味着波在节点上的传播速度仅取决于分配的标量值。这样一来，特征方向就与总成本函数的梯度相吻合，因此只需使用梯度下降法就能检索出路径。多年来，人们提出了一整套方法，以较低的计算要求计算这一问题公式的解，因此这些方法被命名为快速方法 [18]。其中最著名的是由 Sethian [205] 提出的快速行进法 (FMM)。该算法采用与 Dijkstra 相同的策略访问网格节点。与 Dijkstra 不同的是，FMM 通过求解 Eikonal 算法为每个节点分配成本值。这样得到的路径是平滑、连续和最优的。Chiang 等人[206]将该算法与 A* 进行了比较，结果表明，由于路径不受网格限制，FMM 得到的路径更短。目前有许多使用 FMM 进行路径规划的研究 [207-210]。Gómez 等人[18]在综述中介绍了 FMM 的一些变体，其中大部分都降低了 FMM 的计算能力要求，同时还介绍了其他 Eikonal 求解器。它们是二进制 FMM、斐波纳契 FMM、简化 FMM 和不整齐 FMM。Eikonal 使用的成本值决定了计算波的传播速度。Petres 等人[24] 证明了这些成本值的梯度如何影响所产生路径的曲率半径。他们的研究还引入了启发式快速行进 (FM* ) 的理念，并将其与其他图搜索算法进行了比较。为了顺利避开障碍物，快速行进方阵（FMS）[74] 计算两次 FMM，首先在障碍物周围形成一个排斥场。图 11a 描述了由于障碍物附近的成本值较高（颜色较深），路径如何平稳地远离障碍物。Liu 和 Bucknall [211] 使用 FMS 以及对初始位置周围的成本进行修改，以考虑车辆的初始方向。研究人员还致力于提出 FMM 的增量版本，如 E* [212-214]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011034842.png" alt="image-20240201103456553"></p>
<p>要处理汉密尔顿-雅各比-0 贝尔曼（HJB）方程更一般的表达式，必须使用其他类型的方法。如果使用与方向相关（各向异性）的代价，FMM 会产生次优结果[215]。这种代价意味着，相对于节点的矢量代价而言，波的传播方向不同。在某些特殊情况下，FMM 可以在一定程度的各向异性条件下得出准确的结果，例如，成本函数的计算方式使其主要在与参考轴平行的方向上变化[24,216]。图 11b 描述的就是这种情况。Sethian 和 Vladimirsky [215] 建议使用一种名为有序上风法 (OUM) 的算法来处理静态 HJB 方程，Shum 等人[217] 证实了该算法的收敛速度。其主要缺点是计算成本的增加与场景中存在的各向异性成正比。Shum 等人[31]使用 HJB 进行各向异性路径规划，考虑了能量最小化和稳定性，并考虑了斜坡的方向和幅度。快速扫描法（FSM）也被证明适用于一般的静态 HJB 方程 [218]。它的工作原理是访问网格上的所有节点，沿着特定方向反复进行，这意味着它需要大量的迭代。Takei 和 Tsai [37] 使用 FSM 拟定 HJB 方程，以符合转弯半径约束条件。对于 Eikonal 情况，Bak 等人[219]对 FSM 进行了改进，以在成本变化过大时加快计算速度，Detrixhe 等人[220]则推出了并行版本。Jeong 和 Whitaker [221] 提出了一种名为快速迭代法 (FIM) 的算法，同样可以在并行架构上求解 Eikonal 方程。</p>
<h3><span id="62-global-optimization">6.2. Global Optimization</span></h3><p>该子类包含优化现有初步可行路径的路径规划算法。与第 3.1 节中介绍的局部优化方法不同，&#x3D;&#x3D;全局优化方法是以投入更多计算负荷来换取路径的全局最优。&#x3D;&#x3D;例如，Ratliff 等人[222]提出的方法首先使用基于采样的方法，如 RRT 或 PRM。第二步是使用梯度优化技术，从这条可行路径中逼近最优解。Van Den Berg 等人[223]也是从使用 RRT 计算出的轨迹开始，&#x3D;&#x3D;随后将 jt 应用于基于差分动态编程（DP）的优化过程&#x3D;&#x3D;。Plonski 等人[70]考虑到机器人会收获太阳能，因此使用 DP 计算了太阳地图中动态变化的路径。Ajanovi ́ c 等人 [224] 将 DP 与模型预测控制 (MPC) 相结合，计算出能量最小的路径。其他技术包括砰砰方法 [225] 和混合整数线性规划 (MILP) [226]。最后，Kogan 和 Murray[227]提出了一种独特的方法，他们使用非线性优化来规划长度在 20 米至 70 米之间的时间最优路径。</p>
<h2><span id="7-summary-and-conclusions">7. Summary and Conclusions</span></h2><p>根据本文提出的分类系统（见图 1），表 3 总结了每个路径规划类别的主要特征。表 3 分析了这些算法是否需要一个初步的环境模型、是否具有确定性（即在相同的初始条件下总能提供相同的解决方案）、是否能处理动态环境并重新规划、是否是最优的以及是否完整（即如果可行，总能返回一条路径）。考虑到最终路径规划应用的范围，有些算法会比其他算法更适合。此外，规划器的覆盖范围和重新规划能力（即处理环境信息更新的能力）将决定一种算法更适合局部规划还是全局规划。局部规划通常需要快速的在线计算，在环境数据发生变化时需要这种反应行为来规划新的路径。全局规划甚至可以离线计算，目的是在有静态初始环境的情况下，生成长距离穿越的路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011037997.png" alt="image-20240201103702845"></p>
<p>基于反应式计算的算法似乎很适合局部避障路径规划，因为这些算法易于实现且成本低廉。此外，对于不确定性较高的场景或使用传感能力非常有限的机器人时，反应式机动方法也是一个不错的选择。局部优化甚至可以考虑使用 TEB 的动力学约束，尽管它们不能确保完整性。必须特别注意这两个子类别，以避免陷入局部最小值。软计算算法使用多个可配置的运算符生成路径，这些运算符的灵感可以来自自然界，也可以基于模糊规则和&#x2F;或神经网络。它们适用于涉及大量变量的问题或难以建模的问题，例如高度动态的环境。在包含移动元素的情况下，在远距离（全局路径规划）情况下，使用进化法就足够了。最新的人工智能方法，包括 DL 和 RL 方法，还需要进一步研究才能得出可靠的结论，Sun 等人也指出了这一点[21]。基于模糊规则或神经网络的人工智能方法可用于快速局部规划，以替代反应式机动方法。C 空间搜索算法利用样本来表示机器人的不同配置。这些样本可以事先以图形的形式提供，也可以动态创建。图形搜索算法适用于全局路径规划，考虑到了高级图形（如可见度图或空间网格图），但需要投入时间来构建这些图形（这在离线规划中是允许的）。不过，这种算法在处理高维度问题时扩展性较差，因此需要使用基于采样的算法。事实证明，基于采样的算法也适用于此类操作和高维度问题。优化控制算法在获得全局最优结果方面表现突出。基于各向同性成本函数或各向异性成本函数的 PDE 求解算法在很大程度上依赖于所配制的 PDE，并且可以使用网格形式的地图模型。全局优化算法必须从已定义的路径开始，并根据机器人的运动限制进行调整。在不确定性较低的静态情况下，PDE 求解算法可提供最优路径，而无需重新规划，因此适合离线计算长距离穿越。最后，需要注意的是，所有这些规划算法都依赖于描述环境和机器人的可用信息。必须尽可能准确地模拟这些信息，才能改善路径规划器的结果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011043554.png" alt="image-20240201104312676"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402011043220.png" alt="image-20240201104327334"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-31T04:54:25.000Z" title="2024/1/31 12:54:25">2024-01-31</time>发表</span><span class="level-item"><time dateTime="2024-02-15T09:20:14.879Z" title="2024/2/15 17:20:14">2024-02-15</time>更新</span><span class="level-item">15 分钟读完 (大约2278个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/31/A-Survey-of-Path-Planning-Algorithms-for-Mobile-Robots/">A Survey of Path Planning Algorithms for Mobile Robots</a></p><div class="content"><h1><span id="a-survey-of-path-planning-algorithms-for-mobile-robots">A Survey of Path Planning Algorithms for Mobile Robots</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202402151635332.png" alt="image-20240215082504403"></p>
<p>自动驾驶汽车（AV）有可能大大减少因人类驾驶员的失误和疏忽而造成的车辆碰撞事故。这些自动驾驶汽车必须在时间、距离、能量和其他因素方面安全高效地从 A 点行驶到 B 点。路径规划是确定和评估实现这些目标的合理轨迹的关键。</p>
<p>在执行导航任务时，机器人系统（如自动导航仪）需要利用环境建模、定位系统在环境中的位置、控制运动、检测和避开障碍物以及在从简单到高度复杂的动态环境中移动等能力。导航的四个一般问题是感知、定位、运动控制和路径规划 [1-3]。</p>
<p>其中，路径规划可以说是导航过程中最重要的问题。路径规划是在给定的环境中确定一条无碰撞的路径，而在现实世界中，环境往往可能是杂乱无章的[4]。为了充分利用这些功能，同时实现系统的设计和使用目标，必须确定并实施适当的路径规划技术。通常情况下，性能最佳的技术会因系统类型和运行环境而异。</p>
<p>随着移动视听设备的激增，对路径规划或路径寻找的需求也越来越多，这些功能已成为自主控制领域近期的一个重点领域。由于移动机器人的应用范围广泛，研究人员已开发出有效满足其要求的方法，以克服在杂乱环境中实现完全或部分自主导航时面临的一些重大挑战。</p>
<p>为了简化路径规划问题，确保机器人在杂乱环境中顺利运行&#x2F;移动，同时避开障碍物，配置空间必须与所使用的算法相匹配。目前存在多种路径规划和路径查找算法，其适用性取决于系统的运动学、环境的动力学、机器人的计算能力以及传感器和其他来源信息的可用性。算法性能和复杂性的权衡也取决于使用情况。</p>
<p>对于新手来说，只选择一种方法是非常困难的，尤其是对于那些没有控制背景的人来说。然而，随着自动驾驶汽车的日益普及，工程师们在没有经过充分培训的情况下被迫承担起这样的角色。本文件旨在总结路径规划的常用基础技术，适合在控制方面专业知识有限的人员使用，并寻求确定探索领域，以支持新的自动驾驶汽车功能。</p>
<p>我们考虑了算法在静态和动态环境中的适用性，并回顾了自动驾驶汽车和机器人技术中常用的路径规划算法，为快速发展的自动驾驶领域的新手从业人员提供了入门指南。本文探讨了具有代表性的算法，但其覆盖范围并不全面，也无意反映自动驾驶汽车路径规划的最新水平。</p>
<h2><span id="1-path-planning">1. Path Planning</span></h2><p>路径规划是一个非确定性多项式时间（”NP”）难题[5]，其任务是找到一条连接系统从初始目标配置到最终目标配置的连续路径。问题的复杂性随着系统自由度的增加而增加。要走的路径（最优路径）将根据约束条件和条件来决定，例如，考虑终点之间的最短路径或不发生任何碰撞的最短行进时间。有时，约束条件和目标是混合在一起的，例如，在不使行进时间超过某个临界值的情况下，寻求能耗最小化。</p>
<p>自 20 世纪 70 年代以来，路径规划一直备受关注，多年来，它已被用于解决从简单的空间路线规划到选择达到特定目标所需的适当行动序列等各个领域的问题。路径规划可用于完全已知或部分已知的环境，也可用于完全未知的环境，在这种环境中，系统安装的传感器会接收信息并更新环境地图，为机器人&#x2F;自动机的预期运动提供信息。</p>
<p>路径规划算法根据可用的环境知识进行区分。通常情况下，机器人&#x2F;自动机只能部分了解环境。路径规划可以是局部的，也可以是全局的。全局路径规划在环境信息基本完整的情况下寻求最优路径，在环境静止且机器人完全已知的情况下执行效果最佳。在这种情况下，路径规划算法会先生成一条从起点到终点的完整路径，然后机器人才开始按照规划的轨迹运行[6]。全局运动规划是环境穿越的高级控制。</p>
<p>相比之下，本地路径规划通常在未知或动态环境中执行。本地路径规划是在机器人移动过程中，通过本地传感器获取数据进行的。在这种情况下，机器人&#x2F;AV 能够根据环境的变化生成新的路径。如果存在障碍物，障碍物可能是静态的（相对于已知的固定坐标系，其位置和方向在时间上是不变的），也可能是动态的（相对于固定坐标系，其位置、方向或两者都发生了变化）[6]。</p>
<p>有效的路径规划算法需要满足四个标准。首先，运动规划技术必须能够在现实的静态环境中始终找到最优路径。第二，必须能够扩展到动态环境。第三，它必须与所选的自参照方法保持兼容并增强其功能。第四，必须最大限度地减少复杂性、数据存储和计算时间[7]。本文概述了适用于机器人&#x2F;AV 的最常用路径规划算法，并讨论了哪种算法最适合静态&#x2F;动态环境。</p>
<h2><span id="2-path-planning-algorithms">2. Path Planning Algorithms</span></h2><p>本文从 Dijkstra 算法[8]及其变体开始，这些算法通常用于谷歌地图[9]和其他交通路由系统等应用中。为了克服 Dijkstra 算法在盲搜索时的计算密集度，本文介绍了 A* 算法[10]及其变体，它们是在静态环境下使用的最先进算法。</p>
<p>不过，A* 和 A* replanner 是根据环境中存在的障碍物信息进行最短路径评估的，而已知静态环境的最短路径评估是一个两级问题，包括选择可行的节点对和根据获得的可行节点对进行最短路径评估 [11]。上述两个标准在动态环境中都不存在，因此该算法在动态环境中效率低下且不实用。</p>
<p>为了支持动态环境中的路径规划，D* [12] 及其变体作为在杂乱环境中快速重新规划的有效工具得到了讨论。由于 D* 及其变体不能保证大型动态环境中的解质量，我们还探讨了快速探索随机树 (RRT) [13] 和一种结合了松弛 A* ( RA* ) [14] 和一种元启发式算法的混合方法。这种混合方法包括两个阶段：使用 RA* 算法的初始化阶段和使用一种启发式方法的后优化阶段，这种启发式方法可提高前一阶段找到的解决方案的质量。此外，还讨论了三种元启发式算法：即遗传算法、蚁群算法和萤火虫算法。这些算法旨在提供有效的功能，以追求路径规划的混合方法。</p>
<p>我们之所以选择这些算法，是因为它们代表了当代实时路径规划解决方案中使用的基础算法。新的研究以这些算法为基础，寻求更高的性能和效率。因此，所列算法并非详尽无遗，但涵盖了自动驾驶汽车和机器人系统路径规划中常用的几种算法。其他路径规划算法的讨论见 [15]。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-30T00:43:22.000Z" title="2024/1/30 08:43:22">2024-01-30</time>发表</span><span class="level-item"><time dateTime="2024-02-01T02:57:44.844Z" title="2024/2/1 10:57:44">2024-02-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">43 分钟读完 (大约6455个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/30/Autonomous-land-vehicle-path-planning-algorithm-based-on-improved-heuristic-function-of-A-Star/">Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star</a></p><div class="content"><h1><span id="autonomous-land-vehicle-path-planning-algorithm-based-on-improved-heuristic-function-of-a-star">Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star</span></h1><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300902671.png" alt="image-20240130090211867"></p>
<h2><span id="abstract">Abstract</span></h2><p>自主陆地车辆的路径规划已成为近年来的研究热点。本文提出了一种新型的自主陆地车辆路径规划算法。根据自主陆地车自主运动的特点，设计了一种改进的 A-Star 路径规划算法。使用 A-Star 算法进行路径规划的缺点是，A-Star 算法规划的路径包含许多不必要的转弯点，不够平滑。自主陆地车辆需要在每个转弯点调整姿态，这将大大浪费时间，也不利于自主陆地车辆的运动控制。针对这些不足，本文提出了一种新的启发式函数，结合人工势场方法，其中包含距离信息和障碍物信息。我们提出的算法在提高执行效率和减少转弯点数量方面表现出色。仿真结果表明，与传统的 A-Star 算法相比，所提出的算法能使路径更加平滑，使自主陆地车辆更易于控制。</p>
<h2><span id="introduction">Introduction</span></h2><p>近年来，陆地自动驾驶汽车（ALV）被广泛应用于应急救援、港口货运、物流配送等领域。1 路径规划在自动驾驶汽车领域占据核心地位，路径规划算法的效率直接影响自动驾驶汽车的寻路效率，而规划能力的实现决定了自动驾驶汽车能否高效、安全地完成任务。例如，在自动驾驶中不同车辆之间充分共享环境信息，不仅有利于实现更充分的路径规划，还能确保更高的安全等级。近几十年来，人们提出了许多路径规划算法，如 Floyd 算法、 Dijkstra 算法、 A-Star 算法、 蚁群算法、 粒子群算法 和人工势场等。</p>
<p>由于搜索速度快的特点，A-Star 算法已被广泛应用于解决静态路网的最短路径问题。A-Star 算法源于 Dijkstra 算法，引入了启发式函数以实现快速的节点搜索速度。然而，A-Star 算法的启发式函数只考虑了距离信息，导致寻路过程中出现多余的扩展节点。鉴于 A-Star 算法的不足，大量学者提出了相应的改进算法。洪斌等人提出了一种将改进的 A-Star 算法和动态窗口法相结合的混合算法，在复杂动态环境下具有良好的性能。Chen 等人将估值函数定义为指数衰减法，以减少冗余扩展。Wang 等人提出了一种基于网格映射的高效全区域覆盖路径规划算法。Zhang 等人考虑了无人艇的实际应用场景，通过增加角损耗项改进了评估函数，使最终路径具有最小的角，减少了路径上的损耗。Wu 等人通过建立禁忌表改进了 A-Star 的评价函数，从而快速有效地实现路径规划。Lin 等人通过引入父节点的影响来改进 A-Star 的实时性，但在对评价函数进行加权时没有考虑权重值的影响。</p>
<p>然而，上述算法在路径规划过程中只考虑了障碍物在全局地图中的位置，而没有考虑ALV周围的障碍物数量和距离，对地图信息的利用不够充分。针对 A-Star 算法路径不平滑的问题，我们提出了一种新的启发式函数，结合人工势场优化路径，提高搜索效率。在计算启发式项目时，我们的方法不仅考虑了当前位置到目标位置的距离，还考虑了当前位置周围的障碍物信息。仿真实验表明，我们的算法比 A-Star 算法性能更好。在网格地图环境下，比较 A-Star 算法和本文提出的算法，结果验证了我们的方法更有利于运动控制，规划的路径更平滑。</p>
<h2><span id="establishment-of-environment-model-for-alv-path-planning">Establishment of environment model for ALV path planning</span></h2><p>对于路径规划而言，环境建模是至关重要的一步。根据建立的环境模型，真实的环境场景被转换成机器人可以处理的抽象场景，方便机器人进行路径规划。常见的地图表示方法包括拓扑建模法、轮廓地图法和网格地图法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300908036.png" alt="image-20240130090834038"></p>
<p>我们使用网格图法建立网格图，记录 ALV 的障碍物网格和路径信息。我们定义网格的属性，存储轨迹的父节点和网格是否为障碍物等信息，并使用矩阵将每个节点的信息映射到网格图中。然后对网格图进行二值化处理，将 0 定义为可通过的网格，1 定义为障碍物网格，从而得到二值化后的网格图。图 1 显示了网格图的一个示例。黑色网格代表障碍物，白色网格为可通过区域。在栅格化模型的环境地图中，地图被划分为多个紧密相连的小网格，每个网格代表地图的一个节点。地图中的每个节点只与相邻的八个节点构成一条路径。因此，在网格地图中，ALV 的移动方向一般只有 8 个，即网格地图中 8 个相邻节点的方向。</p>
<h2><span id="background">Background</span></h2><h3><span id="a-star-algorithm">A-Star algorithm</span></h3><p>A-Star 算法由 Hart 等人提出(Hart PE, Nilsson NJ, and Raphael B. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans Syst Sci Cybern 1968; 4(2): 100–107.)，现已广泛应用于最短路径问题领域。作为一种典型的启发式搜索算法，A-Star 算法通过启发式搜索对节点进行评估，提高了节点搜索的效率，具有更好的性能和精度。启发式搜索使用估值函数，估值函数表示如下 其中，$f(n)$ 表示从起始位置经过当前位置 n 到目标位置的估计总成本, $g(n)$表示从起始位置到当前位置的实际路径成本，$h(n)$ 表示从位置 n 到目标位置的估计成本。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300910261.png" alt="image-20240130091029260"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300910156.png" alt="image-20240130091049003"></p>
<h3><span id="artificial-potential-field">Artificial potential field</span></h3><p>Khatib 于 1986 年提出了人工势场法。人工势场法以目标位置为中心构建引力势场。引力势场的值随着自动驾驶汽车与目标之间距离的增加而增加，方向是从自动驾驶汽车到目标。吸引力势场函数的数学表达式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300912895.png" alt="image-20240130091203978"></p>
<p>$f_a(x, y)$ 是吸引力势场函数，$\epsilon$ 是比例因子。</p>
<p>以 ALV 的当前位置为中心，构建一个排斥力场，该力场随着障碍物与 ALV 之间距离的增加而减小，方向是从障碍物到 ALV。排斥力场函数的数学表达式如下：	</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300913059.png" alt="image-20240130091311957"></p>
<p>其中，$\rho(x, y) $为当前点$(x, y)$到障碍物的距离，$d_0$为距离阈值。当当前点到最近障碍物的距离大于 $d_0$ 时，不会产生排斥力。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300915511.png" alt="image-20240130091529455"></p>
<p>这两个势场共同构成一个抽象的人工势场。人工势场法的势场力计算如图 3 所示 在人工势场中，对于空间中的某一点，ALV 将受到一个具有一定大小和方向的力的作用。人工势场法将 ALV 的运动抽象为受该虚拟力拖动的运动。</p>
<h2><span id="method">Method</span></h2><p>在应用场景中，ALV 首先在环境地图中规划路径，然后沿着路径前进。然而，在使用传统的 A-Star 算法进行路径规划时，规划的路径包含太多的转折点，路径不够平滑。因此，在路径跟踪过程中，ALV 需要进行许多不必要的姿态调整，以调整 ALV 的移动方向。当车辆沿着蜿蜒曲折的路径行驶时，会减慢 ALV 的速度，而且过多的姿态调整很容易破坏 ALV 的平衡。为了解决上述问题，本文结合人工势场方法的思想对 A-Star 算法进行了改进，并提出了一种新的启发式函数构造方法。在我们的方法中，周围障碍物和目标点对 ALV 的影响也包含在估算成本中。新的估值函数表达如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300916932.png" alt="image-20240130091631698"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300917496.png" alt="image-20240130091701261"></p>
<p>其中，$f(n)$表示从起始位置到当前位置再到终点位置的总估计成本，$g(n)$ 表示从起始位置到当前位置的路径移动成本[22]，我们使用 $h(n)&#x3D;h’(n)+v(n)$ 作为改进的启发式函数，$h’(n)$ 表示传统 A-Star 中的距离成本，$v(n)$ 表示潜在场地成本，包含周围障碍物的信息。</p>
<h3><span id="improved-distance-heuristics-hn">Improved distance heuristics $h’(n)$</span></h3><p>启发式函数的启发项 $h’(n)$ 对算法的计算效率有重要影响。它在总估计成本中的权重与 A-Star 的搜索速度呈正相关。启发式函数具有信息性。所谓启发式函数的信息量是指评估节点时的约束条件。信息量越大（即约束条件越多），被排除的节点就越多。</p>
<p>对于启发式项$h’(n)$的选择，有如下结论，其中$H(n)$为节点n到目标的实际路径长度。如果$h’(n)&lt;H(n)$，算法可以找到最优路径，但搜索节点较多，搜索效率很低；如果 $h’(n) &#x3D; H(n)$，这是最理想的情况，算法可以以最高的效率搜索到最优路径；而如果 $h’(n)&gt; H(N)$，此时算法虽然搜索速度较快，但很难得到最优路径：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300921857.png" alt="image-20240130092118946"></p>
<p>如果能找到更接近实际损失的启发式函数，就能提高搜索效率。A-Star 算法估计路径代价的函数一般取曼哈顿距离，此外还有欧氏距离和对角线距离。</p>
<p>假设矩形坐标中有两点 P 和 Q，P 点坐标为 $(X_{P}, Y_{P})$，Q 点坐标为 $(X_{Q}, Y_{Q})$，则 P 和 Q 之间的曼哈顿距离可表示为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300922205.png" alt="image-20240130092257451"></p>
<p>考虑到正方形网格地图有八个移动方向，存在对角线移动，对角线距离更接近实际路径代价。为了简单验证这三种距离选择方法对 A-Star 算法的影响，我们通过实验仿真比较了不同距离选择方法下 A-Star 算法的搜索速度和搜索网格节点数。我们在大小为 40x40 的网格图上进行了验证实验，结果如图 4 和表 1 所示</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300936449.png" alt="image-20240130093643452"></p>
<p>实验结果表明，由于使用曼哈顿距离法计算出的估计成本大于实际路径中的成本，因此搜索时间最快，搜索网格数最少。但搜索范围最小，未能搜索到最短路径，这样规划的路径长度最长。用欧氏距离法计算的估计成本小于实际路径中的成本，所以网格节点数是三者中最大的；可以搜索到最短路径，但搜索时间是最长的。对角线距离更接近实际长度。因此，如实验所示，与曼哈顿距离和欧氏距离相比，使用对角线距离搜索的网格节点数量适中。</p>
<p>对角距离可以找到最短路径，而运行时间适中。因此，我们使用对角距离作为距离启发式 $h’(n)$。$h’(n)$的计算公式如下：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300938223.png" alt="image-20240130093829304"></p>
<p>其中，$x_n$表示当前位置 n 的横座标，$y_n$ 表示当前位置 n 的纵座标，$x_e$ 表示目标的横座标，$y_e$ 表示目标的纵座标。</p>
<h3><span id="obstacle-heuristics-vn">Obstacle heuristics $v(n)$</span></h3><p>根据人工势场法的原理，障碍物会产生排斥力，排斥力随障碍物与节点之间距离的增加而减小，而目标位置会产生吸引力，吸引力与节点到目标的距离成正比。本文将环境图构建为网格图，每个网格的位置用坐标表示。因此，势场力的计算方法与人工势场方法不同。</p>
<p>在栅格化地图环境中，斥力的计算公式如下，方向是从障碍物 i 到节点 k:</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300940340.png" alt="image-20240130094057381"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300941259.png" alt="image-20240130094124214"></p>
<p>其中，k 表示当前位置，坐标为$(x_k, y_k)$；i 表示包含障碍物的第 i 个网格，坐标为$(x_i, y_i)$；n ~r 表示从障碍物 i 到节点 k 的矢量；e ~x 和 e ~y 分别表示 X 轴方向和 Y 轴方向的单位矢量。考虑到只有靠近 ALV 的障碍物才会影响 ALV 的工作，为了减少计算量，本文限制了障碍物的范围。其中，$\rho(x_i, y_i)$是当前节点 k 到第 i 个障碍物的距离，$d_0$ 是距离阈值，本文中 $d_0 &#x3D; 10$。</p>
<p>吸引力大小的计算公式如公式 (11) 所示，方向是从节点 k 到目标点 d</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300943994.png" alt="image-20240130094353821"></p>
<p>其中，k 表示当前位置，坐标为 $(x_k, y_k)$；d 表示目标点，坐标为 $(x_d, y_d)$；$\vec{v_r}$表示从节点 k 到目标点 d 的矢量。</p>
<p>得出吸引力和排斥力后，可以计算吸引力和排斥力的合力，从而得出当前网格节点 k 所受的势场力。计算公式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300946721.png" alt="image-20240130094648606"></p>
<p>这里的 $\alpha$ 和 $\beta$ 分别代表吸引力和排斥力的权重。在本文中，$\alpha &#x3D; 5$，$\beta &#x3D; 4$。</p>
<p>在人工势场法中，局部最小值问题是不可避免的。当计算出的 $\vec{F}(k)$ 为 0 时，为了避免算法回到传统的 A-Star 算法，我们将在此时放弃斥力。此时 $\vec{F}(k)$ 的计算公式如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300949949.png" alt="image-20240130094905025"></p>
<p>由于 A-Star 算法基于光栅化地图信息，因此在搜索节点时采用八邻搜索法，在搜索路径时只考虑八个方向的网格。上节计算的势场力是任意方向的。因此，在计算 $v(n)$ 时，我们将势场力投影到邻近节点的八个方向，即前、左前、左、左后、后、右后、右、前右。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300950453.png" alt="image-20240130095007335"></p>
<p>计算过程如下： 首先计算从点 k 到相邻节点 n 的单位向量，如下式所示</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300951059.png" alt="image-20240130095058973"></p>
<p>图 5 显示了当前位置 k 在扩展其相邻节点 n 时的计算示意图。首先计算障碍物 S1~S3 的排斥力$\vec{F}<em>{r}(k, S_i)$; SiÞ和目标位置 d 的吸引力 $\vec{F}</em>{a}(k)$，然后计算所有排斥力和吸引力的结果力 $\vec{F}(k)$。在计算当前位置 k 右侧节点 n 的 $\vec{v}(n)$时，首先计算方向矢量 $\vec{e_n}$，然后计算结果力在方向矢量上的投影，得到 $\vec{v}(n)$。根据这种方法，计算节点 k 相邻八个扩展节点（不包括障碍物节点）的  $\vec{v}(n_i)$。然后计算 $h’(n)$、$g(n)$ 和 $f(n)$，得到扩展节点的代价函数，并进行路径搜索。</p>
<p>算法步骤如下： </p>
<p>步骤 1：创建开放列表 O 和关闭列表 C，O 用于记录已生成但尚未访问的节点，C 用于记录已访问的节点；将起点添加到 O 中；</p>
<p>步骤 2：将 O 中代价 f 最小的节点 k 添加到 C 中，并检查该节点是否为目标节点，如果是目标节点，路径规划结束；否则，进入下一步；</p>
<p>步骤 3：扩展节点 k 的所有相邻节点。计算所有相邻节点 n 的 $v(n)$、$g(n)$、$h’(n)$ 和 $f(n)$。如果节点 $n$ 既不在 O 中，也不在 C 中，则将节点 n 添加到 O 中；如果节点 n 在 O 中，但计算出的 $f(n)$ 小于 O 中的旧值，则更新节点 n 在 O 中的 $f(n)$，然后根据 $f(n)$ 的值对 O 中的所有节点重新排序；如果节点 n 在 C 中，则跳过这一点。重复以上步骤，直到节点 k 的所有相邻节点都扩展完毕；</p>
<p>步骤 4：检查目标点是否在 C 中，O 是否为空。如果目标点在 C 中或 O 为空，则算法结束；否则，重复步骤 2~4。</p>
<h3><span id="path-smoothing">Path smoothing</span></h3><p>要获得平滑的路径，常用的方法包括样条函数和贝塞尔函数。B 样条曲线是贝塞尔曲线的扩展。B 样条曲线的多项式阶数可以与控制点的数量无关，而贝塞尔曲线的阶数与控制点密切相关。因此，我们使用四元 B-样条曲线来平滑规划路径。给定 n þ 1 个控制点，四次 B 样条曲线的方程如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300957746.png" alt="image-20240130095731591"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300957704.png" alt="image-20240130095746470"></p>
<h2><span id="experiment">Experiment</span></h2><p>本节设计了三组网格图进行实验验证，网格图中的每个网格代表 10 厘米 10 厘米的实际环境。仿真所用的计算机配置为 i7-6700HQ，16 GB 内存。</p>
<p>在第一张地图中，给定的起始位置坐标为(1, 1)，目标位置坐标为(20, 17)。原始规划路径如图 6（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 6(b) 显示的是平滑后的路径。表 2 列出了 A-Star 算法和我们提出的算法规划路径的比较。其中，算法消耗的时间是经过 30 次重复实验后得到的平均值。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300959256.png" alt="image-20240130095922174"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401300959887.png" alt="image-20240130095938606"></p>
<p>如图 6 所示，A-Star 算法从靠近终点的一片障碍物之间穿过。改进后的 A-Star 算法避免穿越障碍物，而是选择从侧面绕行。计划路径中几乎没有不必要的转弯点。从表 2 中可以看出，路径长度都是 323.1 厘米，但 A-Star 算法规划的路径总共需要转弯 540 次，而我们提出的算法只需要转弯 315 次，大大降低了转弯成本。路径平滑后，A-Star 的路径缩短为 294.4 厘米，转弯角度减小到 219.09。我们的方法规划的路径缩短到 303.3 厘米，转弯角度减小到 140.86。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3.8 毫秒，而我们的算法耗时 5.2 毫秒。</p>
<p>在第二组实验中，我们选择了一个更为复杂的环境。ALV 需要多次绕过障碍物才能到达给定的目标点。给定的起始位置坐标为（24,17），目标位置坐标为（4,16）。</p>
<p>原计划路径如图 7(a) 所示。图 7(b) 显示了平滑后的路径。表 3 列出了 A-Star 与我们提出的算法规划路径的比较。</p>
<p>如图 7 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，两者规划的路径长度都是 906.7 厘米，但 A-Star 规划的路径总共需要转弯 1080 次，而我们提出的算法只需要转弯 540 次。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 99.6 毫秒，而我们的算法耗时 110.1 毫秒。</p>
<p>我们还对活性氧算法进行了实验。使用 Gmapping 方法创建网格地图，如图 8 所示，地图分辨率为 5 厘米&#x3D;像素，膨化安全距离设置为 15 厘米。我们使用基于阿克曼模型的四轮驱动汽车，尺寸为 20 厘米 18 厘米 13 厘米。给定的起始位置坐标为（3.6 米，2.15 米），目标位置坐标为（4 米，15 米）。</p>
<p>原始规划路径如图 8（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 8(b) 显示的是平滑后的路径。表 4 列出了 A-Star 算法和我们提出的算法规划路径的比较。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301007055.png" alt="image-20240130100757892"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301008717.png" alt="image-20240130100815423"></p>
<p>如图 8 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，我们规划的路径长度为 1558.9 厘米，但 A-Star 规划的路径总共需要转弯 1755 °，而我们提出的算法只需要转弯 495 次。经过路径平滑处理后，A-Star 的路径缩短为 1516.5 厘米，转弯角度减小到 687.46。我们的方法规划的路径缩短到 1534.9 厘米，转弯角度减小到 237.84。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3332.7 毫秒，而我们的算法耗时 6657.4 毫秒。随着地图复杂度的增加，所消耗的计算时间也在增加。如图 8 所示，A-Star 算法规划的路径有许多锯齿状的转折点。这使得路径不够平滑，不利于 ALV 的运动控制。由于 ALV 在每个拐点都要调整角度，这势必会降低速度，影响运行效率。</p>
<p>实验仿真结果表明，与传统的 A-Star 算法相比，我们的改进算法转弯损耗更低、路径更直。我们的算法规划的路径长度与 A-Star 算法相似。但是，与 A-Star 算法相比，总转弯角度减少了 4060%。不过，我们的算法更为复杂，计算时间也比 A-Star 算法长。特别是在障碍物较多的环境中，计算时间会明显增加，算法效率仍有待进一步提高。我们的算法减少了拐点，让 ALV 更容易调整姿态，实现 ALV 的自主移动。当 ALV 在运行过程中遇到转弯时，它会降低速度并调整角度，以确保安全运行。在这个过程中，ALV 的效率会降低，控制难度会增加，而且会消耗大量时间。我们的方法虽然增加了规划时间成本，但提高了运行效率，减少了 ALV 的运行时间和控制难度。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401301009825.png" alt="image-20240130100951777"></p>
<h2><span id="conclusion">Conclusion</span></h2><p>本文提出了一种新的启发式功能设计方法，以改进广泛使用的 A-Star 算法。考虑了周围障碍物对小车运行的影响。在启发式函数中加入了人工势场力，加强了算法的搜索方向信息，从而提高了 A-Star 算法的性能。与传统的只考虑距离的启发式函数相比，我们的方法考虑了周围的障碍物信息，更适用于障碍物较多的环境；改进后的算法规划的路径更直，有效减少了不必要的拐点，使小车能尽可能少地调整角度，减少了路径损耗，更有利于小车的运动控制。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-24T01:42:31.000Z" title="2024/1/24 09:42:31">2024-01-24</time>发表</span><span class="level-item"><time dateTime="2024-01-24T15:47:49.537Z" title="2024/1/24 23:47:49">2024-01-24</time>更新</span><span class="level-item">1 小时读完 (大约7794个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/24/Online-Graph-Pruning-for-Pathfinding-on-Grid-Maps/">Online Graph Pruning for Pathfinding on Grid Maps</a></p><div class="content"><h1><span id="online-graph-pruning-for-pathfinding-on-grid-maps">Online Graph Pruning for Pathfinding on Grid Maps</span></h1><p>作者：Daniel Harabor and Alban Grastien</p>
<h2><span id="abstract">Abstract</span></h2><p>在均匀成本网格环境中寻路是机器人和视频游戏等应用领域中常见的问题。最先进的分层寻路算法速度快、内存开销小，但通常会返回次优路径。在本文中，我们提出了一种专门针对网格的新颖搜索策略，它速度快、最优且无需内存开销。我们的算法可以被描述为一个宏运算符，它只识别并有选择地扩展网格图中的某些节点，我们称之为跳跃点。连接两个跳转点的路径上的中间节点永远不会扩展。我们证明这种方法总能计算出最优解，然后进行了全面的实证分析，并将我们的方法与文献中的相关作品进行了比较。我们发现，使用跳跃点进行搜索可以将 A* 的速度提高一个数量级或更多，并报告了与当前技术水平相比的显著改进。</p>
<h2><span id="introduction">Introduction</span></h2><p>在机器人学（Lee 和 Yu，2009 年）、人工智能（Wang 和 Botea，2009 年）和视频游戏（Davis，2000 年；Sturtevant，2007 年）等领域，无处不在的无向匀成本网格图是一种非常流行的寻路环境表示方法。该领域具有规则性，通常具有高度的路径对称性（Harabor 和 Botea，2010 年；Pochter 等，2010 年）。在这种情况下，对称性表现为路径（或路径段）具有相同的起点和终点、相同的长度以及除移动顺序外的其他相同之处。除非处理得当，否则对称性会迫使搜索算法评估许多相等的状态，从而阻碍朝着目标取得真正的进展。</p>
<p>在本文中，我们通过开发一种宏运算符来处理这种路径对称性问题，这种宏运算符只选择性地从网格中扩展某些节点，我们称之为跳跃点。从一个跳转点移动到下一个跳转点，需要沿着一个固定的方向行进，同时反复应用一组简单的邻接剪枝规则，直到到达死胡同或跳转点。由于我们不会在跳转点之间扩展任何中间节点，因此我们的策略可以对搜索性能产生显著的积极影响。此外，计算出的解决方案保证是最优的。跳跃点剪枝速度快，无需预处理，也不会带来内存开销。它在很大程度上还与许多适用于网格图的现有加速技术是正交的。</p>
<p>我们的贡献如下：(i) 对跳跃点算法的详细描述；(ii) 一个理论结果，表明用跳跃点搜索能保持最优性；(iii) 一个经验分析，将我们的方法与两种最先进的搜索空间缩小算法进行比较。我们对文献中的一系列合成基准和实际基准进行了实验，发现跳点能将标准 A* 的搜索时间性能提高一个数量级或更多。我们还报告了与 Swamps（Pochter 等人，2010 年）（一种最新的优化剪枝技术）相比的显著改进，以及与 HPA*（Botea、M ̈ uller 和 Schaeffer，2004 年）（一种众所周知的次优寻路算法）相比具有竞争力的性能，而且在很多情况下占优势。</p>
<h2><span id="related-work">Related Work</span></h2><p>在规划（Fox 和 Long，1999 年）、约束编程（Gent 和 Smith，2000 年）和组合优化（Fukunaga，2008 年）等领域，已经提出了识别和消除搜索空间对称性的方法。然而，明确识别和处理寻路领域（如网格图）对称性的作品却寥寥无几。</p>
<p>Empty Rectangular Rooms（Harabor 和 Botea，2010 年）是一种离线对称破缺技术，它试图纠正这种疏忽。它将网格地图分解为一系列无障碍矩形，并用一组宏边取代每个矩形内部的所有节点，从而实现最佳旅行。这种方法只适用于 4 连地图，通用性不如跳跃点剪枝法。它还需要离线预处理，而我们的方法是在线预处理。</p>
<p>Empty Rectangular Rooms（Harabor 和 Botea，2010 年）是一种离线对称破缺技术，它试图纠正这种疏忽。它将网格地图分解为一系列无障碍矩形，并用一组宏边取代每个矩形内部的所有节点，从而实现最佳旅行。这种方法只适用于 4 连地图，通用性不如跳跃点剪枝法。它还需要离线预处理，而我们的方法是在线预处理。</p>
<p>死胡同启发式（Bj ̈ ornsson 和 Halld ́ orsson，2006 年）和沼泽（Pochter 等人，2010 年）是与我们的工作相关的两种类似修剪技术。两者都将网格地图分解为一系列相邻区域。之后，这种分解被用来识别与优化解决特定寻路实例无关的区域。这一目标与我们的工作类似，但又互为正交，我们的目标是减少探索搜索空间中任何给定区域所需的工作量。</p>
<p>修剪搜索空间的另一种方法是识别死单元和冗余单元（Sturtevant、Bulitko 和 Bj ̈ ornsson，2010 年）。这种方法是在基于学习的启发式搜索背景下开发的，只有在运行多次迭代深化算法后才能加快搜索速度。此外，识别冗余单元需要额外的内存开销，而跳跃点不需要。</p>
<p>快速扩展（Sun 等人，2009 年）是另一项加快最优 A* 搜索的相关工作。当它找到的后继节点与开放列表中的最佳节点一样好（或更好）时，就能避免不必要的开放列表操作。跳跃点是一个类似但本质上不同的想法：它允许我们识别出大量节点集，这些节点集通常会被扩展，但可以完全跳过。</p>
<p>在不要求最优化的情况下，分层寻路方法非常普遍。它们通过将搜索空间（通常是离线搜索）分解为更小的近似空间来提高性能。这类算法，如 HPA*（Botea、M ̈ uller 和 Schaeffer，2004 年），速度快、内存效率高，但也是次优的。</p>
<h2><span id="notation-and-terminology">Notation and Terminology</span></h2><p>我们使用无向均匀成本网格图。每个节点都有≤ 8 个邻居，要么可穿越，要么不可穿越。从一个可穿越节点到它的一个相邻节点，每次直线（即水平或垂直）移动的成本为 1；对角移动的成本为√2。不允许涉及不可穿越（障碍）节点的移动。符号 d 指的是八个允许的移动方向之一（上、下、左、右等）。当 d 是一个对角移动时，我们将与 d 成 45 度角的两个直线移动记为 d1 和 d2。</p>
<p>路径 π &#x3D; 〈n0,n1,…,nk〉是一条从节点 n0 开始到 nk 结束的无循环有序行走。我们有时会在路径的上下文中使用 setminus 运算符：例如 π \ x。我们还将使用函数 len 来表示路径的长度（或成本），使用函数 dist 来表示网格上两个节点之间的距离：例如 len(π) 或 dist(n0,nk)。</p>
<h2><span id="jump-points">Jump Points</span></h2><p>在本节中，我们将介绍一种搜索策略，通过有选择地只扩展网格图上的某些节点（我们称之为跳跃点）来加快最优搜索速度。我们在图 1(a) 中给出了基本思想的示例。</p>
<p>在这里，搜索正在扩展一个节点 x，它的父节点是 p(x)；从 p(x) 到 x 的移动方向是向右直线移动。在扩展 x 时，我们可能会注意到，评估任何突出显示为灰色的邻节点都没有什么意义，因为这种移动所引起的路径总是被提及 p(x) 而未提及 x 的另一条路径所支配（即不优于）。我们建议不要像经典的 A* 算法那样生成这个邻居并将其添加到开放列表中，而是简单地向右移动并继续朝这个方向移动，直到我们遇到一个节点，如 y；它至少还有一个非主邻节点（这里是 z）。如果我们找到了 y 这样的节点（跳转点），我们就将其作为 x 的后继节点，并赋予其 g 值（或成本值）：g(y)&#x3D;g(x)+dist(x, y)。或者，如果我们遇到了障碍，我们就会得出结论：在这个方向上继续搜索是没有结果的，因此不会生成任何结果。</p>
<p>在本节的其余部分，我们将开发一个宏步算子，通过识别直线和对角线移动情况下的跳跃点后续节点来加速节点扩展。首先，我们有必要定义一系列剪枝规则，以确定是生成节点还是跳过节点。这将使我们能够精确地定义跳点的概念，并给出跳点算法的详细描述。然后，我们将证明 “跳转 “节点（如图 1(a) 中的 x）的过程不会影响搜索的最优性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241021418.png" alt="image-20240124102117088"></p>
<h2><span id="neighbour-pruning-rules">Neighbour Pruning Rules</span></h2><p>在本节中，我们将制定从网格中剪除与某个节点 x 紧邻的节点集的规则。我们的目标是从每一组邻接节点（即邻接节点(x)）中找出无需评估的节点 n，以便以最佳方式达到目标。我们通过比较两条路径的长度来实现这一目标：一条是以节点 p(x) 为起点、访问 x 并以 n 为终点的路径 π，另一条是同样以节点 p(x) 为起点、以 n 为终点但未提及 x 的路径 π′。此外，π 或 π′ 提到的每个节点都必须属于邻居（x）。</p>
<p>根据从父节点 p(x) 到 x 的过渡是直线移动还是斜线移动，有两种情况需要考虑。请注意，如果 x 是起始节点 p(x)，那么它就是空节点，不会被剪枝。</p>
<p>直线移动 我们会剪除任何满足以下优势约束条件的节点 n∈ 邻居（x）：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241023012.png" alt="image-20240124102335907"></p>
<p>图 2(a) 显示了一个例子。在这里，p(x)&#x3D;4，我们删除了除 n &#x3D;5 以外的所有相邻数据。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241021697.png" alt="image-20240124102148550"></p>
<p>对角移动 这种情况类似于我们为直线移动制定的剪枝规则；唯一的区别是排除 x 的路径必须是严格占优的：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241024959.png" alt="image-20240124102436373"></p>
<p>假设邻域（x）不包含任何障碍，我们将把应用直线或对角线剪枝（视情况而定）后剩余的节点称为 x 的自然邻域，它们与图 2(a) 和图 2(c) 中的非灰色节点相对应。当邻域（x）包含障碍物时，我们可能无法剪除所有非自然邻域。如果出现这种情况，我们就会说对每个这样的邻居的评估都是被迫的。</p>
<p>定义 1. 在下列情况下，节点 n∈ neighbours(x) 是被迫的：</p>
<ol>
<li><p>n 不是 x 的自然邻接节点</p>
</li>
<li><p>len( 〈p(x),x,n〉 ) &lt;len( 〈p(x),…,n〉\x )</p>
</li>
</ol>
<p>在图 2(b) 中，我们展示了一个直线移动的例子，其中 n &#x3D;3 的求值是强制的。图 2(d) 显示了一个涉及对角线移动的类似示例；这里 n &#x3D;1 的评估是被迫的。</p>
<h2><span id="algorithmic-description">Algorithmic Description</span></h2><p>我们首先要明确跳跃点的概念。</p>
<p>定义 2. 如果节点 y 的值 k 最小，使得 y &#x3D; x+k d，且以下条件之一成立，那么节点 y 就是从节点 x 向 d 方向的跳跃点：</p>
<ol>
<li>节点 y 是目标节点。</li>
<li>节点 y 至少有一个根据定义 1 被强制评估的邻居。</li>
<li>d 是对角移动，并且存在一个节点 z &#x3D; y + ki di，它位于方向 di ∈{ d1, d2} 的 ki ∈ N 步，这样根据条件 1 或条件 2，z 是一个从 y 跳转的点。</li>
</ol>
<p>图 1(b) 显示了通过条件 3 确定跳转点的一个示例。在这里，我们从 x 开始，沿对角线移动，直到遇到节点 y。因此 z 是 y 的跳转点后继节点（根据条件 2），这反过来又确定了 y 是 x 的跳转点后继节点。</p>
<p>确定单个跳转点后续节点的过程见算法 1。我们从紧邻当前节点 x 的邻居剪枝集开始（第 2 行）。然后，我们不是将每个相邻节点 n 添加到 x 的后继节点集合中，而是尝试 “跳转 “到距离 x 更远但与 n 处于相同相对方向的节点（第 3 行至第 5 行）。例如，如果边（x，n）是从 x 开始向右直线移动的，我们就在紧靠 x 右边的节点中寻找一个跳转点。这个过程一直持续到邻节点集合用完，并返回 x 的后继节点集合（第 6 行）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241029213.png" alt="image-20240124102905838"></p>
<p>为了识别单个跳跃点的后续节点，我们将采用算法 2。该算法需要一个初始节点 x、一个行进方向 d 以及起始节点 s 和目标节点 g 的身份信息。概括地说，该算法试图通过沿行进方向 d 行进（第 1 行）并检测该位置的节点 n 是否满足定义 2，来确定 x 是否有任何跳跃点后继节点。如果符合，n 将被指定为跳转点并返回（第 5、7 和 11 行）。当 n 不是跳跃点时，算法会递归并再次沿 d 方向前进，但这次 n 是新的初始节点（第 12 行）。当遇到障碍且无法继续前进时，递归结束（第 3 行）。请注意，在每个对角线步骤之前，算法必须首先检测不到任何直线跳跃点（第 9:11 行）。这一检查与定义 2 的第三个条件相对应，对于保持最优性至关重要。</p>
<h2><span id="optimality">Optimality</span></h2><p>在本节中，我们将证明对于网格图中的每一条最优长度路径，都存在一条等效长度路径，在搜索过程中只需扩展跳跃点节点即可找到（定理 1）。我们的结果是通过为每条最优路径确定一个对称的替代方案得出的，我们将该替代方案分割成连续的线段。然后，我们证明这条路径上的每个转折点也是一个跳跃点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241029220.png" alt="image-20240124102936861"></p>
<p>定义 3. 转折点是指路径上任何一个节点 ni，从上一个节点 ni-1 到 ni 的行进方向与从 ni 到下一个节点 ni+1 的行进方向不同。</p>
<p>图 3 描述了我们在最优路径上可能遇到的三种转折点。节点 nk 处的对角线到对角线转折点（图 3(a)）包括从其父节点 nk-1 开始的对角线步长，以及从 nk 到其后继节点 nk+1 的第二个对角线步长，这次的方向不同。同样，从直线到对角线（或从对角线到直线）的转折点包括从 nk-1 到 nk 的直线（对角线）步，然后是到达其后继 nk+1 的对角线（直线）步（分别如图 3(b) 和 3(c)）。其他类型的转折点，如直线到直线，都是微不足道的次优转折点，在此不予考虑（这些转折点已被我们之前制定的规则剪除；再看图 2）。</p>
<p>现在，我们准备在跳跃点和转折点之间建立等价关系，这些转折点出现在某些最佳长度的对称路径上，我们称之为对角先行路径。</p>
<p>定义 4. 如果一条路径 π 不包含可以被对角线到直线的转折点 〈nk-1,n′k,nk+1〉替代的对角线到直线的转折点，且 π 的长度保持不变，那么这条路径 π 是对角线优先的。</p>
<p>给定一条任意的最优长度路径 π，通过对 π 应用算法 3，我们总能推导出一条对称的对角线优先路径 π′。 请注意，这只是一种概念上的手段。</p>
<p>定理 1. 最优对角线优先路径 π′ 上的每个转折点也是一个跳跃点。</p>
<p>证明 假设 nk 是沿着 π′ 的任意转折点节点。我们将考虑三种情况，每种情况都与图 3 中所示的三种可能的最佳转折点之一相对应。</p>
<p><strong>对角线到对角线</strong> 既然 π′ 是最佳值，那么 nk 和 nk-1 附近一定有障碍物，迫使我们绕道而行。我们之所以知道这一点，是因为如果没有障碍物，dist(nk-1,nk+1) &lt; dist(nk-1,nk)+ dist(nk,nk+1)，这与 π′ 是最优路径这一事实相矛盾。我们得出结论，nk+1 是 nk 的强邻。这足以满足定义 1 的第二个条件，使 nk 成为一个跳跃点</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241033893.png" alt="image-20240124103351403"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241034540.png" alt="image-20240124103456262"></p>
<p><strong>直线到对角线</strong>：在这种情况下，nk 附近一定有障碍物。如果不是这样，nk 可能会被对角线到直线的转折点所取代，这与π′对角线优先的事实相矛盾。由于 π′ 保证是对角线优先的，因此我们得出 nk+1 是 nk 的强制邻接点这一事实。这满足了定义 1 的第二个条件，因此我们得出 nk 是一个跳变点的结论。</p>
<p><strong>对角线到直线</strong>： 在这种情况下有两种可能性，取决于从 nk 出发是否可以通过一系列直线步骤到达目标，或者 π′ 是否有额外的转折点。如果目标可以通过直走到达，那么 nk 有一个跳跃点后继点，它满足定义 1 的第三个条件，因此我们得出结论 nk 也是一个跳跃点。如果 nk 的后继点是另一个转折点 nl，那么该转折点一定是直线到对角线，并且根据这种情况的论证，也是一个跳跃点。我们再次得出结论，nk 有一个满足定义 1 中第三个条件的跳转点继承点。因此，nk 也是一个跳变点。</p>
<p><strong>定理 1</strong>. 用跳跃点剪枝法搜索总能得到最优解。</p>
<p>证明 假设π是网格上两个节点之间任意选择的最优路径，π′是对π应用算法 3 得出的对角线优先对称等效路径。我们将证明，在使用跳跃点剪枝搜索时，π′提到的每个转折点都会得到最优扩展。我们的论证如下：</p>
<p>将 π′ 分成一系列相邻的线段 π′ &#x3D; π′ 0 + π′ 1 + … + 每个 π′ i &#x3D; 〈n0,n1,…,nk-1,nk〉都是一条子路径，沿这条路径的所有移动都沿同一方向进行（例如，仅 “上行 “或 “下行 “等）。请注意，除了起点和终点外，路段起点和终点的每个节点都是一个转折点。</p>
<p>由于每个 π′ i 只包含单一方向（直线或对角线）的移动，因此我们可以使用算法 2 从 n0∈ π′ i（每段开始的节点）跳转到 nk∈ π′ i（结束的节点），而不一定要停止扩展中间的每个节点。中间的扩展可能会发生，但我们从 n0 以最佳方式到达 nk 这一事实是有保证的。我们只需证明 n0 和 nk 都被确定为跳跃点，因此必然会扩展。根据定理 1，沿着 π′ 的每个转折点也是一个跳跃点，因此在搜索过程中每个转折点节点都必须扩展。只剩下起点和目标。起点节点必须在每次搜索开始时展开，而目标节点根据定义是一个跳转点。因此这两个节点都要展开。</p>
<h2><span id="experimental-setup">Experimental Setup</span></h2><p>我们在免费提供的寻路库层次开放图（HOG，<a target="_blank" rel="noopener" href="http://www/">http://www</a>. googlecode.com&#x2F;p&#x2F;hog2）中的四个基准上评估了跳跃点剪枝的性能：</p>
<ul>
<li><p><strong>自适应深度</strong> 是一组大小为 100×100 的 12 幅地图，其中每幅地图约有 1.3 的面积被划分为大小不一的矩形房间和一大片空地，空地上还穿插着随机放置的大型障碍物。在该基准测试中，我们为每张地图随机生成了 100 个有效问题，共计 1200 个实例。</p>
</li>
<li><p><strong>《博德之门》</strong> 是一组 120 幅地图的集合，取自 BioWare 的热门角色扮演游戏《博德之门 II：阿蒙之影》；它经常作为标准基准出现在文献中（Bj ̈ ornsson and Halld ́ orsson 2006; Harabor and Botea 2010; Pochter et al.） 我们使用了由 Nathan Sturtevant 提供的变体，其中所有地图都已缩放至 512×512 大小，以更准确地反映现代寻路环境。地图和所有实例可从 <a target="_blank" rel="noopener" href="http://movingai.com/">http://movingai.com</a> 获取。</p>
</li>
<li><p><strong>《龙腾世纪》</strong> 是另一个现实主义的标杆；这一次取自 BioWare 最近推出的角色扮演游戏《龙腾世纪》： 起源》。它由 156 张地图组成，大小从 30 × 21 到 1104 × 1260 不等。在该基准测试中，我们使用了大量随机生成的实例集，这些实例集也是由 Nathan Sturtevant 提供的，可从 http:&#x2F;&#x2F; movingai.com 获取。</p>
</li>
<li><p><strong>房间</strong> 是一组 300 幅大小为 256×256 的地图，这些地图被分成对称的一排排小矩形区域（7×7），并由随机放置的入口连接。该基准曾出现在（Pochter 等人，2010 年）中。我们为每个地图随机生成了 100 个有效问题，共计 30000 个实例。</p>
</li>
</ul>
<p>我们的测试机配备 2.93GHz 英特尔酷睿 2 双核处理器和 4GB 内存，运行 OSX 10.6.4。</p>
<h2><span id="results">Results</span></h2><p>为了评估跳跃点，我们使用了 A* 的通用实现，并对其进行了调整，以方便在线邻接剪枝和跳跃点识别。我们以加速度来讨论性能：即在网格中进行和不进行图修剪搜索时，解决给定问题所需的时间和扩展节点数量的相对改进。使用这一指标，搜索时间加快 2.0 表示速度快了一倍，而节点扩展速度加快 2.0 则表示节点扩展数量减少了一半。在每种情况下，都是越高越好。图 4 显示了四个基准测试的平均搜索速度。表 1 显示了平均节点扩展速度；每列的最佳结果以粗体显示。</p>
<p>与沼泽的比较 我们首先将跳跃点与 Swamps（Pochter 等人，2010 年）进行了比较：Swamps 是一种用于加速寻路的优化剪枝技术。我们使用了作者的源代码及其 A* 实现，并使用其推荐的运行参数进行了所有实验：沼泽种子半径为 6，”无变化限制 “为 2。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241040501.png" alt="image-20240124104049438"></p>
<p>如图 4 所示，在所有基准测试中，跳跃点剪枝对平均搜索时间的改善令人信服。在《博德之门》和《龙腾世纪》中观察到的最大差异是，使用跳跃点搜索能提前 25-30 倍达到目标，而使用沼泽搜索只能加快 3-5 倍。在表 1 中也可以观察到类似的趋势，总扩展节点数的提升更为明显。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401241041713.png" alt="image-20240124104147524"></p>
<p>基于这些结果，我们得出结论：虽然沼泽能有效识别地图中与实现目标无关的区域，但仍需花费大量精力搜索这些区域。跳跃点使用了一种更强大但却正交的策略，证明可以忽略沼泽所扩展的许多节点。由于这两个想法似乎是互补的，因此我们认为可以很容易地将它们结合起来：首先，应用基于沼泽的分解来修剪与当前搜索无关的区域。然后，使用跳跃点搜索地图的剩余部分。</p>
<p><em><em>与 HPA</em> 的比较</em><em><em>： 接下来，我们将跳跃点剪枝与 HPA</em> 算法（Botea、M ̈ uller 和 Schaeffer，2004 年）进行比较。HPA</em> 算法虽然不是最佳算法，但速度非常快，被广泛应用于视频游戏中。为了评估 HPA* ，我们测量了插入和分层搜索的总成本。我们没有细化任何抽象路径，而是假设有一个预先计算好的簇内路径数据库。这种配置是 HPA* 最快的通用实现方式，但需要额外的内存开销。在搜索过程中，我们使用了单级抽象层次结构和固定的 10 个集群规模。这些设置是原作者推荐的，他们指出，更大的集群和更多的层次通常没有什么好处。</p>
<p>如图 4 所示，跳跃点剪枝与 HPA* 相比具有很强的竞争力。在 “自适应深度”、”博德之门 “和 “房间 “中，跳跃点具有明显的优势，在某些情况下比 HPA* 的搜索时间缩短了几倍。在《龙腾世纪》基准测试中，对于长度小于 500 的问题，跳跃点的优势很小，但对于更长的实例，两种算法之间的差距就很小了。表 1 提供了更多信息：虽然使用跳转点搜索所扩展的节点比 HPA* 少得多，但每次此类操作所需的时间却更长。</p>
<p>我们的结论是，跳点剪枝是 HPA* 的一个有竞争力的替代品，对于各种问题而言，它有助于更快地找到解决方案。HPA* 仍然具有优势，尤其是在内存开销可以接受且最优性并不重要的情况下，但前提是在抽象图中插入起点和目标节点的成本（如果没有路径数据库，还可能包括细化成本）可以在寻找抽象路径所需的时间内得到充分摊销。进一步工作的一个方向是使用跳点剪枝来加快 HPA*：例如在插入和细化过程中。</p>
<h2><span id="conclusion">Conclusion</span></h2><p>我们介绍了一种新的在线节点剪枝策略，用于加快无向均匀成本网格图上的寻路速度。我们的算法只从网格图中识别并有选择地扩展某些节点，我们称之为跳跃点。在跳跃点之间移动只需沿着固定的方向（直线或对角线）行进。我们证明，两个跳转点之间路径上的中间节点永远不需要扩展，”跳过 “它们不会影响搜索的最优性。</p>
<p>我们的方法在寻路文献中是独一无二的，因为它几乎没有缺点：它简单，但非常有效；它保持最优性，但不需要额外内存；它速度极快，但不需要预处理。此外，它在很大程度上与文献中的竞争性提速技术是正交的，也很容易与之结合。我们还没有发现任何其他算法具备所有这些特点。</p>
<p>与文献中的相关研究相比，新算法具有很强的竞争力。与最近最先进的优化剪枝技术 Swamps（Pochter 等人，2010 年）相比，我们发现跳跃点的速度快了一个数量级。我们还表明，跳跃点剪枝与 HPA* 相比具有竞争力，而且在许多情况下明显快于 HPA<em>；HPA</em> 是一种常用的次优寻路技术，经常用于视频游戏等对性能敏感的应用中。</p>
<p>进一步工作的一个有趣方向是将跳转点扩展到其他类型的网格，如六边形或三维网格（Yap，2002 年）。我们建议通过制定一系列类似于方形网格的剪枝规则来实现这一目标。由于这些域上的分支因子低于方形网格，我们认为跳跃点可能比本文所观察到的更加有效。另一个有趣的方向是将跳跃点与其他加速技术相结合：如沼泽或 HPA*。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-23T06:43:52.000Z" title="2024/1/23 14:43:52">2024-01-23</time>发表</span><span class="level-item"><time dateTime="2024-01-23T16:13:53.633Z" title="2024/1/24 00:13:53">2024-01-24</time>更新</span><span class="level-item">4 小时读完 (大约32059个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/23/Hierarchical-and-smoothed-topographic-path-planning-for-large-scale-virtual-simulation-environments/">Hierarchical and smoothed topographic path planning for large-scale virtual simulation environments</a></p><div class="content"><h1><span id="hierarchical-and-smoothed-topographic-path-planning-for-large-scale-virtual-simulation-environments">Hierarchical and smoothed topographic path planning for large-scale virtual simulation environments</span></h1><p>作者：Caroline Chagas , Eliakim Zacarias , Luís Alvaro de Lima Silva , Edison Pignaton de Freitas </p>
<p>Hierarchical pathfinding 、Path smoothing、 Terrain topography、 Agent-based simulations、 Simulation systems</p>
<h2><span id="abstract">ABSTRACT</span></h2><p>虚拟仿真系统应充分利用智能体的逼真行为，让用户感觉沉浸在模拟真实世界环境的虚拟场景中。基于智能体的仿真通常用于培训和教学目的，在开发计算机游戏时经常探索的人工智能解决方案需要考虑更多的要求。为了提供模拟智能体如何在真实世界地形中导航的宝贵印象，关键要求之一是在路径规划任务中需要考虑地形特征。这意味着所使用的寻路算法必须正确处理智能体导航能力的重要方面。在最先进的仿真系统中考虑大规模地形场景时，这个问题更具挑战性，因为在处理搜索空间较大的地形表征时，路径规划可能过于耗时。为了应对为插入基于仿真的学习环境中的智能体计算安全且真实的路径解决方案这一挑战，本研究讨论了一种名为 HPA Theta* 的分层寻路算法，展示了在处理大规模真实世界虚拟地形中的路径规划时，如何在合理的计算时间内计算地形起伏感知的平滑路径。通过使用不同的模拟真实世界虚拟地形，利用大规模虚拟地形表示进行了广泛的实验活动，验证了该建议。实验结果表明，与其他类似的路径规划算法相比，所提出的方法能够有效地解决目标问题，并显示出更好的效果。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>大规模真实虚拟地形中的寻路对于开发基于智能体的仿真系统至关重要（Abar, Theodoropoulos, Lemarinier, &amp; O’Hare, 2017; Abar et al.） 在虚拟地形场景中，仿真智能体应具备规划和执行不同类型导航任务的能力，以实现所需的基于仿真的训练目标。当涉及到智能体在真实世界地形环境的虚拟表征中进行路径规划计算时，不同的地形特征可能会阻碍模拟智能体的导航任务，或者干脆使这种自主运动完全不可能实现（Abd Algfoor, Sunar, &amp; Kolivand, 2015）。为了应对不同地形特征可能带来的智能体导航风险（如模拟车辆因丘陵地形特征而翻车和撞车），必须探索增强型路径规划算法，以保证智能体模拟的完整性和真实性（Brondani、de Lima Silva、Zacarias &amp; de Freitas，2019）。</p>
<p>通过对文献中发现的不平整地形寻路问题的分析，这项工作的贡献在于提出了 HPA Theta* 寻路算法。&#x3D;&#x3D;该算法解决了与所代表的地形起伏倾斜特征相关的问题，在起点和目标位置之间寻找最直的可能路径和低成本路径。&#x3D;&#x3D;在此过程中，它&#x3D;&#x3D;考虑了智能体的移动限制，对分析路线中的微小偏差进行了平滑处理，避免了陡峭的地形倾斜阻碍模拟中智能体的安全移动&#x3D;&#x3D;。此外，HPA Theta* 算法还能在一定的响应时间内提供路径结果，即使是在大规模虚拟地形中计算出的长距离路径也不例外。这对于保持模拟的逼真度以及用户沉浸于模拟培训活动中至关重要。HPA Theta* 算法采用分层方法进行路径规划，可以更好地探索仿真系统中不规则和分层地形的结构。</p>
<p>本工作是对 Brondani 等人（2019 年）所做工作的延伸，其动机是作为 SIS-ASTROS 项目（SIS-ASTROS，2014 年）的一部分，虚拟战术仿真系统在不同方面不断发展和改进的路径规划需求。结合不同的技术，提供更逼真的寻路方法，以支持增强型仿真系统的构建，从而带来诸多益处，这项工作的贡献如下：</p>
<p>(1) 安全路径，尊重目标智能体的参数化运动限制。因此，所提出的 HPA Theta* 算法可以计算出平滑路径，避开陡峭的地形区域，而这种地形倾斜可能会给模拟智能体的导航带来风险；</p>
<p>(2) 高质量路径，因为该算法在平滑路径的同时还处理了路径的地形成本。这意味着所提出的 HPATheta* 算法在最短路径和最低成本路径之间取得了平衡，从而降低了在不平坦地形区域导航的难度；</p>
<p>(3) 即使在处理大规模虚拟地形时，也能优化执行时间。这是因为建议的解决方案将地形表示（即使用 QuadTree 结构）和路径规划的分层方法与前两项提到的优点结合起来。</p>
<p>为评估所提出的技术，在 SIS-ASTROS 模拟器使用的不同真实世界虚拟地形场景中进行了实验。需要强调的是，用于构建这些虚拟地形场景的地图都是真实世界的地图。实验使用寻路响应时间和路径成本值作为评估指标，将所提出的算法与文献中提出的其他分层寻路算法和基于平滑的寻路算法进行对比。此外，还对每种地形的实验结果进行了深入讨论，并对所有地形的实验结果进行了交叉分析。讨论还包括对 HPATheta* 算法分层特征相关性的分析。讨论最后分析了所建议技术的效率和准确性。</p>
<p>本文接下来的内容安排如下： 第 2 节介绍本文所要解决的问题。第 3 节回顾了寻路技术的背景概念和相关工作。第 4 节介绍了地形浮雕信息和大规模虚拟地形的表示结构。第 5 节解释了如何根据地形倾斜信息计算拟议寻路解决方案中使用的路径成本。第 6 节介绍了建议的 HPATheta* 算法。第 7 节介绍了实验并报告了获得的结果，第 8 节是本文的结论部分，为今后的工作指明了方向。</p>
<h2><span id="2-problem-statement">2. Problem statement</span></h2><p>计算机仿真系统和计算机游戏在为用户提供虚拟场景方面有某些相似之处，除此之外，前者还提出了更多地形表示方面的挑战，特别是与使用真实世界地形数据有关的挑战。在最先进的仿真系统中，大规模地形必须在虚拟场景中建模，这就要求地形表示结构更加优化（Brondani et al 2019). 这种大规模的真实世界地形最终需要对模拟目的的目标地形特征进行优化表示和处理，从而使图形三维可视化算法和人工智能（AI）算法的计算不会受到负面影响。</p>
<p>从人工智能的角度来看，在这些大型虚拟地形中运行的寻路算法（Abd Algfoor 等人，2015 年）往往需要处理极其庞大的搜索空间，这很可能会影响在所需响应时间限制内计算不同类型的路径。&#x3D;&#x3D;在基于计算机的培训活动中，在一定的处理时间限制（建议响应时间低于 1 秒（Nielsen，1994 年））内获得路径规划结果至关重要。&#x3D;&#x3D;这是因为这些有时间限制的反应不会对模拟训练的流畅性和真实度产生负面影响。此外，在处理大量沉浸在模拟中的智能体时，受时间限制的路径规划任务不仅对最先进模拟系统的开发，而且对许多其他应用的改进计算解决方案的开发提出了更艰巨的人工智能挑战。</p>
<p>在复杂的模拟环境中（如 Hawe、Coates、Wilson 和 Crouch，2012；Heinze 等人，2002；Murphy 和 Perera，2002），依赖于大规模虚拟地形的模拟器通常必须对具有不同运动能力的多个智能体进行建模，其中一些智能体能够在陡峭的地形缓解倾斜中导航，而另一些则不能（Brondani、de Freitas 和 Silva，2017）。为了向用户提供有效的模拟学习，模拟器应能尽可能真实地模拟智能体的导航行为。如果模拟不符合这一要求，就有可能因用户沉浸于真实世界的虚拟场景而降低预期的模拟培训效益（例如，Fletcher，2009；Frutos-Pascual &amp; Zapirain，2015）。例如，在 SIS-ASTROS 模拟器中，模拟目标之一是训练用户选择最佳地形位置来移动一组模拟车辆。如果模拟器不能让这些车辆沿着不同的地形特征进行真实的移动，用户就会从模拟中得到错误的反馈。由于在这种不真实的虚拟仿真中进行训练活动，当用户需要在实际情况中应用所获得的仿真知识时，他们很可能会做出不知情的、可能是错误的决定。无论仿真系统是否打算实现其仿真培训目标，都应避免这种情况。</p>
<p>特别是在模拟智能体探索路径的算法方面，模拟系统行业中使用的大多数算法都热衷于返回起点和目标地形位置之间距离较短的路径。虽然在许多电脑游戏场景中，这些结果足以达到预期的娱乐目的，但模拟问题在于，这些路径往往与模拟智能体在现实世界中选择的路线并不相似。除其他方面外，这些路径没有根据目标智能体的特定导航能力进行调整，这可能导致导航行为无法在虚拟仿真环境中捕捉到预期的真实世界中的智能体特征。在实践中，这可能会导致错误的智能体导航行为，如模拟车辆翻车（和撞车）、爬陡峭的山峰等。</p>
<p>有鉴于此，本文所要解决的问题&#x3D;&#x3D;是如何在可接受的响应时间内，在大规模虚拟地形上计算出逼真的路径，以达到虚拟仿真的目的。&#x3D;&#x3D;模拟智能体的路径规划算法需要根据地形起伏特征进行调整，即避开静态障碍物并尊重地形地貌，同时提供尽可能短的安全路径。&#x3D;&#x3D;考虑到地形起伏，生成的路径应尽可能接近现实生活中的路径选择，避免不必要的路径曲线和&#x2F;或 “之 “字形导航行为&#x3D;&#x3D;，因为当路径规划算法在计算中严格避开所有其他地形起伏特征时，就会产生这样的结果。最后，生成的路径应为模拟智能体返回安全的导航路线，防止出现意料之外的智能体导航事故，而这些事故并不属于预期模拟的一部分。如何将这些特点结合起来是一个重要的研究课题，本作品将对其进行研究。根据所提出的建议，本工作范围之外的其他寻路问题也值得研究，如带有动态障碍物的寻路问题。</p>
<h2><span id="3-background-and-related-work">3. Background and related work</span></h2><p>本研究提出的寻路方法基于不同的技术，旨在将路径成本处理、路径平滑和优化寻路响应时间等优势结合起来。因此，本节将回顾这些技术的背景概念，同时讨论相关工作。</p>
<h3><span id="31-the-exploration-of-the-hierarchical-approach-for-pathfinding">3.1. The exploration of the hierarchical approach for pathfinding</span></h3><p>在人工智能领域（Nilsson，1998 年），人们对 A* 寻路算法系列进行了大量研究（Abd Algfoor 等人，2015 年；Souissi 等人，2013 年）。A* 算法采用启发式方法来安排地形结构节点的处理顺序。考虑到评估地形节点（n）的优先级，该算法基于以下成本函数：f(n) &#x3D; g(n) + h(n)，可描述如下：</p>
<ul>
<li><p>g(n)：它是评估当前节点（n）成本的函数；</p>
</li>
<li><p>h(n)：这是一个估算从当前节点（n）到目标的成本的函数。该函数进行 “启发式”（h）评估，近似于精确的成本评估。</p>
</li>
<li><p>f(n)：它是 g 和 h的总和，是给定节点（n）的总体成本评估结果。</p>
</li>
</ul>
<p>A* 算法的效率是最优的，没有其他最优算法能保证在地形表示图中展开更少的节点（Dooms，2013；Souissi，等人，2013）。虽然 A* 算法在实现计算机游戏中角色的路径规划功能方面得到了广泛的探索（Huang，2020；Kapi、Sunar 和 Zamri，2020），但随着搜索空间的大小和虚拟场景中智能体数量的扩大，其计算成本可能会变得过高。在这种情况下，分层地形表示技术通常与寻路方法相结合，以处理大规模和复杂的虚拟地形环境，主要用于开发现实生活中的模拟应用（Brondani 等人，2019）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231508976.png" alt="image-20240123150615281"></p>
<p>分层寻路技术旨在减少使用标准 A* 寻路算法确定路径所需的计算时间。这些技术通常使用地形表示的分层抽象。这些抽象为同一虚拟地形创建了不同的表示层次，其中低层次层次通常能更准确地表示地形特征。与此相反，使用较不详细的表征会导致搜索空间更简单，其中存在较大的地形表征单元。实际上，&#x3D;&#x3D;与使用更详细的地形表示结构相比，更简单的搜索空间能让寻路算法执行得更快。&#x3D;&#x3D;在分层寻路研究领域，Botea、Müller 和 Schaeffer（2004 年）提出了分层寻路 A* (HPA* )。&#x3D;&#x3D;其目的之一是降低与由规则网格表示的地形结构相关的寻路复杂性。&#x3D;&#x3D;具体做法是将地形图抽象为预先计算好的簇。然后将这些簇分组，形成更大的簇。HPA* 找到抽象路径后，会对该路径进行细化，并将其作为搜索过程的结果返回。&#x3D;&#x3D;为了优化路径规划算法在大规模地形结构中执行时的响应时间，建议的工作采用了这种分层寻路方法。&#x3D;&#x3D;</p>
<p>在另一项工作中，Sturtevant（2013a）介绍了部分重构 A* (PRA* )，旨在以路径质量的小幅下降为代价加快寻路过程。在 PRA* 中，虚拟环境被细分为若干小块。相邻的瓦片形成小块，小块被组合起来，形成更抽象的地形表示层次。这一过程一直持续到用一块地砖代表整个地形环境为止。PRA* 算法在抽象地形表示层上执行搜索，直到找到抽象解决方案。在向下投影到地形表示的较低层次后，该粗略路径解决方案将在这些较低层次上进行细化，返回到虚拟地形的原始离散化。</p>
<p>除了将分层方法应用于地形表示网格结构外，&#x3D;&#x3D;Pelechano 和 Fuentes（2016 年）还提出了一种探索导航网格结构的分层寻路方法。&#x3D;&#x3D;其中，预处理阶段从多边形导航网格开始。该网格代表了三维环境的一个抽象分区。第一个导航回路被视为层次树的最低层。层次结构中的其余层级是通过递归方式将较低层次的图形划分为特定数量的节点来创建的。分区一直执行到最高层图形无法再细分为止。这样，就从表示多边形网格的输入图形中创建了小图形。虽然寻路是基于 HPA* 算法（Botea 等人，2004 年），但它已被调整为在名为 “分层导航网格图 “的表示结构中工作。在寻路过程中，起点和终点被插入搜索层次的所需层次。然后将它们连接到最高层。搜索在最高层次进行，并在此提取最佳子路径。虽然 Botea 等人（2004 年）提出的算法也采用了分层方法，但其执行结构与本研究提出的方法相似。</p>
<p>在 HPA*中，地形图被抽象为若干个簇，通过抽象搜索在大簇中找到 “最粗 “的路径。然后，建立一条具体路径，它是在每个簇中搜索得出的细化路径。&#x3D;&#x3D;正如 Botea 等人（2004 年）所描述的那样，这种技术降低了搜索的计算成本，生成的路径与理想路径的差距在 1%以内&#x3D;&#x3D;。虽然这种分层方法可以与不同的地形表示拓扑相结合，但它需要预先计算地形簇。</p>
<p>预处理方法见图 1。如图 1a 所示，一旦确定了集群，就有必要对每个网格内的路径进行预处理。确定每个簇的内部值后，就可以检测连接这些簇的边界节点（图 1b）。</p>
<p>一旦执行了分层算法，就会根据起点和终点发现初始地形簇和最终地形簇，因为它们都包含在各自的簇中。然后，从集群到集群，发现所有应计算的路径连接（图 1c）。发现与路径相关的集群后，在每个集群内部执行标准寻路算法，从而形成路径（图 1d）。一旦使用了这些经过预处理并存储在内存中的地形表示信息（作为地形图离线预处理任务的一部分），路径搜索时间就会比运行时执行点对点寻路算法所需的时间减少。</p>
<p>正如 van Elswijk、Sprinkhuizen-Kuyper 和 Wiedijk（2013 年）所提出的那样，目前这项工作中提出的建议详细介绍了一种分层算法，该算法还依赖于路径平滑技术，为模拟智能体的导航任务提供更具真实性的路线。</p>
<h3><span id="32-path-smoothing">3.2. Path smoothing</span></h3><p>寻路算法返回的路径将地形表示结构中的连续点（或节点）连接起来。一般情况下，这一过程会产生一段相对较短的路径。例如，A* 算法找到的路径是由连接相邻节点和相邻节点、从起点位置到终点位置的线段组成的。有时，这些连接会导致路径蜿蜒曲折，出现可以避免的小曲线。在许多模拟虚拟环境中执行的智能体运动中，与现实中的智能体形成的运动相比，遵循这种小曲线可能显得不切实际。在许多应用中，当智能体以最直接的方式向目的地移动时，就会出现逼真的移动行为。为了解决路径曲折和不真实的问题，可以在路径规划算法返回路径后执行平滑技术。</p>
<p>路径平滑算法可以消除生成路径上的多余点。只要没有需要避开的障碍物或不可导航的节点，这种情况就会发生，从而防止形成不需要的曲线的路径点被移除。图 2 展示了平滑的思路，只要路径上没有障碍物，就可以消除最终路径上的多余点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231510332.png" alt="image-20240123150713867"></p>
<p>Thorpe 和 Matthies（1984 年）采用了对 A* 算法返回的路径进行后处理平滑的方法。后处理平滑通常返回虚拟地形所使用的表示结构中可能的最短路径。虽然在执行这种平滑处理时路径长度可以减少，但寻路算法的总执行时间会增加。为便于比较，图 3 举例说明了最短路径、在搜索算法的每个步骤中使用网格的每个节点找到的路径，以及执行后处理平滑后找到的最短路径。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231513132.png" alt="image-20240123151308123"></p>
<p>Botea 等人（2004 年）提出了一种平滑算法（算法 1）。该算法检查哪些属于路径的点或节点可以移除，用一条直线取代这些中间路径点之间的连接。该过程从解决方案的一侧开始。对于解中的每个节点，都要检查用直线到达后续路径节点的可能性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231512301.png" alt="image-20240123151235884"></p>
<p>如果是，两个节点之间的线性路径就会取代最初的次优路径节点序列。如算法 1 所示，后处理算法的输入是原始寻路算法返回的路径。一个名为𝑘的计数变量从 0 开始，作为参数接收的初始路径节点被分配为新平滑路径的输入节点。之后，会执行一个循环，以验证是否有可能直接追踪路径到下一个路径点，从而消除不必要的节点。这可以从算法 1 的第 5 至第 7 行观察到。如果看不到下一个路径节点，即路径受阻，无法直接到达循环中的下一个节点，则更新新路径的节点计数器。这种更新会使计数器增量，并在平滑路径中添加一个新节点。这样，计数器索引中的节点就接收到了输入路径的节点，即循环中正在验证的节点，在本例中就是𝑆𝑖。重复循环检查从输入路径起点到倒数第二个路径节点的节点。最后，平滑路径计数器递增，并将输入路径的最终节点分配给正在寻找的平滑路径的最终节点。这样，就能保证到达最终节点并返回后处理路径。与上述著作一样，本文提出的算法会从路径搜索算法返回的路径中删除可能不必要的点。在此过程中，该算法会检查路径障碍物和其他地形起伏特征，这些可能会阻碍沉浸在模拟场景中的智能体的自主导航模拟。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231513306.png" alt="image-20240123151349143"></p>
<p>Theta* 算法（Nash、Daniel、Koenig 和 Felner，2007 年）使平滑成为可能。正如当前工作中所研究的那样，该算法还可以进行调整，以便在生成的路径中处理地形的倾斜度。Theta* 算法由 A* 算法发展而来，在将路径扩展到地形表示结构的下一个相邻节点时，Theta* 会检查是否有可能从当前节点的父节点追踪到算法打算扩展路径的相邻节点。Theta* 结合了在可见度图中搜索路径的 A* 思想和在网格结构中应用 A* 的思想。与 A* 算法不同的是，在更新成本 𝑔 和可见的未扩展邻节点的父节点时，Theta* 会考虑两种寻路可能性。其中一种是 A* 算法的路径，它考虑的是从初始节点到当前已验证节点的路径（𝑠），以及到其邻居节点的直线距离（𝑠′）[&#x3D; dist(s, s’)]。第二种方案考虑的是从初始节点到当前节点的父节点的路径。在此基础上，算法会检查是否有可能形成一条从父节点到可见邻居的路径[&#x3D; dist(parent(s), s’)]，考虑的是直线距离。重要的是，当当前节点的父节点与可见邻居节点之间有一条视线时，第二种选择是可行的。有这样的视线意味着在观察节点（当前节点的父节点）和被观察节点（可见的邻居节点）之间没有任何阻碍从父节点到邻居节点的路径搜索的节点。图 4 展示了视线的概念。如果没有路径障碍，则使用路径 2。否则，使用路径 1。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231515667.png" alt="image-20240123151558573"></p>
<p>上述 Theta* 方法之间的区别也可以从算法 2 中详细说明的伪代码中得到验证。在第 2 行中，函数返回值用于检查是否存在视线。这是选择路径的一个条件。如果返回值为 “true”，则使用路径 2（使用平滑原则）；否则使用路径 1，从当前节点到直接相邻节点。</p>
<p>Theta* 算法在应用平滑理念时非常高效。这是因为它已经平滑地规划了路径，不需要进一步的后处理。不过，这种算法允许在处理路径限制的基础上搜索路径，扩展了只检查节点是否可航行的思路。这种想法有利于当前的工作，其目的是处理与地形起伏的某些陡峭倾斜有关的智能体移动限制。一般来说，拥有一条平滑的路径，其智能体的移动限制得到了考虑和规划，这些特征都可以作为路径质量的指标。</p>
<p>总之，Botea 等人（2004 年）提出的分层算法处理了与执行时间和内存使用相关的问题。在这个方向上，van Elswijk 等人（2013 年）提出了分层路径搜索 Theta* (HPT* ) 的想法，将 HPA* 分层技术与 Theta* 路径搜索算法相结合（这两种算法都曾在本文中重新讨论过）。通过这种方式，HPT* 成功地结合了两种算法的优点，即 (1) Theta* 提供的路径质量；(2) HPA* 的计算时间和内存要求。HPT* 的路径预处理和搜索程序与 HPA* 非常相似，但有两个例外： (1) 作为预处理任务的一部分，如果集群内部节点之间有 Theta* 算法返回的路径，则将这些节点连接起来；(2) 作为运行时搜索具体路径的一部分，这项任务使用 Theta* 算法执行。因此，目前的工作是以 HPT* 算法为基础，同时采用 Theta* 算法和 HPA* 分层技术，前者在路径规划过程中平滑路径，后者则优化路径搜索算法的性能。</p>
<h3><span id="33-pathfinding-with-topographic-terrain-characteristics-and-agent-movement-constraints">3.3. Pathfinding with topographic terrain characteristics and agent movement constraints</span></h3><p>文献（Chen, Shi, &amp; Liu, 2009; Ganganath, Cheng, &amp; Chi, 2014, 2015; Marasinghe Arachchige, 2016; Pütz, Wiemann, Sprickerhof, &amp; Hertzberg, 2016）描述了在虚拟地形表示结构中表示地形特征的不同方法。其中，可以对地形表示节点的面（即法向量）进行定向，例如表示每个地形区域的最大和最小地形高度。此外，如 Ganganath 等人（2014、2015 年）、Marasinghe Arachchige（2016 年）和 Pütz 等人（2016 年）所述，依赖加权图的表示方法可以从地形高程模型中实现。路径规划算法还能考虑不同性质的地形地貌特征导致的智能体移动限制。正如 Kapadia、Ninomiya、Shoulson、Garcia 和 Badler（2013 年）、Sturtevant（2013 年 b）以及 Ninomiya、Kapadia、Shoulson、Garcia 和 Badler（2015 年）中介绍的那样，将成本应用于地形特征和路径规划计算，可以搜索到与智能体在现实中探索的路径更为相似的路径。归根结底，路径规划可以看作是一个约束处理问题，其中所代表的地形表面信息就是在路径搜索过程中正确计算的路径成本。不过，将地形高度和倾斜度数据表示（或转换）为成本信息的形式可以多种多样。有必要考虑寻路算法必须提供路径解决方案的应用问题：防止智能体出现非预期行为、实现较低的智能体能耗，以及处理燃料或维护成本等智能体后勤问题。</p>
<p>陈等人（2009 年）提出的导航网格是一种出色的表示结构。这种地形表示结构中使用的每个多边形都有一个法向量。所有法向量的集合构成一个梯度图，其变化表示在两个多边形之间移动的难度。因此，在执行寻路算法时会对梯度变化进行评估。生成成本的方法考虑到三个方面：路径长度（始终寻找最短路径）、根据法线矢量指示的地形倾斜度移动的难度以及与每种智能体相关的偏好&#x2F;限制。因此，导航成本是根据穿越每个地形节点的难度的线性组合计算得出的。根据两个多边形之间的地形倾斜度，寻路算法返回的路线变化平滑，表明智能体移动的难度较低。虽然这种寻路方法中使用的路径成本计算与本文提出的解决方案不同，但这些工作也说明了如何在路径规划中表示和计算地形信息。在此过程中，会对穿越每个地形节点的成本进行局部分析，这与当前工作中的做法类似。虽然他们提出了防止为不同种类的模拟智能体确定风险路径的相关方法，但目前这项工作还研究了在大规模虚拟地形中使用分层和平滑路径规划技术进行寻路的问题。</p>
<p>在 Ganganath 等人（2014、2015 年）和 Marasinghe Arachchige（2016 年）的研究中，使用了加权图来支持地面智能体（机器人）的路径规划。该图由高分辨率数字高程模型（DEM）创建，可精确表示与地形表面相关的高程信息。在这里，每个图形节点都对应地形表面上的一个点。地形的倾斜角度会影响智能体（或机器人）的能量消耗，从而影响路径的选择。在这种情况下，除了智能体与地形之间的摩擦力信息外，还在建立地形表示的节点中加入了权重。考虑到智能体的特性（及其约束条件），计算出智能体在地形区域内航行所需的能量成本，并将该成本应用于路径搜索算法的启发式。这一过程会在最短路径和执行移动所需的能量消耗之间达成平衡。因此，智能体可以使用更多现实生活中可导航的路径。尽管对后勤问题的处理，例如对某些路线的能源成本的考虑（这是 SIS-ASTROS 项目未来工作的一个相关问题），例如，目前的这项工作不仅计算了地形缓解感知路线（避免了对预期模拟来说很奇怪的智能体事故），而且还计算了拉直的和尽可能真实的路线。考虑到技术方面的问题，这项工作依赖于启发式计算，这种计算根据智能体的一些运动属性进行调整，与机器人导航相关，但对于本文所要模拟的情况来说过于详细。这项工作没有考虑启发式计算，而是侧重于根据当前地形表示节点的地形起伏特征确定本地导航成本。在路径搜索过程中会对该节点进行分析，而这项工作仍然使用标准的启发式寻路计算。</p>
<p>Pütz 等人（2016 年）讨论了用于粗糙地形区域路径规划的三维导航网格。生成虚拟地形结构的主要输入是由表面重建程序构建的三角形网格。这一过程生成的导航网格可应用图优化算法。通过这种结构，可以对地形表面的若干特征进行编码。这些特征用所有图形边的地形导航成本层来表示，每个边的成本函数合并为一个成本函数。在这些层中，有一层是指与局部地形起伏不平有关的成本。由于导航网格结构允许将法线矢量关联到网格的每个三角形和顶点，因此该成本也可以基于法线矢量的计算。因此，所代表的信息表明了当地地形的倾斜度。在路径搜索计算中，可以通过检查某条路线的可通行程度来获得该信息。总之，这项工作探索了法向量，以捕捉导航网格结构中每个三角形的地形倾斜度。同样，本作品还探讨了在地形表示节点的每个方向（北、南、东、西）使用此类法向量表示地形起伏倾斜特征的问题。路径成本计算过程中的一个不同点是，他们的工作使用了不同的地形特征（在地形表示图的不同层中表示），这些特征在确定路径成本值时被结合在一起，而目前的工作关注的是仅考虑地形起伏倾斜度的寻路计算。不过，与这项工作类似，该工作中描述的路径搜索过程也是在本地计算地形起伏的路径成本。</p>
<p>Abd Algfoor、Sunar 和 Abdullah（2017 年）通过三种不同的技术提出了在寻路计算中使用权重信息的想法。第一种是基于与一组权重𝑤相关联的启发式搜索算法的迭代。第二种是基于起点节点和终点节点之间的长度，然后将其与𝑤 相关联。后者基于与一组权重𝛼相关的轨迹成本。一般来说，探索这些特征的目的是确定如何改进由此产生的寻路算法，使之与其他更传统的方法相比较。由于这项工作探索了在搜索过程中计算这些权重的不同方法，因此是本研究中需要考虑的相关方法。尽管地形信息可以作为路径搜索过程中需要考虑的一组权重值来获取，但他们的工作展示了如何将这些权重作为启发式路径搜索计算的一部分。这与目前的建议不同，因为它仍在探索寻路算法中的标准启发式函数。他们的工作与本文提出的工作之间的另一个对比是所开发实验中使用的算法。与他们不同的是，这项研究对比了使用和不使用路径成本值（可作为权重）的不同算法，并展示了如何从所代表的地形特征中得出这些值。</p>
<p>在 Perkins、Marais、Gain 和 Berman（2013 年）的研究中，提出了一种计算机器人最近路径的算法。一旦为这类智能体设计出这样的路径，它们就会在具有不同特征的地形中导航，该算法在路径搜索中还会考虑加权地形区域。该算法一般用于网格或 QuadTree 数据结构，需要高分辨率才能准确模拟不规则结构的边界。在这项工作中，所使用的成本函数已扩展到在二维三角形模型和三维四面体网格所代表的结构上运行，它们能更精确地模拟世界的多边形结构。与目前的建议类似，这项工作关注的是地形的详细分层表示，尽管在捕捉大规模地形时对网格结构的探索可能不利于计算有时间限制的寻路答案。与本文提出的工作一样，他们工作中使用的启发式方法优先确定最短路径，并在本地进行必要调整，以考虑相关地形区域的路径成本。虽然没有采用路径平滑技术，但他们的工作也研究了不规则地形表示结构中的路径计算。</p>
<p>在 Sturtevant、Sigurdson、Taylor 和 Gibson（2019、2020 年）中，动态成本被应用于代表地形的图形。成本是根据智能体要穿越的土地类型（草地、道路、水域等）的特征分配的。因此，我们提出了一种分层寻路方法，即根据成本信息定义的地形类型，在较大的地形区域内搜索路径。然后，在确定最终路径时进行路径细化。地形的成本由路径搜索算法计算，路径成本被用作算法质量的衡量标准。与当前的工作类似，他们的工作使用了与不同类型地形特征相关的路径成本计算，这种详细分析超出了当前建议的范围。他们的工作与本文介绍的工作的另一个共同点是使用了分层方法，这在处理大规模地形时具有相关性。不过，在他们的动态地形环境中没有研究平滑技术，而这项工作仅在处理静态地形表征时采用了这种寻路技术。</p>
<p>Uggelberg 和 Lundblom（2017）所做的工作研究了应用于 A* 算法的不同权重信息如何影响寻路执行时间。它还研究了这些权重对路径准确性的影响程度。将权重应用于代表虚拟地形环境的图节点，虽然得到的路径看起来更真实，但路径计算变得更加复杂。这种权重被应用于代表虚拟地形环境不同区域的结构；大权重被应用于智能体应避免的地形区域，而小权重则被应用于首选导航区域。此外，还存在不可导航的地形区域。通过这种方式，算法可以进行路径搜索，从而使最终路径的成本最小化。在这项工作中，所使用的启发式函数也是加权的，即根据待导航区域的面积对欧氏距离进行加权。与这项工作类似，这里提出的方法也呈现了不同的地形区域及其相应的地形特征。虽然这种类似吸引力和排斥力的方法似乎可以避免智能体路线的风险，但由此产生的路径可能会呈现不必要的曲线，与现实生活中的路径选择并不相似。这就是为什么不仅要根据地形起伏特征来指导路径确定，还要平滑所产生的路径，以便为目标智能体提供尽可能笔直的路线。</p>
<p>在 Basiri (2020)一书中，作者提出了一种寻路算法，用于处理开放地形区域，如空地和公园，传统的路线规划应用软件无法适当支持这些区域（例如，它们最常处理的是地图上的道路）。提议的算法根据轮椅移动应用进行了调整，这取决于不同的因素。这些因素考虑了轮椅使用者在规划路线时所受到的限制。这样，作为地形表示结构的增强可见度图的可见度点之间的链接就有了权重。该可见度图考虑到了障碍物、障碍等方面。链接的权重基于距离信息和地表条件、坡度等。这些因素是从轨迹挖掘算法和机器学习技术获得的运动模式中学习的。分配给每个可见度图链接的权重是所学因素的平均值。因此，在进行搜索时，应考虑地形结构的权重，寻找成本较低的路径。在根据目标智能体调整路径规划解决方案的同时，这项工作还考虑到了所提出的方法，其重点是处理智能体的导航要求，即在标准寻路解决方案通常无法接近的地形区域搜索路径。与本文介绍的方法不同，该方法利用机器学习来学习智能体的约束条件，并在确定智能体路线时对其进行计算。迄今为止，由于对机器学习方法的探索，这种改进寻路计算的方法尚未在本文介绍的研究项目中得到研究。</p>
<p>Li 和 Chou（2018）采用了基于约束的目标函数。在计算目标函数时，会权衡路径长度约束、平滑和碰撞风险，旨在最小化运动成本并平衡不同的约束条件。利用粒子群优化算法，计算出的函数可用于机器人在复杂环境中的运动规划。虽然通过基于约束条件的优化算法实现目标函数的最大化&#x2F;最小化是解决现实路径确定问题的合理方法，但优化技术可能会带来寻路响应时间的延迟，不利于现实模拟的开发。虽然目前的工作只侧重于由于所表现的地形起伏而产生的导航约束，但它解决了路径规划的分层技术，以同时应对大规模虚拟地形和有限的响应时间要求。</p>
<p>要在虚拟地形图中表示倾角信息，就必须表示每个地形区域的地形特征，这些特征保存在相应的表示节点中。虽然采用了不同的技术来表示和使用有关地形不平整度的信息，但这些信息是由路径规划功能计算出来的，然后转换成导航成本。路径搜索算法会使用这些成本，还可以处理分配给智能体的其他运动限制。在当前的工作中，我们决定使用法向量来表示虚拟地形结构中的地形倾斜度信息。这一决定是基于这样一个事实，即 SIS-ASTROS 项目应用问题中涉及的智能体在通过包含陡峭倾斜度的地形区域时有移动限制（这些倾斜度是根据地形地面的法向量计算得出的）。</p>
<h2><span id="4-overview-of-the-proposed-approach">4. Overview of the proposed approach</span></h2><p>用于构建仿真系统的大规模地形的地形信息表示和计算是本研究提出的寻路方法的相关特点。正如 Brondani 等人（2019）所讨论的，QuadTree 数据结构的层次性是优化地形表示和路径搜索的基础。这是因为现实世界中不同层次的地形细节都可以在生成的虚拟地图的层次结构中表达出来。因此，QuadTree 表示结构的叶节点表达了虚拟地形的不规则网格和分层表示（其中地形特征多的地形区域要比地形特征少的其他区域精细得多）。这样，层次结构中的最高级别就代表了虚拟地形的总面积。在层次结构中，节点越深，表示的地形区域的详细程度越高。</p>
<p>在激励这项工作的模拟系统中，在构建地形导航地图时对 QuadTree 表示结构的细分考虑了不同的地形特征，如植被密度、地形景观的形状和地形区域的陡峭程度，以及河流或其他水体的存在。如果在所使用的真实世界地图上发现了这些地形特征（在 SIS-ASTROS 项目中，虚拟地形是根据基于地理信息系统的真实地形区域地图数据构建的），则会相应地在 QuadTree 层次结构中构建一个新的层次。这个过程一直重复进行，直到满足 QuadTree 层次结构的最终细分条件为止，该细分条件是根据所代表的现实世界地形特征和达到 QuadTree 层次结构的最高级别确定的。</p>
<p>在Brondani等人（2019）提出的QuadTree结构寻路执行中，分层搜索过程可以减少地形导航地图中访问节点的数量，从而降低整体搜索成本。此外，访问节点的数量与搜索的处理时间直接相关。这样，即使在处理大规模真实世界虚拟地形时，也能接近路径规划计算所需的处理时间限制。这种特性与当前的工作息息相关，因为所提出的寻路技术完全基于这种地形表示方法。</p>
<p>正如 Brondani 等人（2019）所描述的，QuadTree 结构是一种 “有根的树”，其中每个节点（n）正好有四个子节点或没有子节点。作为导航 QuadTree，它由一个分层结构组成，用于表示虚拟地形。由该结构生成的不规则网格由分层表示法的叶节点表示。在生成的不规则网格表示法中，每个节点都有以下信息：</p>
<ul>
<li><p>代表虚拟地形信息的属性：n&lt;最小高度、最大高度、邻居、有河、有湖、有崖、可步行、正常北、正常南、正常东、正常西&gt;。</p>
</li>
<li><p>minHeight 和 maxHeight 属性提供了节点所代表的真实地形区域中的最小和最大地形高度信息；</p>
</li>
<li><p>可步行属性表示插入模拟中的智能体是否可以访问该节点。根据该节点所代表的地形特征，它是否允许地面智能体移动；</p>
</li>
<li><p>属性 normalNorth、normalSouth、normalEast 和 normalWest 是节点的四个法向量，分别指向每个节点的方向。它们提供了地形与向上矢量（平面的法向量，指向上方，在空间中的坐标为（0, 1, 0））相比的倾斜角度信息。</p>
</li>
</ul>
<p>为了在寻路过程中探索分层表示法，我们使用 QuadTree 的较高层次来形成地形簇，第 3.1 节中解释了这一想法。这种层级的定义可能无法一概而论；这意味着应根据目标应用领域确定形成簇群的层级，以便优化抽象图中的搜索时间，并优化最终路径的搜索。为了在我们的项目中进行这样的分析，我们在模拟系统中进行了一系列测试，旨在了解什么是解决我们的应用问题最合适的聚类级别。这样，在执行寻路算法时，就有可能比只在叶子 QuadTree 节点上执行算法获得更高的性能。最后，如果叶节点比在层次结构中定义地形簇所选择的层次高一级，它就会成为一个簇，形成一个不规则的网格，也用于抽象路径计算（簇的层次）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231523040.png" alt="image-20240123152314952"></p>
<p>从已形成的地形簇出发，一旦底层模拟系统启动，就可以开始发现簇边界节点并对每个簇进行处理。集群处理的部分工作包括隔离边界节点（图 5.a）和搜索所有集群边界之间的路径距离（图 5.a）。为了找出这些距离，需要在每对边界节点中执行搜索算法，并将集群的输入和输出作为输入。在本文提出的方法中，除了处理集群边界节点对之间的距离外，还要计算每条路径的成本。在这种情况下，这些成本考虑了地形的倾斜度。之后，路径搜索算法将使用这些地形成本信息。例如，对于每个地形群节点，边界节点会被存储在一个列表中，以减少搜索时间。这一过程相当于在准备虚拟仿真场景时对地形表示结构进行预处理。</p>
<p>在执行搜索算法时，它首先通过集群边界连接规划集群之间的路径（图 6.a），搜索 “抽象路径”。然后，使用寻路算法在每个簇内部搜索路径，得到 “具体路径”。在每个集群中，在两个选定的边界节点之间搜索路径，同时考虑集群的路径入口和出口。每个集群返回的路径的联合构成结果路径。该路径由寻路算法的抽象和具体搜索步骤获得（图 6.b）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231524674.png" alt="image-20240123152403645"></p>
<p>在虚拟地形图的结构中插入了每个地形表示节点所代表的最大和最小地形高度值及其法向量（用于捕捉这些地形节点的起伏倾角）。之后，路径规划算法将使用这些节点属性来获取每个地形节点的起伏倾角。由于所开发的算法处理的是智能体在不平整地形图中的移动困难问题，因此决定使用倾斜度特征来表示地形的起伏特征，这一决定是基于第 3.3 节中的作品分析做出的。这种地形倾斜度被认为是智能体移动的障碍，因此，在模拟系统执行过程中，它们与为智能体计算更安全的路径有关。</p>
<p>在这项工作中，除了捕捉目标地形特征的属性外，与路径计算最相关的地形特征还包括节点是否受阻（可行走）。在这种情况下，与 Chen 等人（2009 年）提出的方法类似，浮雕倾斜信息由表示结构中每个节点的地形法向量表示。为了提高表示这种倾斜的准确性，使用了与组成地形表示节点的四个定向面（北、南、东、西）有关的法向量（normalNorth、normalSouth、normalEast 和 normalWest）。根据智能体的运动方向，这些有向法线向量有助于计算路径成本，路径规划算法会对路径成本进行分析。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231525858.png" alt="image-20240123152528685"></p>
<p>法向量由组成每个三角形地形区域的向量的向量积构建而成。这些区域位于四叉树的叶节点内部（图 7）。这些法向量指的是各自节点的方向。这一过程使用节点四角的两个点（相对于正在建立的法线矢量方向（北、南、东、西））以及其中心点。根据这些点，可以得到构成三角形地形区域的矢量，从而计算出矢量乘积。因此，与这些三角形地形区域向量的正交向量就产生了。然后，这个法向量垂直于三角形地形区域的面。这样，就定义了法线北（NN）、法线南（NS）、法线东（NE）和法线西（NW）。有了它们，就可以在计算路径成本时只计算智能体将经过的浮雕倾斜值。根据智能体到达节点的方向，可以确定进入节点的成本；根据离开节点的成本，可以确定离开节点中心到与邻近节点交界处的成本。</p>
<p>法向量的计算方法如下：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231526164.png" alt="image-20240123152610267"></p>
<p>有了关于四个节点方向的法向量表示法，就可以获得路径入口和出口的地形倾斜度。这使得地形信息的表示更加详细。同时，由于可以在计算路径时计算特定地形区域的成本，因此算法性能更加精确。</p>
<h2><span id="5-using-terrain-relief-inclinations-in-the-computations-of-path-costs">5. Using terrain relief inclinations in the computations of path costs</span></h2><p>目前这项工作中提出的成本计算方法可以处理路径搜索过程中的地形倾斜问题，并保证智能体的行车路径安全。为此，有必要在寻路计算中加入地形高程的成本值。正如第 3.3 节所述，可以探索不同的方法将可用的地形数据转换为成本值，而方法的选择往往基于要解决的应用问题。在这项工作中，采用了一种处理地形起伏倾斜度的方法，因为模拟智能体的移动会受到一定倾斜角度的影响。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231527189.png" alt="image-20240123152724278"></p>
<p>地形起伏信息通过四叉树每个三角形节点的法向量获得。在此基础上，根据所代表的地形起伏倾斜角的余弦值计算出一个权重值。该权重值会影响选择或不选择给定路径的决定。权重值越高的地形区域，相关成本越低。实际上，地形倾斜角度（𝜃）越小，其余弦值就越大，权重值也就越大。因此，通过计算反余弦值，可以获得较低的成本。</p>
<p>由于 QuadTree 的每个叶节点都是由四个三角形区域（指节点方向）组成的，因此每个叶节点都有四个法向量。为了确定通过一个节点的成本，需要选择当前节点出口方向和相邻节点路径入口方向的地形起伏倾角。这些都是智能体在移动过程中要经过的节点部分。例如，如果智能体向东移动，它就会利用相应的法向量从东侧离开当前节点。这样，它就会根据自己的移动方向，使用节点一侧的法向量，从西侧边界进入邻近节点（见图 8）。尽管根据智能体经过的节点方向使用了地形倾斜信息，但仍有必要检查节点的其他法向量。这一点很重要，可以保证节点中是否存在急剧的地形倾斜，这种情况不允许智能体通过该地形区域。如果该节点所代表的地形倾斜度超过了智能体安全移动所允许的极限，则算法计算时将不考虑该节点。这样就可以跳过剩余的地形倾斜度验证过程，以及作为路径成本计算一部分的地形特征计算。</p>
<p>获得节点入口和出口的地形倾角后，检查这些倾角是否在 5 o 和 𝛼 之间。在这项工作中，根据联合国提供的资料（Blyth，2002 年），5◦ 以上的地形倾角被视为山脉。𝛼 代表允许智能体移动的最大地形倾角值，这种寻路&#x2F;智能体移动约束可以在所提出的寻路方法中进行参数化。如果地形倾斜度在规定范围内，则根据上述计算方法确定路径成本。如果低于该范围，则成本为单位成本，因为建议的算法只处理被认为与智能体安全导航相关的浮雕倾角。这意味着，数值 1 只反映了路径距离的成本，而没有分配给地形起伏的成本值。因此，路径成本计算可概括为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231528175.png" alt="image-20240123152833130"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231529333.png" alt="image-20240123152921235"></p>
<p>图 9.a 和 9.b 可以直观地分析搜索过程的有效性。首先，将路径成本应用于标准 A* 算法，该算法不考虑地形起伏的高程。这意味着只考虑起点和终点之间的最短距离，而忽略了对智能体的交通可能有危险的地形区域。唯一考虑到地形高度的寻路处理方法是阻止地形倾斜值超过一定限制的节点，这是一种用于处理导航障碍的更简单的寻路处理方法。第二步，改进路径搜索算法，以考虑地形的不平整性，解决可能对智能体移动造成负面干扰的问题，返回成本较低的路径，绕过可能被视为移动轨迹障碍的特定地形区域。从图 9.a 和图 9.b 中可以看出，与标准 A* 算法的路线所包含的区域相比，寻路算法所搜索的路线穿过的地形区域具有轻微的地形起伏倾斜。在这里，底层法向量图显示了地形的倾斜度：区域颜色越深，地形的倾斜度越大。在本例中，35◦ 的倾斜值被定义为目标智能体流量的极限值。</p>
<p>由于将成本值应用于 A * 算法反映了路径搜索结果与急剧地形倾斜的偏差，这也是这项工作的目标之一，因此开发了一种旨在平滑所获路径的方法。平滑的想法基于 Theta* 算法，该算法在计算路径的同时，使其与模拟智能体在现实世界中可能选择的路线更加相似。</p>
<h2><span id="6-the-proposed-hpatheta-algorithm">6. The proposed HPATheta* algorithm</span></h2><p>这项工作探讨了 Theta* 算法的路径成本计算。在此过程中，它允许根据选定的地形特征对计算出的路径进行平滑处理。除其他优点外，平滑还能改善路径规划算法得出的路径，通过避免蜿蜒曲折的路线使其更符合实际情况。因此，如果能返回智能体需要走过的最短距离，路径质量就会得到改善。如果路径偏离了非常陡峭的浮雕斜面，这些路径对智能体来说就会变得更加安全，这也是这些智能体沉浸在模拟环境中所需要的。因此，结合这两个优势的建议产生了一种高效的算法。</p>
<p>问题在于，当在路径规划计算中使用地形信息时，文献（Thorpe &amp; Matthies, 1984）中描述的标准平滑技术会忽略地形起伏的哪些部分可能有利于智能体导航行为的模拟。为了缩短距离和降低路径成本，有必要在 Theta* 中处理地形起伏，这也是当前工作的探索方向。在这种情况下，仅仅检查当前位置与其相邻位置的地形倾斜度是不够的。在使用视线平滑技术时，有必要解决地形起伏倾角问题。这样才能确定地形起伏倾角是否不会阻碍视线。因此，在 HPA Theta* 算法中探索的拟议路径平滑技术具有以下特点：</p>
<p>(1) 当地形起伏倾斜度等于或大于𝛼（允许智能体安全移动的最大倾斜度）时，阻碍视线；</p>
<p>(2) 将这些节点之间视线范围内遇到的进入和退出地形节点成本相加。这相当于在路径搜索计算中分配了一个视线成本；</p>
<p>(3) 像执行标准 A* 算法一样，沿着一个节点到其邻居的路径，检查从当前节点到下一个节点的移动成本。当视线受阻，无法进行平滑时，就会这样做。</p>
<p>建议对 HPATheta* 算法使用的视线技术进行调整的目的是：</p>
<p>(1) 只要没有给智能体移动带来风险从而导致无法导航的阻塞节点或地形起伏倾斜，就能避免路径障碍；</p>
<p>(2) 计算沿视线的浮雕倾斜度总和，以确定其产生的路径是否会给智能体造成导航困难。</p>
<p>总之，视线方案的特点是 “近视视线”（算法 3）。与 Theta* 算法使用的标准视线方法不同，这种近视方法表明，只要地形起伏倾斜的总成本低于其他路径可能性，就有可能出现自由平滑视线。这意味着，与小曲线路径的成本相比，平滑会降低路径的成本。</p>
<p>HPA Theta* 算法通过处理地形起伏倾斜度和路径平滑技术，在起点和终点位置之间找到了成本较低的路线（见本文提供的实验结果）。实际上，较低的成本意味着可以避开陡峭的地形坡度。该算法完成从初始节点 Ns 到目标节点 Ng 的路径所需的成本定义如下：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231532727.png" alt="image-20240123153209745"></p>
<p>其中，成本函数 g(Ns, N) 是𝑁𝑠 到查询节点 𝑁 的穿越成本。路径成本是通过累积组成路径的每个连续节点的穿越成本计算得出的。因此，它反映了从初始节点𝑁𝑠 到当前节点（即查询节点𝑁 的路径父节点）的路径成本，加上穿过当前节点 𝑝𝑎𝑟𝑒𝑛𝑡(𝑁) 到查询节点𝑁 的成本，如图所示：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231532719.png" alt="image-20240123153241704"></p>
<p>c(parent (N), N) 表示从当前父节点 (𝑁)到查询节点 𝑁 的旅行成本（考虑路径的缓解倾斜成本）。其定义如下</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231533627.png" alt="image-20240123153317563"></p>
<p>其中，d(父节点 (N)，N) 是父节点 (N) 到 N 的欧氏距离，再乘以第 5 节所述的 mScost 路径倾斜成本。综上所述，从 Ni 到 Nk 的路径成本是节点对之间的交叉成本之和，其值为</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231534429.png" alt="image-20240123153427344"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231535127.png" alt="image-20240123153502124"></p>
<p>其中，𝜆 NiNk 描述了从 Ni 到 Nk 的路径，代表节点序列，即每 i ≤ j ≤ k 有一条路径（Nj，Nj + 1）。</p>
<p>最后，h(N, Ng) 是启发式函数，反映了从当前节点 𝑁 到目标节点 𝑁 的估计路径成本。在 HPATheta* 算法中，该启发式函数是通过这些节点之间的欧氏距离计算得出的，尽管所提议的算法在进行路径规划的同时还处理了地形起伏倾斜问题。</p>
<p>根据提议的算法，搜索过程从在开放节点列表中插入初始节点开始（算法 4，第 3 行）。因此，𝑔(𝑁𝑠) &#x3D; 0。</p>
<p>在探索当前节点的邻居节点时，如果该邻居节点既不是目标节点，也不是代价无限大的节点，则会将不在开放节点列表中的邻居节点纳入其中。然后将当前节点从列表中删除。如果被探索的邻居是目标节点，则会使用𝑂𝑟 𝑔𝑎𝑛𝑖𝑧𝑒𝑃𝑎𝑡函数返回找到的路径，该函数会沿着 StartNode 和 TargetNode 之间的路径对节点进行排序。像往常一样，HPATheta* 算法会计算路径成本，并考虑列表中每个已探索的邻居。此时，算法会尝试应用平滑技术：使用 “近视视线”（算法 5，第 2 行）检查是否可以在当前节点的父节点和已访问的邻居之间找到一条直接路径。使用ε𝐵𝑜𝑢𝑛𝑑𝐼𝑛𝑡𝑒𝑟𝑠𝑒𝑐𝑡𝐿𝑖𝑛𝑒ε函数检查两个节点之间视线相交的扩展节点。如果视线畅通，则考虑平滑路径计算路径（算法 5，第 3 行）；如果视线受阻，则不平滑计算路径，使用当前节点的直邻节点组成路径（算法 5，第 5 行）。然后，算法会更新函数𝑚𝑜𝑣𝑒𝑚𝑒𝑛𝑡𝐶𝑜𝑠𝑡𝑂𝑛𝑈𝑒𝑣𝑒𝑛𝑒𝑠（计算穿越成本的函数、 算法 6，第 4 行）和（算法 7，第 5 行）。要更新该成本，需要使用 𝐶𝑎𝑙𝑚𝑝函数对所获得的穿越成本值的一致性进行检查。该函数将确保 𝑐𝑜𝑠𝑡 ∗ 𝑑𝑖𝑠𝑡𝑎𝑛𝑐𝑒 的值包含在距离和无穷大之间的区间内。如果得到的值小于𝑀𝑖𝑑𝑤𝑎𝑦和𝐶𝑎𝑛𝑑𝑖𝑎𝑡𝑒节点之间的距离，则返回它们之间的距离。探索完当前节点后，将其插入封闭节点列表。在下一次迭代中，将探索开放节点集中成本值最低的节点 𝑓 (𝑁)（算法 4，第 4 行）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231536771.png" alt="image-20240123153643161"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231537328.png" alt="image-20240123153708201"></p>
<p>一般来说，HPATheta* 算法分析的路径方向可以根据检查每条视线时获得的成本而改变。这种处理方法指的是所谓的 “路径 2”（算法 6），其选择标准见第 3.2 节中描述 Theta* 搜索过程的伪代码中的算法 2。通过加权视线，如果 “近视 “视线没有受到阻碍，算法将返回一个路径成本，供路径决策时考虑（算法 5，第 2 行）、 其中的变量 𝑑𝑖𝑡𝑎𝑛𝑐𝑒 𝑖𝑡𝐶𝑜𝑠𝑡 返回 “𝐶𝑎𝑛𝑆𝑒𝑀𝑦𝑜𝑝𝑖𝑐’’函数计算的成本）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231538502.png" alt="image-20240123153807334"></p>
<p>但是，如果加权视线受阻或超重，要保持路线方向不变，则由 Theta* 执行所谓的 “路径 1”（算法 7），该算法也会在决策中使用地形倾斜成本。因此，在搜索过程中，地形地貌的处理是通过检查当前节点每个近邻节点的成本来完成的。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231538779.png" alt="image-20240123153831834"></p>
<p>在算法中，路径成本是根据智能体的移动方向计算的。这意味着，该成本是根据出口节点方向的法向量（normalFrom）和邻近节点的入口法向量（normalTo）计算的，这两个法向量是智能体移动方向的一部分。𝑜𝑣𝑒𝑚𝑛𝑡𝐶𝑜𝑠𝑡𝑂𝑛𝑈 𝑛𝑒𝑣𝑒𝑛𝑒𝑠是计算穿越成本的函数，如第 5 节所述。对于视线来说，进入和离开地形表示节点的思路是相同的。经 ε𝐵𝑜𝑢𝑛𝑑𝐼𝑛𝑡𝑒𝑟𝑠𝑒𝑐𝑡𝐿𝑖𝑛𝑒ε 函数验证的视线穿过的所有节点都会计算其输入和输出成本，如图 10 所示。在图中，三角形输出区域用浅灰色虚线边界表示。三角形输入区域用深灰色表示。进入和离开每个节点的成本都会被计算出来，并与视线中包含的其他节点相加，形成近视视线的成本。如图所示，视线穿过的所有节点都会计算其成本。然后将它们加入视线的最终成本中。这条视线以一个节点的中心为起点，以另一个节点的中心为终点，尽可能平滑。</p>
<p>正如 HPA Theta* 方法所探讨的那样，Theta* 能提供更高质量的路径。但是，它需要更长的执行时间和更多的内存。在处理地形起伏倾斜时，这种类似于 Theta* 的计算时间会变得更长。为了解决这个问题，本研究提出了分层寻路方法，从而降低了搜索的复杂性，缩短了执行时间，如 Botea 等人（2004 年）的研究。此外，Theta<em>结果与 HPA * 结果相结合，成功地结合了HPA Theta</em>算法，因为两种算法的优点（van Elswijk等人，2013）都得到了保证。</p>
<p>总之，HPATheta* 算法依靠 Theta* 平滑技术来解决智能体因地形起伏不平而产生的移动困难。它还将 Theta* 算法集成到了分层寻路方法中。在实践中，QuadTree 所描述的地形表示结构被抽象为簇。然后，这些集群由更高 QuadTree 层级的节点来表示。预处理在每个簇中寻找内部的 QuadTree 路径，并使用旨在处理地形倾斜的 Theta* 算法找到路径。按照第 3.1 节中描述的 HPA* 提出的想法，在地形表示结构中与其他可行走节点有边界的所有可行走节点之间都会进行这种预处理。此外，集群之间相邻的边界节点也会相互连接，从而提供集群之间的连接。运行时，在经过起点和终点时，会确定感兴趣的簇。然后，执行经适当扩展以处理地形起伏倾斜的 Theta* 算法，搜索具体路径。总之，HPATheta* 算法除了通过一种新的视线计算形式考虑地形的不平整外，还利用了 Theta* 和 HPA* 的优点。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231542727.png" alt="image-20240123154222713"></p>
<p>这项工作使用 QuadTree 来支持分层地形表示和寻路。De Berg、Van Kreveld、Overmars 和 Schwarzkopf（1997 年）指出，作为预处理模拟活动的一部分，对于细分为 n 个节点的地形，构建 QuadTree 的复杂度为 O((𝑑+1)𝑛)，其中 d 是树的深度。此外，在这种层次结构中插入、移除和搜索节点的复杂度为 O(𝑙𝑜𝑔(𝑛))。HPATheta* 首先会在更高层次的地形表示中搜索抽象路径。这是在 QuadTree 层次结构的某一中间层中进行的，地图簇就在这一层中表示。为了计算抽象路径，使用了类似 A* 的算法。实际上，A* 搜索需要构建一棵搜索树，其复杂度为 O(𝑏𝑑 )，其中 d 是成本最低的解的深度，b 是搜索树的分支因子。考虑到抽象路径所经过的地形群，HPATheta* 算法对具体路径进行细化搜索。再次使用类似 A* 的算法在每个簇中找到一条具体路径。在此过程中，只使用属于目标簇的四叉树分支的叶节点。考虑到每个簇只包含代表一小部分地形的节点数，每个簇搜索的复杂度也是 O(𝑏𝑑 )（搜索树缩小到簇的极限所代表的地形节点）。HPATheta* 算法基于 Theta* 算法（Nash 等人，2007 年）。它的时间复杂度是根据扩展节点的数量与搜索树的深度成指数关系来计算的，因此为 O(𝑏𝑑 )。然而，在 HPATheta* 的复杂度中还必须考虑另一个因素，即与用于验证视线的节点数量相关的线性成本，从而导致路径平滑（Daniel、Nash、Koenig 和 Felner，2010 年；Nash 等人，2007 年）。因此，HPATheta* 的渐近复杂度为 O（𝑏𝑑 + d）。</p>
<h2><span id="7-experiments-and-results">7. Experiments and results</span></h2><p>本实验旨在评估 HPATheta* 算法在根据目标智能体的移动限制在虚拟地图中搜索路径时处理地形特征的有效性。我们的假设是，在路径规划过程中对地形起伏倾斜进行处理可能会产生低成本路径。最重要的是，拟议的 HPATheta* 应该能找到不会对模拟智能体的导航行为造成风险的路线，允许它们偏离具有陡峭地形特征的地形区域。</p>
<p>实验使用了大型虚拟地形图。作为 SIS-ASTROS 项目（SIS-ASTROS，2014 年）的一部分，这些地图代表了三个真实世界的地形，Engel、Frasson 和 Pozzer（2016 年）、do Nascimento、Franzin 和 Pozzer（2018 年）、Frasson、Engel 和 Pozzer（2018 年）对这一计算机制图过程进行了描述。 虚拟地形’’B’’的主要地形特征是高山，可以更好地测试 HPATheta* 算法的地形起伏倾角计算。相比之下，虚拟地形’’A’’的地形起伏倾角较小。地形’’C’’虽然没有明显的地形起伏倾斜，但该区域有许多水体，导致表示结构中出现大量阻塞节点。每个地形的特征摘要见表 1。</p>
<p>针对每种地形，测试了六种不同的寻路算法，以便将拟议的 HPATheta* 算法与其他算法的结果进行比较。为便于比较，选定的算法包括：(i) 标准 Theta* （Nash 等人，2007 年）；(ii) 能够计算地形起伏倾斜度的改进 Theta* ；(iii) 基于标准 Theta* 的分层算法，称为 HPT* （van Elswijk 等人，2013 年）；(iv) Botea 等人（2004 年）提出的 HPA* ；以及 (v) 经过调整的 HPA*，以便在路径计算中处理地形起伏倾斜度。</p>
<p>值得一提的是，本研究对分层和非分层路径规划算法进行了比较。采用分层算法可以分析这种分层方法的影响，主要是在执行时间方面。此外，这些算法既可以使用与地形起伏倾斜度相关的路径计算，也可以不使用，从而可以根据这些地形特征比较寻路过程的成本。为了扩大围绕 HPATheta* 算法的分析和讨论，HPA* 算法（其在线版本称为 OHPA*）也被纳入实验中。这样，我们就可以比较是否使用路径平滑技术的算法。</p>
<p>对于每种算法，测试中都使用了以下指标：(i) 结果路径的长度（以米为单位的路径距离）；(ii) 路径搜索的执行时间（以毫秒为单位）；(iii) 结果路径的成本。成本是本研究中最相关的指标之一，因为它可以分析路径规划算法是否避免了可能损害目标智能体移动安全的救济倾斜。为了计算在路径规划中处理此类地形特征的成本，如第 5 节所述，我们定义了一系列相关的地形倾斜度。实际上，在路径规划计算中使用的地形起伏倾角在 5 o 度到 35 o 度之间。低于此范围的倾角值在路径计算中不予考虑。高于 35◦ 度的地形起伏倾角只被视为模拟智能体移动的障碍。</p>
<p>在我们的研究项目中，响应时间也是评估已测试路径规划算法的一个重要指标。根据 Nielsen（1994 年）的研究，人机交互研究中的响应时间有三个需要考虑的重要限制，主要是在仿真系统中，用户在其中扮演着与运行中的仿真互动的积极角色。这些时间分别为 0.1 秒、1.0 秒和 10 秒。在 0.1 秒内，用户认为系统会立即做出反应。从这个值开始到大约 1 秒的时间间隔被认为是 “用户的反应时间极限”，尽管他们可以处理一些系统延迟。当时间间隔在一秒到十秒之间时，用户会感觉与运行中的模拟越来越脱节。当等待系统响应的时间达到 10 秒左右时，只要系统不提供某种反馈信息来告知用户正在执行用户请求，用户就会开始觉得发生了错误。在这项工作中，这些系统响应时间限制与拟议的 HPATheta* 算法执行时间分析相关。</p>
<p>在测试中使用的每个虚拟地形的地图上都有 4,300 个起点和终点。这些点是在地形图的不同位置随机生成的。用于实验的计算机配置如下： CPU： 英特尔(R) 酷睿(TM) i5-8400 CPU @ 2.80 GHz 2.81 GHz；内存：16 GB（2 个 8 GB 插槽，频率 2400 MHz）；显卡：NVIDIA GeForce GTX 6000 显卡（2 个 8 GB 插槽，频率 2400 MHz）： NVIDIA GeForce GTX 1660 Ti；固态硬盘：240 GB；Windows 10 Pro（版本 10.0.19043.1052）。</p>
<p>为了分析实验结果，使用了广义线性回归模型（McCullagh 和 Nelder，1989 年）。根据实验结果的类型，在构建回归模型时使用了伽马分布。在这种情况下，该分布能更好地代表正的实际值，也就是实验中计算的路径搜索执行时间和结果路径的成本值。实际上，每种测试算法的结果都包含在回归模型中，以便对这些技术进行比较。</p>
<p>用于分析和比较测试算法的路径规划执行时间和由此产生的路径成本的回归模型定义为 g(mu) &#x3D; 𝐵𝑒𝑡𝑎0 + 𝐵𝑒𝑡𝑎1 * X + 𝐵𝑒𝑡𝑎2 * D1 + 𝐵𝑒𝑡𝑎3 * D2 + 𝐵𝑒𝑡𝑎4 * D3 + 𝐵𝑒𝑡𝑎5 * D4 + 𝐵𝑒𝑡𝑎6 * D5、 其中，g 为对数函数。在实践中，该模型表示找到的路径的各自成本值和搜索算法的执行时间，两者都是虚拟地形上起点和终点位置之间距离的函数，这些距离值由模型中的变量 X 表示。为了将不同的技术与本研究提出的基本方法（HPATheta* ）进行比较，本统计模型中的所谓虚拟变量 D1-D5 用于表示每种算法。因此，回归模型描述了当 D1 &#x3D; D2 &#x3D; D3 &#x3D; D4 &#x3D; D5 &#x3D; 0 时 HPATheta* 算法的执行时间或路径成本，并分别描述了当 D1 &#x3D; 1 时的 HPT* 算法、当 D2 &#x3D; 1 时带浮雕倾斜计算的 OHPA* 算法、当 D3 &#x3D; 1 时的 OHPA* 算法、当 D4 &#x3D; 1 时带浮雕倾斜计算的 Theta* 算法和当 D5 &#x3D; 1 时的 Theta* 算法。也就是说，要获得上述每种算法的结果，必须给代表第 i 种算法的变量 Di 赋值 1，而其他变量 D 的值必须为 &#x3D;0。</p>
<p>通过比较 HPATheta<em>、HPT</em>、OHPA* 和 Theta*，统计估算值代表了 (i) 执行时间和 (ii) 与 (iii) 不同路径距离值相关的路径成本的平均值。回归模型中使用的连接函数是对数函数，因为该函数在统计方法中的结果可以代表任何实际值。为了进行统计分析，确定显著性水平为 0.01（1%）。因此，在 i &#x3D; 1、2、3、4、5 和 6 时，分别以 𝐵𝑡𝑎𝑖 &#x3D; 0 或 𝐵𝑒𝑡𝑎𝑖 ≠ 0 定义了两个假设 H0 和 H1。然后，将 alpha 值与𝑝值进行比较。如果 alpha &lt; 𝑝-值，则拒绝 H0；否则，不拒绝 H0。𝐵𝑒𝑡𝑎1&gt;0意味着起点和终点位置之间的距离越远，算法返回这些距离的路径的执行时间就越长。对于𝐵𝑒𝑡𝑎𝑖来说，当 i 取值为 2、3、4、5 和 6 时，𝐵𝑒𝑡𝑎𝑖 &#x3D; 0 意味着𝐷𝑖方法等同于基本方法。𝐵𝑒𝑡𝑎𝑖 &gt; 0 表示 Di 所指的方法比基本方法慢。𝐵𝑒𝑡𝑎𝑖 &lt; 0 意味着 𝐷𝑖 所代表的方法比基本方法快。</p>
<p>如图 12、图 14 和图 16 所示，在测试技术的寻路结果中，回归模型得到的 P 值均接近零，且低于 0.01 的α水平；因此，所有结果均具有统计学意义。因此，回归模型表明，对比技术之间存在显著差异。使用 HPT* 技术、OHPA* 技术以及有和无浮雕倾斜的 Theta* 技术，起点和目标位置之间路径距离的所有执行时间和成本值都与基准 HPATheta* 技术不同。以统计数据的分析为例，图 12A 中 D5 &#x3D; Theta* 的路径成本值为 0.3224。由于 exp (0.3224) &#x3D; 1.38（这里使用的是指数函数，因为链接函数使用的是对数），因此可以看出，在相同的路径距离下，Theta* 技术计算出的路径比 HPATheta* 技术多需要 1.38 个成本单位。图 12、图 14 和图 16 所示的其他结果也有类似的解释。由于上述图中的所有成本估计值均为正值，回归模型显示，使用 HPATheta* 算法进行路径搜索的成本低于 HPT* 、带浮雕倾斜的 OHPA<em>、OHPA</em>、带浮雕倾斜的 Theta* 和 Theta* 算法。</p>
<p>就两点之间的路径成本而言，我们最初的预期是，使用 HPATheta* 算法和带有浮雕倾斜度的 Theta* 算法所需的成本最低。在这种情况下，这些算法在进行路径规划时，会处理地形地貌的特殊性，并平滑所产生的路径。此外，OHPA* 算法很快就会出现，因为它考虑到了地形的起伏倾斜。不过，OHPA* 算法并没有对路径进行平滑处理，这也是影响最终路径成本的一个因素。从测试结果来看，最初的预期得到了部分证实。这是因为，每种地形的特殊性和是否使用分层搜索技术都会影响路径结果，进而影响路径成本。</p>
<h3><span id="71-pathfinding-results-with-terrain-a">7.1. Pathfinding results with terrain ‘‘A’’</span></h3><p>与其他地形的测试结果相比，虚拟地形 A 的计算路径成本（以计算出的路径长度以及沿该路径的浮雕倾斜成本来衡量）在所有测试算法中差异最大。即便如此，随着路径距离的增加，返回路径成本曲线的增量也略有不同。由于地形 A 的浮雕倾斜度大多在 0 o 到 10 o 之间（对目标智能体来说是微妙的地形特征），而算法考虑的浮雕倾斜度从 5 o 开始，因此成本结果大多反映了每种算法返回的路径长度。这个地形 A 也与其他地形不同：它代表了一个经过预处理的不规则群集级网格（图 11b）。也就是说，当一个节点的维度大于集群网格节点时（相对于集群定义的层级，该节点在层级上高一级），该节点就会成为一个集群，从而形成抽象层级路径搜索的不规则网格。与其他地形相比，地形 A 中的一些簇在 QuadTree 层次结构中处于较高的层次，从而扩大了这些簇的维度（鉴于 QuadTree 的性质，该簇将比系统中定义的传统簇大四倍）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231548968.png" alt="image-20240123154853980"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231549445.png" alt="image-20240123154929405"></p>
<p>在地形 A 中，与其他算法相比，HPATheta* 算法的路径成本最低。除此基本算法外，还有 HPT* 算法获得的路径成本，该算法是基本方法的一个版本，不处理虚拟地形的地形特征。由于 HPATheta* 算法和 HPT* 算法的寻路结果相差无几，而且与其他算法相比，HPATheta* 算法的路径成本最低，因此很明显，在图 11（a）所示的阻塞节点较少、地形倾斜度较小（绝大多数在 0 o 至 10 o 范围内）的地形中，具有路径平滑功能的分层搜索算法可以获得更好的路径成本结果。这是因为 HPATheta* 方法很容易找到平滑路径。这种平滑也仅限于计算出的地形群的极限，避免了很长的平滑距离。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231550552.png" alt="image-20240123155038580"></p>
<p>当 HPATheta* 算法与分层 A* 算法（如带浮雕倾斜的 OHPA* 算法和标准 OHPA* 算法）进行比较时，得出的路径成本差异较大。与基本方法相比，带浮雕倾斜的 OHPA* 算法的路径成本增加了 1.3462 个单位。另一方面，OHPA* 算法的路径成本增加了约 1.3554 个单位。这表明，尽管处理地形特征会导致路径成本增加，但所选算法对最终路径结果有很大影响。当处理的地形没有大的阻塞区域和地形起伏相当平缓时，这种影响更大，这也导致虚拟地形的分层表示结构（在我们的工作中为 QuadTree）的精细度降低（图 11a）。使用 OHPA* 方法时，在地形簇内部执行的 A* 算法考虑了从当前节点到其近邻节点的路径规划，有时会导致路径中出现不必要的曲线和偏差（例如之字形行为）。当采用带地形坡度的 OHPA* 时，对每个地形群执行带地形坡度的 A* 时，会偏离坡度在相关范围内的区域。因此，虽然由于地形起伏而降低了成本，但却增加了路径长度方面的成本。如果不考虑浮雕倾斜造成的成本计算，那么不带浮雕倾斜的 OHPA* 版本即使寻求尽可能短的路径，也会导致较高的地形成本。因此，使用促进路径平滑的算法是有意义的，因为它能使得到的路径更加真实，避免可能增加最终路径距离的微小而不必要的路径偏差。</p>
<p>比较 Theta* 算法的分层版本和非分层版本，分层版本在搜索过程的计算时间和所产生的路径成本方面都具有优势。带有浮雕倾斜度的 Theta* 算法比基本方法高出 1.29 个成本单位，这表明在地形群层面限制路径平滑可能有利于搜索。在不使用测试过的分层技术的情况下，该算法对地图进行整体探索，能够平滑长距离路径。不过，在某些情况下，这种较大的平滑可能会忽略与最终路径相关的偏差。反过来，与 HPATheta* 基本方法相比，不带浮雕倾斜的 Theta* 算法会使生成路径的成本增加 1.38 个单位。这是因为 Theta* 可以在不考虑地形特征的情况下平滑长距离路径。它只将路径障碍物视为一些障碍因素。它还能找到更直接的路径，即距离更短的路径，因为它寻求的是最短最平滑的路径。不过，与其他测试算法相比，不考虑地形倾斜度的 Theta* 算法得到的路径成本要高得多。在对考虑和不考虑地形信息的非层次算法版本进行观察时，与其他技术相比，比较其考虑和不考虑地形信息的版本，所获得的成本值之间的差异更大。从 HPATheta* 算法到 HPT* 算法的成本增加约为 1.4%（路径增加 1.0138 个成本单位），而从带浮雕倾斜的 Theta* 算法到标准 Theta* 算法的成本增加约为 7%（途中增加 1.0694 个成本单位）。</p>
<p>在执行时间方面，OHPA* 算法的表现优于其他测试算法，这一点可以从报告结果中观察到。如果将 A* 算法与分层算法一起研究，它们的表现会更加令人满意，因为它们能获得更好的性能。与基本方法相比，OHPA* 算法的执行时间非常接近，但比其他算法快约 80%。不过，OHPA* 算法并没有将平滑路径作为其优势之一，这也是本研究要解决的一个重要方面。考虑到所提出的 HPATheta* 算法能满足在 1 秒内给出路径结果的时间限制（如本节开头所述），虽然它不是所有测试算法中速度最快的，但在响应时间和返回路径质量方面都能满足要求。这表明，使用分层方法进行地形表示和寻路是缩短路径搜索执行时间的根本。在这种情况下，标准 Theta* 算法的执行速度是基础方法的 9.15 倍。在 Theta* 算法中加入对地形地貌的处理，执行时间比 HPATheta* 算法慢 14.39 倍。</p>
<h3><span id="72-pathfinding-results-with-terrain-b">7.2. Pathfinding results with terrain ‘‘B’’</span></h3><p>虚拟地形 B 在地形起伏不平方面非常复杂，约有 34.73% 的节点被遮挡，占虚拟地形总面积的 19.81%。由于地形起伏高度的变化，QuadTree 的细化程度更高，因此分层表示法的叶节点更小。在约 30 km × 30 km 的尺寸范围内，总共有 773 440 个法线矢量值来捕捉地形的倾斜度。其中，73.81% 属于与目标智能体相关的倾斜范围（介于 5° 和 35°  之间）。与地形 A 不同的是，该地形在群集层面上具有规则的网格结构（即节点代表具有相同尺寸的地形区域）。这是因为在构建 QuadTree 时使用了高度细化，因此节点较小。这意味着没有必要因为节点过大而扩展这种地形集群级别（如第 4 节所述）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231553971.png" alt="image-20240123155330863"></p>
<p>在地形 B 中，我们注意到测试算法得出的路径成本相对接近（图 14A）。这一结果与该地形结构中受阻节点的数量有关。该地形除了起伏高度变化大（导致地形表示节点受阻的一个因素）外，还有许多河流，这也是在表示结构中阻塞节点的一个因素。在某些地形群中，这些障碍物形成了有限的通航路径。例如，请看图 13 中以深色线段表示的河流之间的路径（在地形图的放大部分可以很容易地观察到）。虽然寻路结果彼此接近，但它们之间存在显著的统计差异。</p>
<p>在地形 B 的测试中，与其他算法相比，HPATheta* 算法的路径成本也是最低的。紧随其后的是 HPT* 算法，如统计模型所示，多出约 1.012 个成本单位。由于地形表示结构中的阻塞节点导致搜索空间有限，因此这些算法最终返回的路径彼此接近。尽管 HPATheta* 算法和 HPT* 算法得出的路径差别很小，但 HPATheta* 算法得出的路径成本更高。</p>
<p>由于使用分层 Theta* 算法得出的结果很相似，因此下一个得出较好路径成本的算法是带浮雕倾斜的 Theta<em>。与建议的基本方法相比，带浮雕倾斜的 Theta</em> 算法的路径成本增加了约 1.064 个单位。这是因为带浮雕倾斜的 Theta* 并没有将搜索空间限制在属于抽象路径的地形集群区域。因此，路径平滑可以通过不同的方式、不同的延伸、不同的路径点或延伸段进行，从而影响最终的路径结果。例如，在使用分层技术时，每个地形群的边界、入口和出口节点都必须是生成路径的一部分。这就限制了通过这些地图点进行路径平滑的可能性。这一事实也解释了为什么该算法没有获得比 HPT* 更优的路径成本（如最初预期的那样），因为 HPT* 也采用了分层策略，将搜索空间限制在由抽象路径扩展的地形簇内。反过来，标准 Theta* 算法在不考虑地形特征的情况下，与其他算法相比显示出更高的路径成本增加，大约增加了 1.117 个路径成本单位。当然，由于路径平滑中使用的视线技术只评估路径是否受阻，而不考虑平滑计算中的地形倾斜度，因此得出的路径成本要高于有地形倾斜度的 Theta* 算法。不过，分层 Theta* 版本，即 HPT* 与 Theta* 和带浮雕倾斜的 Theta* 版本相比，路径成本仍然相对较低。同样，从搜索空间的大小可以看出，尽管 HPT* 算法是一种分层算法，但它在搜索空间中也有局限性。总之，标准 Theta* 算法将地形图作为一个整体来探索，能够在不考虑地形信息的情况下平滑较大的地形区域，从而导致生成路径的路径成本较高。</p>
<p>与本文提出的基本方法相比，OHPA* 算法的路径成本也更高。虽然它们的搜索空间也仅限于地形集群节点，但这些算法并不进行路径平滑。因此，它们组成的节点-节点路径，其最终路径长度也会影响路径成本。在这种情况下，与拟议的 HPATheta* 相比，带有地形倾斜度的 OHPA* 所产生的路径成本增加了约 1.089 个单位。反过来，与基本方法相比，不带浮雕倾斜的 OHPA* 所产生的路径成本增加了约 1.104 个单位。如前所述，该算法寻求的是最短路径，但它没有考虑地形起伏信息。</p>
<p>在执行时间方面，拟议的 HPATheta* 算法落后于 OHPA* 算法（包含和不包含地形起伏倾斜度）和 HPT* 算法。这一结果在意料之中，因为 HPATheta* 算法不仅能计算由地形起伏产生的路径成本，还能在执行搜索时平滑路径。在地形 B 中，可以观察到长距离路径计算时间的增加远高于前面讨论过的地形 A 中类似路径计算时间的增加。增加的原因在于搜索过程中探索的节点数量，因为地形 B 的复杂性更高，因此分层表示结构的细化程度也更高。因此，响应时间与这些地形表示结构中已探索节点的数量成正比。不过，HPATheta* 算法即使在虚拟地形 B 中涉及较大距离的路径，也能在不到 1 秒的时间内返回路径结果。</p>
<p>与 HPT* 算法相比，HPATheta* 所需的计算时间延长了约 6.8%。至于两种版本的 OHPA* 算法（处理地形信息和不处理地形信息），基本算法的响应时间大约长 7 倍。需要强调的是，与标准的逐节点路径搜索相比，路径平滑执行过程需要额外的计算时间。如果考虑到浮雕倾斜信息，路径搜索过程就会变得相对耗时，从而导致响应时间比不执行平滑的有浮雕倾斜和无浮雕倾斜的 OHPA* 更长。不过，在计算寻路过程中考虑地形起伏信息进行平滑处理，比执行标准搜索，然后在平滑处理过程中执行考虑地形起伏倾角的后处理算法要好。考虑到所获得的计算时间值很低（路径距离为 20 千米时约为 50 毫秒），而且彼此非常接近，因此差异并不显著。</p>
<p>在地形 B 中，路径搜索中使用分层技术的重要性再次凸显。标准 Theta* 算法的执行时间比建议的基本方法多出约 3.61 毫秒。当使用带浮雕倾斜的 Theta* 算法时，执行时间比 HPATheta* 基本方法多出约 6.31 毫秒。</p>
<h3><span id="73-pathfinding-results-with-terrain-c">7.3. Pathfinding results with terrain ‘‘C’’</span></h3><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231558370.png" alt="image-20240123155817383"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231558931.png"></p>
<p>与其他地形相比，虚拟地形 C 有更多的节点被阻塞（40% 的叶节点被阻塞，占地图总面积的 21.82%）。在使用的三个虚拟地形中，地形 C 的地形不平整度较低。总体而言，该地形的山脉较少，而且位于地图中心区域，高度也不高。这与地形 A 不同，地形 A 的不平整区域位于地形边缘。地形 C 还有大量的湖泊和河流，因此在其虚拟表示中会产生阻塞节点。地形 C 的尺寸约为 33 km × 62 km，其结构中共有 676 300 个法线矢量，反映了地形的起伏倾斜。其中，24.59%的地形处于与目标智能体相关的地形倾斜范围内（5◦至 35◦）。</p>
<p>由于许多节点被河流和湖泊阻挡，地形 C 的搜索空间也很有限，甚至比地形 B 更有限。图 15 中突出显示了地形 C 的一部分，以说明在因河流而受阻的节点之间狭窄的自由空间中寻找路径的情况。尽管在地形 C 中观察到的算法之间的差异很小，但 HPATheta* 方法显示出了最佳的路径成本。不考虑地形特征的 HPT* 算法的结果排在第二位，与基本方法相比，路径成本增加了 1.017 个单位。鉴于地形 C 有许多阻塞节点和轻微的地形倾斜，搜索结果有一定的就近路径倾向，特别是在使用类似性质的算法时。与基本方法相比，OHPA* 算法的路径成本增加了约 1.065 个单位。这再次表明，由于 HPATheta* 和 HPT* 对分层技术的探索，路径平滑对最终路径成本的影响。如前所述，在具有微妙地形倾角的虚拟地形中，返回路径之间的差异主要是由于路径搜索算法所使用的技术而非地形倾角信息本身造成的。在分析分层算法的结果时，路径搜索结果的这种相似性更加明显，因为这些算法将搜索空间限制在所产生的抽象路径所选择的地形群上。然而，对于在搜索过程中无限制地探索虚拟地形图（无集群限制）的算法，在寻路结果中观察到了更大的差异。与基本方法相比，带浮雕倾斜的 Theta* 算法增加了约 1.030 个路径成本单位，而标准 Theta* 算法则增加了约 1.100 个路径成本单位；与不带浮雕倾斜的Theta* 算法相比，带浮雕倾斜的 Theta* 算法的路径成本增加了约 6.7%，这是测试的性质相似的算法之间观察到的最大差异。如前所述，自由探索虚拟地形图，不局限于某些地形集群区域，可使最终寻路结果产生更大差异。然而，在大规模虚拟地形中，使用分层搜索技术对于提高寻路的执行时间是至关重要的。</p>
<p>正如在其他测试过的虚拟地形中已经看到的那样，OHPA* 算法在有地形特征处理和无地形特征处理的版本中，执行时间比其他算法短得多。在这种情况下，基本算法（HPATheta* ）比两个版本的 OHPA* 算法（带浮雕倾斜和不带浮雕倾斜）慢约 7 倍。与 HPT* 算法相比，HPATheta* 算法的执行时间更长，这在意料之中，也在情理之中，因为该算法计算的是与地形起伏倾斜度相关的路径成本。需要指出的是，在 HPT* 算法的路径规划中，并没有考虑计算地形起伏倾斜度成本的步骤。执行时间最长的算法是处理地形信息的 Theta* ，与基本方法相比，响应时间约为 5.155 毫秒。最后，与拟议的 HPATheta* 算法相比，标准 Theta* 算法的响应时间增加了约 3.346 毫秒。</p>
<h3><span id="74-discussion">7.4. Discussion</span></h3><p>为了扩大对本研究实验结果的评估范围，可以对以下几个方面进行分析：(i) 在所有地形中进行的测试结果，(ii) 本文所研究建议的分层寻路特性，(iii) 建议算法的效率和 (iv) 精度。</p>
<h4><span id="741-cross-analysis-of-the-pathfinding-results-with-the-real-world-terrain">7.4.1. Cross analysis of the pathfinding results with the real-world terrain</span></h4><p>通过这三种不同的测试场景，我们可以发现每种地形的特殊性是如何影响每种测试算法的寻路结果的。地形 B 和地形 C 在地形细化程度和地形阻塞方面有相似之处，其结果在路径成本和执行时间方面也有一定的相似性（成本方面分别为图 14A 和图 16A，计算时间方面分别为图 14B 和图 16B）。这两种地形结构都有很大的细化，生成的节点越来越小，越来越大（其中许多节点被阻塞，根据所代表河流的走向形成 “小巷”）。此外，地形 B 和地形 C 的网格簇以规则布局的形式表示，与 QuadTree 处于同一级别（即第 5 级）。根据测试算法得出的最佳路径成本，B 地形和 C 地形的结果相当，但在执行时间方面存在差异。</p>
<p>地形 A 的路径成本与其他地形的结果不同（图 12A）。地形 A 的路径成本值与路径距离值一致。正如之前所讨论的，这是因为地形 A 与地形 B 和地形 C 不同，地形 A 有少量陡峭的浮雕倾斜（接近 35◦），并且由于地形特征，结构细化很少。这些结果还表明，分层平滑算法返回的路径成本较低。由于地形 A 的细化程度不高，也就是说，节点在表示结构中捕捉到的地形面积较大，此外还有细微的浮雕倾斜（绝大多数在 0 o 和 10 o 之间），因此路径平滑对结果路径的低成本起着根本性的作用。就每种算法在使用地形 A 时获得的最佳路径成本而言，它们的效率排序与使用其他地形进行测试时观察到的结果相同。这一寻路结果在所有测试场景中都是相同的。在性能方面，一般来说，与在其他地形下进行的测试相比，在地形 A 下执行的算法所需的处理时间要短得多（图 12B）。例如，对于 27 千米的距离，拟议的 HPATheta* 算法需要约 16 毫秒才能返回路径。在这种情况下，最耗时的算法是处理了地形特征的 Theta*。对于 27 公里的路程，该算法的执行时间约为 240 毫秒。在考虑这些长距离时，使用分层搜索方法的相关性再次凸显出来，从而提高了测试路径规划算法的性能。</p>
<p>如前所述，在地形 B 和 C 中，与测试算法返回的路径成本相关的效率顺序是相等的。不过，在使用不同算法时，路径计算时间的效率顺序存在差异（分别见图 14B 和图 16B）。在地形 C 中，与标准版本相比，带浮雕倾斜的 OHPA* 算法的执行时间更长。这是意料之中的，因为该算法采用了额外的成本计算步骤来计算地形起伏特征。在地形 B 中，观察到了相反的情况：基于地形的路径搜索算法与其标准版本相比，执行时间更短。不过，这一差异太小，小于 0.1 毫秒，因此不能视为相关。</p>
<p>与其他地形相比，在地形 C 中搜索相同距离路径所需的计算时间较长（图 16B）。在地形 C 中，拟议的 HPATheta* 算法搜索 27 千米距离的执行时间约为 200 毫秒，而在地形 B 中，相同距离的搜索时间约为 130 毫秒。</p>
<p>与地形 A 相比，地形 B 和地形 C 的搜索时间更长，这是意料之中的合理结果，因为这两个地形使用的表示结构更加精细。由于 B 和 C 地形更加复杂，搜索过程中需要探索的节点更多，这与路径规划算法的执行时间直接相关。在这些情况下，对地形特征进行处理的 Theta* 算法在所有情况下都获得了最长的计算时间，对 B 和 C 地形的响应时间分别达到约 820 毫秒和 1117 毫秒。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401231602967.png" alt="image-20240123160206946"></p>
<h4><span id="742-analysis-of-the-hierarchical-pathfinding-characteristics">7.4.2. Analysis of the hierarchical pathfinding characteristics</span></h4><p>实验中使用的寻路算法的选择基于以下问题： (i) 平滑化，因此选择了标准版本的 Theta* 算法，并对其进行了调整，以处理地形路径成本和加权视线的计算；(ii) 层次化，这也是选择 HPA* 算法（在本研究中使用 OHPA* 在线版本）和 HPT* 算法的原因–比较它们在应用地形路径成本和不应用地形路径成本时的性能–因为导航结构被划分为群组，所以它们可以处理较大的搜索空间。这项工作是对 Brondani 等人（2019）所做工作的扩展，其动机是 SIS-ASTROS 项目（SISASTROS，2014 年）正在开发的虚拟战术模拟系统的相同路径规划需求。虽然其他算法也能探索分层和平滑的路径规划，例如 N 层子目标图（Uras &amp; Koenig, 2014）和跳点搜索（JPS）（Harabor &amp; Grastien, 2011），但我们实验中使用的算法能更好地探索 SIS-ASTROS 模拟系统中已经实现的分层和不规则地形表示结构。</p>
<p>实验结果表明，使用分层方法进行路径规划对于获得更好的搜索性能非常重要。正如本文前面所讨论的，搜索空间仅限于 “抽象路径 “所发现的簇的维度，从而引导搜索并减少搜索 “具体路径 “时所探索的节点数量。实际上，具体路径是通过对表征结构更高层次的细化分析得到的。从实验结果中可以看出，在地形 A（地形复杂度较低）中，建议的算法（HPATheta<em>）计算出一条距离约为 27 千米的路径大约需要 16 毫秒，而不使用层次结构的算法（Theta</em>，带浮雕倾斜度）计算出一条通往同一对来源点和目的地点的路径则需要 240 毫秒。而 HPT* 算法在相同地形上的相同距离则需要约 17 毫秒，而其不使用层次细化的版本，即不使用浮雕倾斜的 Theta* 算法则需要 150 毫秒。在地形 B 中，层次结构的相关性也很明显，这主要是因为该地形的浮雕复杂度更高。要找到一条距离为 27 千米的路径，HPATheta* 算法大约需要 137 毫秒，而有浮雕倾斜的 Theta* 算法只需 896 毫秒就能返回一条路径。HPT* 算法及其非层次化版本，即不带地形倾斜的 Theta* 算法的执行时间分别约为 129 毫秒和 505 毫秒。在地形更为复杂的地形 C 中，HPATheta* 算法在 27 千米距离内的执行时间约为 200 毫秒，而带浮雕倾斜的 Theta* 算法在相同距离内寻找路径的执行时间约为 1,117 毫秒。此外，在相同距离上，不带浮雕倾斜的 HPT* 算法和 Theta* 算法的执行时间分别约为 200 毫秒和 725 毫秒。</p>
<p>正如第 3.1 节所分析的，使用分层方法的寻路算法与非分层方法的寻路算法相比，性能提升是显而易见的，尤其是在应用于大规模搜索空间时。地形信息的预处理也是有助于实现上述结果的一个方面。正如在 HPA* （Botea 等人，2004 年）中介绍的那样，在不使用层次结构的情况下比较 HPA*  和 A* 算法，寻路性能的提高是显而易见的，尤其是在大型搜索空间和具有许多特征的地形中。不使用层次结构的寻路算法可能比使用该技术的算法稍好的情况是，搜索问题非常简单，通常涉及源点和目标点之间非常小的距离。然而，在模拟大型地形时，有必要处理较难处理的情况，包括在不超过进行模拟所需的时间限制的情况下穿越地图的长度。</p>
<h4><span id="743-efficiency-analysis">7.4.3. Efficiency analysis</span></h4><p>为了证明寻路算法的效率，该算法必须达到预期目的，即以较低的成本获得结果路径，并在预定范围内提供执行时间。可以看出，所提出的算法在这些标准之间进行了相关的权衡：得到的路径成本和执行时间。在许多情况下，这两个方面是相互冲突的，因为要评估这些限制条件下的计算成本，就必须包含额外的路径搜索程序，这可能会增加执行时间。在所进行的实验中，根据第 7 节中介绍的实验方案，对所选算法的这些指标进行了收集和比较。低成本、平滑的路径可避免 “之 “字形行为，这对于开发算法的仿真系统以及许多需要进行此类地形计算的应用来说非常重要。此外，相对较短的执行时间也很重要，尤其是在仿真环境中，这一点将在第 7 节中说明。虽然实验结果并不表明所提出的算法（HPATheta* ）是所有测试算法中速度最快的算法，但就路径成本（这是实现本研究目标的关键因素）而言，该算法在所有测试地形中与其他算法相比取得了最好的结果。此外，即使是长距离路线，HPATheta*  算法的执行时间也低于规定的时间限制，从而保证了用户在模拟中的沉浸感（见第 7 节）。这表明 HPATheta* 算法即使在大规模地形中使用，也能在仿真时间限制内运行，从而实现了其目的。</p>
<h4><span id="744-accuracy-analysis">7.4.4. Accuracy analysis</span></h4><p>为了评估寻路算法的准确性，我们需要评估返回路径的成本。我们的目标是最大限度地降低成本，因为成本越低，地形倾斜度越小。然而，一条能避开所有陡峭地形坡度的路径可能会变得非常曲折。为了在模拟上实现更真实的智能体运动（避免 “之 “字形的智能体行为），建议算法的目标是为平滑的路径获取更低的成本。这意味着 HPATheta* 算法获得的最终路径成本并不会导致浮雕倾斜成本之和的最小值。实际上，该算法返回的是避免这种不理想之字形的最小倾斜成本总和。</p>
<p>带浮雕倾斜的 A* 算法返回的路径成本最优。不过，这种算法往往会产生蜿蜒曲折的路径。通过比较 HPATheta* 算法与带浮雕倾斜度的 A* 算法的路径成本，可以发现 HPATheta* 算法的路径成本非常接近最优成本。根据寻路算法所适用的地形配置，平滑也能有效降低路径成本。比较在地形 A 中获得的成本值，所提出的算法比带有浮雕倾斜度的 A* 算法成本更低，这是与目标相关的结果。这一结果与在地形表示和搜索过程中使用分层和不规则结构的方式有关。尽管取得了这一积极成果，但在测试中考虑地形 B 和 C 时，结果却不尽相同。这是因为在模拟这些真实世界地形的各种特征时，所使用的表示结构略有细化。</p>
<p>当所使用的地形中只有很少的地形特征可供模拟使用时，就会在表示结构中使用较大的节点（有些节点甚至有一个集群的大小）。这些节点最终代表了智能体移动时需要覆盖的大片地形。从这个意义上说，在计算路径时访问这些节点中心的具有浮雕倾斜度的 A* 的行为会导致不必要的之字形路线，从而增加智能体路线的最终成本。实际上，与平滑后的路径相比，它们最终要走更长的距离。在使用地形 A 时，这种影响会更大，因为地形 A 在 0 o 和 10 o 之间有轻微的起伏倾斜。在这种倾斜情况下，平滑过程并不会给生成的路径增加多少成本，这意味着最终成本要低于忠实地偏离这些倾斜的路径的成本，尽管要走更长的距离。根据丹尼尔等人（2010 年）的研究，如果考虑到路径的长度，Theta* 算法在网格上找到的路径比 A* 算法更短。根据该研究中的实验，99% 的情况下 Theta* 算法比 A* 算法在网格上获得的路径最小。在具有微妙地形倾斜和大型表示节点的地形中，最终成本主要表示的是行进距离，而不是地形倾斜造成的成本。对于这种地形 A，拟议算法的最终成本比 A* 算法加上地形起伏处理后的路径成本低 16%。</p>
<p>对于地形 B 和 C，由于其复杂性更高，特别是与所考虑的智能体相关的大量河流和浮雕倾斜度，它们的分层和不规则表示结构表现出更高的精细度，带有浮雕倾斜度的 A* 算法通过彻底偏离倾斜度返回最佳成本。在这种情况下，这些地形表示结构的节点并不大。因此，路径上的浮雕倾斜度对路径成本的影响相对于行驶距离而言会变得更大（这与地形 A 不同）。尽管如此，HPATheta* 算法与带有浮雕倾斜度的 A* 算法相比，成本变化较小，后者能返回最优路径成本。对于地形 B，HPATheta* 算法产生的路径成本增加了 6%。对于地形 C，则增加了约 7.5%。总之，建议的算法提出的路径成本接近于返回最优成本的算法。这样，它还避免了 “之 “字形行为，此外，与带有浮雕倾斜度的 A* 算法相比，运行时间也短得多。根据第 7.1-7.3 节的分析，与实验中测试的其他算法相比，该算法得出的路径成本最低。这也是路径质量的相关指标。</p>
<h2><span id="8-final-remarks">8. Final remarks</span></h2><p>这项工作提出了一种寻路算法，用于处理基于真实世界地图构建的虚拟地形浮雕中的不平整问题，地形特征的处理反映在寻路的计算成本上。研究结果表明，在同一区域，相同的路径距离间隔，HPATheta* 算法的成本更低。</p>
<p>值得注意的是，这项研究解决了在不平坦的地形中搜索路径的问题，旨在促进插入大规模模拟虚拟环境中的不同类型智能体的安全移动。此外，该作品还介绍了如何使生成的路径更加逼真，这是以教育为目的的仿真系统的一个基本特征。这项研究通过对生成路径的平滑算法进行探索来实现。为此，路径计算使用了视线的概念，并对其进行了适当修改，以处理地形的浮雕倾斜。实际上，使用视线来处理涉及地形起伏倾斜的智能体移动限制信息，是一种在文献中仍未得到充分探讨的方法。尤其是在寻路过程中仅使用受阻节点信息时（通常在此过程中转换为路径权重），情况更是如此。此外，所提出的算法采用了分层搜索技术，将地形节点之间的路径预处理与虚拟地形表示结构的层次结构结合起来使用。这种技术优化了计算的执行时间。</p>
<p>针对提出的问题，通过与文献中的其他建议进行比较测试，对提出的路径规划解决方案进行了评估。通过这些测试，我们可以评估不同方案的优缺点，例如使用分层方法（OHPA* 和 HPT* ）所带来的性能提升，以及使用路径平滑技术（Theta*  和 HPT* ）的益处。通过所进行的实验，可以观察到 HPATheta* 算法成功地将不同寻路和地形表示技术的优势与使用和计算与目标智能体相关的地形特征信息结合在一起。研究还发现，无论模拟地形的复杂程度如何，提议的算法都能返回更高质量的路径。这意味着尽可能提供低成本的路径，包括浮雕倾斜度和覆盖距离，以及平滑路径。在性能方面，HPATheta* 算法也达到了 SIS-ASTROS 项目的研发预期。尽管在所有已执行的路径规划实验中，HPATheta* 算法的执行时间都不是最短的，但却接近最佳结果时间。在那些不是最佳时间的实验中，即使计算长路径距离（即大搜索空间），它也能满足所有实验中小于 1 秒的响应时间要求。</p>
<p>在未来的工作中，我们可以设想一种更加通用的方法，用于新型虚拟仿真的路径规划。这不仅是 SIS-ASTROS 项目的新发展，也是其他模拟培训和教学环境的新发展。由于这项工作仅限于有静态障碍物的场景，今后的工作可以扩展所提出的算法，以处理移动障碍物。尽管如此，仍有可能扩展本文讨论的分层和平滑技术，开发出一系列具有相似性的算法。这类算法将处理不同的现实智能体约束，更适合特定类型的大规模真实世界虚拟地形环境。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-23T00:41:30.000Z" title="2024/1/23 08:41:30">2024-01-23</time>发表</span><span class="level-item"><time dateTime="2024-01-23T06:30:24.826Z" title="2024/1/23 14:30:24">2024-01-23</time>更新</span><span class="level-item">39 分钟读完 (大约5903个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/23/Improved-Heuristics-for-Optimal-Pathfinding-on-Game-Maps/">Improved Heuristics for Optimal Pathfinding on Game Maps</a></p><div class="content"><h1><span id="improved-heuristics-for-optimal-pathfinding-on-game-maps">Improved Heuristics for Optimal Pathfinding on Game Maps</span></h1><h2><span id="abstract">Abstract</span></h2><p>随着计算机游戏世界变得越来越复杂，寻路性能瓶颈也变得越来越明显。通常用于指导基于 A∗ 的寻路的启发式函数过于简单，无法在如此复杂的大型游戏世界中为搜索提供必要的指导。这可能会导致 A∗ 搜索为了在两个遥远的地点之间找到一条路径而探索整个游戏地图。<br>本文提出了两种有效的启发式方法，用于估算大型复杂游戏地图中不同地点之间的距离。前一种启发式，即死胡同启发式，可以从搜索地图中剔除与当前查询无关的区域，而第二种启发式则使用所谓的网关来改进其估计值。在实际游戏地图上进行的经验评估表明，与标准的八分距离度量法相比，这两种启发式方法都能显著降低 A∗ 搜索的探索复杂度和时间复杂度。</p>
<h2><span id="introduction">Introduction</span></h2><p>现代计算机游戏世界的规模和复杂程度逐年增加，这既体现在地图的大小上，也体现在世界中存在的单位数量上。例如，在即时战略（RTS）游戏中，可能有数百个单位同时在世界中航行。为所有这些单位实时计算路径对计算要求很高，可能会消耗掉为游戏逻辑预留的大部分可用 CPU 资源。在 RTS 游戏中，寻路查询还用于回答计算机控制的人工智能提出的各种战略问题（例如，距离特定资源有多远，或敌人可以从哪里发动攻击）。因此，在现代游戏中，使用高效（并经过仔细实施）的算法进行寻路计算至关重要。A∗ 算法（Hart、Nilsson 和 Raphael，1968 年）是游戏寻路事实上的行业标准。虽然不同游戏的状态空间表示可能不同（网格或网状都很常见），但 A∗ 搜索或其变体通常是首选算法。通常使用简单有效的启发式来指导搜索。例如，在基于网格的地图中，通常使用八分距离（曼哈顿距离的扩展，允许对角线移动）。然而，随着游戏地图变得越来越大、越来越复杂，这种简单的启发式方法无法提供足够有针对性的指导，导致在两个遥远的地图位置之间寻找最短路径时，搜索经常会探索几乎整个地图。</p>
<p>克服这一问题的一种技术是分层寻路。这种方法不是只使用单一的状态空间表示法，而是同时使用更高层次的抽象表示法。层级结构中的每一级都会使用越来越抽象的游戏地图视图，随后可以使用更小的状态空间来表示。在回答寻路查询时，会在其中一个高层中找到近似路径（然后可能会在基础层中使用小范围局部搜索进行细化）。由于 A∗ 搜索的状态空间更小，因此处理速度更快。这种方法的主要缺点是返回的路径不一定是最优的。这是因为在抽象过程中，通常会丢失地图的一些细节。不过，如果路径只是略微次优，这通常对游戏性影响不大。幸运的是，大多数情况下都是如此。然而，随着地图上单位和其他动态障碍物数量的增加，路径变得严重次优的风险也会增加。这是因为在抽象状态空间中进行的搜索通常不会（也无法）考虑这些动态障碍。</p>
<p>我们在本文中提出的方法在减少状态空间探索的同时，还能考虑动态障碍。我们不是利用状态空间抽象来创建分层视图，而是利用它来提供改进的启发式函数，以指导常规 A∗ 搜索。我们面临的挑战是&#x3D;&#x3D;如何设计出既能高效计算，又能大大改进搜索引导的启发式方法。&#x3D;&#x3D;我们引入了两种这样的新启发式，它们都是可容许的，因此保持了最优性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230847336.png" alt="image-20240123084710488"></p>
<p>本文的主要贡献有</p>
<ol>
<li>改进了用于指导（游戏）地图寻路搜索的可接受启发式方法–我们在实际游戏地图上的实验表明，使用新启发式方法进行的 A∗ 搜索，无论从节点扩展还是从总搜索时间来看，都大大优于标准的八邻域距离启发式方法；</li>
</ol>
<p>&#x3D;&#x3D;2) 一种将游戏地图自动分解成较小区域的算法方法；该方法不仅有助于为我们的新启发式方法创建抽象视图，还有助于创建一般的分层寻路技术。&#x3D;&#x3D;</p>
<p>下一节我们将介绍新的启发式函数，并提供详细示例和伪代码。下一节将介绍自动地图分解，随后将总结利用真实游戏地图对启发式方法进行广泛实证评估的结果。最后，我们总结并讨论了未来的研究方向。</p>
<h2><span id="improved-heuristics">Improved Heuristics</span></h2><p>图 1 中的地图描绘了一个典型的角色扮演游戏室内场景。这个世界由多个房间组成，房间之间通过门和走廊相连。最先进的游戏地图一般会更大更复杂，但为了便于演示，我们将使用图中的地图。</p>
<p>在地图上寻找两个遥远地点之间的最短路径时，&#x3D;&#x3D;基于八英里距离的天真启发式会或多或少地探索地图上的所有地点。这部分是由于它无法事先知道是否存在一条穿过任何给定房间的路径，可以通往到达所需目的地的捷径。&#x3D;&#x3D;为了更好地说明这一点，我们在地图上用深灰色标出了 A∗ 使用八分启发式在相距较远的两个地点之间寻找最优路径时探索到的所有地砖。最佳路径以深灰色显示，起点在左边，目标在右边。该算法花费了大量精力探索那些我们一眼就能看出不可能相关的区域，因为这些区域要么是死胡同，要么是明显劣质的路径。</p>
<p>本文提出的两种启发式方法的理念是通过事先识别并排除两个给定地点之间不可能在最佳路径上的所有区域（在我们的例子中是房间）来缓解这一问题。前者，即死胡同启发式，避免了通往死胡同的区域，而后者，即网关启发式，则更进一步，认识到穿过某些房间只能通往次优路径。接下来的两个小节将分别介绍死胡同启发式和网关启发式。启发式计算分为两个阶段。第一阶段是对地图进行预处理并创建抽象视图。&#x3D;&#x3D;具体方法是自动将地图分解成较小的区域，然后计算路径信息。这种计算是离线完成的，每张地图只需计算一次。&#x3D;&#x3D;在第二阶段，来自预处理阶段的抽象视图被用来为寻路搜索得出改进的启发式估计值。启发式是实时计算的，因此效率非常重要。</p>
<h3><span id="dead-end-heuristic">Dead-End Heuristic</span></h3><p>死胡同启发式可以立即判断出搜索是否进入了一个最终通向死胡同的房间，也就是说，从这个房间没有通向目标的路径（除了从我们进来时的入口出去）。显然，我们没有必要探索这样的房间。</p>
<p>预处理阶段 &#x3D;&#x3D;预处理阶段分为两个步骤&#x3D;&#x3D;。第一步，将游戏地图分解成几个较小的区域，在本例中代表房间和走廊。在此地图上运行分解算法的结果如图 2 左侧所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230851584.png" alt="image-20240123085136043"></p>
<p>这一阶段的第二步是构建一个高级图，用于表示不同的区域和它们之间的相互联系。图中的节点代表一个区域，节点之间的边代表两个相应区域之间的入口。请注意，连接同一两个房间的入口可能不止一个，因此图中连接一对节点的边也可能不止一条。因此，该图是一个所谓的无向多图。该图与区域信息一起存储在游戏地图中。</p>
<p>运行阶段 当地图加载到游戏中时，预处理阶段的数据也会随地图一起加载。这确实会导致一些额外的内存使用，但只要仔细实施，就能将内存使用量降到最低。</p>
<p>当我们收到寻路查询，要求找出起点和目标位置之间的最短路径时，会进行两次搜索。首先是在多图中进行搜索，以确定地图中与查询相关的区域子集；其他区域，即所谓的死胡同区域，可以完全排除在寻路搜索之外。让多图中的节点 S 和 G 分别代表地图中的起点和目标位置区域。我们在多图中搜索从节点 S 到节点 G 的所有可能路径，以确定相关区域。需要注意的是，在搜索过程中，我们需要标记所有已经访问过的边，以防止出现循环和其他重复搜索工作。事实证明，简单的深度优先搜索在这项任务中最为有效，这是因为多图非常小，而且我们必须找到所有可能的路径。</p>
<p>一旦我们确定了相关区域的子集，就会执行类似 A∗ 的常规寻路搜索。唯一不同的是，我们使用了一个改进的启发式函数，对于位于非相关区域的网格单元，该函数会返回一个无穷大的值。这样做非常有效。每个网格单元都标有所属区域（使用了几个额外的比特），因此我们可以在恒定时间内琐碎地询问该区域是否相关。死胡同启发式的主要优点之一就是计算效率非常高。</p>
<p>这种方法与分层寻路有着本质区别，因为我们并没有事先确定任何高级路径。例如，在分层寻路中，如果高层路径被动态障碍物阻挡，通常要到路径跟踪阶段才会被注意到，搜索可能不得不重新执行。而在我们的案例中，其他可能的路径都是开放的，如果存在另一条路径，A*搜索也会找到。</p>
<p>这种方法能否有效减少对状态空间的探索，在很大程度上取决于地图的结构。一方面，对于主要由通过相对较少的可能路径连接的区域组成的地图，这种简单的启发式方法有可能带来显著的改进。然而，可供选择的路径越多，启发式的效果就越差。例如，如果我们在示例地图的顶部房间开辟一条新的路径，那么死胡同启发式就只能从搜索中排除几个小区域。</p>
<p>此外，在自动分解地图时也需要小心谨慎，因为如果生成的区域太小，抽象多图就会变得很大。这样一来，多图搜索的开销就会变得很大。当然，在实时情况下，可以通过预处理所有相关的面积计算来避免这种开销，不过要付出额外的内存使用代价。</p>
<p>我们接下来介绍的启发式方法不存在上述问题。</p>
<h3><span id="gateway-heuristic">Gateway Heuristic</span></h3><p>网关启发式会预先计算区域出入口之间的距离。它也分两个阶段进行。</p>
<p>预处理阶段 地图分解成区域的方法与死胡同启发式相同。我们将区域之间的边界定义为网关（或大门）。网关的大小可以是任意的，但我们分解算法的一个缺陷是它的方向总是水平或垂直的。接下来，我们使用多次 A* 搜索来预先计算门之间的（静态）距离。对于每个网关，我们都会计算其与所有其他网关的路径距离（如果不存在路径，则成本为无穷大）。或者，我们也可以只计算每个房间内网关之间的距离，然后在运行时使用小规模搜索来累计总成本。不过，我们的方法能带来更准确的启发式估计和更快的运行时间访问（当然，代价是额外的内存）。</p>
<p>我们的方法的一个重要元素是为每对网关存储四种不同的成本。每个关口都是双向的，因为我们想知道从关口出发和到达关口的每种可能性的不同距离。与只计算一个成本值相比，这能在运行时大大提高启发式估算的准确性。因此，我们需要对每对闸门进行四次单独的预计算寻路搜索（这是离线完成的，因此额外的时间并不重要）。在这些寻路搜索中，我们不允许通过出发和到达的闸门。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230854188.png" alt="image-20240123085415988"></p>
<p>运行阶段 运行阶段是使用下面启发式函数的常规 A* 搜索：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230855828.png" alt="image-20240123085501729"></p>
<p>启发式 hl(n, G) 计算网格单元 n 到门 G 中最近点的八分距离。这可以简单地计算为一个点到水平线&#x2F;垂直线的距离。术语 H(Gi, Gj) 代表预先计算出的闸门 Gi 和 Gj 之间的最短距离（实际上，我们还必须通过闸门方向，但为了清晰起见，我们在这里省略了这一点）。我们需要查看当前区域的所有大门，并将每个大门与目标区域的所有大门进行比较，然后取最小成本。</p>
<p>网关启发式的准确性和计算效率与网关总数无关（尽管会影响内存使用）。启发式估算的计算效率主要受我们所经过区域，尤其是目标所在区域的门数量影响。这是因为在每个状态下，我们都会在所有门对中选择最小估计距离，前一个门在当前房间，后一个门在目标房间（见启发式函数方程）。另一方面，启发式的准确性受到两方面的影响：房间的形状和各个门的大小。由于我们使用八分启发式来估计当前状态（和目标）到最近的门的距离，因此很容易出现八分启发式带来的低估误差。不过，由于估算的距离通常较短，这些低估误差不会对整体距离估算产生重大影响。此外，我们的区域分解算法倾向于将地图分割成凸面区域，而八分启发式会在这些区域内给出准确的估计值。另一种低估与门的大小有关。在计算从一个州到一个门的距离时，我们总是使用门上最近的点来确保可接受性。这并不一定是我们在闸门距离预计算中使用的同一个闸门点。这两点之间的距离是造成低估的一个原因。闸门越大，这两点之间的距离就越远。</p>
<h2><span id="decomposition-algorithm">Decomposition Algorithm</span></h2><p>将地图划分为区域的算法是一种洪水填充算法。该算法无需输入边界，而是在遇到满足特定条件的地块时自动建立边界。该算法无需输入任何其他信息，只需输入基于地砖的地图，以及每个地砖是否可通行的信息。输出是每块瓦片的信息，说明它属于哪个区域（或无法通过）。</p>
<p>分解方法的伪代码如算法 1 所示。在创建区域时，算法首先找到最左上方可通行且尚未分配到区域的瓦片。从该瓦片开始，算法开始向右填充，直到填充到非空闲瓦片为止。之前分配的瓦块和无法通过的瓦块都被视为非空闲瓦块（第 9-15 行）。然后，算法开始下一行，使用与右侧类似的停止标准尽可能向左选择一个起点（第 27-36 行）。然后再开始向右填充，重复上述过程。</p>
<p>该算法会检测一行之间的左右边界是扩大还是缩小（第 17-26 行和第 37-42 行）。如果边框在缩小后重新增长，该区域的填充就会停止（可能需要撤销最后一行的填充（第 20-24 行））。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230858778.png" alt="image-20240123085818621"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230858688.png" alt="image-20240123085844285"></p>
<p>图 4 举例说明了分解算法的工作原理。左上方的图片显示的是一张未分割的地图，右边的图片中已经开始了洪水填充。第四行已经停止，因为该区域向上打开。在这种情况下继续前进是不明智的，因为这条线将直接穿过另一个潜在区域。这就是算法第 12 行的停止条件（(x + 1, y - 1) 6&#x3D; f ree）。在左下方的图片中，算法已经完成了对区域的填充。在紧接着区域下方的一行中，算法有机会将区域向右扩展。但是，由于区域已经从右侧开始缩小，而且禁止再生长，因此区域填充停止。这就确保了区域具有相当规则的形状。在最后一张图片中，又有两个区域进行了类似的填充。</p>
<h2><span id="empirical-evaluation">Empirical Evaluation</span></h2><p>我们在计算机游戏地图上运行了新的启发式方法，评估了这些方法的有效性，这些地图既有我们自己制作的，也有从流行的商业角色扮演游戏中提取的。所有实验均在 3.0 GHz CPU 个人电脑上运行。</p>
<p>表 1 显示了我们的寻路实验结果，其中对 octile 和两种新启发式方法进行了比较。在每张地图上，使用随机选择的起点和目标位置进行了 1000 次搜索。上半部分包括搜索我们的演示地图（图 1）所获得的实验数据，中半部分包括搜索热门游戏《光头之门 II》中九张不同地图所获得的数据（图 5）。在最后一部分，我们分别展示了同样来自《博德之门 2》的一个特别大的游戏地图的数据（图 6）。水平和垂直移动的成本为 100，而对角线移动的成本为 150。</p>
<p>在所有类型的地图中，新启发法在节点扩展数量和总运行时间方面都明显优于标准八进制启发法。总的来说，网关启发式是最好的。我们还可以看到，计算死胡同启发式的时间开销几乎可以忽略不计，因为节省的时间与节省的节点数大致相当。这是因为多图路径是预先计算好的。对于网关启发式而言，节点的减少尤为显著。然而，搜索时间并没有随着节点数量的增加而相对减少。这是由于新的启发式函数比计算八分距离复杂。尽管如此，所节省的时间还是相当可观的，而且在精心实施后还能进一步提高。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230859287.png" alt="image-20240123085954018"></p>
<p>我们还有兴趣仔细研究启发式方法在较长的路径上的表现。前 10%部分给出了长于平均路径的结果（我们为每张地图随机生成了 10,000 条路径，其中包括最长的 10%）。现在，新启发式方法的性能提升更为显著。我们还想看看网关启发式估计值与真实路径长度的接近程度。</p>
<h2><span id="conclusions">Conclusions</span></h2><p>我们提出了两个新的可接受启发式函数，用于指导大型游戏地图寻路中的启发式搜索。这些启发式方法的初步结果很有希望。这两种启发式方法确实优于大多数现代游戏中使用的标准技术。不过，在得出任何具体结论之前，我们希望在更多地图上进行更全面的实验评估。很明显，随着游戏地图的不断增加，像这里讨论的启发式方法将变得非常必要。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401230901276.png" alt="image-20240123090107970"></p>
<p>我们在实施方面仍有改进的余地，也许更重要的是，在改进启发式估计方面也有改进的余地。关于如何继续这项研究，我们有几个想法。其一是进一步研究区域分解算法，使其更好地适应各种不同类型的地形。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-17T15:16:04.000Z" title="2024/1/17 23:16:04">2024-01-17</time>发表</span><span class="level-item"><time dateTime="2024-01-19T17:01:08.987Z" title="2024/1/20 01:01:08">2024-01-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/">路径规划启发式</a></span><span class="level-item">2 小时读完 (大约14302个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/17/An-improved-heuristic-mechanism-ant-colony-optimization-algorithm-for-solving-path-planning/">An improved heuristic mechanism ant colony optimization algorithm for solving path planning</a></p><div class="content"><h1><span id="an-improved-heuristic-mechanism-ant-colony-optimization-algorithm-for-solving-path-planning">An improved heuristic mechanism ant colony optimization algorithm for solving path planning</span></h1><h2><span id="abstract">abstract</span></h2><p>随着人工智能算法的发展，智能路径规划因其广阔的应用前景和发展潜力吸引着研究人员的目光。蚁群优化（ACO）算法是目前应用最广泛的路径规划求解方法之一。然而，传统的 ACO 算法存在搜索效率低、容易停滞等缺点。本研究提出了一种新的 ACO 变体，名为改进的启发式机制 ACO（IHMACO）。IHMACO 包含四种改进机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整。具体而言，&#x3D;&#x3D;自适应信息素浓度设置和带有方向判断的启发式机制可提高规划路径的目的性并减少转弯时间。改进的伪随机转移策略和信息素蒸发率的动态调整提高了搜索效率和全局搜索能力，进一步避免了陷入局部最优。&#x3D;&#x3D;随后，通过一系列实验检验了四种机制的有效性，并验证了所提出的 IHMACO 的性能。与现有的 15 种求解路径规划的方法进行比较，包括 ACO 的 9 种变体和 6 种常用的确定性搜索算法。实验结果表明，所提出的 IHMACO 在路径转弯时间方面的相对改进率分别为 33.33%、83.33%、35.29%、38.46% 和 38.46%，证明了 IHMACO 在可用性和高效率方面的优越性。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>全局路径规划是在已知障碍环境下，建立一条从起点节点到目标节点的有序可行路径，且必须保证规划路径不与任何障碍物发生碰撞。智能路径规划是许多领域的重要工具，如机器人路径规划[1]、无人战车（UCV）[2]、车辆路由问题（VRP）[3,4]、交通系统导航[5]、军事指挥系统[6]、巡航导弹轨迹规划[7]、无人机（UAV）轨迹规划[8,9]、火险逃生[10]、自动导引车（AGV）[11]等。由于应用广泛，路径规划问题得到了众多研究者的关注，大量优化算法被用于解决路径规划问题。</p>
<p>传统的路径规划算法主要包括最佳第一搜索算法[12]、Dijkstra算法[13]、A* 算法[14]、跳点搜索算法[15]、广度第一搜索算法[16]、跟踪算法[17]、快速探索随机树（RRT）算法[18]、概率路线图（PRM）算法[19]等。Kurdi 等人将 Dijkstra 算法应用于自动驾驶车辆问题[20]。然而，由于需要遍历大量节点，Dijkstra 算法效率较低，而且无法处理负边问题。&#x3D;&#x3D;Luo 等人提出了一种扩展的 Dijkstra 算法，利用 Delaunay 三角剖分法解决曲面最优路径规划问题[21]。&#x3D;&#x3D;Best-First Search 算法与 Dijkstra 算法的过程类似，不同之处在于它使用启发式函数快速引导目标节点[22]。El Baz 等人提出了一种改进的并行 Best-First Search 算法来解决多核处理器规划问题[23]。Breuker 等人将双基算法与 Best-First Search 算法相结合，解决了图历史交互（GHI）问题 [24]。A * 算法在路径规划问题中具有良好的鲁棒性、对环境信息响应快等优异性能[25]。Sang 等人引入了人工势场来改进无人水面飞行器编队的 A* 算法 [26]。Li 等人将双向 A* 应用于机器人路径规划 [27]。然而，&#x3D;&#x3D;A* 算法并不适合高维空间，而且在复杂环境中会导致计算量骤增。 通过改进 A* 算法，引入了 JPS 算法，以避免扩展许多无用节点 [28,29]。&#x3D;&#x3D; 广度优先搜索算法采用基于地毯的级联搜索策略，沿着树的宽度遍历节点。Li 等人采用 Breadth-First Search 提出了一种快速路径规划算法 [30]。&#x3D;&#x3D;RRT 和 PRM 是基于图搜索的动态路径规划求解方法[31,32]。&#x3D;&#x3D;广度优先搜索算法是一种盲搜索方法，无法确保找到最优路径 [33]。因此，Tripathy 等人提出了一种改进的基于广度优先搜索的识别方法，用于解决移动机器人导航问题 [34]。</p>
<p>近年来，许多启发式仿生算法被广泛应用于解决路径规划问题，如粒子群优化（PSO）[35]、遗传算法（GA）[36]、蚁群优化（ACO）[37]等。然而，传统的启发式算法在解决路径规划问题时存在局限性。为克服 GA 算法运行效率低的缺点[38]，Flores-Caballero 等人提出了一种改进的遗传算法来解决无人机的路径规划问题[39]。Cheng 等人提出了一种适用于可重构平铺机器人的新型遗传算法[40]。Chong 等人提出了一种改进的自适应遗传算法（IAGA）来解决自主水下航行器的路径规划问题[41]。此外，PSO 容易进入局部最优[42]。根据提出的 PSO 变体，Wang 等人介绍了一种用于 AUV 离线路径规划的量子 PSO 方法[43]。为了获得较高的最优精度，Zhao 等人提出了一种混合 PSO，用于求解串行机械手时空最优轨迹规划[44]。Kathen 等人提出了一种改进的 PSO 来解决高级安全飞行器的路径规划问题[45]。此外，随着路径规划问题复杂度的不断提高，许多学者提出了各种改进的优化算法。&#x3D;&#x3D;Wu 等人引入了一种名为自主导航和避障（ANOA）的深度强化学习技术，以解决无人水面飞行器（USV）的自主导航和避障问题[46]。&#x3D;&#x3D; SA 是一种基于概率的算法，源自固体退火原理。Xiao 等人提出了一种改进的 SA 来实现无人机覆盖路径规划，结果验证了改进 SA 的高质量效果[47]。&#x3D;&#x3D;Xiong 等人从快速探索随机树星（RRT*）中汲取灵感，结合锦标赛选择方法和信息启发式算法，提出了一种独特的基于样本的路径规划算法[48]。&#x3D;&#x3D;与其他启发式仿生算法相比，ACO 具有并行性、自组织性、正反馈能力等优点。然而，传统的 ACO 算法也存在一些缺点，如效率低、收敛慢、易停滞等。因此，许多研究人员提出了许多改进措施，以解决路径搜索策略和信息素更新方面的问题。Ma 等人提出了一种烟花蚁群混合算法，并通过考虑导航距离成本和能耗成本建立了新的数学模型[49]。Ajeil 等人提出了一种基于老化的 ACO，通过与栅格法相结合实现了路径规划的求解[50]。Liu 等人提出了一种改进的 ACO，它集成了信息素扩散和几何局部优化，用于移动机器人路径规划[51]。</p>
<p>&#x3D;&#x3D;Zhu 等人提出了一种用于月球机器人路径规划的自适应势场 ACO[52]&#x3D;&#x3D;，引入了启发式因子和自适应状态转换来提高搜索能力和收敛速度。Yi 等人通过引入多目标编程模型对 ACO 进行了改进，以优化多自动制导车辆的信息素矩阵[53]。为了解决室内移动机器人路径规划问题，Miao 等人通过增强信息素更新策略和状态转换概率，提出了一种改进的 ACO（IACO）[54]。Jiao 等人提出了一种自适应多态 ACO，用于解决智能轮椅的路径规划问题，它主要改进了信息素更新策略[55]。Tao 等人提出了一种改进的 ACO，它结合了初始信息素的分布、修正的启发式函数和信息素更新规则来解决移动服务机器人的路径规划问题[56]。&#x3D;&#x3D;为了改善 ACO 计算量大的缺点，Wang 等人提出了一种新的加权邻接矩阵用于路径规划[57]&#x3D;&#x3D;。Zhao 等人通过引入信息素更新策略和路径选择策略，提出了一种改进的 ACO，用于解决全向移动车辆路径规划问题[58]。尽管 ACO 及其变体在解决路径规划问题时能产生令人满意的解，但就有效性和效率而言，ACO 的性能仍有进一步提高的空间。</p>
<p>本研究提出了一种改进的 ACO 来解决路径规划问题。为了克服经典 ACO 的缺点，&#x3D;&#x3D;本文提出了四种新的机制，分别是自适应信息素浓度设置、具有方向判断能力的启发式机制、改进的伪随机转移策略以及信息素蒸发率的动态调整。&#x3D;&#x3D;自适应信息素浓度设置是为了加强在初始搜索过程中优先选择可选区域的引导能力。提出了具有方向判断能力的启发式机制，以增强算法的搜索目的性和规划路径的平滑性。引入了改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。提出了一种动态调整信息素蒸发率的方法，以增加蜂群多样性和提高全局搜索能力。将上述四种机制与传统的蚁群优化算法相结合，提出了一种新的蚁群优化算法变体，即 IHMACO（改进的启发式机制蚁群优化）算法。为了验证 IHMACO 的有效性和优越性，我们进行了一组实验，将其与其他路径规划算法在不同实例中进行了比较。结果验证了 IHMACO 在收敛速度和最优解搜索能力方面的优势。</p>
<p>其余部分的结构如下： 第 2 节给出了建立全局路径规划数学模型的说明。然后，第 3 节介绍了传统 ACO 和 IHMACO 中的四种新型机制。第 4 节进行了实验和分析。最后，第 5 节给出结论。</p>
<h2><span id="2-mathematical-model-of-global-path-planning">2. Mathematical model of global path planning</span></h2><h3><span id="21-grid-environment-model">2.1. Grid environment model</span></h3><p>全局路径规划的环境模型是为了模拟实际应用场景，为算法实现提供仿真环境。&#x3D;&#x3D;栅格法是路径规划中应用最为广泛的方式，可以降低环境模型的复杂度。&#x3D;&#x3D;因此，本研究选择栅格法来构建全局路径规划的环境模型。一般来说，环境模型由自由栅格和障碍物栅格组成，自由栅格用白色栅格表示，也可以用数值 0 表示。障碍物栅格用黑色栅格表示，也可以用数值 1 表示。为方便起见，每个栅格都有唯一的序列号和坐标值。图 1 显示了一个带有 (20 × 20) 个栅格的环境模型示例。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172338680.png" alt="image-20240117233843703"></p>
<p>如图 1 所示，起点节点和目标节点分别用 S 和 T 表示。黑色栅格代表障碍区域，白色栅格代表可行区域。相应坐标与栅格序列号之间的变换规则如式（1）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172347491.png" alt="image-20240117234705986"></p>
<p>其中，(xn, yn) 表示第 n 个栅格的坐标位置；n 是其序列对应的编号；mod () 表示余数函数；Rx 和 Ry 是环境模型的行列总和；ceil () 表示四舍五入函数。环境模型建立后，转而寻找一组连续的栅格来连接 S 和 T，任意栅格的可能方向如图 2 所示。在图 2 中，任何栅格都可以选择 8 个可能的方向，障碍物栅格为禁止栅格。</p>
<h2><span id="22-mathematical-model-of-path-planning">2.2. Mathematical model of path planning</span></h2><p>传统 ACO 的目标函数只考虑路径长度，但转弯次数对优化过程也有重要影响 [59]。我们知道，一条令人满意的路径应该具有最短的长度和最少的转弯次数。在本研究中，引入了多目标函数来建立路径规划的数学模型，该模型考虑了路径长度和转弯次数[60]。同时还采用了加权法来维持两个目标，如式（2）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172348715.png" alt="image-20240117234816200"></p>
<p>其中，L(p) 表示路径长度；T (p) 表示转弯时间；w1、w2 表示权重系数。实际上，w1 和 w2 与 L（p）和 T（p）的最小值有关。 &#x3D;&#x3D;w1 和 w2 应保证（w1×L(p)）和（w2×T (p)）的值处于同一振幅，以平衡路径长度和转弯时间的影响。&#x3D;&#x3D;</p>
<h2><span id="3-improved-mechanisms-and-the-proposed-variant-of-aco">3. Improved mechanisms and the proposed variant of ACO</span></h2><h3><span id="31-aco-algorithm">3.1. ACO algorithm</span></h3><p>ACO 算法的灵感来源于蚂蚁的觅食行为。在蚁群中，每只蚂蚁都是独立的合作个体，觅食行为是通过蚁群内个体间的交流来实现的。</p>
<p>(1) 初始化参数设置 ACO 的基本参数可根据实验经验进行分配，主要包括蚂蚁数量 M、最大迭代次数 K、信息素启发因子 α、期望启发因子 β、信息素挥发因子 ρ 和信息素强度值 Q。</p>
<p>(2) 状态转换概率 在环境模型中，位于节点 i 上的蚂蚁 m 利用状态转换概率选择下一个节点 j，如公式 (3) 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172351111.png" alt="image-20240117235138596"></p>
<p>其中，$p_{ij}^{m}$ 节点 $i$ 和节点 $j$ 之间的转换概率；$$\tau (i, j)$$ 代表信息素浓度值；$η(i, j)$ 代表能见度启发式信息，$η(i, j) &#x3D; 1&#x2F;d_{ij} * J{m}$ 代表可选节点集。</p>
<p>(3) 信息素更新规则 信息素更新规则复制了 ACO 中信息素的积累和蒸发，用公式 (4) 和 (5) 表示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172352893.png" alt="image-20240117235240675"></p>
<p>其中，ρ 的值在 [0, 1] 范围内；$\tau^{m}<em>{t}(i, j)$ 表示第 m 只蚂蚁从节点 i 到节点 j 的信息素；$\Delta \tau^{m}</em>{t}(i, j)$ 表示当前迭代中从节点 i 到节点 j 的信息素增量；$L_m$ 表示路径长度。</p>
<h3><span id="32-a-proposed-variant-of-aco">3.2. A proposed variant of ACO</span></h3><p>本节提出了四种新的机制来改善传统 ACO 的缺点。首先，提出了一种自适应信息素浓度设置，以加强在初始搜索过程中选择先行可选区域的引导能力。然后，提出了一种具有方向判断能力的新型启发式机制，以提高规划路径的目的性和平稳性。随后，引入了一种改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。最后，提出了信息素蒸发率的动态调整机制，以增加蚁群的多样性，提高全局搜索能力。然后，结合上述四种机制，形成了一种新的 ACO 变种，即改进的启发式机制 ACO（IHMACO）。IHMACO 的流程图如图 3 所示。图 4 给出了 IHMACO 的伪代码。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172355363.png" alt="image-20240117235534260"></p>
<h3><span id="33-adaptive-pheromone-concentration-setting">3.3. Adaptive pheromone concentration setting</span></h3><p>在传统的 ACO 中，初始信息素值的设置是均匀分布的，如图 5（a）所示。这种方式会导致算法在早期阶段出现搜索盲区，收敛速度较慢。为了克服这一缺点，&#x3D;&#x3D;引入了自适应信息素浓度设置来增强引导功能，即在初始搜索过程中优先选择优势可选区域，如式（6）所示。改进后的初始信息素分布如图 5(b) 所示。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172356023.png" alt="image-20240117235634863"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401181119688.png" alt="image-20240118111949767"></p>
<p>其中，$\tau_{ij}(0)$ 是 $i$ 到 $j$ 的初始信息素浓度，存在  $\tau_{ij}(0) \neq \tau_{ji}(0)$；$τ_0$ 是传统 ACO 中的初始信息素，取一常数；a 被定义为初始信息素奖惩因子。$d_{Si}$ 是节点 $i$ 到 $S$ 的欧拉距离，$d_{iT}$ 是节点 $i$ 到目标节点 $T$ 的欧拉距离，$d_{Sj}$ 是节点 $j$ 到节点 $S$ 的欧拉距离，$d_{jT}$ 是节点 $j$ 到节点 $T$ 的欧拉距离，$d_{ST}$ 表示 $S$ 到 $T$ 的距离。假设 $S$ 的坐标为（xS , yS ），T 的坐标为（xT , yT ），欧拉距离计算公式如式（7）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172357036.png" alt="image-20240117235711148"></p>
<p>对于特殊情况，&#x3D;&#x3D;引入的欧拉距离 $d_{Si}$、$d_{iT}$、$d_{Sj}$、$d_{jT}$ 和 $d_{ST}$ 如图 6 所示。显然，dSi 和 diT、dSj 和 djT 之和的最小值就是 $d_{ST}$ 的值。当前节点 i 与直线 “ST “之间的距离越远，初始信息素浓度就越小。&#x3D;&#x3D;</p>
<p>此外，在信息素浓度自适应设置方程中，a 是用来控制一般可选节点和优势区域可选节点的初始信息素浓度。如果 diT &gt; djT，则下一个节点 j 离目标节点位置更近，被视为优势区域节点。为确保当前节点尽可能选择优势区域的下一个节点，a 取其最大奖励值 1。另一方面，如果 diT &lt; djT，则需要进行综合统计实验以找出 a 的合适惩罚值。</p>
<p>具体而言，a 的惩罚值分别设置为 0.1、0.3、0.5、0.7 和 0.9。IHMACO 的其他主要参数设定为 K &#x3D; 100、M &#x3D; 50、α &#x3D; 1、β &#x3D; 7、Q &#x3D; 1、ρ &#x3D; 0.2。每组选定的参数组合模拟运行 20 次。不同 a 值的实验结果如图 8 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004175.png" alt="image-20240118000412109"></p>
<p>从图 8 中可以看出，当 a 的惩罚值设置为 1&#x2F;2 时，算法的性能在路径长度和转弯时间方面都有优势。总之，当 diT &gt; djT 时，a 的最大奖励值为 1，而当 diT &lt; djT 时，a 的惩罚奖励值为 1&#x2F;2。在自适应信息素浓度设置功能的作用下，ACO 的初始搜索过程更有目的性，效率更高。</p>
<h3><span id="34-heuristic-mechanism-with-directional-judgment">3.4. Heuristic mechanism with directional judgment</span></h3><p>对于当前节点 i，如果在传统 ACO 中没有障碍物包围，则它有八个可选节点。如图 9 所示，节点 i 及其八个可选节点分别用 j1、j2、j3、j4、j5、j6、j7 和 j8 表示。在路径规划中，&#x3D;&#x3D;启发式函数 η(i, j) &#x3D; 1&#x2F;dij 只与当前节点 i 和下一个可选节点之间的距离有关，而欧拉距离 dij 是环境模型中的已知值，为 1 或 $\sqrt{2} $。&#x3D;&#x3D; 因此，&#x3D;&#x3D;传统的启发式函数缺乏指导性和启发性。&#x3D;&#x3D;这会导致蚂蚁随机选择搜索路径，进一步减慢 ACO 的收敛速度，尤其是在迭代初期。显然，为了保持搜索过程的效率，&#x3D;&#x3D;希望节点 i 所选择的下一个节点 j 也是沿着从 S 到 T 的箭头方向&#x3D;&#x3D;，&#x3D;&#x3D;如图 9 所示。本节通过考虑 S 和 T 的位置信息，提出了一种新颖的带有方向判断的启发式机制&#x3D;&#x3D;，从而使路径搜索过程变得有目的性和流畅性，进一步有效避免了搜索的盲目性。带有方向判断的启发式机制基于 S 和 T 的相对位置，与 S 和 T 的绝对位置无关。具体如图 9（a）所示，当前节点的八个可选节点被赋予不同的权重值。假设节点 i 的坐标为 (xi，yi)，下一个选定节点 j 的坐标为 (xj，yj)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401172359652.png" alt="image-20240117235945622"></p>
<p>基于新颖的启发式方向判断机制，从 i 到 j 的向量应尽可能指向从 S 到 T 的箭头方向。这意味着（x &#x3D; xj-xi ）-（X &#x3D; xT -xS ）和（y &#x3D; yj-yi ）-（Y &#x3D; yT -yS ）的值应尽可能不小于 0。如果 x-X &gt; 0 或 y-Y &gt; 0，则表示下一个节点的 x 或 y 方向为正，可标记为 “+”；相反，如果 x - X &lt; 0 或 y - Y &lt; 0，则标记为”-“。如图 9（a）所示，八个可选节点的值分别为 j1（+，+）、j2（0，+）、j3（+，0）、j4（-，+）、j5（+，-）、j6（-，0）、j7（0，-）、j8（-，-）。共有五种情况：j1 有两个 “+”；j2 和 j3 有一个 “+”和一个 “0”；j4 和 j5 有一个 “+”和一个”-“；j6 和 j7 有一个”-“和一个 “0”；j8 有两个”-“。根据方向判断规则，对于当前节点 i 来说，选择 “+”符号较多的可选节点是更好的选择。因此，将八个可选节点的优先级顺序分为五组，分别为 j1&gt;j2 &#x3D; j3&gt;j4 &#x3D; j5&gt;j6 &#x3D; j7&gt;j8，并赋予它们 5:4:3:2:1 的不同权重系数。经过归一化处理后，8 个可选节点的权重值 $\pi$ 依次为 5&#x2F;15、4&#x2F;15、3&#x2F;15、2&#x2F;15、1&#x2F;15，如表 1 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004642.png" alt="image-20240118000432302"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180000297.png" alt="image-20240118000039249"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180000770.png" alt="image-20240118000057789"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180001369.png" alt="image-20240118000117392"></p>
<p>如果起始位置（S）位于（n，n），目标位置（T）位于（0，0），则方向最一致的指向 S -→T 的下一个节点变为 j8，而方向相反的指向 S -→T 的 j1 变为（-，-），如图 9（b）所示。因此，带有方向判断的启发式机制只与 S 和 T 的相对位置有关，而与它们的绝对位置无关。此外，传统的 ACO 只考虑距离函数的影响，启发式函数中还应考虑转弯因素的影响，以提高路径的平滑度。带有方向判断的启发式机制在路径规划中考虑了下一节点、目标节点和转弯时间之间位置信息的联系。改进后的启发式函数详见公式 (8)-(10)。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180002174.png" alt="image-20240118000222169"></p>
<p>其中，η（i，j）′为改进启发式函数；π为方向判断权重值；T（i，j）为上一节点（i-1）与下一节点 j 之间的转弯时间；T0 为初始转弯系数常数。改进后的启发式函数综合考虑了节点方向判断、距离信息和转弯时间。&#x3D;&#x3D;选择正方向的节点，距离和转弯次数越小，启发式函数越好。如此一来，使得算法具有更好的方向引导性，有效提升规划路径的平滑度。&#x3D;&#x3D;</p>
<h3><span id="35-improved-pseudo-random-transfer-strategy">3.5. Improved pseudo-random transfer strategy</span></h3><p>为了提高搜索效率，避免陷入局部最优，我们提出了一种改进的伪随机转移策略，如式（11）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180003093.png" alt="image-20240118000329200"></p>
<p>其中，$S_{ij}^{m}$ 是蚂蚁 $m$ 从节点 $i$ 转移到节点 $j$ 的概率；随机变量 q 在 [0, 1] 之间平均分布；argmax () 是函数达到最大值时的变量位置；$q_0$ 决定了选择确定性转移和随机性转移的概率。因此，如式（12）和图 10 所示，引入了 $q_0$ 的自适应调整机制，以实现确定性转移和随机转移的合理组合。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180004298.png" alt="image-20240118000451322"></p>
<p>其中，$εq$ 表示 $q_0$ 的调整系数，$εq$ 取 0.1 较好。在&#x3D;&#x3D;早期阶段，$q_0$ 取较大的值，选择确定性转移的概率较大，可以加快局部最优路径的搜索速度。在算法执行的中期，$q_0$ 取较小值，可以增加选择随机转移的概率，防止局部最优的出现。&#x3D;&#x3D;当算法迭代到后期，其进化方向已基本确定，可逐渐增大 $q_0$ 值，加快收敛速度。如果某次迭代中有一半以上的蚂蚁获得了相同的路径，取 $q_0$ 的值为$(εq - q_0)$，可以增加选择其他路径的概率。改进后的伪随机转移策略在全局搜索能力和收敛速度之间取得了良好的平衡。</p>
<h3><span id="36-dynamic-adjustment-of-the-pheromone-evaporation-rate">3.6. Dynamic adjustment of the pheromone evaporation rate</span></h3><p>当蚂蚁因信息素干扰次优路径而无法选择最优路径时，就会出现局部最优。当经过多次迭代仍未找到最优解时，算法就会停止搜索。传统的 ACO 在迭代后期很容易陷入局部最优解的困境。为了加强算法后期的全局搜索能力，&#x3D;&#x3D;增加路径搜索的多样性，引入了信息素蒸发率的动态调整&#x3D;&#x3D;。此外，还引入了多目标函数 $Fitness$ 来替代全局信息素更新中的路径长度 $L_m$，如式（13）和式（14）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180006352.png" alt="image-20240118000641343"></p>
<p>其中，$\rho_0$ 是 $\rho$ 的初始值，$\rho$ 随迭代次数的增加而变大。在迭代初期，$\rho$ 设置得较小，以增强蚂蚁的方向性，进一步加快收敛速度。随着迭代次数的增加，$\rho$ 逐渐增大，以扩大蚁群的搜索空间，进一步增强全局搜索能力，避免陷入局部最优。</p>
<h3><span id="37-parameter-optimization-of-ihmaco">3.7. Parameter optimization of IHMACO</span></h3><p>&#x3D;&#x3D;众所周知，ACO 参数的选择直接影响其性能。&#x3D;&#x3D;迄今为止，还没有一种成熟的理论分析方法可以直接确定参数的最佳组合。因此，为了找到 IHMACO 的合适参数 $q_0$，我们进行了一次全面的统计实验。在每段测试实验中，只改变其中一个参数，其他参数设置为常数，以分析单一参数的影响。为减少偶然因素造成的误差，每组选定的参数组合都要模拟运行 10 次。测试实验的环境模型设置如图 11 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180006723.png" alt="image-20240118000616637"></p>
<p>q0 的值分别设置为 0.1、0.2、……、0.9。, 0.9。IHMACO 的其他主要参数设定为 K &#x3D; 100、M &#x3D; 50、α &#x3D; 1、β &#x3D; 7、Q &#x3D; 1、ρ &#x3D; 0.2。不同 q0 值的实验结果如图 12 所示。<br>如图 12 所示，当 q0 的取值范围在 [0.5, 0.6] 之间时，算法的转向时间和平均收敛生成量的性能都较好。考虑到图 12 所给出的结果，在仿真实验中将 $q_0$ 的初始值设为 0.5。</p>
<p>为了证明 q0 的大小对全局搜索能力和收敛速度有显著影响，我们又进行了一次综合统计实验。环境模型（20 × 20）设置为相同，如图 11 所示。起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。图 13 显示了不同 q0 值下最优解的演化曲线。<br>从图 13(a) 可以看出，当 q0 值较小时，ACO 具有很好的全局搜索能力，但收敛速度较慢。相反，随着 q0 值的增大，ACO 的收敛速度较快，且容易陷入局部最优解。同时，当 q0 取中间值 0.5 时，最优解在算法初期具有良好的离散性。此外，在迭代的中后期，算法的全局搜索能力减弱，容易达到局部最优。从图 13（b）可以看出，当 q0 采用自适应调整机制时，算法在迭代初期能有效地搜索到最优路径，收敛速度较快。随着迭代次数的增加，蜂群多样性得到提高，算法的全局搜索能力得到加强，有效避免了算法陷入局部最优。因此，可以得出结论：q0 的自适应调整机制能够很好地平衡全局搜索能力和收敛速度。</p>
<h3><span id="38-time-complexity-of-ihmaco-algorithm">3.8. Time complexity of IHMACO algorithm</span></h3><p>时间复杂度是判断算法运行效率的重要因素，也是反映算法性能的重要工具。一般来说，算法的时间复杂度由种群数量、实验环境空间维数和模型目标函数决定。假设参数初始化时间为 t0，信息素矩阵初始化时间为 G2-t1，其中 t1 为矩阵各节点初始化时间。初始化每只蚂蚁的时间为 t2。因此，初始化阶段的时间复杂度如式（15）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180009310.png" alt="image-20240118000931313"></p>
<p>在迭代过程中，最大迭代次数为 K，f (G) 是计算最优个体适应度值的时间。此外，从种群中选择最优个体的时间为 t3，替换最后一次迭代个体的时间为 t4。边界初始化阶段的时间复杂度如式（16）所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180010105.png" alt="image-20240118001004100"></p>
<p>在单个位置更新阶段，假设计算权重的时间为 t5，则执行带有方向判断策略的启发式机制的时间为 8-t5。假设更新参数的时间为 t6，则通过式（12）和式（14）计算改进的伪随机转移策略和动态调整信息素蒸发率的时间为 2-t6，生成随机数的时间为 t7。然后，根据公式（8）选择下一个节点位置的时间为 M-t8。此外，信息素矩阵重新初始化的时间为 G2-t1。因此，单个位置更新阶段的时间复杂度可用公式（17）表示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180010394.png" alt="image-20240118001050315"></p>
<p>总之，IHMACO 的时间复杂度可以通过公式 (18) 计算出来。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011255.png" alt="image-20240118001109463"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011506.png" alt="image-20240118001131348"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180011905.png" alt="image-20240118001150685"></p>
<h2><span id="4-experiments-and-numerical-analysis">4. Experiments and numerical analysis</span></h2><p>为了验证 IHMACO 在解决路径规划问题中的性能，本部分操作了一组实验。首先，第一组实验用于测试四种机制的改进效果。然后，第二组实验用于评估建议算法在四种不同实验环境中的适应性。此外，还比较了 ACO 的几个变体和六种广泛使用的算法（Dijkstra 算法、Bes-First Search 算法、A* 算法、Trace 算法、JPS 算法和 Breath-First Search 算法），以验证 IHMACO 在路径规划问题中的实用性和效率。所有算法均由 Matlab 2020a 进行编码，并在英特尔® 酷睿 i5-2400 <a href="mailto:&#67;&#x50;&#x55;&#64;&#51;&#46;&#48;">&#67;&#x50;&#x55;&#64;&#51;&#46;&#48;</a> GHz、2 GB 内存和 Windows 10 计算机上运行。</p>
<h3><span id="41-performance-verification-of-the-four-proposed-mechanisms">4.1. Performance verification of the four proposed mechanisms</span></h3><p>为了区分和检验四种机制的有效性，将每种机制与传统ACO有序结合，形成ACO的几种过渡变体，分别命名为ACO-1、ACO-2、ACO-3和IHMACO，如表2所示，并建立了一个空间环境模型（20×20）的实例，其中有几个凹陷的栅格陷阱，如图14所示。起始节点 S 和目标节点 T 用红点表示，它们的坐标分别为（0.5，19.5）和（19.5，0.5）。ACO 变体的初始参数设置如表 3 所示。由于智能算法的随机性，这些算法产生的解可能比新搜索过程中产生的解更好，也可能更差。因此，为了比较模拟结果，使用统计量是一个不错的选择。在本节中，每种算法独立运行 20 次来求解路径规划实例。这些算法得到的最优路径和收敛曲线如图 14 和图 15 所示，五种算法的结果如表 4 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180013660.png" alt="image-20240118001317762"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180013697.png" alt="image-20240118001338571"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180014130.png" alt="image-20240118001404098"></p>
<p>与 ACO 相比，增加了初始信息素浓度设置改进的 ACO-1 在最优路径长度（32.384&lt;34.042）、平均路径长度（33.213&lt;35.758）、转弯次数（8&lt;9）和收敛代数（68&lt;81）等方面都有更好的表现。特别是在收敛代数方面，表明这种改进能有效提高搜索效率，降低蚂蚁陷入僵局的概率。</p>
<p>然后，将 ACO-1 与进一步引入方向判断启发式机制的 ACO-2 进行比较。如表 4 所示，可以发现 ACO-2 在最优路径长度和平均路径长度方面都有明显更好的表现。ACO-2 的较好性能表明了所提出的带有方向判断的启发式机制的可用性。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016673.png" alt="image-20240118001622336"></p>
<p>将 ACO-2 与 ACO-3 进行比较，可以发现 ACO-3 在转弯时间（6&lt;8）方面表现出色。但是，ACO-3 产生的收敛生成次数更多（38&gt;32）。这说明改进后的伪随机转移策略减慢了收敛速度。<br>将 ACO-3 与 IHMACO 比较，IHMACO 在所有指标上都有显著的表现。具体而言，IHMACO 可以获得最小的最优路径长度（31.556）、最小的转弯次数（4）和最少的收敛代数（19）。因此，所提出的信息素蒸发率动态调整方法可以很好地平衡全局搜索能力和收敛速度。</p>
<p>此外，图 14 和图 15 也显示了 IHMACO 更好的结果。对于这五种算法生成的最优路径，可以发现 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序有明显改善。同时，收敛曲线进一步验证了所提出的四种机制的有效性。总之，所提出的四种机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整，都具有提高 ACO 性能的作用。</p>
<h3><span id="42-performance-verification-in-different-environments">4.2. Performance verification in different environments</span></h3><p>为了评估所提出的 IHMACO 的适应性，本实验设计了四种不同的环境模型。表 5 总结了每个环境模型的特征和设计目标。同时，还使用了传统 ACO 进行比较。环境模型的设置如图 16 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。平心而论，IHMACO 的常用参数设置与传统 ACO 相同。具体来说，ACO 设置为 K &#x3D; 100、M &#x3D; 50、ρ &#x3D; 0.3、Q &#x3D; 1、α &#x3D; 1、β &#x3D; 4，IHMACO 设置为 K &#x3D; 100、M &#x3D; 50、ρ0 &#x3D; 0.3、Q &#x3D; 1、α &#x3D; 1、β &#x3D; 4、T0 &#x3D; 1、τ0 &#x3D; 1、εq &#x3D; 0.1、w1 &#x3D; 0.5、w2 &#x3D; 1。然后，每种算法独立运行 20 次，求解路径规划实例。实验结果如表 6 所示，两种算法得到的最优路径如图 16 所示。表 6 说明了与传统 ACO 相比，路径长度和转弯时间都有所改善。此外，Path_L_Improve 表示与其他算法相比改进路径长度的百分比，Differ_Length 表示 IHMACO 与其他算法在路径长度上的差异，其他算法的路径长度用 Path_Length 表示。转弯时间也可以用同样的方法得到，如公式 (19) 和 (20) 所示。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016957.png" alt="image-20240118001638132"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180016637.png" alt="image-20240118001652610"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180017443.png" alt="image-20240118001713449"></p>
<p>如表 6 所示，可以看出在这四种不同环境下，IHMACO 的效率均高于传统 ACO。特别是转弯时间，IHMACO 产生的转弯时间更少（环境 1，5&lt;13；环境 2，6&lt;17；环境 3，4&lt;9；环境 4，4&lt;9；）。在四种不同环境下，转弯时间的改善百分比分别为 61.54%、64.71%、55.56% 和 55.56%。在其他性能指标方面，IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（’’Std’’. 具体而言，IHMACO 得到的 “最佳 “路径长度分别为 29.213、29.799、31.556 和 30.384，小于 ACO。其中，环境 3 中最佳路径长度的改进百分比最多可提高 7.31%。IHMACO 所获得的路径长度 “平均值 “分别为 29.213、29.799、31.556 和 30.384，也小于 ACO。在环境 3 中，改进后的平均路径长度最多可增加 11.75%。 图 16 也显示了 IHMACO 的性能，IHMACO 的结果进一步验证了其优越性。总之，实验结果证明了改进算法在不同环境模型下求解路径规划实例的优越性和适应性。</p>
<h3><span id="43-comparison-experiments-with-other-variants-of-aco">4.3. Comparison experiments with other variants of ACO</span></h3><h4><span id="431-simulation-experiment-i">4.3.1. Simulation Experiment I</span></h4><p>在这一部分中，采用了 ACO 和文献[54]中提出的 ACO 的另一种变体，即改进型自适应蚁群优化（IAACO），与 IHMACO 进行比较，以验证其优越性。此外，还采用了六种常用的路径规划算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。环境模型与文献 [54] 一致，如图 17 所示。本实例的起始节点 S 用红点表示，其坐标为（0.5，19.5），位于环境模型的左上角。目标节点 T 也用红点表示，其坐标为（19.5, 0.5），位于环境模型的右下角。为公平起见，ACO 变体（ACO、IAACO、IHMACO）的共同参数设置为相同值。具体来说，ACO 和 IAACO 的参数设置为 K &#x3D; 100，M &#x3D; 50，λ &#x3D; 7，k &#x3D; 0.9，Q &#x3D; 2.5，α &#x3D; 1，β &#x3D; 7，σ1 &#x3D; 0.1，σ2 &#x3D; 0.9，Rs &#x3D; 0.5，δ0 &#x3D; 0.15，kL &#x3D; 0.7，kS &#x3D; 0.1，kE &#x3D; 0.2。IAACO 的具体参数可参见文献[54]，如 σ1 和 σ2（距离权系数，σ1 + σ2 &#x3D; 1）、λ（角度引导系数的权系数）、k（调整系数）。建议的 IHMACO 参数设置为 K &#x3D; 100，M &#x3D; 50，ρ0 &#x3D; 0.2，Q &#x3D; 2.5，α &#x3D; 1，β &#x3D; 7，T0 &#x3D; 1，τ0 &#x3D; 1，εq &#x3D; 0.1。这些算法的详细参数见表 7。ACO 及其变体算法独立运行 20 次。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019918.png" alt="image-20240118001900010"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019920.png" alt="image-20240118001917839"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180019661.png" alt="image-20240118001936666"></p>
<p>此外，还采用了六种常用的路径规划算法，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法，与 IHMACO 进行比较。由于这六种常用算法都是确定性搜索算法，它们可以在多次运行中产生相同的解。因此，这六种确定性搜索算法得到的最优路径的最佳值和平均值总是相等的，而且它们只进行一次迭代搜索。表 8 记录并列出了每种算法在 20 次实验中的最佳值、平均值和标准偏差（Std.），产生的最优路径详见图 17-19。此外，收敛速度也是衡量算法效率的一个重要指标，四种改进 ACO 算法的收敛迭代曲线见图 20。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180020868.png" alt="image-20240118002017816"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180020208.png" alt="image-20240118002035030"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180021171.png" alt="image-20240118002106961"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180021865.png" alt="image-20240118002134667"></p>
<p>如表 8 所示，与 ACO 的其他变体相比，IHMACO 的性能最好。具体而言，虽然 IHMACO 的最优路径长度（29.79）与 IAACO 相同，小于 ACO（29.79 &#x3D; 29.79&lt;33.56），但从 “平均值”（29.79&lt;30.12&lt;36.61）和 “标准值”（0&lt;0.3953&lt;3.4189）来看，IHMACO 的性能更稳定。(0&lt;0.3953&lt;3.4189). 众所周知，”平均值 “和 “标准差 “是衡量智能算法总体性能的两个重要指标。IHMACO 产生的”‘Std’’. “值为 0，这意味着 IHMACO 总是能在 20 次独立操作中获得最佳路径长度（29.79）。上述 “平均值 “和 “标准值 “的统计结果证明，IHMACO 在稳定性能和收敛精度方面具有明显的优势。图 20 中的收敛迭代曲线也证明了 IHMACO 的出色稳定性。可以发现，IHMACO 不仅在收敛速度上占优势，而且在 ACO 陷入局部优化的情况下，IHMACO 的 “Std”.代找到了更精确的解，具有明显的优越性。因此，与 ACO 和 IAACO 相比，IHMACO 可以综合考虑长度和转弯次数等因素，在路径规划中取得更好的效果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180023951.png" alt="image-20240118002332815"></p>
<p>与六种常用算法相比，虽然IHMACO的最优路径长度（29.79）与Dijkstra算法、A* 算法、JPS算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和Trace算法（29.79&lt;31.56&lt;32.73）。在其他性能指标方面，IHMACO产生的最优路径的转弯次数均少于Dijkstra算法、A *  算法、Best-First Search算法、Trace算法和Breath-First Search算法。考虑到最优路径的路径长度、收敛生成和转弯时间的综合性能，表 8 中的结果验证了在本实例中，IHMACO 与 ACO、IAACO、Dijkstra 算法、A * 算法、最佳第一搜索算法、跟踪算法和呼吸第一搜索算法相比具有更优的性能。图 17-19 也证明了 IHMACO 更好的性能。事实上，IHMACO 所获得的最优路径的高质量得益于所提出的具有方向判断能力的启发式机制、信息素蒸发率的动态调整，而寻找最优路径的高效率则得益于所提出的改进的伪随机转移策略、自适应信息素浓度设置。</p>
<p>此外，如图 20 所示，考虑到收敛速度和求解精度，IHMACO 的优势更加明显，远远领先于 ACO 的其他变体。IHMACO 的平均收敛代小于 ACO 和 IAACO（5.8&lt;6.4&lt;23.1）。总之，与 ACO、IAACO、Dijkstra 算法、A* 算法、Best-First Search 算法、Trace 算法和 Breath-First Search 算法相比，IHMACO 能以更高的效率获得更好的最优解。为了进一步证明 IHMACO 的优越性，应使用更多的实例和采用更多的方法进行比较。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180023388.png" alt="image-20240118002351376"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180024202.png" alt="image-20240118002411119"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180024160.png" alt="image-20240118002426125"></p>
<h3><span id="432-simulation-experiment-ii">4.3.2. Simulation experiment II</span></h3><p>在这一部分，通过文献[55]中给出的一个智能轮椅的简单路径规划示例来测试 IHMACO 的性能。此外，文献[55]中提出的三种改进型 ACO（IACA、GPACA 和 APACA）、Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法也被用来进行比较。为公平起见，环境模型（20 × 20）的设置与文献[55]相同，如图 21 所示。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。此外，IHMACO、IACA、APACA 和 GPACA 的详细参数见表 9。十种算法的计算结果见表 10，其生成的最优路径见图 2123。图 24 给出了四种 ACO 算法的收敛迭代曲线。如图 21 所示，可以发现 IHMACO 的性能优于 IACA、GPACA 和 APAC。具体而言，在 “最佳 “结果中，IHMACO 获得了最佳路径长度（28.038 &#x3D; 28.038&lt;29.210&lt;30.380）。就 “平均值 “而言，拟议的 IHMACO 得出的结果最佳（28.038&lt;29.184&lt;32.708&lt;35.357）。在 “标准值 “方面，IHMACO 的值为 0，表明在所有比较算法中，IHMACO 的偏差最小，稳定性最好（0&lt;1.0020&lt;4.2827&lt;4.3764）。图 24 中 IACA、GPACA、APAC 和 IHMACO 的收敛曲线也证明了所提出的 IHMACO 具有极佳的稳定性和鲁棒性，其他 ACO 变体在迭代后期缓慢收敛到某个最优解，而 IHMACO 在迭代过程中迅速接近最优解。IHMACO 的迭代次数为 4 次，少于 24 次（IACA）、12 次（GPACA）和 9 次（APACA）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180025380.png" alt="image-20240118002548325"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180026654.png" alt="image-20240118002611565"></p>
<p>与六种确定性搜索算法相比，虽然 IHMACO、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法获得的最优路径长度相同（28.038），但 IHMACO 产生的转弯次数比 Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法最少，如表 10 所示。IHMACO 性能较好的原因在于所提出的机制，包括自适应信息素浓度设置和带有方向判断的启发式机制。图 22-23 也证明了 IHMACO 的优异性能。综上所述，与 IACA 算法、GPACA 算法、APACA 算法、Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法相比，IHMACO 可以获得智能轮椅路径规划实例的最优解。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180026370.png" alt="image-20240118002638036"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180027494.png" alt="image-20240118002700582"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180027786.png" alt="image-20240118002720808"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180028133.png" alt="image-20240118002805119"></p>
<p>如表 11 所示，可以看出 IHMACO 的效率高于 ACO 和 IACO [56]。特别是在路径长度方面，IHMACO产生的最短路径长度为30.9706，小于ACO的39.6985和IACO的31.7990。在其他性能指标方面，IHMACO 产生的转弯次数为 11，是最小的（11&lt;13&lt;17）。图 25 也可以证明 IHMACO 的显著改进性能，可以看出 ACO 和 IACO 都陷入了死锁栅格，导致算法进入局部最优。此外，IHMACO 的最佳收敛代小于 IACO 和 ACO（8&lt;13&lt;62）。IHMACO 的较好结果进一步验证了其在提高全局搜索能力方面的优势，从而提高了 ACO 的收敛精度。与其他六种确定性搜索算法相比，所提出的 IHMACO 比 Best-First Search 算法和 Trace 算法性能更优。最佳第一搜索算法和跟踪算法生成的路径长度较长，且有很多多余的转弯时间。IHMACO 的出色表现表明了所介绍的四种机制的效率。IHMACO 和其他六种确定性搜索算法获得的最优路径如图 26-27 所示，IHMACO 的出色表现进一步证明了其优越性。</p>
<h3><span id="434-simulation-experiment-iv">4.3.4. Simulation experiment IV</span></h3><p>在本节中，文献[57]中提出的一种方法与所提出的 IHMACO 在相同的模拟实验中进行了比较。此外，还采用了另外六种算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。为公平起见，IHMACO 与文献[57]中算法的公共参数设置相同。文献[57]中的算法参数设置为 M &#x3D; 30，K &#x3D; 200，ρ &#x3D; 0.43，Q &#x3D; 100，α &#x3D; 1，β &#x3D; 7，γ &#x3D; 3，γ 表示导向系数。IHMACO 设为 M &#x3D; 30，K &#x3D; 200，ρ0 &#x3D; 0.43，α &#x3D; 1，β &#x3D; 7，T0 &#x3D; 1，Q &#x3D; 100，w1 &#x3D; 0.3，w2 &#x3D; 1。随后，每种算法独立运行 20 次。这八种算法的模拟结果见表 12，其生成的最优路径见图 28-30。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180028301.png" alt="image-20240118002836381"></p>
<p>从表 12 可以看出，虽然 IMHACO 的最优路径长度（29.79）与文献[57]中提出的 Dijkstra 算法、A* 算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和跟踪算法（29.79&lt;31.56 &#x3D; 31.56）。特别是在这些不同算法得到的转弯时间中，IHMACO 可以得到最平滑的路径，转弯时间最少（8），其较好的性能也可以从图 2830 中得到证明。实际上，IHMACO 的主要性能得益于自适应信息素浓度设置的启发式机制、方向判断的启发式机制、改进的伪随机转移策略、信息素蒸发率的动态调整。这四种机制兼顾了 ACO 的全局探索和局部利用能力。总之，考虑到路径长度、收敛生成和转弯时间等综合性能，实验结果表明，在本实例中，IHMACO与文献[57]中提出的算法、最佳第一搜索算法、Dijkstra算法、A*算法、Trace算法和呼吸第一搜索算法相比具有更优越的性能。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180030199.png" alt="image-20240118003025298"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180030336.png" alt="image-20240118003040388"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031122.png" alt="image-20240118003121995"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031525.png" alt="image-20240118003135479"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031777.png" alt="image-20240118003158787"></p>
<h3><span id="435-simulation-experiment-v">4.3.5. Simulation experiment V</span></h3><p>本节使用文献[58]中提出的一个更复杂的路径规划实例进行比较。此外，还采用了 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法进行比较。在这个 30 × 30 空间环境模型中，S 和 T 的坐标分别为（0.5，8.5）和（25.5，28.5）。为了公平起见，文献[58]和 IHMACO 算法的常用参数设置相同。这八种算法的仿真结果见表 13，其生成的最优路径见图 31-33。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180031019.png" alt="image-20240118003105148"></p>
<p>从表 13 中可以看出，与文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法相比，IHMACO 的性能更优。尽管文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、跟踪算法和呼吸优先搜索算法获得的最优路径长度相同，但 IHMACO 能产生较小的转弯时间。JPS 算法的转弯次数略少于 IHMACO，但 IHMACO 无法保证最短路径长度。此外，IHMACO 生成的最优路径长度的 “平均值 “和 “最佳值 “均为 35.63，这表明了 IHMACO 的稳定性。图 31-33 也证明了 IHMACO 的出色性能。总之，IHMACO 的综合结果进一步证明了它在这一复杂环境模型中的优势。事实上，IHMACO 的优异结果得益于所提出的四种机制。</p>
<h2><span id="44-summarization-of-case-study">4.4. Summarization of case study</span></h2><p>在这一部分中，通过一系列实验将 IHMACO 应用于解决路径规划问题。在第一组实验中，采用了几种 ACO 的过渡变体，分别命名为 ACO-1、ACO-2、ACO-3 和 IHMACO，以区分四种机制的有效性。五种算法得到的最优路径和收敛曲线按照 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序逐渐变好，可以得出结论：四种机制对提高 ACO 的性能有一定的作用。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401180034599.png" alt="image-20240118003447101"></p>
<p>在第二组实验中，设计了四种不同的环境模型来评估所提出的 IHMACO 的适应性。与传统 ACO 相比，IHMACO 在路径长度和转弯时间方面更胜一筹。具体而言，IHMACO 在路径转弯时间方面的相对改进率分别为 61.54%、64.71%、55.56% 和 55.56%。而 IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（”Std”. 总之，本实验证明了 IHMACO 在不同环境模型中解决路径规划实例的有效性和适应性。</p>
<p>在第三组实验中，采用了五个实验来比较 IHMACO 与 ACO 的其他变体以及六种常用路径规划算法。具体而言，在所有实验中，IHMACO 的整体性能普遍优于 ACO 的九种变体。在 IHMACO 与六种常用路径规划算法的比较中，就路径长度和转弯时间的综合结果而言，IHMACO 在全部五组仿真实验中普遍优于 Best-First Search 算法和 Trace 算法，在三组实验中优于 Dijkstra 算法，在四组实验中优于 A* 算法，在三组实验中优于 JPS 算法，在三组实验中优于 Breath-First Search 算法。总之，实验结果验证了所提出的 IHMACO 算法的高效性和优越性。</p>
<h2><span id="5-conclusion">5. Conclusion</span></h2><p>本研究提出了一种改进的启发式机制 ACO（IHMACO），以克服传统 ACO 在解决路径规划问题时的不足。首先，提出了一种自适应信息素浓度设置方法，以加强引导能力，避免早期阶段的过度发散。其次，提出了一种新颖的带有方向判断的启发式机制方法，有效增强了搜索目的性和规划路径的平滑性。第三，引入改进的伪随机转移策略，以最大限度地保持全局搜索能力和收敛速度。然后，提出了一种动态调整信息素蒸发率的方法，以增加蜂群的多样性，避免陷入局部最优。随后，进行了一组路径规划的仿真实验，验证了所提算法的适应性和优势。此外，IHMACO 还与现有的九种 ACO 变体和六种常用算法（包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法）进行了比较。由路径长度的’’最佳’’、’’平均’’、’’标准’’组成的实验结果验证了 IHMACO 在最优解搜索能力上的优势，尤其是在转弯次数上明显优于其他算法。总之，所提出的四种机制能有效提高 ACO 的性能，IHMACO 与其他算法相比，具有实用性和高效率的能力，能获得相应路径规划实例的最优解。</p>
<p>然而，IHMACO 的研究和应用仍处于起步阶段，存在一些不足之处，有待进一步研究。例如，与确定性搜索算法相比，IHMACO 的执行时间不具有竞争力，这主要是由算法机制造成的。下一步工作中，将着重提升算法的效率和精度，将其应用于动态空间环境和三维路径规划中求解。此外，还可以建议将 IHMACO 用于其他实际应用中，如管道路由设计，以进一步提高其在实际工程问题中的应用能力。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SUNX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SUNX</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/null"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_43571647?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">C++学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MATLAB/"><span class="level-start"><span class="level-item">MATLAB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/excel%E6%93%8D%E4%BD%9C/"><span class="level-start"><span class="level-item">excel操作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E5%88%9B/"><span class="level-start"><span class="level-item">原创</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路径规划</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="level-start"><span class="level-item">路径规划启发式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">路径规划算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-03T10:45:41.000Z">2024-03-03</time></p><p class="title"><a href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T06:17:52.000Z">2024-03-01</time></p><p class="title"><a href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T08:06:51.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T07:45:43.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/">Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-28T15:35:45.000Z">2024-02-28</time></p><p class="title"><a href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%AD%A6%E4%B9%A0/"><span class="tag">C++学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLion%E5%AE%89%E8%A3%85/"><span class="tag">CLion安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GDAL/"><span class="tag">GDAL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hierachical/"><span class="tag">Hierachical</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MAPF/"><span class="tag">MAPF</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Q1/"><span class="tag">Q1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XTDrone/"><span class="tag">XTDrone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pandas/"><span class="tag">pandas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82/"><span class="tag">分层</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"><span class="tag">分层方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"><span class="tag">原文翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"><span class="tag">可视图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="tag">启发式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">图论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"><span class="tag">多智能体</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="tag">离散数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"><span class="tag">维诺图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%BC%E8%BF%B0/"><span class="tag">综述</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a><p class="is-size-7"><span>&copy; 2024 SUNX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>