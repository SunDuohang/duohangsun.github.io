<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SUNX的记录</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SUNX的记录"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SUNX的记录"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天的天气不错"><meta property="og:type" content="blog"><meta property="og:title" content="SUNX的记录"><meta property="og:url" content="https://duohangsun.gitee.io/"><meta property="og:site_name" content="SUNX的记录"><meta property="og:description" content="今天的天气不错"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://duohangsun.gitee.io/img/og_image.png"><meta property="article:author" content="SUNX"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://duohangsun.gitee.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://duohangsun.gitee.io"},"headline":"SUNX的记录","image":["https://duohangsun.gitee.io/img/og_image.png"],"author":{"@type":"Person","name":"SUNX"},"publisher":{"@type":"Organization","name":"SUNX的记录","logo":{"@type":"ImageObject","url":"https://duohangsun.gitee.io/img/logo.svg"}},"description":"今天的天气不错"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?69225dadb01d44aae3f8c4f29649a59d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">目录</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub" href="/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-17T00:54:08.000Z" title="2024/1/17 08:54:08">2024-01-17</time>发表</span><span class="level-item"><time dateTime="2024-01-17T01:00:01.245Z" title="2024/1/17 09:00:01">2024-01-17</time>更新</span><span class="level-item">10 分钟读完 (大约1530个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/17/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%9C%B0%E5%9B%BE/">路径规划地图</a></p><div class="content"><h1><span id="路径规划地图">路径规划地图</span></h1><p>In robot path planning, various types of maps are used to represent the environment and assist in the navigation process. Each type of map provides a different way to model the space and the obstacles within it, and the choice of map can depend on the specific requirements of the application, such as the complexity of the environment, the level of precision needed, and the computational resources available. Here are some of the common types of maps used in robot path planning:</p>
<ol>
<li><p><strong>Grid Maps (Occupancy Grids):</strong></p>
<ul>
<li>Represent the environment as a grid of cells.</li>
<li>Each cell indicates whether it is occupied, free, or unknown.</li>
<li>Suitable for indoor environments and structured spaces.</li>
</ul>
</li>
<li><p><strong>Topological Maps:</strong></p>
<ul>
<li>Represent the environment as a graph of nodes and edges.</li>
<li>Nodes represent specific places or landmarks, and edges represent the paths between them.</li>
<li>Focus on the connectivity of the space rather than detailed geometry.</li>
</ul>
</li>
<li><p><strong>Geometric Maps:</strong></p>
<ul>
<li>Use geometric primitives (lines, polygons, etc.) to represent the shapes and locations of obstacles.</li>
<li>Can provide a more accurate representation of the environment than grid maps.</li>
</ul>
</li>
<li><p><strong>Feature-Based Maps:</strong></p>
<ul>
<li>Constructed using distinct environmental features detected by sensors (corners, edges, etc.).</li>
<li>Useful for localization and navigation based on recognizable landmarks.</li>
</ul>
</li>
<li><p><strong>Semantic Maps:</strong></p>
<ul>
<li>Include labels or annotations that provide additional information about the environment (e.g., “kitchen,” “office”).</li>
<li>Useful for tasks that require context about the environment, not just geometry.</li>
</ul>
</li>
<li><p><strong>Voronoi Diagrams:</strong></p>
<ul>
<li>Partition the environment based on the nearest obstacle, creating a graph that can be used for path planning.</li>
<li>Paths on a Voronoi diagram maximize the distance to the nearest obstacles, which can be useful for safe navigation.</li>
</ul>
</li>
<li><p><strong>Visibility Graphs:</strong></p>
<ul>
<li>Nodes represent the corners of obstacles, and edges represent lines of sight between nodes.</li>
<li>Useful for finding the shortest path in an environment with polygonal obstacles.</li>
</ul>
</li>
<li><p><strong>Probabilistic Roadmaps (PRMs):</strong></p>
<ul>
<li>Consist of randomly placed nodes in the configuration space and edges that represent valid movements between these nodes.</li>
<li>Particularly useful for high-dimensional spaces and complex environments.</li>
</ul>
</li>
<li><p><strong>Rapidly-exploring Random Trees (RRTs):</strong></p>
<ul>
<li>Incrementally build a tree by randomly expanding towards unexplored areas of the map.</li>
<li>Suitable for real-time path planning and exploration in unknown or dynamic environments.</li>
</ul>
</li>
<li><p><strong>Configuration Space (C-Space) Maps:</strong></p>
<ul>
<li>Represent the space of all possible positions and orientations of the robot.</li>
<li>Useful for understanding the robot’s movement capabilities and constraints.</li>
</ul>
</li>
<li><p><strong>Elevation Maps:</strong></p>
<ul>
<li>Represent the terrain with a 2.5D map that includes the height of the environment at each point.</li>
<li>Important for outdoor robots or those operating in uneven terrain.</li>
</ul>
</li>
<li><p><strong>3D Maps and Point Clouds:</strong></p>
<ul>
<li>Use three-dimensional models of the environment, often constructed from data collected by 3D sensors like LIDAR.</li>
<li>Provide a detailed representation of the environment for navigation in three dimensions.</li>
</ul>
</li>
</ol>
<p>Each type of map has its own strengths and weaknesses and can be used alone or in combination with others to achieve effective path planning for robots. The choice of map is influenced by factors such as the robot’s sensors, the environment’s complexity, and the computational resources available.</p>
<h2><span id="grid-map">Grid map</span></h2><p>A grid map is a type of data structure commonly used in robotics, computer graphics, and geographic information systems (GIS) for spatial representation and navigation. It is a discretized representation of a space where the environment is divided into a grid of cells, each of which represents a portion of the environment.</p>
<p>Here’s how a grid map is typically constructed and used:</p>
<ol>
<li><p><strong>Discretization:</strong> The space is divided into a uniform grid of cells. Each cell corresponds to an area in the environment and can be in one of several states, such as free, occupied, or unknown.</p>
</li>
<li><p><strong>Representation:</strong> Each cell in the grid can hold different types of information. In the simplest case, a binary value is used, with ‘0’ indicating a free space and ‘1’ indicating an obstacle. In more complex implementations, cells can store additional information such as the probability of occupancy, cost of traversal, or height.</p>
</li>
<li><p><strong>Navigation and Pathfinding:</strong> Grid maps are often used in pathfinding algorithms, where the goal is to find a path from one point to another while avoiding obstacles. Algorithms like A*, Dijkstra’s, or various other search algorithms can be applied to grid maps to determine the shortest or least costly path.</p>
</li>
<li><p><strong>Sensing and Updating:</strong> In robotics, grid maps are frequently updated in real-time using sensor data. As a robot explores an environment, it uses sensors like LIDAR, sonar, or cameras to detect obstacles and free space, updating the grid map accordingly.</p>
</li>
</ol>
<p>Grid maps have several advantages:</p>
<ul>
<li>They are simple and easy to implement.</li>
<li>They provide a clear and intuitive representation of space.</li>
<li>They are compatible with many well-established pathfinding algorithms.</li>
</ul>
<p>However, grid maps also have some limitations:</p>
<ul>
<li>The resolution of the grid determines the precision of the map. Higher resolutions can capture more detail but require more memory and computational power.</li>
<li>The representation is typically limited to two dimensions, although three-dimensional grid maps are also possible (often called voxel maps).</li>
<li>They may not be efficient for large, open environments where much of the space is empty, as they do not compress or scale well in such cases.</li>
</ul>
<p>In summary, grid maps are a foundational tool in areas that require spatial representation and are particularly useful for navigation and path planning in discretized environments.</p>
<p>栅格地图是一种数据结构，通常用于机器人、计算机制图和地理信息系统（GIS）的空间表示和导航。它是空间的离散化表示，其中环境被划分为一个个栅格单元，每个单元代表环境的一部分。</p>
<p>下面是栅格地图的典型构造和使用方法：</p>
<ol>
<li><p><strong>离散化：</strong> 空间被划分为统一的栅格单元。每个单元格对应环境中的一个区域，可以处于空闲、被占用或未知等几种状态之一。</p>
</li>
<li><p><strong>表示法：</strong> 栅格中的每个单元格可以保存不同类型的信息。最简单的情况是使用二进制值，”0 “表示自由空间，”1 “表示障碍物。在更复杂的情况下，单元格可以存储更多信息，如占用概率、穿越成本或高度。</p>
</li>
<li><p><strong>导航和寻路：</strong> 栅格地图通常用于寻路算法，其目标是找到一条从一点到另一点的路径，同时避开障碍物。A*、Dijkstra’s 等算法或其他各种搜索算法都可应用于栅格地图，以确定最短或代价最小的路径。</p>
</li>
<li><p><strong>传感和更新：</strong> 在机器人技术中，栅格地图经常利用传感器数据进行实时更新。机器人在探索环境时，会使用激光雷达、声纳或摄像头等传感器探测障碍物和自由空间，并相应地更新栅格地图。</p>
</li>
</ol>
<p>栅格地图有几个优点：</p>
<ul>
<li>它们简单且易于实现。</li>
<li>可清晰直观地显示空间。</li>
<li>与许多成熟的寻路算法兼容。</li>
</ul>
<p>不过，栅格地图也有一些局限性：</p>
<ul>
<li>栅格的分辨率决定了地图的精度。更高的分辨率可以捕捉到更多的细节，但需要更多的内存和计算能力。</li>
<li>虽然也可以绘制三维栅格地图（通常称为体素地图），但其表示方法通常仅限于二维。</li>
<li>对于大部分空间都是空的大型开放环境来说，网格地图可能并不有效，因为在这种情况下，网格地图不能很好地压缩或缩放。</li>
</ul>
<p>总之，栅格地图是需要空间表示的领域的基础工具，尤其适用于离散环境中的导航和路径规划。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-10T16:53:51.000Z" title="2024/1/11 00:53:51">2024-01-11</time>发表</span><span class="level-item"><time dateTime="2024-01-16T13:49:43.746Z" title="2024/1/16 21:49:43">2024-01-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></span><span class="level-item">1 小时读完 (大约10053个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/11/Classical-and-Heuristic-Approaches-for-Mobile-Robot-Path-Planning-A-Survey/">Classical and Heuristic Approaches for Mobile Robot Path Planning A Survey</a></p><div class="content"><h1><span id="classical-and-heuristic-approaches-for-mobile-robot-path-planning-a-survey">Classical and Heuristic Approaches for Mobile Robot Path Planning: A Survey</span></h1><p>作者：Jaafar Ahmed Abdulsaheb and Dheyaa Jasim Kadhim *</p>
<p>摘要： 机器人学最重要的研究领域是导航算法。机器人路径规划（RPP）是指在移动机器人移动前为其选择最佳路径的过程。寻找理想或接近理想的路径被称为 “路径规划优化”。其目标是找到满足单个或多个目标（如最短、最平滑和最安全的路径）的最佳解决方案值。本研究旨在概述移动机器人的导航策略，这些策略采用了三种经典方法，即 路线图方法（RM）、单元分解（CD）和人工势场（APF），以及十一种启发式方法，包括遗传算法（GA）、蚁群优化（ACO）、人工蜂群（ABC）和灰狼优化（GWO）、 蛙跳算法 (SFLA)、鲸鱼优化算法 (WOA)、细菌觅食优化 (BFO)、萤火虫算法 (FF)、布谷鸟搜索 (CS) 和蝙蝠算法 (BA)。本研究中介绍的不同文章涉及多个问题，包括动态目标、静态和动态环境、多机器人、实时模拟、运动学分析和混合算法。在本作品的最后将进行讨论，并提供详尽的表格和图表，以帮助读者了解开发了哪些类型的路径规划策略，可用于各种生态环境。因此，本作品的主要贡献在于，它为机器人路径规划提供了一个广阔的视角，这将为科学家们在不久的将来研究这一课题提供更多便利。</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>机器人是一种能够对周围环境做出反应，并（通过传感器）收集环境信息，从而安全执行各类任务的机器。自主机器人可以在没有人类直接控制的情况下自行操作和移动。与制造工厂中使用的机器人不同，在制造工厂中，机器人所处的环境受到严格控制且完全已知，而自主机器人则不可能总是通过编程来执行预定义的动作，因为机器人不可能预测可能遇到的各种情况。此外，环境可能是不可预测的，也可能随着时间的推移而发生变化，这就意味着机器人的动作必须在线快速改变[1]。自主机器人的应用包括医院的快递员、保安、军事监控、航空航天研究、环境监测、清洁工和割草机。一般来说，最重要的应用之一是在危险领域（如雷区或核电站内部）使用自主移动机器人。由于移动机器人与生俱来的自主性，必须克服一系列挑战，包括不确定性、感知误差、规划、学习、可靠性和实时响应[2]。机器人需要动态响应变化并适应环境。</p>
<p>机器人路径规划学科的雏形可以追溯到 20 世纪 60 年代中期。机器人路径规划问题，通常称为机器人路径规划（RPP），是移动机器人导航领域的一个重要问题。&#x3D;&#x3D;其目标是确定在指定环境中，从预定位置出发，以目标目的地为终点，没有任何碰撞的最佳路径。&#x3D;&#x3D;一般来说，机器人有无数条路线可以到达目的地，但最佳路线实际上是根据一系列规则来选择的。最广泛使用的标准是距离最短、耗能最少或时间最短、距离最短。由于路径规划的目标是找到最短路径，同时牢记给定环境和无碰撞运动等约束条件，&#x3D;&#x3D;因此可以将其视为一个优化问题[3]&#x3D;&#x3D;。移动机器人的地图、定位和导航可以通过环境模型来实现。然而，这些模型中的数据量必须易于管理，并能满足实时计算的要求。机器人领域一个非常棘手的问题是机器人路径的规划。主要目标是在不撞到任何东西的情况下，找到一条从起点到终点的路线。&#x3D;&#x3D;在解决机器人导航问题时，必须考虑三个关键问题：效率、安全性和准确性。效率要求算法避免让机器人多走几步或反复停下来转弯，这样会浪费时间和精力，以便在最短的时间内确定最短的距离。安全性和准确性取决于找到一条不会撞到任何东西的路径，同时保持在该路径附近[4]。&#x3D;&#x3D;机器人导航问题可分为定位、路径规划、运动控制和认知映射，如图 1 所示。路径规划可能是机器人导航最重要的方面 [5]。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401110955430.png" alt="image-20240111013711561"></p>
<p>根据其所在位置[6]，区域淘汰计划可分为两类：</p>
<p>(a) 在静态环境中遇到固定障碍物时的 RPP。<br>(b) 在动态环境中面对静止和移动障碍物时的 RPP。</p>
<p>这两类中的每一类又可细分为一个子群。&#x3D;&#x3D;全局路径规划&#x3D;&#x3D;，即环境中的机器人可以在开始移动之前（离线）规划好整体路径，因为它们掌握了静止障碍物的完整信息，而移动障碍物的轨迹也是事先已知的。由于设置新地图具有挑战性，因此全局导航中环境变化的成本非常高，尤其是在动态环境中。无法利用完整的环境知识规划本地路线是本地路径规划的一个局限。移动机器人在环境中移动时，会使用传感器收集信息（在线）。机器人必须反复移动到新的位置，感知周围环境，更新地图，规划下一步行动路线，从而绘制出周围环境的地图。局部路径规划面临着一系列挑战，包括传感器读数误差、传感器约束、多变的环境条件、机器人动力学、位置估计和机器人运动限制等[6]。在极其复杂和广阔的环境中，本地路径规划可能无法确定通往目标的路径。出现这种情况的主要原因是传感器无法提供足够的数据，将机器人送至理想位置[7]。机器人的基本位置、旋转以及整个链路的旋转或平移称为机器人的配置。所有可能配置的集合构成了配置空间或 c 空间，它需要几个元素：</p>
<ol>
<li><p>描述机器人的形状，如是否有腿、轮子或没有四肢（运动）。</p>
</li>
<li><p>解释机器人所处的环境，包括其几何形状（二维或三维工作空间）。</p>
</li>
<li><p>环境必须有一个起点和目标配置，必须在这两个配置之间规划机器人的路径。</p>
</li>
</ol>
<p>一些参数用于描述机器人的工作空间配置。例如，两个参数（通常称为 x 和 y）可用于描述机器人的配置，将其转换为二维工作空间。机器人工作区内的障碍物会阻止某些配置的使用。例如，配置为 C 的机器人如果与工作区的任何障碍物发生碰撞，就会被禁止使用。由此，配置空间 C 被划分为一组禁止配置 C forbited 和一组允许配置 C free。一般来说，路径被定义为一个连续函数 π : [ 0, L ] → C，以路径的长度 L 为参数。路径规划问题是在给定的起点配置 s∈C 和目标配置 g∈C 之间找到一条无（碰撞）路径。就配置空间 C 而言，通过找到一条路径 π，使 π ( 0 ) &#x3D; s 和 π ( L ) &#x3D; g，并且 ∀(t∈ [ 0, L ] :π ( t )∈C f ree ) [8]。绘制地图是构建环境模型的过程。为了绘制出足够精确的地图，显示机器人沿途所见，必须准确显示地形。有不同类型的地图可用于表示环境。其中一些使用栅格，栅格中的单元格要么是空的，机器人可以在其中自由行进，要么是被占满的，以表示障碍物，如图 2 所示。如图 3 所示，其他人使用二维（或三维）矩形或正方形工作空间，障碍物为多边形。</p>
<p>许多研究人员都提交了有关移动机器人导航的调查论文[9-11]；然而，这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在发现特定领域的研究空白和创新范围。它深入分析了静态环境中的单个算法、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合，以及在三维（3D）环境中的应用。</p>
<p>调查还强调了传统方法和反应式方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。在参考文献[9]中，该方法仅限于路径计算。[9]中，该方法仅限于三维路径规划，而参考文献 [10]综述了适用于各种机器人类型（包括空中、地面和水下机器人）的多机器人路径规划方法和决策策略。参考文献 [11 [11]主要研究了移动机器人路径规划的多目标优化算法。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001404.png" alt="image-20240111100109345"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401111001670.png" alt="image-20240111100135547"></p>
<p>本综述编排如下： 第 2 节讨论机器人路径规划技术，第 3 节讨论移动机器人导航建模，第 4 节是讨论。</p>
<h2><span id="2-robot-path-planning-techniques">2. Robot Path Planning Techniques</span></h2><p>机器人的路径需要优化以满足某些标准，因此路径规划问题是一种优化问题。过去几十年来，优化算法的研究吸引了众多研究人员的关注。优化方法和算法分为确定性和随机性两类 (12]。&#x3D;&#x3D;随机方法更善于发现各种目标函数的全局最优解，而确定性方法则依赖于问题的数学属性。&#x3D;&#x3D;相反，随机方法并不依赖于特定函数的数学属性，如参考文献[13]所述。然而，最初的方法也存在一些局限性，包括依赖梯度、容易出现局部最优、在&#x3D;&#x3D;搜索大规模空间时效率低下&#x3D;&#x3D;，以及无法处理离散函数。基于随机过程的技术被认为具有更高的用户友好性。由于现实世界中许多优化问题的复杂性，特别是在优化无差别、多模态和离散复杂函数时，随机方法是必要的–这些算法已被发现优于基于梯度的经典方法。这些受自然启发的范式目前正被广泛应用于众多工程领域 [14]。这些技术已被证明是可靠而强大的搜索方法。</p>
<p>多年来，众多科学家和研究人员提出了各种导航方法。移动机器人的导航方法大致可分为两类：经典方法和启发式方法（图 4）。&#x3D;&#x3D;经典方法存在一些缺陷，导致其在实际应用中效果不佳，包括高维度下的高时间复杂性问题和陷入局部极小值的现象，这些都是该领域的重大问题。&#x3D;&#x3D;启发式方法优于传统方法，并因 PP 问题的 NP 难度而广受欢迎。启发式技术在解决涉及多维度、复杂工作空间和局部极小值的问题方面也取得了成功，因此越来越受欢迎[15]。在下面的研究小节中，我们将考察一组使用经典方法和启发式方法寻找最佳单目标或多目标路径规划的科研成果。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160852835.png" alt="image-20240116085249597"></p>
<h2><span id="21-classical-approaches">2.1. Classical Approaches</span></h2><p>我们将在下文中讨论用于寻找最佳单目标或多目标路径的三种经典方法：</p>
<ol>
<li>路线图（可视图 [16]；沃罗诺图 [17]）： 如图 5 所示，路线图方法（RM）涉及将自由 C 空间重新制定、缩小或映射到一维工作空间。Salzman 研究了 RM 在自主移动机器人导航中的应用[18]。在规划阶段，机器人的配置空间是随机生成的，会产生特定数量的节点。然后，在确保路径不与任何障碍物相交的前提下，通过直线连接节点对来构建路线图。根据规划阶段获得的结果，查询阶段设计出一条连接初始配置和目标配置的路径。如参考文献[19]所述，对 Voronoi 图的有效路径规划进行了改进，以优化其性能并减少突然转向和扩展环路等问题。如参考文献[20]所述，通过采用一种混合方法，将可视图、沃罗诺伊图和势场技术相结合，确定最佳路径。学者们强调，这种方法无法确定最佳路径，在实施过程中也面临挑战。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401160857115.png" alt="image-20240116085749819"></p>
<p>Yang 等人（21）采用骨架图和维诺图等技术，有效地制定了路线战略。Wein 等人[22]提出了一种新方法，它将可视图和维诺图整合在一起，以确定最佳路线。&#x3D;&#x3D;Kavraki 等人在他们的工作（23）中展示了概率在机器人运动中的应用，目的是理解和产生路径规划解决方案。然而，该方法在获得理想路径长度方面效果不佳。Sanchez 等人（24）利用概率路线图方法对概率路径规划稍作修改，改进了最短路径确定方法（PRM），提出了懒碰撞检查策略作为实际路径规划问题的解决方案。&#x3D;&#x3D;Yan 等人（25）成功测试了无人飞行器在三维环境中的导航能力。这种方法同时使用概率公式和路线图来确定飞行路径。一种在动态环境中避开障碍物的创新路径规划算法被称为 “时间-PRM”（26）。通过在原始概率路线图（PRM）中加入时间概念，该算法创建了一个可有效查询的增强结构。</p>
<p>Huang 等人在（27）中介绍了利用启发式机器人在线路径规划（HIRO）的方法，与传统方法相比，无论机器人是否事先了解环境，该方法都能显著加快发现无碰撞路径的速度。为了快速寻找路径，HIRO 同时采用了知情启发式和确定性路线图。概率路线图（PRM）因其简单易行而被广泛应用于移动机器人导航。&#x3D;&#x3D;当环境中存在狭窄通道时，概率路线图的效率就会大大降低。&#x3D;&#x3D;Zhang 等人 [28] 提出了一种改进的基于势场的概率路线图算法。在具有大量复杂约束和高维度的环境中，概率路线图（PRM）可以成功地解决路径规划问题。其缺点是在狭窄空间和动态环境中的路径规划质量和效率较差。最后，You 等人[29] 建议使用动态 PRM 混合势场来规划移动机器人在多维环境中的路径。</p>
<ol start="2">
<li>单元分解（Cell decomposition CD）[30]： 为了确定连接初始配置和目标配置的路径，无障碍配置空间被划分为一系列单元格。如图 6 所示，在开始单元和终止单元之间建立连接以及随后通过一系列中间单元建立连接决定了单元关系。Samet [31] 和 Noborio [32] 提出了利用四叉树进行分解的方法。大的栅格单元分割环境；然而，当一个栅格单元只填满一部分时，它就会被分解成四个相同大小的小部分，直到填满为止。该系统的缺陷在于，当有新信息（如障碍物的位置）出现时，它无法更新程序，因此在动态环境中效果不佳。&#x3D;&#x3D;Lingelbach [33] 证明了路径规划的高维静态配置问题是存在的&#x3D;&#x3D;。他为类似链条和迷宫的机器人平台找到了路径规划问题的解决方案。利用基于 CAD 的数据，Sleumer 等人[34]提出了一种移动机器人的路径规划策略。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161004274.png" alt="image-20240116100419776"></p>
<p>Cai 等人 [35]的研究表明，使用传感器的粗糙 cell decomposition 可以将复杂环境中的许多固定目标分成不同的组。在静态环境中，所开发的方法效果最佳，因为它能选择最短的路线并覆盖整个环境。Dugarjav 等人（36）利用基于传感器的 CD 模型仍然适用于处理移动机器人不熟悉的直线工作空间。他们利用 CD 策略和激光扫描机制绕过了不熟悉的位置和物体。&#x3D;&#x3D;Glavaski 等人[37]提出了一种混合方法，以解决路径规划问题中理论进展与实际考虑之间的差异。为了减少计算费用，他们开发了一种基于 APF 方法的精确 CD 路径规划器。&#x3D;&#x3D;Tunggal 等人 [38] 介绍了如何利用 CD 和模糊逻辑来实现不确定性环境中的实时运行。</p>
<p>Mark 等人[39]的论文旨在阐明贪婪深度优先搜索算法和利用遗传算法 (GA) 的 CD 技术的机理，目的是规划机械手系统的三维路径。Gonzalez 等人[40] 通过改变图权重、航点计算方法和 CD，对路径进行了定量分析。Wahyunggoro 等人[41]介绍了利用 CD 方法探索三维环境在空中导航问题上的应用。在该方法中，CD 方法和模糊逻辑一起用于引导和控制航空飞行器。[42] 与垂直（VCD）算法相比，径向 CD（RCD）算法能产生更短的路径。&#x3D;&#x3D;杂乱环境和走廊环境都能从 RCD 算法中受益。RCD 在路径长度和处理时间方面的有效性得到了仿真结果的支持。&#x3D;&#x3D;</p>
<ol start="3">
<li>人工势场（APF）： 如图 7 所示，本方法涉及一个配置空间，该空间由两种不同的力组成，一种是排斥力，其作用方式是将机器人从障碍物中驱逐出去；另一种是吸引力，其作用方式是将机器人引向所需的目标配置。Khatib (43) 是 1986 年将 APF 方法引入移动机器人导航的先驱。按照他的说法，目标和障碍物就像通电的表面，机器人受到由它们的势能总和产生的假想力的作用。这个假想力（如图 7 所示）将机器人推向所需的方向，使其不会冲向障碍物。在这里，机器人沿着负梯度绕过障碍物，到达理想位置。Garibotto 等人[44]介绍了这种方法在移动机器人导航中的应用。Kim 等人（45）讨论了一种利用 APF 在未开发环境中避开障碍物的新技术。为了绕过局部最小值的问题，他们使用了谐函数。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161017039.png" alt="image-20240116101702985"></p>
<p>Borenstein 等人[46] 提供了另一种解决局部最小条件问题的方法。他们在研究中考虑了机器人的动态导航特性。在参考文献[47,48]中，对动态避障背景下的 APF 进行了研究。通过利用静电定律，APF 方法在某些方面得到了改进[49]，利用静电可以产生势函数并即时确定无碰撞路径。在实时环境中，移动时避开障碍物是一项艰巨的任务；因此，Huang [50] 开发了一种控制速度的方法，以确定障碍物的位置和移动方式。&#x3D;&#x3D;Shi 等人[51] 提出的 “超强势能 “和 “超强排斥势能 “指的就是这两种功能，以防止局部最小值并达到全局最大值。&#x3D;&#x3D;Sfeir 等人[52]研究了移动机器人的导航问题，该问题可通过采用振荡和冲突等 APF 技术来解决。他们改变了 APF，使其在目标靠近障碍物时不易发生振荡和产生问题。</p>
<p>Pradhan 等人[53]使用 ROBOPATH 仿真工具测试了人工势场的适用性。人工势场法被认为是最流行的路径规划技术之一。为了解决无法到达目标的问题，文章[54]增强了斥力场函数。当它陷入陷阱时，它会选择一个虚拟目标点来帮助它解脱。文章[55]的主题是将人工势场方法应用于环境数据不可知的静态障碍物。通过 MATLAB 仿真证明，改进后的人工势场方法偶尔可以绕过局部极小值，顺利到达目的地。Shi 等人[56]涉及多智能体编队避障控制，研究了步长对路径规划的影响，并提出了两种使路径更高效的方法。&#x3D;&#x3D;知情快速探索随机树星（RRT*）算法会进行质量检查，并重新优化采样路径&#x3D;&#x3D;。Liu 等人提出了一种更有效的 APF 局部避障路径规划算法[57]。根据仿真结果，该算法提高了动态避障的稳定性，改进后的势场法得到的航向角变化减少了 84%。该算法可应用于车辆的实时避障。</p>
<p>随后，又有人尝试改进这些经典方法，如概率路线图（PRM）和快速探索随机树（RRT*）。此外，还出现了结合经典方法和启发式方法的混合方法，以利用两种技术的优势（模拟退火（SA）与人工势场（APF）[58]）。&#x3D;&#x3D;启发式方法旨在克服传统方法的局限性，如陷入局部最小值的问题。&#x3D;&#x3D;以下各小节列出了其中一些启发式方法：</p>
<h2><span id="22-heuristic-approaches">2.2. Heuristic Approaches</span></h2><p>我们将在下文中讨论十一种用于寻找最佳单目标或多目标路径的启发式方法：</p>
<ol>
<li>遗传算法（GA）： 这是一种著名的基于搜索的优化工具，秉承了 1958 年布雷默曼[59]对遗传学和自然选择的发现。1975 年，Holland [60] 首次将其引入计算机科学领域。机器人导航只是目前广泛应用的众多科技领域之一。机器人导航是科学和技术领域的一项普遍应用。该主题涉及复杂问题的优化，这些问题要求在遵守预先设定的约束条件的同时，实现目标函数的最大化或最小化。这种方法涉及将由具有独特遗传特征的个体组成的群体分配到特定问题中。随后，种群中的每个成员都会被分配一个由目标函数决定的适应度分数。根据个体的适应度值选择个体，并允许个体与后代进行交叉，以确保遗传物质的传递。变异可防止过早趋同，并保持群体的多样性。</li>
</ol>
<p>如果种群已经收敛，则算法结束。&#x3D;&#x3D;遗传算法具有一定的随机性，但由于它也可以使用历史数据，因此其性能优于随机局部搜索。&#x3D;&#x3D;GA 的一般流程图如图 8 所示。机器人技术的难点之一是多机器人路径规划。&#x3D;&#x3D;Kala [61] 借助 GA 探讨了多移动机器人的路径规划策略。通过他的研究，研究人员开发出一种有效的方法来协调多个机器人，以避免在静止环境中发生碰撞。参考文献[62]对静态环境下的多目标策略进行了说明。&#x3D;&#x3D;[62] 针对静态环境，类似于多机器人路径规划。Yang 等人[63] 解决了动态环境中多移动机器人系统导航的问题。他们展示了在存在静态和移动障碍物时的结果。一些研究表明，&#x3D;&#x3D;GA 具有一定的局限性，如收敛速度慢、无法保证获得最优解、选择突变率和种群规模参数的方法繁琐等。&#x3D;&#x3D;</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161034489.png" alt="image-20240116103439016"></p>
<p>Hong 等人[64]提出了改进的遗传算法路径规划器，其中包含了基于种群的机器人导航协同评估机制。通过应用改进的遗传算法，作者证明了在陌生环境中运行的多机器人系统在避障和路径优化方面的仿真结果得到了增强。建军等人[65] 提出了一种不同的用于路径优化的改进型遗传算法，为了达到最佳效果，他们的方法修改了染色体的长度。GA 方法被用于仿人机器人（66）的二维路径规划以及水下机器人（67）和空中机器人（68）的三维路径规划问题，因为它能有效地适应环境（包括已知环境和未知环境）。&#x3D;&#x3D;Patle 等人 [69] 针对单机器人和多机器人系统，开发了一种利用二进制代码的基于矩阵的 GA（MGA）来解决移动目标问题。&#x3D;&#x3D;在这种方法中，机器人可以快速、轻松地跟随移动目标和障碍物到达目的地。</p>
<p>Creaser 等人（70）展示了一个结合了模糊逻辑和 GA 方法的导弹控制演示。在为导弹创建制导法则的过程中，GA 起着至关重要的作用。Lin 等人（71）介绍了一种基于 GA 的军事和海洋监测创新方法。在 GA 的帮助下，他们能够确保关键军事资产的安全，并确定水下传感器网络的最佳定位策略。[72]的作者试图找到一种机器人路径规划问题的解决方案，以解决收敛速度慢和局部最优容易衰减的问题，并提出了一种基于种群多样性水平评估的自适应选择技术。为了证明该算法的可行性和有效性，我们在栅格环境中进行了多次仿真。在改进种群初始化方法后，(73) 采用双向 RRT 算法替换部分种群，以创建精英种群。结果表明，本文提出的精英种群遗传算法弥补了传统遗传算法的缺陷。</p>
<ol start="2">
<li>蚁群优化（ACO）： 1992 年，马可-多里戈（Marco Dorigo）在论文中提出了这一群体智能算法（74]。为了解决组合优化问题，该算法采用了基于种群的方法。蚂蚁群从巢穴到食物来源的有效导航是 ACO 算法的灵感来源（图 9）。ACO 算法已在许多科学和工程领域得到应用，包括图着色、二次赋值问题、车辆路由、旅行推销员问题、作业车间调度等。关正等人[75]将 ACO 应用于移动机器人的实时路径规划。与 GA 等其他算法相比，ACC 算法在动态收敛行为、解的变化、收敛速度和计算效率等方面都有所提高。Liu 等人（76）介绍了 ACO 在多移动机器人导航中的应用。他们为静止环境中的不同机器人系统提供了一种避免碰撞的方法。为了增强选择性策略，他们使用了一个特殊函数。当蚂蚁遇到死角时，会对轨迹强度施加惩罚函数，以防止机器人的路径无法移动。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161039669.png" alt="image-20240116103909463"></p>
<p>Castillo 等人[77] 提出了一种基于 ACO-模糊的混合方法，用于移动机器人在静态环境中的导航。Kumar 等人(78) 提出了一种基于 RA-ACO 的方法，用于仿人机器人在杂乱环境中的导航。他们使用 Petri 网测试了所提出的用于多个仿人机器人实时导航的方法，发现仿真结果与实时结果之间具有良好的一致性。Liu 等人[79]就如何调整当前的 ACO 方法以便在静态环境中更好地工作提出了建议。当蚂蚁趋向于更高的效率子空间时，模式的搜索空间会缩小，沿当前路径的信息素会向势场力的方向扩散。他们结合信息素扩散和几何局部优化找到了最佳路径。Rajput 等人（80）针对动态环境提出了另一种修改方法。为了防止无意义的循环并实现更快的收敛，他们还提出了一种新颖的信息素更新技术。Purian 等人（81）将 ACO 算法应用于未知动态环境中的移动机器人导航。在模糊规则的选择和优化方面，他们使用了 ACO。</p>
<p>Brand 等人在（82）中比较了模拟和真实世界中移动机器人在相同环境下的运行情况。Liu 等（83）提出的水下机器人三维路径规划方案使用了一种基于 ACO 的搜索算法来寻找从一个位置到另一个位置的无碰撞路径。Chen 等人也提出了 ACO 算法（84）。利用强化学习可以解决无人驾驶飞行器在战场上确定最佳路径的问题，从而解决原始蚁群算法搜索速度慢和停滞不前的问题。蚁群算法还被应用于军事硬件。Gao 等人[85]将蚁群算法用于导弹路线规划时，发现其性能有所提高，包括最优路线长度和更快的收敛速度。Zong 等人(86) 建议使用改进的蚁群算法为移动机器人规划路径。该算法的信息素更新机制具有加速收敛的能力。大量模拟实验的结果表明。 </p>
<p>通过修改通往目标点的路径，可以显著提高蚁群算法的收敛性 [87]。节点数量减少，更能满足机器人运动的需要。焊接路径的长度直接影响自动线的工作时间和生产效率 [87]。针对传统路径规划方法不适合多目标点的问题，提出了一种基于（ACO）算法的路径规划方法。虽然路径太长，转弯太多 [88]，但基本的蚁群算法（ACO）很容易进入局部最优。改进后的 ACO 会在地图上没有障碍物的区域随机设置可行走的位置点。对于移动机器人，提出了一种基于进化优化的自主路径规划方法。</p>
<ol start="3">
<li>粒子群优化（PSO）： 这种元优化方法从野生动物（如鱼群和鸟群）中获取群体动力学的线索。它是由 Eberhart 和 Kennedy 于 1995 年开发的[89]，是一种用户群迅速增长的优化工具，用于解决各种工程和科学问题。PSO 模仿社会性动物行为，但不需要群体领导者来完成工作。鸟群在寻找食物时不需要领导者，而是跟随离食物最近的成员（图 10）。通过这种方式，鸟群成功地与种群中的其他成员沟通，从而找到所需的解决方案。PSO 算法由一系列粒子组成，每个粒子都代表一个潜在的解决方案。PSO 现已成为移动机器人导航领域广泛使用的工具。Tang 等人[90]利用多智能体粒子过滤器，处理了移动机器人在未知环境中导航的测绘和定位问题。之所以使用 PSO，是因为它具有更稳定的收敛特性，有助于减少计算量。</li>
</ol>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202401161059605.png" alt="image-20240116105911079"></p>
<p>为了获得精确的轨迹并防止陷入局部最优，Xuan 等人[91]采用了 PSO 算法与 MADS（网格自适应直接搜索）算法相结合的方法。PSO-MADS 算法与 GA 算法和 EKF 算法相结合，产生了有效的结果（扩展卡尔曼滤波器）。Atyabi 等人[92]创建了区域扩展 PSO（AEPSO）。此外，受时间和变化限制的移动机器人导航问题也可以用 PSO 来解决，该算法结合了基本 PSO 算法和其他优化技术。AEPSO 策略已成功应用于炸弹拆除和幸存者搜救。Tang 等人的[93]挑战环境下的合作运动路径规划解决了多移动机器人系统导航问题。在将 PSO 和多体系统动力学（由加速度、质量、力和惯性等机器人属性组成）都考虑在内的情况下，对所提出方法的容错性进行了研究。对于现实世界中众多移动机器人的导航，Couceiro 等人[94]做了一些修改。他们改变了 PSO 和达尔文 PSO（DPSO）系统，以解决通信和避障问题。他们发现，由 12 个物理机器人组成的系统可将最佳总体性能和最大通信距离提高 90%。</p>
<p>Chen 等人[95]利用多类别分类器为不确定环境制定了可学习的人类专家控制策略。在此背景下，粒子群优化（PSO）算法被用于及时有效地提高精度。与传统的栅格搜索法相比，它具有更高的精度。Li 等人提出的自适应学习粒子群优化（SLPSO）技术，旨在解决复杂环境中机器人路径规划的难题，同时满足各种约束条件。作者最初将路径规划问题转化为多目标优化问题，目的是满足路径长度和碰撞风险最小化以及平稳性最大化的导航目标。在实现这些目标之后，他们又加入了自适应学习机制，以增强粒子群优化（PSO）探索具有众多约束条件的环境的能力。Das 等人[96]为创建有效的路径规划提供了一种混合方法。他们提出了一种使用改进引力搜索算法（IGSA）和 PSO 的混合方法，用于评估杂乱环境中众多移动机器人的最佳行动路线。He 等人的研究[97]探讨了如何利用粒子群优化（PSO）来应对在多元、三维环境中水下环境导航的挑战。该研究采用了 PSO-UFastSLAM 组合方法来提高估计精度和限制粒子大小，从而取得了更好的结果。</p>
<p>粒子群优化（PSO）方法已被用于各类机器人的导航，包括水下机器人、三维未知环境中的空中机器人[98]、仿人机器人[99]和工业机器人[100]。值得注意的是，这些机器人都取得了成功的导航结果。Algabri M 等人[101] 对 GA、PSO、NN 和 FL 等各种导航控制技术进行了比较分析，以确定最佳方法。研究人员得出的结论是，FL 和 PSO 的融合产生了与穿越距离相关的最佳结果。&#x3D;&#x3D;粒子群优化（PSO）在移动机器人导航领域之外也有潜在的应用，特别是在国防领域。Banks 等人[102]研究了 PSO 在非确定性无人机导航中的应用及其促进无人机间协作的潜力，以保护广大地区免受空中威胁。&#x3D;&#x3D;文献[103]采用栅格法对环境进行划分，以实现粒子群优化。路径的距离由目标函数来衡量，避开途中的障碍物会受到惩罚。利用粒子群优化解决了涉及紧急车辆和普通车辆的两个路径规划问题。路径规划是当前机器人领域最活跃的研究领域之一。Chen 等人[104]提到了粒子群的局部搜索性能不达标这一问题；因此，可以更快地规划出理想路径，该算法可以在前期和后期提高粒子搜索的质量。Sarkar 等人[105]开发了一种自适应适配函数，解决了三个重要问题，包括避开障碍物和选择更短、更平滑的路径。该适应度函数通过使用粒子群优化（PSO）算法进行优化。</p>
<p>[103] Yuan, D. Research on path-planning of particle swarm optimization based on distance penalty. In Proceedings of the 2021 2nd International Conference on Computing and Data Science (CDS), Stanford, CA, USA, 28–29 January 2021; pp. 149–153.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-03T02:30:26.000Z" title="2024/1/3 10:30:26">2024-01-03</time>发表</span><span class="level-item"><time dateTime="2024-01-04T00:54:07.158Z" title="2024/1/4 08:54:07">2024-01-04</time>更新</span><span class="level-item">1 小时读完 (大约8685个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/03/A-tutorial-on-heuristic-methods/">A tutorial on heuristic methods</a></p><div class="content"><h1><span id="a-tutorial-on-heuristic-methods">A tutorial on heuristic methods</span></h1><p>作者：Edward A. Silver,  R. Victor V. Vidal, Dominique de Wearra</p>
<h2><span id="1-introduction">1. Introduction</span></h2><p>本文的目的有两个。首先，我们希望为决策分析人员和对运筹学基本技术略有了解的管理人员介绍启发式方法。我们的目的并不是要给出一个构建启发式方法的通用秘诀，也不是要对许多现有的启发式程序及其性能进行详尽的比较。不过，我们的第二个目标是确定与启发式方法的使用有关的重要问题，这些问题需要进行更多的研究。关于解决问题的启发式方法，有许多可能的定义。尼科尔森[42]将启发式方法定义为”……通过直观方法解决问题的程序，在这种方法中，问题的结构可以被智能地解释和利用，从而得出合理的解决方案。我们将采用这一定义，此外，我们还将在本文中假定，我们从一个适当的、定义明确的现实问题数学模型开始。</p>
<p>更具体地说，&#x3D;&#x3D;知道了建议解决方案所隐含的决策（或可控）变量的值，我们就能确定 (i) 解决方案是否可行，以及 (ii) 解决方案的有效性度量值。&#x3D;&#x3D;换句话说，我们有了约束条件和目标函数的数学表达式。该程序在数学上定义明确，但不能保证给出数学上的 “最优 “解决方案。上述定义中的 “直觉 “一词是指决策者（提出问题者）的实际直觉和&#x2F;或分析者的数学直觉可能会指导程序的选择和阐述。我们将使用 “启发式解决方案 “来表示通过启发式方法获得的解决方案。最后，有时我们会使用 “启发式 “一词作为名词来代替 “启发式方法或程序”。</p>
<p>诚然，在假设我们对现实世界的问题有一个适当的数学表述时，我们可以说我们忽略了运筹学研究中最困难的方面，即数学模型本身的开发。在这方面，怀特[66]对运筹学研究中所谓的次要决策进行了有趣的讨论，例如，要考虑哪些目标、包括哪些约束条件以及测试哪些替代方案？然而，我们必须认识到，特别是当我们处理更复杂的决策问题时，现实的表述很可能导致数学问题很难甚至不可能精确求解（这在很大程度上是由于许多实际问题的组合性质造成的）。因此，我们认为，对于决策分析师来说，定义明确的数学问题的近似解法程序这一课题越来越重要。</p>
<p>有关启发式方法的文献浩如烟海。不过，我们要特别提到 Klein [25]、MiJller–Merbach [36-38]、Newell [41]、Streim [55] 和 Weinberg mad Zehnder [61] 的全面研究。这些研究大多试图对现有的启发式方法进行系统化和分类。此外，Streim [55] 还列出了大量参考文献。</p>
<h2><span id="2-why-use-a-heuristic-method">2. Why use a. heuristic method?</span></h2><p>使用启发式解法可能有几个原因。这些原因包括：</p>
<p>(a) 数学问题的性质决定了其分析（封闭形式）或迭代求解程序是未知的。</p>
<p>(b) 虽然可能存在精确的分析或迭代求解程序，但其计算成本可能过高，或其数据要求可能不现实。枚举法尤其如此，从理论上讲，枚举法通常适用于找不到分析和迭代程序的情况。Ronald Graham[16]就此指出：</p>
<p>“关于 NP-完备性的发现改变了调度问题的研究方向。早期的努力是为了找到调度问题的最优解或精确解，但现在大部分注意力都转向了更容易确定近似解的方向，即找到能保证给出接近最优结果的高效方法”。</p>
<p>(c) 启发式方法在设计上可能更容易为决策者所理解，因此明显增加了实施的机会。例如，在某些存货控制问题中，虽然可以得到数学上的最优解，但管理者更倾向于实施比最优解更简单的特定形式的解。用Woolsey和Swanson 的话说[68，第 169 页]：”人们宁愿忍受一个他们无法解决的问题，也不愿接受一个他们无法理解的解决方案”。</p>
<p>(d) 对于可以优化求解的明确问题，启发式方法可用于学习目的，例如，对哪些变量是重要的形成直觉（这与运筹学中使用模拟方法的一个主要原因密切相 似）。(这与运筹学中使用模拟方法的主要原因之一非常相似）。</p>
<p>(e) 启发式方法可作为保证找到最优解的迭代程序的一部分。有两种不同的可能性：</p>
<ul>
<li><p>i. 容易获得初始可行解，例如，用所谓的西北角规则（Northwest Corner Rule）（见 Wagner [60]）获得运输问题的初始解。该规则通常不会给出特别好的解，但这在本例中并不重要，因为随后的计算机优化程序可以从任何初始可行解中快速找到最优解。</p>
</li>
<li><p>ii. 在精确求解程序的中间步骤做出决定，例如，在单纯形法中选择变量输入基数的规则是启发式的，因为它不一定能使达到最优解所需的步骤数最小化。</p>
</li>
</ul>
<p>(f) 在隐式枚举解决问题的方法中，一个好的起始解可以给出一个极大减少计算量的约束。启发式方法可以用来给出这种 “好 “的起始解。</p>
<p>有了所有这些使用启发式方法的可能原因，读者可能会开始思考 “为什么会有人费尽心机去获得问题的最优解”。我们并不主张在适当的情况下放弃使用优化方法（包括实施方面的考虑）。此外，使用启发式方法并不是一条简单的出路。正如我们将看到的那样，正确地开发和评估启发式程序并不简单。</p>
<h2><span id="3-measuring-the-quality-of-a-heuristic">3. Measuring the quality of a heuristic</span></h2><p>我们对启发式方法的定义包括 “通过……获得合理的解来解决（数学上定义明确的）问题”。在本节中，我们将解释’合理’一词的含义。(Wheeling[64，第 372 页]很早就讨论过这个问题）。</p>
<p>我们认为，一个好的启发式应该具备以下四个特性：</p>
<p>(1) 求解所需的实际计算量。</p>
<p>(2) 解决方案的平均值应接近最优值，也就是说，我们希望平均值表现良好。</p>
<p>(3) 出现极差解（即远离最优解）的几率应该很低。</p>
<p>(4) 启发式方法应尽可能简单，便于用户理解，最好能用直观的语言加以解释，特别是在手动使用的情况下。在这方面，精心准备的文档应有所帮助。</p>
<p>如果启发式方法涉及重复尝试解法，只保留最佳解法，那么在性质 2 和 3 中，我们指的只是这个 “最佳 “解法（而不是从中选出的所有解法）。</p>
<p>决定属性 2 和属性 3 相对重要性的一个重要因素是采用启发式的问题的求解次数。随着求解次数的增加，人们会认为属性 2 相对于属性 3 的权重更大。</p>
<p>属性 4 比其他三个属性更难量化，在文献中大多被忽视，但它很可能是四个理想特性中最重要的一个。Peterson 和 Silver [45] 提供了一个例子，说明这一理念在开发库存管理和生产规划决策系统中的应用。</p>
<p>在此，我们主要从特性 2 和 3 的角度来衡量质量。我们将讨论几种不同的测量方法，但在讨论之前，以下几点值得强调。与其精确地确定某一启发式的质量度量值，不如找出该启发式在什么条件下（即不可控变量的值）表现特别差，因而不应该使用。举例来说，在向随机到达的客户提供服务的问题情境中，用于确定最佳服务通道数量的启发式，只要通道的利用率不是太高，就可能表现得非常好。第二个例子是 Blackburn 和 Millen [3]，他们为动态批量大小问题（面对确定但随时间变化的需求模式，对单一物品的补货时间和规模进行选择）提供了从几种启发式求解方法中进行选择的指导。</p>
<h3><span id="31-comparison-with-the-optimum-solution">3.1. Comparison with the optimum solution</span></h3><p>我们希望能够将启发式解决方案与大量问题实例中的最佳解决方案进行比较。通常这是不可能的，因为正如前面所讨论的，首先使用启发式程序的一个主要原因是，从计算的角度来看，获得最优解可能是不可能的或令人望而却步的。我们可能不得不借助模拟来估算最佳解决方案的值（在目标函数只能用可控和不可控变量间接表示的情况下）。此外，可能有必要集中精力解决小规模问题（其规模至少小于某些感兴趣的实例），以将计算工作量降至合理水平。</p>
<p>即使找到了最优解，还存在一个问题，即使用什么样的问题实例进行测试，也就是给不可控变量分配一组什么样的值。这显然是一个实验设计的问题，这方面的文献很多（参见文献[7,18 和 35]）。通常情况下，不可控因素太多，无法进行完整的因子实验设计。洞察力（部分来自对相关理论的理解）以及对初步实验结果的调查可以提示哪些变量可能是重要的。通常，维度分析（如 Naddor [40]）可以减少需要考虑的不同参数的数量。</p>
<p>在理想情况下，最好能确定与使用启发式解法而非最优解法相关的成本惩罚大小的概率分布。要做到这一点，首先必须确定不可控变量的适当概率分布。从理论上讲，我们可以开发出所需的分布。然而，一些研究人员的初步研究表明，即使是在不可控变量独立这一值得商榷的简化假设下，分析也会变得极其复杂。&#x3D;&#x3D;因此，从实用的角度来看，概率分析的主攻方向似乎是根据不可控变量的指定概率分布，即所需概率分布的数值确定，通过经验生成不可控变量的值，从而绘制成本惩罚直方图。&#x3D;&#x3D;条件分布也很重要，例如，特定参数取特定值时的误差分布。这种条件分布有助于决定在什么情况下使用所考虑的启发式更有吸引力。</p>
<h3><span id="32-problem-relaxation-bounding">3.2. Problem relaxation-bounding</span></h3><p>当无法找到最优解时（通常是在使用启发式的情况下），另一种方法是对问题进行松弛，以便可以评估出至少与最优解一样好的解，从而为最优解的值提供一个约束，即最优解的值不能优于约束值。松弛解本身并不需要得到，我们需要的只是它的值，或者更少，它的值的界限。然后，我们检查启发式解与这个界限有多接近。这实际上只是一个单向测试。&#x3D;&#x3D;我们知道，最优解的值必须介于启发式解的值和边界值之间。&#x3D;&#x3D;因此，&#x3D;&#x3D;如果启发式解法的值非常接近边界，那么它也一定非常接近最优解的值。&#x3D;&#x3D;另一方面，&#x3D;&#x3D;启发式求解值与约束值之间的巨大差距可能是由于启发式太差、约束太松或两者兼而有之造成的。&#x3D;&#x3D;请注意，&#x3D;&#x3D;启发式方法本身给出的约束条件正好相反，即最优解的值不能比启发式解的值差。&#x3D;&#x3D;</p>
<p><strong>最优解的值不能比启发式值差指的是：对于最优解函数o()和启发式函数h()，每一个自变量的函数值o(v)不能差于启发式值，如果启发式是从下界逼近最优解值，则o(v) 不能小于 h(v)，如果启发式是从上界逼近最优解值 o(v)不能大于h(v)，最优解函数o()如果是希望最小化目标函数，则需要h()从下界逼近，如果最优解函数o()如果希望最大化目标函数，则需要h()从上界逼近。</strong></p>
<p>放松问题的最常见方法是忽略一个或多个约束条件。下面介绍两个例子：</p>
<p>(i) 在整数线性规划问题中，忽略整数约束条件，求解简单得多的连续变量问题，就可以得到约束。(Peterson 和 Silver [45, 第 536-5371 页提供了协调控制库存问题求解约束的 8 个相关例子）。</p>
<p>(ii) 在 “旅行推销员问题 “中，求解的困难是由每座城市必须在一次旅行中准确地游览一次这一约束条件造成的。去掉单次游览的约束条件，就可以直接得到原问题的约束条件。</p>
<p>随着问题的放宽，我们仍然必须面对使用哪些示例进行测试的问题。</p>
<h3><span id="33-extreme-value-statistical-methods">3.3. Extreme value statistical methods</span></h3><p>通常使用的启发式方法包括生成许多解决方案并从中选出最佳方案。在这种情况下，生成的每个解的值都可视为一个随机变量。极值统计理论可用于估算当前问题的最优解的值。有关这一主题的有趣参考文献有 Clough [6]、Dannenbring [lo] 和 Golden [15]。</p>
<h3><span id="34-other-comparisons">3.4. Other comparisons</span></h3><p>为了便于讨论，我们假定正在处理的问题是我们希望最大化某个目标函数。因此，在第 3.2 节中得到的任何界限都是上限。如果不容易得到这样的边界或怀疑边界不佳，我们可以将启发式解法与其他类型的解法进行比较，后者会产生最优解值的下限。可能的方法包括</p>
<p>(i) <strong>与枚举法比较</strong>  枚举法需要的计算量要大得多，计算量很大，但很可能找不到最优解。例如，分支与边界程序（关于此类程序的描述，请参见瓦格纳[60]）在产生了一定数量的分支后就停止了。这种 “截断式 “分支与边界程序也能为我们提供最优解值的上限（在最大化问题中）。</p>
<p>(ii) <strong>与决策者的绩效进行比较</strong>  可以在较早的时间段内进行，也可以直接进行平行比 较–这类比较有令人信服的理由。与现有程序相比，发现重大改进可能比任何最优或接近最优的证明对鼓励实施更为重要。Bowman 的文章 [43.</p>
<p>(iii) <strong>与其他启发式程序比较</strong> 如果已经提出和&#x2F;或使用了其他启发式求解方法，当然可以将 “我们的 “启发式与 其他启发式进行比较。危险在于，其他启发式解法可能特别糟糕，因此，即使 “我们的 “启发式解法的性能被评为最佳，它仍可能是一种糟糕的解法。</p>
<p>(iv)<strong>与 “随机 “决策规则比较</strong>一种极端的启发式是完全随机决策。举例来说，一些研究人员（如 Conway [8]）在研究工作中心作业排序的启发式时，使用了在工作中心等待的作业中随机选择下一个作业的决策规则作为基准比较。一般来说，”随机 “规则会对最优解的值产生一个相当差的约束，因此可以用来快速否定一个差的启发式方法。</p>
<h3><span id="35-worst-case-behaviour">3.5. Worst case behaviour</span></h3><p>最近，&#x3D;&#x3D;<strong>关于大规模、确定性、组合型问题的许多研究的重点是确定在使用特定启发式求解程序时可能出现的最差误差（见 [10,11 ]）。</strong>&#x3D;&#x3D;知道启发式的成本惩罚永远不会比某个特定值更差，这一点令人欣慰。然而，这一信息几乎肯定不足以在相互竞争的启发式程序中做出选择。如前所述，决策者可能更关心平均性能和&#x2F;或成本惩罚大于特定值的概率。某一启发式可能会因不可控制变量的罕见值（本质上是病态值）而导致最差易错行为，但同一启发式在几乎所有其他条件下都可能表现出色。Quicksort 就是一个例子，它是运筹学相关软件中常用的排序程序（见 Nievergelt 等人[43]）。另一方面，最差易用性分析的另一个好处是，它可以指出启发式在哪些条件下表现不佳，从而提示何时不应使用该方法。</p>
<h2><span id="4-types-of-heuristic-methods">4. Types of heuristic methods</span></h2><p>现在我们对启发式方法进行分类。需要强调的是，这些分类并不是相互排斥的。事实上，在解决某一类问题时，往往可以混合使用两种或更多的启发式方法。此外，我们也不应忽视并行使用两种不同的启发式方法来解决同一问题的可能性，选择两种解决方案中较好的一种，即不一定要依赖单一方法的良好性能。最后，在可能的情况下，启发式方法的开发者最好首先对所考虑的特定问题的理论研究有一个正确的认识；这些理论往往会提出一些具体的思路，这些思路可能对开发有效的启发式程序很有帮助。</p>
<p>顺便提一下，由于复杂问题的启发式解法往往是从较简单问题的精确解法发展而来的（参见 de Werra [63]），这就是向学生传授简单学术问题精确解法的一个很好的理由，也许是最重要的理由。</p>
<h3><span id="41-decomposition-methods">4.1. Decomposition methods</span></h3><p>在这里，所考虑的问题被分解成更小的部分，分别解决，并且至少需要粗略地考虑到各部分之间可能存在的相互作用。分解法在传统的将问题划分为组织的各个职能领域的过程中十分普遍。第二种常见的分解方式是将系统设计与系统运行分开。通常在设计阶段忽略运行效果，然后根据已选定的设计制定运行规则。Hax 和 Meal[17]的分层规划工作是分解的另一个很好的例子，在他们的工作中，中程总体规划决策与短程调度问题分离开来，但两个问题领域又有适当的耦合。这种分解的一个重要优点是，它符合大多数组织的实际运作方式。</p>
<h3><span id="42-inductive-methods">4.2. Inductive methods</span></h3><p>这里的思路是从同一问题的较小（或较简单）版本中归纳出来的。例如，在一个涉及多个设施（如工厂和仓库）的选址以满足客户需求的问题中，对于只有几个设施的情况，求解可能相对容易。利用这种较简单情况下的解的特性，可以有效地开发出一种启发式方法，用于更广泛的几种设施的情况（见 Bilde 和 Vidal [2]）。此外，有时某个参数变得非常大的情况特别容易分析，这也为分析参数的中间值（不大也不小）提供了启示。例如，在更新过程的一般领域，大量过程的总体效应具有泊松行为。(西尔弗[54]在开发概率需求下库存物品协调控制程序时利用了这一特性）。</p>
<h3><span id="43-feature-extraction-or-reduction-methods-特征提取法">4.3. Feature extraction (or reduction) methods 特征提取法</span></h3><p>这里采用的一般方法是，首先获取所考虑的几种数值情况的最优解。提取这些解的共同特征，并假定这些特征在一般情况下成立。例如，某个变量的值总是为 0，或者某些控制变量具有高度相关性，或者某个约束条件从未出现过。更极端的还原法是（通过分析问题的简单版本或仅仅凭 “直觉”）假定好的解决方案必须满足某些属性，而这些属性大大简化了分析。然后，一旦求得解，就可以验证是否满足这些属性（见 White [65]）。这种方法的一个很好的例子是，假设在任何合理的库存控制策略中，缺货的频率都会很低。另一个例子是 Hitchings 和 Cottam [19] 在设施布局问题中提出的。他们认识到，如果明智地固定某些设施的位置，或限制某些设施对彼此相邻，那么就可以降低问题的维度，从而更快地评估每个潜在的解决方案。</p>
<h3><span id="44-methods-involving-model-manipulation">4.4. Methods involving model manipulation</span></h3><p>这里的意思是以某种方式改变模型的性质，以便于求解，然后用修正模型的解来代表原始数学问题的解。从更普遍的意义上说，这就是使用数学模型来解决现实世界中的问题，然后将模型的解解释为原始问题的解的过程。模型操作的例子包括</p>
<ul>
<li><p>i. 目标函数的修正，如非线性函数的线性化。</p>
</li>
<li><p>ii. 放宽某些限制，其中有些限制在任何情况下都可能是灵活的（例如，预算限制 不一定是刚性的）。</p>
</li>
<li><p>iii. 改变概率分布的性质，例如，假设正态分布而不是更复杂的分布。</p>
</li>
<li><p>iv. 变量的聚合，其目的是减少决策变量的数量（然而，聚合变量的值最终必须在原 有的分解变量之间进行分配）。Geoffr,ton [14]的研究是关于聚合的成本影响的一个有趣参考。</p>
</li>
</ul>
<h3><span id="45-constructive-methods">4.5. Constructive methods</span></h3><p>这里介绍的方法与局部改进方法形成对比，后者将在下一节讨论。构造方法的基本思想是建立（即构造）一个单一的可行解，通常采用确定性的顺序方式。解决旅行推销员问题的所谓 “最近邻规则 “就是一个例子（见 Rosenkrantz 等人 [48]）。要建立一条只经过每个城市一次的线路，需要从某个城市（比如 i）开始，首先去离它最近的城市（称作i）。这就是所谓 “贪婪 “算法的一个例子，贪婪的意思是在每一步中都尽力而为。对于某些类别的问题（旅行推销员问题并非如此），贪婪启发式会带来非常好的解决方案（Comuejols 等人 [9]、Jenkyns [21 ] 和 Lawler [27]）。然而，最近邻规则通常不能很好地解决旅行售货员问题；它的缺陷在于只考虑下一个节点的近视观点。这与使用所谓 “前瞻 “规则的启发式方法形成了鲜明对比（见 MiiUer-Merbach [37]）；MiiUer-Merbach [36, 第 3.3 节] 给出了旅行推销员问题的一个例子，其中的前瞻规则是基于约束计算的（见本文第 3.2 节）。</p>
<p>另一个建设性方法的例子是，在制造工厂的多个潜在地点（m）设置多个工作中心（n），以尽可能降低材料处理成本。一种可能的建设性启发式方法（见 Lee 和 Moore [28]）是，首先在特定地点（如 ]1）定位一个特定的中心（称作 il）。现在，我们选择第二个中心 i2，并将其置于另一个位置 ]2，然后是第三个中心 i3，置于 ]3，等等。在找到最后一个剩余的中心之前，没有完整的解。要生成新的解，整个过程要重复进行。</p>
<p>另一种构造方法涉及的问题有许多决策变量，但总体约束条件相对较少。举例来说，在同一台产能受限的机器上生产的几种产品，如何选择补货的时间和规模就是一个问题。一种建设性的方法（见 van Nunen 和 Wessels [44]）是先分别选择每个单项的批量大小，忽略产能限制（这是一组相对容易解决的问题）。然后，如果隐含的总生产小时数超过了任何一个产能，则对单个项目的解决方案进行调整，直到获得可行的解决方案。</p>
<h3><span id="46-local-improvement-methods">4.6. Local improvement methods</span></h3><p>与上一节的建构过程不同，这里我们从可行解开始，对 R 进行迭代改进。工作中心位置问题可以用这种方法求解（参见 Hitchings 和 Cottam [19]）。初始可行解可能是制造工厂的现有布局，也可能是一个构造过程的解。局部改进的一种方法是尝试切换成对的中心；当发现有吸引力的切换时，就进行切换，然后继续这个过程，直到任何一次切换都无法实现进一步的改进。一个相关的问题是，当剩余的可能开关数量极大时，是否要继续搜索；换句话说，什么是合适的停止规则？同样，如果使用建构法进行重复试验，我们也希望有一个合理的规则来确定何时停止生成解。伦道夫等人[47]研究了使用贝叶斯（主观概率）方法来构建此类规则。即使使用精确的枚举法（例如分支与边界法），我们也经常会面临同样的停止问题，即进一步的大量计算可能只会导致解的微小改进。启发式推理很可能有助于停止规则的制定。</p>
<p>关于局部改进方法和邻域搜索的更多详情，请参阅 Miiller-Merbach [38] 和 Wheeling [64]。Lin 和 Kemighan [30] 在解决旅行推销员问题时使用了局部改进方法。</p>
<h2><span id="5-interactive-role-of-humans-during-the-execution-of-a-heuristic-method">5. Interactive role of humans during the execution of a heuristic method</span></h2><p>在执行启发式程序的过程中，设计合理的交互式系统可以带来以下优势：</p>
<ul>
<li><p>i. 能够相互指导寻找好的解决方案，特别是利用决策者的经验（见 Segal 和 WeJnberger [52] 和 Tobin [56]）。在对旧方案进行评估时，人类有能力提出新的方案，而详细计算的繁琐工作则留给计算机来完成。交互式程序经常用于工程设计，例如 AIDES（自适应初始设计合成器）程序（Rudd 等人[50]）。</p>
</li>
<li><p>ii. 分析人员了解系统的能力，特别是数学本身的行为方式，以便根据观察到的 行为方式修改模型或启发式程序。</p>
</li>
<li><p>iii. 方便决策者了解系统和&#x2F;或模型，并获得使用模型的信心。Little [31] 在谈到营销领域的决策时强调了这一点。</p>
</li>
</ul>
<p>在本节的最后，我们将提出三点意见，它们实际上与获得精确解的方法以及启发式程序相关：</p>
<ul>
<li><p>i. 在许多重要问题中，很难事先从决策者那里获得有关目标和限制条件的明确说明。在互动模式下，可以通过计算机提问的方式，在制定解决方案的过程中，根据需要获取这些信息。这正是 Roy 和 Bertier [49] 、Zionts 和 Wallenius [69] 以及 Little [31] 等人在多目标决策问题上所做工作的精神所在（另见 Keeney 和 gaiffa [241.）</p>
</li>
<li><p>ii. 交互式系统是否有效的一个重要因素很可能是能否以图形方式描述解 决方案，例如在车辆路由系统中显示地图（Krolak 等人[26]）。</p>
</li>
<li><p>iii. 随着微型计算机的日益普及，交互式方法的使用将大幅增加。</p>
</li>
</ul>
<h2><span id="6-factors-that-may-be-important-in-the-choice-or-testing-of-a-heuristic-method">6. Factors that may be important in the choice or testing of a heuristic method</span></h2><p>在本节中，我们试图找出一些在选择特定启发式方法或对其进行评估时可能很重要的因素。这些因素并不是独立的，尤其是前三个因素肯定是相互关联的。一个重要的研究领域是为设计和测试启发式方法制定更明确的指导方针。</p>
<p>(a) <strong>战略（系统设计）与战术（系统运行）问题</strong>–战略决策（如工厂设施的资本投 资）是一次性的重大决策，需要进行相当细致的分析，而战术决策（如质量控 制、生产调度等）则是次要的、重复性的决策。此外，在战术决策中，还有机会进行调整，以弥补先前决策的失误。</p>
<p>(b) <strong>决策的频率</strong>–是一次性决策问题还是重复决策问题？如前所述，对于重复性决策，平均绩效好的标准更有意义。</p>
<p>(c) <strong>允许的计算工作量</strong>  这个因素显然与决策的重要性和频率有关。一般来说，启发式方法的选择取决于允许的求解时间和&#x2F;或资金预算。</p>
<p>(d) <strong>决策者的分析能力</strong> 如前所述，启发式方法最好能为决策者所理解。因此，决策者对分析推理的理解能力应影响启发式方法的选择，尤其是在手动使用启发式方法的情况下。</p>
<p>(e) <strong>决策（可控）变量的数量</strong> 此类变量的数量首先影响对启发式的需求，并应影响方法的选择。</p>
<p>(f) <strong>不可控变量的数量</strong> –这一因素对启发式方法的测试尤为重要。不可控变量的数量越多，就越不可能进行概率分析。</p>
<p>(g) <strong>问题的规模</strong>–以旅行推销员问题为例。一种启发式方法可能最适合 30 个城市的情况，而另一种启发式方法可能更适合 100 个城市的情况。</p>
<p>(h) <strong>离散变量与连续变量</strong>–关于启发式方法的一般文献大多与涉及整数变量的组合 问题有关。当变量是连续变量时，也许不同的方法更合适。</p>
<p>(i) <strong>确定性变量与概率变量</strong> 大多数文献都涉及大规模确定性模型。</p>
<p>同样，对于通常只涉及数量有限的变量的概率问题，设计出截然不同的启发式程序或许也是有意义的。霍华德[20]和纳多[39]等人研究了在处理特定决策问题时，仅使用概率分布的前几个时刻而不是整个分布的效果。</p>
<h2><span id="7-summary">7. Summary</span></h2><p>在本文中，我们讨论了解决定义明确的数学问题的启发式方法。其中包括启发式方法的性能测量、不同类型的启发式程序，以及在选择和测试用于任何特定问题的启发式方法时可能涉及的一系列因素。希望本文能达到两个目的，即：(i) 向决策分析人员介绍启发式方法的基本概念；(ii) 激发分析人员对启发式程序的一些重要方面进行研究。与后一点相关，一个具有挑战性的研究课题是，在给定一个特定问题和最大允许计算时间（或复杂度）的情况下，找到一种能在这些条件下给出最佳解决方案的求解方法。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-25T22:53:28.000Z" title="2023/12/26 06:53:28">2023-12-26</time>发表</span><span class="level-item"><time dateTime="2024-01-10T16:02:06.324Z" title="2024/1/11 00:02:06">2024-01-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%BA%E6%96%87/">论文</a></span><span class="level-item">35 分钟读完 (大约5283个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/26/Hierachical-path-finding-for-Navigation-Meshes/">Hierachical path-finding for Navigation Meshes</a></p><div class="content"><h1><span id="原文翻译-hierachical-path-finding-for-navigation-meshes">【原文翻译】 Hierachical path-finding for Navigation Meshes</span></h1><p>作者：</p>
<h2><span id="abstract">Abstract</span></h2><p>随着虚拟环境的规模和导航智能体数量的增加，路径搜索可能成为一个重要的瓶颈。重要的是要开发出能有效应用于任何环境的技术，而不受环境抽象表示法的影响。在本文中，我们提出了一种分层 NavMesh 表示法，以加快寻路速度。分层路径搜索（HPAn）已成功应用于规则栅格，但有必要将这种方法的优势扩展到多边形导航网格。与规则栅格相比，<strong>导航网格能提供更高精度的底层几何图形，同时包含更少数量的单元格。</strong>因此，我们提出了一种自下而上的方法，&#x3D;&#x3D;基于多级 k 路分割算法（MLkP）创建分层表示，并标注子路径，可通过我们的分层导航网格路径查找算法（HNAn）在线访问。&#x3D;&#x3D;该算法得益于在单元数更少的图中进行搜索，因此在初始 NavMesh 上的搜索速度比传统的 An 算法快 7.7 倍。我们介绍了 HNAn 在各种情况下的结果，并讨论了该算法的优势和有待改进的地方。</p>
<p>问题：智能体数量增加  环境的规模扩大，使得传统A*算法的速度变慢</p>
<h2><span id="introduction">introduction</span></h2><p>大多数视频游戏都需要模拟数以千计或数以百万计的智能体，这些智能体在三维世界中互动和导航，并显示出追逐、寻找或拦截其他智能体等能力。路径搜索为角色提供了在虚拟环境中自主导航的能力。最著名的寻路算法是 Astar 算法，它在探索图形节点的同时，通过启发式平衡累积成本，快速找到最优路径。多年来，人们提出了许多算法来进一步加快基本的 Astar 算法，但这些算法的成本仍然与图的大小密切相关。分层寻路旨在减少在大型地形中计算路径时需要探索的节点数量。&#x3D;&#x3D;在计算路径时，层级越高，节点数量越少，从而大大减少了执行时间和内存占用。&#x3D;&#x3D;</p>
<p><strong>&#x3D;&#x3D;思考：分层路径规划的核心思想是减少计算路径时需要探索的结点的数量。传统A * 算法 在大规模地图上由于探索了大量不必要结点，而浪费了较多时间&#x3D;&#x3D;</strong></p>
<p>目前的分层技术可能会导致<strong>不平衡的抽象</strong>。例如，自上而下的层次结构是通过将环境分割成大型方形簇来创建的，所有簇都包含数量完全相同的低层栅格单元。这种结构的主要缺点是，由此产生的较高层次的层次结构中，节点之间的边的数量可能不均衡，可行走单元的数量也不均衡（因为有些簇中可能有很大比例的栅格单元被障碍物占据）。</p>
<p>与常规栅格相比，用多边形表示的导航网格能以较少的单元格数更接近地表示几何图形。由于较少的单元数可以大大加快寻路速度，因此有必要将分层寻路的概念扩展到以多边形为单元的导航网格的更一般表示方法。此外，在分层表示法中，每个节点的多边形数量和节点之间的入口数量保持平衡也是有益的。</p>
<p>在本文中，我们针对以多边形导航网格表示的大型三维环境提出了一种新的分层路径查找解决方案。&#x3D;&#x3D;本文提出的解决方案适用于单元为凸多边形的导航网格，因此也包括三角形表示法。&#x3D;&#x3D;&#x3D;&#x3D;我们的分层图表示法基于一种多级 k-way 分区算法，并注有子路径信息。&#x3D;&#x3D;我们的方法在层次结构中使用的层次数量和层次结构之间合并的多边形数量方面都采用了灵活的方法。我们评估了使用我们的分层路径搜索所带来的性能提升，并讨论了合并多边形的数量与搜索所使用的层级数量之间的权衡。我们提出了一些基准，有助于在参数拟合过程中实现最佳加速，并对使用 HNA * 找到的路径的次优化边界进行了定量分析。我们还对在分层表示法中插入起点和目标位置时某些配置出现的瓶颈进行了评估。</p>
<h2><span id="2-related-work">2 Related work</span></h2><p>加快路径搜索速度的大量工作都集中在加强 A * 算法上，以减少计算路径所需的计算时间。这样做的代价是找到次优路径，或者在寻找最优路径时允许一定程度的误差，然后允许算法在未来的搜索中修复这些误差。</p>
<p>众所周知的 A * 算法[1]是一种稳健且易于实现的方法，可严格保证解的最优性和完整性。A * 算法使用启发式来限制在找到真正最优路径之前必须评估的状态数量，并保证比使用相同启发式的其他算法扩展相同数量或更少的状态。然而，对于大型场景来说，这种算法非常耗时。实时规划算法能找到最佳次优规划，并在重复使用之前规划工作的同时迭代改进该规划。其中最流行的一种 A * 算法叫做随时修复 A *（ARA * ）[2]。它在迭代降低松散边界（ε）的同时，执行一系列重复的加权 A * 搜索。它通过减少 ε 和重复使用之前的规划工作来加速后续搜索，从而迭代改进解决方案。不过，ARA * 解决方案不再保证是最优的。</p>
<p>D* Lite[3]通过执行 An 来生成初始解决方案，并通过尽可能多地重复使用之前的搜索工作来修复之前的解决方案，以适应世界的变化。D* 可以纠正 “错误”，而无需从头开始重新规划，但需要更多内存。Anytime Dynamic A* （AD* ）[4] 结合了 D* 和 ARA* 的特性，提供了一种能满足严格时间限制的规划解决方案。它能有效地更新解决方案，以适应环境的动态变化。</p>
<p>DBA* 算法[5]结合了为[6]开发的内存效率扇区抽象和[7]使用的路径数据库，以提高空间复杂性和优化性。Huang [8] 提出了一种在任意复杂导航网格环境中相干和持久群组的路径规划方法。该群组被建模为可变形和可分割的区域保留形状。群搜索的效率由三个因素决定：路径长度、变形最小化和分割最小化。</p>
<p>层次图表示法也被用于大型数据集的可视化目的 [9,10]。这些应用的目标是首先提供一个概览，然后能够根据需要缩放和过滤以提供细节。</p>
<p>通过分层表示进行规划来提高问题求解的性能由来已久[11]。Holte 等人[12] 引入了在抽象空间中进行搜索的分层表示法，并利用解决方案指导在原始空间中的搜索。也有研究基于自下而上的方法对一般图进行抽象 [13,14]，但没有考虑平衡节点数或最小化切边。Sturtevant 和 Jansen [15] 稍微扩展了理论工作，并提供了一些不同图抽象类型的示例。在这项工作中，通过为每个可行走的单元设置一个节点，从二维栅格状结构中创建了图。Bulitko 等人[16]的研究表明，路径的质量会随着抽象程度的增加而呈指数级下降。Sturtevant 和 Geisberger[17]研究了如何结合抽象和收缩层次来加快路径查找速度。抽象采用自上而下的方法，在较低层次的规则栅格上创建一个 16x16 叠加层。收缩则利用节点重要性的概念建立更高层次的图，这就要求正确设置节点的优先级，因为它们会影响收缩算法。</p>
<p>在[19]中，提出了一种自适应环境细分方法，在 GPU 上进行高效的索引、更新和查找邻居操作，从而降低了内存需求。另一种基于 HPA* 的类似方法是分层注释 A* （HAA* ）[20]，但考虑到了智能体的大小和地形穿越能力。它是 HPA* 的扩展，允许多智能体在异构地形环境中高效规划高质量路径。另一个有趣的实现是 DT-HPA* [21]，它使用决策树来创建一个分层细分路径。</p>
<p>Jorgensen 提出了一种基于层次结构的自动结构化方法，该方法将建筑物分为由楼梯连接的楼层，并将楼层表示为由门阶连接的房间[22]。这种方法具有严格的层次结构，无法扩展到大型室外环境，如视频游戏中经常出现的环境。Zlatanova[23]提出了一种专门用于室内导航的空间细分框架，该框架通过识别房间和走廊并包含语义信息来实现。</p>
<p>还有一些方法侧重于让智能体更多地感知环境[24]。在这项工作中，规划是基于随时动态A *（Anytime Dynamic A * ）的，规划的执行要满足对路径施加的多个特殊约束，例如：停留在建筑物后面、沿着墙壁行走或避开其他智能体的视线。文献[25]提出了一个多域随时动态规划框架，它可以通过使用一个域中的规划来加速和集中在更复杂域中的搜索，从而有效地跨域工作。它探索了不同领域的关系，包括使用航点和隧道。不同的域在空间细分方面只使用两种表示方法，即二维栅格和三角形网格。</p>
<p>分层表示法已被用于计算在两点之间移动的智能体，其复杂程度各不相同[26,27]；从寻找路线到三维角色动画，不一而足。它们还被用于将高级路径搜索与低级局部运动相结合[28]。在使用三角形表示法时，有可能优化数据结构和内置功能，如间隙，从而大大提高寻路过程中的性能 [29,30]。但要将这一实现方法扩展到多边形网格并不简单（也就是说，仅对多边形进行简单的三角剖分是不够的）。最近有一份技术报告将 HPA* 扩展到了三角形表示[31]。</p>
<p>在本文中，我们讨论了解决定义明确的数学问题的启发式方法。其中包括启发式方法的性能测量、不同类型的启发式程序，以及在选择和测试用于任何特定问题的启发式方法时可能涉及的一系列因素。希望本文能达到两个目的，即：(i) 向决策分析人员介绍启发式方法的基本概念；(ii) 激发分析人员对启发式程序的一些重要方面进行研究。与后一点相关，一个具有挑战性的研究课题是，在给定一个特定问题和最大允许计算时间（或复杂度）的情况下，找到一种能在这些条件下给出最佳解决方案的求解方法。</p>
<h2><span id="3-framework">3. Framework</span></h2><p>我们的框架包括一个创建层次结构的预处理阶段，以及一个在该层次结构表示中执行在线搜索的基本 A * 算法的改编版本。</p>
<p>预处理阶段从多边形导航网格开始，该网格代表三维世界的一个抽象分区。第一个导航网格被视为层次树中的最低层。层级结构中的其余层级是通过递归将较低层次的图形划分为特定数量的节点来创建的。这种划分一直进行到最高层的图形无法进一步细分为止。因此，特定的路径规划搜索可以在这棵层次树的任何一级中执行。层次结构越高，需要搜索的节点数量就越少。与没有任何层次结构的普通 A* 相比，这种方法可以加快路径搜索计算速度。虽然我们使用基本的 A* 算法测试了结果，但所介绍的方法具有足够的通用性，可用于 A* 的改进版本，如 AD* 、DBA* 、ARA* 或 D*。</p>
<p>二维栅格的经典分层路径查找算法（HPA* [18]）包括将二维栅格作为低层，并通过将环境划分为由入口连接的平方簇来建立高层，其中所有簇具有相同数量的低层栅格单元。簇与簇之间用成本为 1.0 的内部边连接，而内部边的成本则通过在每个簇内搜索共享同一簇的所有抽象节点对的 A* [1] 算法计算。</p>
<p>Gravot 等人[35]提出了一种自上而下的方法，将大块瓦片的二维栅格分区与每个瓦片的低层导航网格相结合。因此，每个 32x32 米的方格都有自己的导航网格，这就迫使单元格的数量大于直接从原始地图生成多边形分解时的数量。这种两级表示法提高了性能，但轴对齐的瓦片和几何图形之间的错位会导致预存表的不一致，从而迫使瓦片进一步细分。</p>
<p>在这项工作中，我们提出了一种自下而上的方法，即从初始导航开始，在尊重多边形导航网格优点的基础上，合并单元格以获得更高层次的抽象。在一般导航网格中对低级单元进行分组并不像决定对 nxn 个单元的正方形进行分组那么简单。&#x3D;&#x3D;我们的目标是要有一个良好的图形分区，组件大小均衡，组件之间的边数量较少，因为这将降低分层寻路算法的成本。&#x3D;&#x3D;我们使用 Recast [33] 提供的多边形网格作为初始导航图，并使用多级 k-way 分区算法（MLkP）[36] 创建分层表示法。MLkP 通过折叠顶点和边来缩小图 Gi 的大小，从而创建 Gi+1。该算法已被证明比其他多级递归分割算法更快，并能生成高质量的图。</p>
<h3><span id="31-hierarchical-representation">3.1. Hierarchical representation</span></h3><p>第一步是建立分层搜索框架，将其定义为图形树。我们首先通过搜索原始导航网格中的多边形来计算层次结构的最低图（G0&#x3D;(V0, E0)）。每个多边形都会成为 G0 图中的一个节点，并且在原始网格中共享边界的多边形之间会创建边。</p>
<h2><span id="5-conclusions-and-future-work">5. Conclusions and future work</span></h2><p>在本文中，我们提出了一种基于自下而上方法在导航网格上执行分层路径查找的新型算法。通过使用多级 k-way 分区算法，我们可以创建复杂度为几级的层次结构，每级的节点数量根据用户输入变量 μ 而递减，该变量决定了层次结构连续级别之间要折叠的节点的大致数量。与自上而下的方法相比，我们的自下而上方法的优势在于，我们的技术提供了均衡数量的可走单元和分区之间的交叉口。我们已经展示了我们的 HNAn 算法如何在这种表示法中比直接在导航网格上应用基本寻路方法更快地获得路径。</p>
<p>对 HNAn 和 HPAn 进行定量比较是很有意义的。不过，这种比较的主要困难在于，HPAn 对栅格的粒度非常敏感，而 HNAn 则没有这种限制。因此，很难找到合适的参数来进行公平的比较。尽管如此，我们预计随着环境复杂度的增加，HNAn 的优势会变得更加明显，因为我们采用 MLkP 分区的自下而上方法可以很好地平衡节点和最小边缘切割，而轴对齐的常规栅格分区则无法实现这一点。因此，随着环境规模和复杂度的增加，我们预计 HPAn 将开始受到这种缺乏平衡的影响。</p>
<p>我们展示了 A * 算法的结果，但本文介绍的架构也可用于 A * 算法的其他变体。</p>
<p>文章提出了一种分层的方法，其提出利用多边形分割方法，来确保分层后的较高级层次中的各个节点能够保持障碍物数量和边数量的平衡。</p>
<p>我们对各种情况下的改进进行了展示，以证明该方法的潜力，但也评估了其局限性。目前，该技术的主要局限性在于将起始位置和目标位置连接到分层表示的步骤，因为其性能会随着高层节点（多节点）中包含的 0 层节点数量的增加而下降。我们测试并比较了这一步骤的两种变体，一种是计算从 S 和 G 到各自上一级节点中每条边的 Astar，另一种是对包含 S 的节点和包含 G 的节点执行单一的 Dijkstra 搜索。尽管 Dijkstra 比 Astar 有所改进，但在关键情况下速度不够快，因此未来的工作将侧重于测试这一步骤的替代方案，例如并行搜索，或预先计算和存储额外的数据结构以进一步提高性能。与处理常规二维栅格时相比，按单元预计算信息更具挑战性，因为初始单元的形状和大小可能会有很大变化，从而难以估计 S 和 G 的可能位置。</p>
<p>我们观察到，如果采用只有一层的层次结构G1 的节点数比 没有层次结构的G0 少约 85%，或者采用两级层次结构，则G1 的节点数比 G0 少约 70%，G2 的节点数比 G0 少约 95%，就能达到最佳提速效果。尽管看起来最快和最简单的方案是采用一级层次结构，但必须强调的是，这些比较是根据图中各种路径的平均成本进行的。例如，目前的算法会检查 S 和 G 是否在同一个多节点中，如果是，则只需执行 An（这意味着这种情况无法从分层表示中获益，但也不会受到惩罚）。此外，我们还证明了当 S 和 G 位于最高层的相邻节点时，由于需要计算多个 An 搜索来连接 S 和 G，因此成本可能会很高，而找到高层路径的成本可以忽略不计。我们认为，在多级表示的下一级计算 HNAn 可以使这两种情况受益。</p>
<p>在今后的工作中，我们还将考虑 NavMesh 的动态更新，以及它们如何影响分层表示法。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-25T13:35:03.000Z" title="2023/12/25 21:35:03">2023-12-25</time>发表</span><span class="level-item"><time dateTime="2023-12-25T14:39:49.864Z" title="2023/12/25 22:39:49">2023-12-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/python/">python</a></span><span class="level-item">7 分钟读完 (大约1009个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/25/Python-%E7%94%BB%E5%9B%BE%E7%9F%A5%E8%AF%86/">Python-画图知识</a></p><div class="content"><h1><span id="python-画图知识">Python 画图知识</span></h1><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/matplotlib/matplotlib-subplots.html">Matplotlib 绘制多图 | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/404145594">最全Python绘制多子图总结 - 知乎 (zhihu.com)</a></p>
<p>python 使用matplotlib绘图要注意的事情：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> colors</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>] </span><br><span class="line"><span class="comment">#用来正常显示负号 #有中文出现的情况，需要u&#x27;内容&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 先声明画布</span></span><br><span class="line"><span class="comment"># figsize=(xx, xx)设置画布大小，画布不能设置太大，不然会报错，最大设置过(64, 64)</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">30</span>, <span class="number">30</span>))	</span><br><span class="line"><span class="comment"># 一个figure 画布对象可以有多个子图axes，通过调用subplot来返回一个子图对象，类似的方法还有add_subplot()</span></span><br><span class="line"><span class="comment"># 函数原型 subplot(numRows, numCols, plotNum), 例如(111)表示共生成一个1行1列的子图对象，即只有一个子图，第三个1表示对第一个子图进行操作</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>) </span><br><span class="line"><span class="comment"># ax = plt.subplot(221)，则表示生成2行2列的子图，则共有4个子图对象，1表示对第一个对象进行操作。</span></span><br><span class="line"><span class="comment"># 子图的编号从左上角第一个子图开始，依照从左到右，从上到下的顺序标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前画布上的图像</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test_fig.png&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图像，注意这两步不能颠倒，不然会保存一个白板。</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> colors</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">2</span>*math.pi, <span class="number">2</span>*math.pi, <span class="number">100</span>)</span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment">#用来正常显示负号 #有中文出现的情况，需要u&#x27;内容&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先声明画布</span></span><br><span class="line"><span class="comment"># figsize=(xx, xx)设置画布大小，画布不能设置太大，不然会报错，最大设置过(64, 64)</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 一个figure 画布对象可以有多个子图axes，通过调用subplot来返回一个子图对象，类似的方法还有add_subplot()</span></span><br><span class="line"><span class="comment"># 函数原型 subplot(numRows, numCols, plotNum), 例如(111)表示共生成一个1行1列的子图对象，即只有一个子图，第三个1表示对第一个子图进行操作</span></span><br><span class="line">ax = plt.subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment"># ax = plt.subplot(221)，则表示生成2行2列的子图，则共有4个子图对象，1表示对第一个对象进行操作。</span></span><br><span class="line"><span class="comment"># 子图的编号从左上角第一个子图开始，依照从左到右，从上到下的顺序标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用plot来绘制曲线</span></span><br><span class="line">ax.plot(x, y2, color=<span class="string">&#x27;blue&#x27;</span>, linewidth=<span class="number">5.0</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴名称</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x-label&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y-label&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Title&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">ax.set_xlim((-<span class="number">2</span>*math.pi, <span class="number">2</span>*math.pi))</span><br><span class="line">ax.set_ylim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴刻度</span></span><br><span class="line">x_ticks = np.arange(-<span class="number">2</span>*math.pi, <span class="number">2</span>*math.pi, <span class="number">0.5</span>)</span><br><span class="line">y_ticks = np.arange(-<span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">0.5</span>)</span><br><span class="line">ax.set_xticks(x_ticks)</span><br><span class="line">ax.set_yticks(y_ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前画布上的图像</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test_fig.png&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图像，注意这两步不能颠倒，不然会保存一个白板。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312252221125.png" alt="test_fig"></p>
<p>上述代码中用到的接口函数，如果我们使用子图(Axes)来调用接口函数，其形式为</p>
<ul>
<li><code>set_xlim()</code>:设置x坐标轴范围</li>
<li><code>set_ylim()</code>:设置y坐标轴范围</li>
<li><code>set_xlabel()</code>:设置x坐标轴名称</li>
<li><code>set_ylabel()</code>:设置y坐标轴名称</li>
<li><code>set_xticks()</code>:设置x轴刻度</li>
<li><code>set_yticks()</code>:设置y轴刻度</li>
</ul>
<p>如果使用的plt画布窗口，则调用函数为：</p>
<ul>
<li><code>xlim()</code>:设置x坐标轴范围</li>
<li><code>ylim()</code>:设置y坐标轴范围</li>
<li><code>xlabel()</code>:设置x坐标轴名称</li>
<li><code>ylabel()</code>:设置y坐标轴名称</li>
<li><code>xticks()</code>:设置x轴刻度</li>
<li><code>yticks()</code>:设置y轴刻度</li>
</ul>
<p>&#x3D;&#x3D;绘制多个子图，使用ax方式调用，（如果调用plt的接口会直接在画布上绘制标题等等），一般情况下，也建议使用ax来调用，比较准确且规范。&#x3D;&#x3D;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-25T10:54:22.000Z" title="2023/12/25 18:54:22">2023-12-25</time>发表</span><span class="level-item"><time dateTime="2023-12-25T11:08:09.320Z" title="2023/12/25 19:08:09">2023-12-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/excel%E6%93%8D%E4%BD%9C/">excel操作</a></span><span class="level-item">2 分钟读完 (大约260个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/25/excel-%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%80%E5%8C%BA%E5%9F%9F%E6%95%B0%E6%8D%AE%E7%BB%9F%E4%B8%80%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%9F%90%E4%B8%80%E6%95%B0%E6%8D%AE/">excel 实现某一区域数据统一加减乘除某一数据</a></p><div class="content"><h1><span id="excel-实现某一区域数据统一加减乘除某一数据">excel 实现某一区域数据统一加减乘除某一数据</span></h1><p>例如：想要对某一列数据进行缩小&#x2F;或者扩大一千倍（或者一万倍，例如当前数据单位是 万元，我希望将数据转为 以元为单位）。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312251858162.png" alt="image-20231225185751880"></p>
<p>首先，在附近一个数据格中填入想要缩小&#x2F;放大的倍数值，然后右击该值，点击复制。</p>
<p>其次，选择想要进行放大&#x2F;缩小的数据（想要操作的数据），例如绿框选中的数据，然后右击，可以看到又一项为“选择性粘贴”，点击该项。会弹出一个小框。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312251907515.png" alt="image-20231225190726398"></p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312251905649.png" alt="image-20231225190530293"></p>
<p>如果是想要放大列数据，选择乘，如果是想要缩小数据，选择除，也可以进行加减插座。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-24T15:30:01.000Z" title="2023/12/24 23:30:01">2023-12-24</time>发表</span><span class="level-item"><time dateTime="2023-12-24T16:19:10.223Z" title="2023/12/25 00:19:10">2023-12-25</time>更新</span><span class="level-item">6 分钟读完 (大约924个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/24/Linux%E7%A7%81%E6%88%BF%E8%8F%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/">Linux私房菜：计算机概论</a></p><div class="content"><h1><span id="linux私房菜计算机概论组装台式机很有帮助">Linux私房菜：计算机概论（组装台式机很有帮助）</span></h1><p>绕不过的，冯诺依曼机的五个组成部分：输入单元、输出单元、控制单元、算术逻辑单元和内存。</p>
<h2><span id="内存">内存</span></h2><p>所有的数据（数据包括软件程序和数据文件）都要先读入内存后，才能由CPU处理，运算。</p>
<p>个人电脑中的内存主要为随机存取内存（Dynamic Random Access Memory，DRAM），DRAM性质的硬件必须通电才能读写，并且掉电后数据会消失。</p>
<p>DRAM又细分为几类，SDRAM和DDR SDRAM。市面上比较常见的是DDR 4.0，再厉害一点的DDR 5.0也已经推出，但是稍贵。DDR的含义是双倍数据传输速度（Double Data Rate），即在一个工作周期内，使用该技术的硬件可以进行两次数据的传输。</p>
<p>内存是沟通CPU和外存的桥梁。可以这样想象，桥梁越宽，那么通行速度越快，能够通过的车辆就越多。所以，对于一台电脑来说，内存越大，通常运行速度就越快，或者说，内存大能够提升电脑的运行速度。</p>
<p>为了加快数据交换速度，硬件制造者提出多通道设计。目前，使用比较多的是双通道。如果想使用双通道技术，尽可能购买两个型号相同，容量相同的内存（就是尽可能确保两个硬件的参数相同），如果<strong>硬件容量不同，双通道技术使用起来会出错。</strong></p>
<h2><span id="显卡">显卡</span></h2><p>显卡又称为<strong>VGA（Video Graphics Array）</strong>，现在的显卡也被称为<strong>GPU（Graphic Process Unit）</strong>；显卡最初的功能是用来处理图像显示的，一般来说，图像的显示的重点在于<strong>分辨率</strong>和<strong>颜色深度</strong>。显卡也具有存储能力，并且也是DRAM，即通电后才能读写，掉电后数据会小时。图像实际是由众多的像素组成的，对于一张图，像素越多，粒度越细，看起来越清晰，而每个像素实际是一个数据值，也即每个像素需要存储，这些像素值就存储在显卡中。故，<strong>显存容量会影响到屏幕的分辨率和颜色深度。</strong></p>
<p>由于显卡有较大的显存容量，并且具有一定的计算能力，同时，由于CPU需要负责太多事情（控制+运算），制造商就希望能够利用显卡的数值计算能力，（显卡本身的设计是为处理图像，图像本身是矩阵数据堆叠，使得显卡本身就具有不错的计算能力），故，制造商在显卡中增加了一个3D加速芯片，这就是GPU称谓的由来。</p>
<p>同样，显卡的容量越大，能够处理的数据就越多。对于需要大量数据渲染的应用，一张好的显卡是必要的。同样，在深度学习等场景，GPU扮演了很重要的数值计算的角色，也是容量越大越好。但如果主机仅仅作为网络服务器，只要一般的显卡即可。网络服务器并不需要很强的图像显示、处理能力。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-24T07:14:02.000Z" title="2023/12/24 15:14:02">2023-12-24</time>发表</span><span class="level-item"><time dateTime="2023-12-24T09:13:04.956Z" title="2023/12/24 17:13:04">2023-12-24</time>更新</span><span class="level-item">10 分钟读完 (大约1522个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/24/%E7%9C%BC%E9%95%9C%E7%9B%B8%E5%85%B3/">眼镜相关</a></p><div class="content"><h1><span id="眼睛相关">眼睛相关</span></h1><p>配眼镜可以事先了解的事情：</p>
<p>折射率：先说结论，高度数可以考虑选高折射率，低度数没必要。</p>
<p>折射率：1.50折射率 1.56折射率 1.60折射率 1.67折射率 1.71折射率 1.74折射率.</p>
<p>折射率越高，镜片越薄，<strong>镜片不是越薄越好</strong>， 折射率高的镜片，阿贝系数会低。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241514775.jpeg" alt="img"></p>
<p>&#x3D;&#x3D;<strong>阿贝系数</strong>&#x3D;&#x3D;对于眼镜镜片的选择非常重要。在选择镜片时，较高的阿贝系数意味着镜片具有更好的成像能力，可以提供更为清晰和舒适的视觉体验。特别是对于需要长时间使用眼镜的人群来说，选择具有高阿贝系数的镜片可以减轻眼睛疲劳和不适感。</p>
<p><strong>结论</strong>：阿贝系数越高，成像越清晰，可以减轻眼睛疲劳，折射率越高，眼镜越薄，眼镜轻，折射率与阿贝系数成反比，阿贝系数越高，折射率越低。</p>
<p>阿贝数在<strong>30以下</strong>的，国家标准中<strong>不能使用，</strong>对人眼有极大的影响与伤害，产生不良的视觉效果，对于青少年近视来说，有加深近视的情况产生，对颜色与形状辨别上也产生不良现象，因此国家不准使用阿贝数低于30的材料当镜片。</p>
<p>球面镜、非球面镜、双非球面镜</p>
<p>球面镜：球面镜片，镜片<strong>变形比较严重，不是特别推荐</strong>（很多都不是很推荐），定制性非球面设计除外</p>
<p>非球面的设计，修正了影像，解决视界歪曲等问题，同时，使镜片更轻、更薄、更平。而且，仍然保持优异的抗冲击性能，使配戴者安全使用。</p>
<p><strong>双非球面镜片：</strong>接近裸眼感受，成像质量更高，镜片的边缘区域变形也更小，对于高散人群会更合适。（视觉效果比较好，价格比较高）</p>
<p>价格上：非球面镜 &lt;  双非球面镜 （这个好像确实挺贵）</p>
<p>镜片材质基本都是树脂的。</p>
<p>镜架：纯钛、含钛、β钛、不锈钢、合金。</p>
<p>纯钛最轻，价格稍高。如果你追求性价比，选国产镜架，甚至不知名的，只要材质对，基本没问题。</p>
<p><strong>简单点说：钛质镜架、1.56、1.60折射率估计挺够用的，非球面镜。</strong></p>
<h2><span id="镜片">镜片</span></h2><p>镜片主要分两个部分：基片，镀膜。</p>
<p>没必要考虑树脂之外材质的，象玻璃、PC都在长期的博弈中被时间淘汰了</p>
<p>拒水、防尘、防雾、防污、防蓝光</p>
<h3><span id="蔡司">蔡司</span></h3><p>系列：佳锐 &lt; A系列莲花膜 &lt; 新清锐 &lt; 臻锐 &lt; 铭睿</p>
<p>蔡司镜片的膜：</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241558084.jpeg" alt="img"></p>
<h4><span id="佳锐非球面-冰蓝光高清膜">佳锐（非球面 冰蓝光高清膜）：</span></h4><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241543829.png" alt="image-20231224154341400"></p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.59</th>
<th>1.60</th>
<th>1.67</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>35.0&#x2F;37.0</td>
<td>29.0</td>
<td>40.5&#x2F;40.0</td>
<td>32.0</td>
<td>33.0</td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）</td>
<td>到手154.1</td>
<td></td>
<td>211</td>
<td>282</td>
<td>677.37</td>
</tr>
</tbody></table>
<p>网址：<img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241554526.png" alt="image-20231224155455093"></p>
<p>佳锐 防蓝光膜</p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.59</th>
<th>1.60</th>
<th>1.67</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>35.0&#x2F;37.0</td>
<td>29.0</td>
<td>40.5&#x2F;40.0</td>
<td>32.0</td>
<td>33.0</td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）</td>
<td>到手244.55</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>佳锐 钻立方防蓝光膜</p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.59</th>
<th>1.60</th>
<th>1.67</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>35.0&#x2F;37.0</td>
<td>29.0</td>
<td>40.5&#x2F;40.0</td>
<td>32.0</td>
<td>33.0</td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）</td>
<td>到手369.84</td>
<td></td>
<td>544.71</td>
<td>794.62</td>
<td></td>
</tr>
</tbody></table>
<h3><span id="依视路镜片">依视路镜片</span></h3><p>依视路钻晶A+： 防水、耐磨、耐污、减少反光、防紫外线、</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241612674.png" alt="image-20231224161223275"></p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>36.1</td>
<td>40.1</td>
<td>32.0</td>
<td>33.0</td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）防蓝光</td>
<td>178</td>
<td>231</td>
<td>430</td>
<td></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://item.jd.com/7863656.html">【依视路镜片】依视路（ESSILOR）1.60非球面钻晶A4防蓝光膜层光学镜片 1片装(现片)【1000度以内】【行情 报价 价格 评测】-京东 (jd.com)</a></p>
<p><strong>依视路（ESSILOR）钻晶膜</strong></p>
<p>防水、耐磨、耐污、减少反光、防紫外线。</p>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241618936.png" alt="image-20231224161858789"></p>
<h4><span id="钻晶膜岩">钻晶膜岩</span></h4><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.67双非球面</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>36.1</td>
<td>40.1</td>
<td>32.2</td>
<td>32.2</td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）防蓝光</td>
<td>178</td>
<td>236.91</td>
<td>398.73</td>
<td>904.85</td>
</tr>
</tbody></table>
<h4><span id="钻晶膜御">钻晶膜御</span></h4><p>防水、耐磨、耐污、减少反光、防紫外线、防蓝光</p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）防蓝光</td>
<td>245</td>
<td>236.91</td>
<td>599.21</td>
</tr>
</tbody></table>
<p>钻晶膜致</p>
<p>防水、耐磨、耐污、减少反光、防紫外线、防蓝光</p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（一片装）（配镜服务京东自营专区）防蓝光</td>
<td>315</td>
<td>412.61</td>
<td>693.01</td>
</tr>
</tbody></table>
<h3><span id="明月">明月</span></h3><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241631155.png" alt="image-20231224163150071"></p>
<h4><span id="明月日常系列">明月日常系列</span></h4><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.71</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>35.5</td>
<td>33</td>
<td>32</td>
<td>37</td>
<td>33</td>
</tr>
<tr>
<td>价格（两片装）（明月京东自营店）</td>
<td>215</td>
<td>294</td>
<td>572</td>
<td>737</td>
<td>1651</td>
</tr>
</tbody></table>
<h3><span id="双重防蓝光">双重防蓝光</span></h3><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.71</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td>41</td>
<td>33</td>
<td>32</td>
<td>37</td>
</tr>
<tr>
<td>蓝光阻隔率</td>
<td>19%</td>
<td>21%</td>
<td>32%</td>
<td>20%</td>
</tr>
<tr>
<td>价格（两片装）（明月京东自营店）防蓝光</td>
<td>285</td>
<td>381</td>
<td>798</td>
<td>911</td>
</tr>
</tbody></table>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241642517.png" alt="image-20231224164254185"></p>
<h3><span id="pmc超亮">PMC超亮</span></h3><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.71</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（两片装）（明月京东自营店）防蓝光</td>
<td>372</td>
<td>485</td>
<td>903</td>
</tr>
</tbody></table>
<h4><span id="明月智能变色">明月智能变色</span></h4><p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241643464.png" alt="image-20231224164321626"></p>
<table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.71</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（两片装）（明月京东自营店）防蓝光</td>
<td>485</td>
<td>607</td>
<td>1033</td>
<td>1216</td>
</tr>
</tbody></table>
<h2><span id="万新">万新</span></h2><p><a target="_blank" rel="noopener" href="https://item.m.jd.com/product/100011308801.html?utm_user=plusmember&gx=RnAomTM2CUKtt-1Q3PM3OkzYd5wIdQ&gxd=RnAoxjJZbzfenZwU_IYkW8CR9T4lD4s&ad_od=share&utm_source=androidapp&utm_medium=appshare&utm_campaign=t_335139774&utm_term=CopyURL">https://item.m.jd.com/product/100011308801.html?utm_user=plusmember&amp;gx=RnAomTM2CUKtt-1Q3PM3OkzYd5wIdQ&amp;gxd=RnAoxjJZbzfenZwU_IYkW8CR9T4lD4s&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL</a></p>
<h3><span id="高清绿膜">高清绿膜</span></h3><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.74</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（两片装）（）</td>
<td>128</td>
<td>209</td>
<td>255.2</td>
<td>400</td>
</tr>
</tbody></table>
<h3><span id="防蓝光">防蓝光</span></h3><table>
<thead>
<tr>
<th>折射率</th>
<th>1.56</th>
<th>1.60</th>
<th>1.67</th>
<th>1.71</th>
</tr>
</thead>
<tbody><tr>
<td>阿贝系数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>价格（两片装）（）防蓝光</td>
<td>158.4</td>
<td>263.2</td>
<td>293.6</td>
<td>437.6</td>
</tr>
</tbody></table>
<p><img src="https://duohangsun-gitee.oss-cn-shanghai.aliyuncs.com/duohangsun-gitee-img/202312241648807.png" alt="image-20231224164856398"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-21T02:55:18.000Z" title="2023/12/21 10:55:18">2023-12-21</time>发表</span><span class="level-item"><time dateTime="2023-12-21T13:39:17.099Z" title="2023/12/21 21:39:17">2023-12-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C-%E5%AD%A6%E4%B9%A0/">C++学习</a></span><span class="level-item">1 分钟读完 (大约173个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/21/Cpp-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/">Cpp:函数声明、定义及使用</a></p><div class="content"><h1><span id="cpp函数声明-定义及使用">Cpp:函数声明、定义及使用</span></h1><p>C&#x2F;C++函数声明形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参列表);</span><br></pre></td></tr></table></figure>

<p>声明不要忘记<code>;</code>，有些时候会忘记以分号结束。</p>
<p>声明是声明函数原型，就是告诉编译器函数的类型。函数原型指明了函数的返回值类型、和函数接受的参数类型；这些信息称为函数的签名（signature）。</p>
<p>C&#x2F;C++函数定义形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参列表)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名（实参传递）;</span><br></pre></td></tr></table></figure>



<h2><span id="使用带有默认参数的函数声明-定义和使用">使用带有默认参数的函数声明、定义和使用</span></h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-20T07:12:14.000Z" title="2023/12/20 15:12:14">2023-12-20</time>发表</span><span class="level-item"><time dateTime="2023-12-20T07:14:40.305Z" title="2023/12/20 15:14:40">2023-12-20</time>更新</span><span class="level-item">几秒读完 (大约84个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/20/C-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA/">C++错误处理异常抛出</a></p><div class="content"><h1><span id="c错误处理异常抛出">C++错误处理异常抛出</span></h1><p>使用throw抛出异常时，如果想要特别提示一些信息，请使用<code>std::logic_error</code>初始化一个错误对象，再作为参数传给<code>std::exception</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::logic_error <span class="title">ex</span><span class="params">((<span class="string">&quot;List to string failed,&quot;</span>+ std::to_string(<span class="keyword">this</span>-&gt;data.size() - str.size())+<span class="string">&quot; byte(s) are missing&quot;</span>).c_str())</span></span>;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(ex);</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="SUNX"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SUNX</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/null"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_43571647?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span></a></li><li><a class="level is-mobile" href="" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">简书</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">C++学习</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/MATLAB/"><span class="level-start"><span class="level-item">MATLAB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/excel%E6%93%8D%E4%BD%9C/"><span class="level-start"><span class="level-item">excel操作</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">博客搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8E%9F%E5%88%9B/"><span class="level-start"><span class="level-item">原创</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87/"><span class="level-start"><span class="level-item">论文</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">路径规划</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="level-start"><span class="level-item">路径规划启发式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">路径规划算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-03T10:45:41.000Z">2024-03-03</time></p><p class="title"><a href="/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/">Hierachical A: Searching Abstraction Hierarchies Efficiently</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T06:17:52.000Z">2024-03-01</time></p><p class="title"><a href="/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/">The Grid-Based Path Planning Competition 2014 Entries and Results</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T08:06:51.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/">Near Optimal Hierarchical Path-Finding</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-29T07:45:43.000Z">2024-02-29</time></p><p class="title"><a href="/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/">Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-28T15:35:45.000Z">2024-02-28</time></p><p class="title"><a href="/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/">Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments</a></p><p class="categories"><a href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">37</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C-%E5%AD%A6%E4%B9%A0/"><span class="tag">C++学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLion%E5%AE%89%E8%A3%85/"><span class="tag">CLion安装</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GDAL/"><span class="tag">GDAL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hierachical/"><span class="tag">Hierachical</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MAPF/"><span class="tag">MAPF</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MATLAB/"><span class="tag">MATLAB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Q1/"><span class="tag">Q1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XTDrone/"><span class="tag">XTDrone</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pandas/"><span class="tag">pandas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82/"><span class="tag">分层</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"><span class="tag">分层方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"><span class="tag">原文翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"><span class="tag">可视图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"><span class="tag">启发式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"><span class="tag">图论知识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"><span class="tag">多智能体</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><span class="tag">环境配置</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"><span class="tag">离散数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"><span class="tag">维诺图</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%BC%E8%BF%B0/"><span class="tag">综述</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"><span class="tag">路径规划</span><span class="tag">6</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="SUNX的记录" height="28"></a><p class="is-size-7"><span>&copy; 2024 SUNX</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>