{"posts":[{"title":"A Conflict-Based Search Framework for Multiobjective Multiagent Path Finding","text":"A Conflict-Based Search Framework for Multiobjective Multiagent Path FindingAbstract传统的多智能体路径规划器通常在优化单一目标（如路径长度）的同时计算路径集合。然而，许多应用可能需要在规划过程中同时优化多个目标，如燃料消耗和完工时间，而且这些标准可能不容易比较，有时还会相互竞争。因此，问题的目标是找到一组帕累托最优解（Pareto-optimal），而不是单一最优解。将现有的多目标搜索算法（如多目标 A* (MOA* )）简单地应用于多智能体路径搜索可能会被证明是低效的，因为搜索空间的维度会随着智能体数量的增加而呈指数增长。本文提出了一种名为 “基于冲突的多目标搜索（MO-CBS）”的方法，试图利用先前的基于冲突的搜索（CBS）（一种著名的单目标多智能体路径搜索算法）和多目标优化文献中的优势原则来解决这种所谓的 “维度诅咒”。我们还开发了 MO-CBS 的几个变体，以提高其性能。我们证明了 MO-CBS 及其变体可以计算整个帕累托最优集。数值结果表明，MO-CBS 的性能优于最近开发的最先进的多目标智能体规划器 MOM* 。 Note to Practitioners本文的动机源于在仓库物流、监控、施工场地路线和危险品运输等应用中，为多个移动机器人规划无冲突路径时，需要优化多个路径标准。现有的多智能体规划方法通常只考虑优化单一路径标准。本文开发了一种新颖的多目标多智能体规划器及其变体，可保证找到问题的所有帕累托最优解。我们还提供了一个示例，用该算法为在建筑工地上运输材料的多个智能体规划路径，同时优化路径长度和风险。在这个例子中，通过计算和可视化一组帕累托最优解，实践者可以直观地了解相互冲突的目标之间的基本权衡，并根据自己的领域知识选择最理想的执行方案。","link":"/2023/11/27/A-Conflict-Based-Search-Framework-for-Multiobjective-Multiagent-Path-Finding/"},{"title":"An Improved Ant Colony Optimization Algorithm for Multi-Agent Path Planning","text":"An Improved Ant Colony Optimization Algorithm for Multi-Agent Path Planning（用于多智能体路径规划的改进型蚁群优化算法）摘要近年来，蚁群优化算法已成为应用最广泛的启发式算法之一，并被广泛应用于解决不同类型的路径规划问题。然而，多智能体路径搜索仍存在一些问题，如收敛效率低、易陷入局部最优和顶点冲突等。本文提出了一种基于==参数优化==和==顶点冲突解决==的改进蚁群优化算法。首先，我们初始化了信息素的分布，以减少算法早期的盲目性。其次，我们引入了自适应信息素强度和信息素减少因子，以避免算法陷入局部最优。在此基础上，通过动态修正蒸发因子和启发式函数，提高算法的全局搜索能力和收敛速度。此外，动态修正影响因子和启发式函数的策略也提高了算法的全局搜索能力和收敛速度。==为解决 MAPF 中的顶点冲突，我们采用了设计冲突预测和解决策略，==有效避免了顶点冲突，提高了多智能体系统的可靠性。仿真实验验证了 IACO 在不同复杂度环境下的有效性和适应性，证明了 IACO 具有良好的收敛速度和路径全局优化能力。 I. INTRODUCTION近年来，随着人工智能技术的飞速发展，路径优化已成为热门研究课题之一。路径优化是指在已知或未知障碍物的情况下，根据最优性能的评价标准，包括收敛速度、路径长度等，在工作空间中找到一条最优的前进路径，并有效地避开障碍物。A* 算法 [1] 和 Dijkstra 算法 [2] 是典型的路径规划方法。随着人工智能优化算法的不断发展，遗传算法[3]和蚁群优化算法[4]等仿生算法越来越受到人们的关注。然而，它们也存在一些缺陷，亟待改进。蚁群优化算法（ACO）作为一种仿生智能算法，因其具有良好的鲁棒性和鲁棒智能搜索能力等优点而被学者们广泛研究。如上所述，它也存在搜索时间长、收敛速度慢、最优局部解等问题[5]。本文基于蚁群优化算法研究了多智能体路由问题，并进行仿真实验验证了我们方法的性能。本文的贡献总结如下： 我们提出了一种改进的蚁群优化算法（IACO），该算法主要针对多智能体路径寻找问题，通过参数优化和顶点冲突解决来提高多智能体系统的效率和可靠性。 我们根据影响 ACO 性能的基本参数对 ACO 进行改进和优化。通过自适应动态参数调整模式，防止算法陷入局部最优。我们利用自适应动态参数调整策略来避免局部最优。 我们提出了多代理路径搜索（MAPF）中的冲突解决策略，有效避免了路径搜索中的顶点冲突问题，确保了系统的稳定性。 II. RELATED WORKSA. Multi-Agent Path FindingMAPF 是多智能体的路径查找问题，要求每个智能体在不发生冲突的情况下到达目标 [6]、[7]。它在仓库管理 [8]、机场牵引 [9]、自动驾驶汽车、机器人技术 [10] 等领域都有实际应用。Nazarahari 等人[11] 对遗传算法进行了改进，在算法中加入了碰撞消除算子，以消除机器人之间可能发生的碰撞。然而，这种方法仅限于障碍物较少的外部环境，无法应用于障碍物较多的复杂环境。Cao 等人[12]提出了一种基于预留区域的多机器人路径规划方法，避免了路径规划中机器人间路径高度耦合的问题。Yu 等人[13]设定了每个机器人的优先级，以最小化工作完成时间。然而，由于每个机器人的独立性很强，使用这种方法很容易找到局部最优情况。尽管如此，人工智能研究人员在过去几年中还是取得了长足的进步，为越来越多的场景和一百多个智能体找到了最优解[14]̢[16]。然而，之前的大多数研究工作都假定：(1) 时间被离散成时间步；(2) 每个行动的持续时间为一个时间步；(3) 在每个时间步中，每个智能体只占据一个位置。这些简化假设限制了 MAPF 算法在现实世界中的适用性。 B. Ant Colony Optimization AlgorithmACO 本质上是一种基于智能体的系统，模拟蚂蚁的自然行为，包括合作和适应机制。Corne 等人[17]将这种系统作为一种新的元启发式来解决组合优化问题。事实证明，这种新的元启发式既稳健又灵活，并已成功应用于一系列不同的组合优化问题。ACO 是一种仿生优化算法，它通过人工模拟蚂蚁的行为来获得最短路径。由于蚂蚁对周围环境不敏感，背景的变化不会影响蚂蚁快速找到新的最短路径。对蚂蚁来说，起决定作用的是一种叫做信息素的特殊分泌物，它是蚂蚁为寻找最短路径而分泌的。每只蚂蚁都会沿路径释放信息素，根据每条路径上信息素浓度的差异，就能找到最短路径。 III. METHODOLOGY在传统的 ACO 中，信息启发因子、期望启发因子、信息素波动系数等都是基本参数，通常是固定不变的。因此，初级 ACO 容易陷入局部最优，在动态环境下迭代速度较慢。此外，在 MAPF 中，不同时期的参数对算法的影响是不同的。因此，我们对传统的 ACO 进行了改进，以克服上述缺陷。 A. Improved Initial Pheromone初始信息素浓度的均匀分布往往会导致一些问题，如初始迭代时搜索盲目性强、收敛速度慢等。在以往的研究中，研究者[18]、[19]证实了信息素初始化的差异化分配有利于更稳健地找到最优路径。为了减少错误启发式信息对蚂蚁的误导，提高寻优能力，我们基于弱启发式的思想对算法中的信息素分布进行初始化。初始化函数定义如下： $$\\tau_t = \\left { \\begin{aligned} C &amp; = &amp; t \\in R \\ \\tau_0 &amp; = &amp; others \\end{aligned} \\right.$$ 其中，C 是常数，且大于 $\\tau_0$ ，R 是蚂蚁可行的有利节点区域集。 B. Adaptive Pheromone Intensity在蚂蚁探索的早期阶段，有必要扩大搜索范围以找到更好的路径。此时，必须将信息素强度设置为较小，以避免蚂蚁继续在一条路径上行走或得到局部最优解。但是，在探索的后期阶段，路径的探索已经完成，较短的路径已经确定。此时，不需要在大范围内探索，而是要稳定一条较短的路径。因此，Q 值需要足够大。在这种情况下，信息素强度的值不再是恒定的，需要随着迭代次数的增加而不断变化。自适应信息素强度函数如下：$$Q_n = \\phi * ln(n),\\phi \\in[0, 1] $$ 其中，n 是当前迭代次数，$\\phi$ 是调节因子。 C. Pheromone Reduction Factor信息素更新可分为两个过程：实时更新和全局更新。当蚂蚁在迭代结束后更新全局信息素时，找到的最短路径上的信息素值就会增加。根据每轮迭代结束后所有路径的平均信息素值，我们引入信息素减少因子，其定义为：$$\\begin{aligned} v = \\frac{L_b}{L_a} \\L_a = \\sum^{k}{i=1} L^{i} / n \\end{aligned}$$其中，$L_b$ 表示一次搜索中找到的最短路径，$L_a$ 表示一次搜索中蚂蚁的平均路径长度。搜索路径越短，信息素减少系数就越小，保留的信息素就越多，反之亦然。蚂蚁完成路径搜索后，需要更新全局信息素。更新规则如下$$\\tau{ij}(t+1) = (1- \\rho)\\tau_{ij}(t) + (1-v) \\bigtriangledown \\tau_{ij}(t)$$其中，$\\tau_{ij}(t)$ 表示时间 t 时（i，j）中的信息素，$\\rho$ 和 $v$ 为权重参数。带有缩减因子的路径信息素更新方法可以加快算法的收敛速度，并显著提高选择最优路径的概率。 D. Optimized Heuristic Function由于正反馈不明显，蚂蚁在栅格环境中很容易陷入局部最优。通过利用当前节点与下一节点之间的距离之和以及下一节点与目标节点之间的距离之和的平方来优化启发式函数，我们改进了迭代搜索中的启发式函数。该函数能使蚂蚁在搜索初始阶段获得指引方向，并增加目标节点对下一个节点的影响。改进后的启发式函数定义如下 $$\\begin{aligned} d_{jk} = \\sqrt{(x_{j} - x_{k})^{2} + (y_{j} - y_{k})^{2}} \\ \\eta_{ij}^{*} = \\frac{1}{(d_{ij}+d_{jk})^2}\\end{aligned} $$其中，$d_{jk}$ 表示节点 J 与目标点 K 之间的欧氏距离，$\\eta_{ij}^{**}$ 表示影响系数。通过将传统的 $d_{ij}$ 改为$(d_{ij} +d_{jk})^2$ ，增强了搜索的目的性，降低了陷入局部最优解的概率。 E. Dynamic Evaporation Factor传统的蚁群优化蒸发系数在算法运行过程中是恒定的，无法适应动态变化的环境。因此，我们采用了自适应动态蒸发系数，具体如下： $$\\rho_d(t+1) = \\left { \\begin{aligned} \\frac{9n}{N}\\rho(t) &amp; &amp; \\frac{9n}{N}\\rho(t) \\leq \\rho_{max} \\\\rho_{max} &amp; &amp; others\\end{aligned} \\right.$$ 其中，$\\rho_{d}$ 表示改进后的信息素蒸发系数，N 表示最大迭代次数。 F. Vertex conflict problemMAPF 系统正逐渐取代单智能体路径搜索（SAPF）系统。与单智能体相比，多智能体在集群中工作时，所有智能体可以协调合作，提高工作效率[7]，[20]。然而，在多智能体集群系统中，如果智能体同时到达同一节点，就会发生路径冲突和系统死锁。为了解决光栅地图路径查找中的顶点冲突问题，本文提出了一种冲突预测与解决策略。 冲突检验：多智能体系统 $A$ 规划初始路径组 $L_c=[L_{c_1},L_{c_2}, …, L_{c_n}]$ 表示为每个智能体，每条路径是一组节点坐标。如果 $A_i$ 的初始路径 $L_{c_i}$ 与其他智能体的初始路径节点集的交集为空，则智能体 $A_i$ 可以按照初始路径安全移动。假设路径坐标位置与其他智能体初始路径坐标集的交集不为空。在这种情况下，初始路径与其他智能体的初始路径存在交点，有必要进行安全判断。判断方法如下： $$|\\frac{d_{S_{i}W_{i,j}(k)}}{v_{i}} -\\frac{d_{S_{j}W_{i,j}(k)}}{v_{j}} |$$ 其中，݀$d_{S_{i}W_{i,j}(k)}$ 表示沿 A 的初始路径 $A_{i}$，从起始节点 $S_{i}$ 到交点 $W_{ij}(k)$ 的距离。这意味着当二者沿初始路径移动时，不会在安全时间内到达交点 $W_{ij}$，也就不存在路径冲突。交点称为伪冲突节点 $M_{ij}$ 。如果不满足该公式，则会发生路径冲突，需要进行路径协调。智能体 $A_{i}$ ，与其他智能体之间的初始路径交点集为$W_{i}=W_{i,1} \\cup W_{i,2} \\cup … \\cup W_{i,n}$，并依次对 $W_i$ 中的交叉节点进行安全判断。判断完成后，从$W_{i}$中删除没有路径冲突的伪冲突节点集, 得到路径冲突节点集ܼ $Z_{i}=Z_{i,1} \\cup Z_{i,2} \\cup … \\cup Z_{i,n}$ 智能体 $A_{i}$ 与其他智能体之间的路径冲突节点。 IV. EXPERIMENTS AND DISCUSSIONSA. Quantitative Experiments根据ACO（A）和IACO（I）算法在不同模拟图中的测试要求，选择蚂蚁数量、初始信息素、信息素强度、蒸发系数等相关参数如表I所示。IACO 的信息素强度和信息素减少因子随迭代次数自适应变化。表二显示了 ACO 和 IACO 在包含不同智能体的不同地图中的算法性能对比结果。根据在四种模拟地图中的测试，在相同的地图环境下，IACO 可以找到更短的最优路径。根据地图比例尺的不同，光路长度从大到小分别为 4、4、7、17。其中，在小地图中，由于环境简单，两种算法得到的最优路径长度相等。其次，IACO 算法的运行速度更快，分别达到 0.11、0.5、5.05 和 267.8。同时，在寻找最优路径的迭代次数上，IACO明显少于ACO，分别为2、5、14、36次。这充分说明本文对 ACO 的优化和改进有效地提高了算法的收敛能力和搜索速度。 B. Conflict resolution为了激发本文提出的顶点冲突解决策略的必要性，本文以 SSMALL 地图为例，仅针对冲突问题进行实验。结合图 2 和表 III，智能体 $A_1$ 和 $A_2$ 在寻路过程中会产生两个冲突点（1, 2）和（2, 3）。在 ACO 中，$A_1$ 序列的路径为 [(0, 0)，(1, 1)，(1, 2)，(2, 3)，(3, 2)]，$A_2$ 序列的路径为 [(1, 0)，(1, 1)，(1, 2)，(2, 3)，(3, 3)]。冲突解决策略改进后，当 $A_1$ 和 $A_2$ 之间发生顶点冲突时，第一步是根据序列 . $A_1$进入路径序列[（0，0），(1,1)，(1, 2), (2, 3), (3, 2)，$A_2$为了避免冲突，路径序列变为[(1, 0). (0, 1), (0, 1), (1, 2), (2, 3), (3, 3)]. 通过使用 $A_2$暂停一次，可以有效避免顶点冲突。 我们选择了具有代表性的中图和大图进行分析。如图 3 所示，圆圈标记表示起点，星号标记表示终点。这两种算法都能帮助每个智能体顺利找到最短的移动路径。随着传统 ACO 迭代次数的增加，蚂蚁会经常进入死锁状态，从而采取后退策略。这会导致智能体之间发生更多顶点碰撞，所得到的可行路径明显长于改进算法。所提出的解决策略能有效防止蚂蚁陷入局部最优状态。这也意味着可以避免顶点碰撞。总之，优化初始信息素和使用自适应信息素强度可以有效调整劣势蚂蚁对下一步路径选择的影响，防止非最优信息素对蚂蚁的误导。同时，引入信息素缩减因子产生的信息素浓度差可以有效帮助蚂蚁脱离局部最优。随着算法迭代的进行，动态信息素蒸发因子保证了蚁群的随机性，提高了算法的全局搜索能力。 V. CONCLUSION本文利用 ACO 算法研究了 MAPF 问题，并针对传统 ACO 算法的缺陷提出了 IACO 优化方案。通过改进初始信息素和提出自适应信息素强度方案，防止算法陷入局部最优。此外，我们还引入了信息素减少因子和改进的蒸发因子，以提高算法的全局搜索能力和收敛速度。新的启发式功能加强了蚂蚁的正反馈作用。同时，基于MAPF中的顶点冲突问题，我们提出了一种新的冲突规避与解决策略，可以有效地检测和解决智能体之间的冲突，保证多智能体集群系统的可靠性。仿真实验表明，我们的方法至少提高了50%的效率，迭代次数减少了30%以上，证明了IACO的有效性和可行性。在今后的工作中，我们将进一步探索启发式算法在多智能体路径规划中的应用。 本文是对针对蚁群算法求解MAPF问题时，存在收敛效率低、易陷入局部最优、定点冲突等问题，进行的改进，该方法包括对蚁群算法的参数优化以及冲突预测和解决策略，参数优化包括：初始化信息素、信息素蒸发因子和启发式函数。 结论：基于蚁群算法进行改进，解决MAPF问题。引入信息素减少因子和改进的挥发因子，提高算法收敛速度和搜索能力，提出了冲突规避策略和解决冲突的策略。","link":"/2023/11/29/An-Improved-Ant-Colony-Optimization-Algorithm-for-Multi-Agent-Path-Planning/"},{"title":"MATLAB 插桩输出","text":"MATLAB 插桩输出该方法主要用于程序调试阶段： 通过该方法可以将程序的运行过程记录到文件中，以便自己分析MATLAB程序存在何种问题。 关于插桩技术的引用可以参考：【python算法】迪杰斯特拉算法 python实现-CSDN博客 主要利用输出语句 1234567print_log = fopen('test_record.txt','a','n','UTF-8');fprintf(print_log, &quot;\\n\\ntime: %s\\n&quot;, datestr(now,0)); % 输出程序运行时间fprintf(print_log, &quot;******************************************\\n&quot; + ... &quot;Algorithm&quot;\\n********************************************\\n&quot;); % 输出分割线fprintf(print_log, 'the Astar cost value is %d. \\n', AStar_cost);fprintf(print_log, 'the ThetaStar cost value is %d. \\n', ThetaStar_cost);fclose(print_log);","link":"/2023/11/24/MATLAB-%E6%8F%92%E6%A1%A9%E8%BE%93%E5%87%BA/"},{"title":"Particle swarm optimization based co-operative task assignment and path planning for multi-agent system","text":"Particle swarm optimization based co-operative task assignment and path planning for multi-agent system [!WARNING]+ 🐣 总结 🎯 研究问题::🔎 研究背景::🚀 研究方法::🐔 研究思路::📺 主要内容:: 本文提出了一种多智能体系统的合作路径规划和任务分配框架。🎉 研究结论:: 本文的重点是开发一种将任务分配与路径规划问题相结合的三层框架。在任务完成和路径搜索期间，该优化算法具有安全导航能力，确保路径无碰撞。在多代理系统中，即使在非常复杂的动态环境中，代理也能通过访问所有目标位置来完成给定任务。分析表明，所提出的框架非常容易实现，而且它能通过完成任何类型的指定任务轻松找到最佳解决方案。今后，我们将在实时场景中应用该框架。🗝️ 创新点::💩 研究局限::🐾 研究展望::✏️ 备注:: CONCLUSION文章重点是开发一种任务分配与路径规划问题相结合的框架。该框架具有： 安全导航能力 多路径无碰撞 能完成给定任务 Abstract本文提出了一种多智能体系统的合作路径规划和任务分配框架。对于候选算法来说，要处理动态环境中的多个智能体是比较困难的，在这种情况下，需要重新规划一条新的路径，以在不发生任何碰撞的情况下执行给定的任务。为了解决这个问题，这里提出了一种基于粒子群优化的路径规划算法，为在某些规定任务下工作的多智能体系统寻找最优路径。结果表明，由于采用了反应式管理结构，所提出的框架非常有效，能够成功完成任务。仿真结果表明，它是解决合作路径规划问题的一种可靠而稳健的方法。 文章问题场景是： 动态场景 多智能体 无碰撞合作式路径规划 完成给定任务 文章使用的基础算法是： 粒子群算法 Particle Swarm Optimization 环境运行空间是连续空间 SIMULATION RESULTS AND DISCUSSIONS实验环境 MATLAB R2015b 预备的参数组合如下： $\\omega= 1.0$, $c1 = 0.5$, $c2 = 2.0$, Population size of swarms (agents) = 25 and Maximum iterations = 50. 避免碰撞策略所考虑的参数如下： $\\omega= 1.0$, $c1 = 3.0$, $c2 = 4.0$, 这些增加的参数值有助于被捕获的粒子恢复。 为了评估整个框架的性能，我们模拟了几种不同情况的测试。我们将一个二维环境视为搜索空间，并考虑了不同类型的工作环境、不同类型的障碍物和不同数量的任务分配。工作空间的大小为 120 × 120 平方单位的地图。为简化起见，考虑了双智能体系统。每种配置均模拟运行 20 次。 实心圆代表静态障碍物，空心圆代表动态障碍物（图 2-8）。空心圆的序列代表动态障碍物的运动轨迹。动态障碍物可以是速度恒定的物体，也可以是随机移动的物体。路径上的圆圈表示智能体。在这种 SRVPSO 算法中，目标位置和目的位置周围考虑了 5-8 % 的容差区。菱形代表智能体需要访问的目标位置 图 2 显示了智能体没有任务分配且只考虑静态障碍物时的路径规划结果。两个智能体都规划了到达目标位置的路径，它们之间没有任何冲突。图 3 描述了在相同环境中分配任务后的无碰撞路径。这里，为智能体分配了四个目标位置 {(20,40)、(40,70)、(60,30) 和 (70,35)}，以便它们在目标点 (80,80) 完成任务。 如图3的相同任务分配，并增加动态障碍的路径规划序列截图如图 4 所示，动态环境由两个静态障碍物和一个动态障碍物组成。动态障碍物半径为 3 个单位，以固定速度从点（20，60）移动到点（43，22）。该规划的计算时间仅需 1.9 秒。 图 5 和图 6 显示了在相同动态环境中不同目标数量下的规划情况。在图 5 中，智能体被分配了 6 个目标，而在图 6 中，智能体访问了 10 个目标并最终到达目标。 图 7 和图 8 所示的搜索空间是一个更加复杂的动态环境，由三个静态障碍物和两个动态障碍物组成。两个动态障碍物的移动方向不同。一个半径为 “3 “个单位的动态障碍物从位置（20，70）移动到（66，1），而另一个半径为 “2 “个单位的移动障碍物则从位置（10，30）移动到（60，30）。图 7 的目标位置与图 8 的目标位置不同。在这个工作区中，智能体需要覆盖 14 个目标位置。完成任务所需的计算时间约为 8.1 秒。在某些图中，我们发现智能体无法到达特定的目标位置。不过，它们能够在容差范围内到达非常接近这些地点的地方。","link":"/2023/11/27/Particle-swarm-optimization-based-co-operative-task-assignment-and-path-planning-for-multi-agent-system/"},{"title":"Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks","text":"Multi-Agent Pathfinding: Definitions, Variants, and BenchmarksAbstract多智能体寻路（MAPF）问题是为多个智能体规划路径的基本问题，其中的关键约束条件是智能体能够同时沿着这些路径前进，而不会相互碰撞。MAPF 的应用包括自动仓库和自动驾驶汽车。在过去几年中，有关 MAPF 的研究一直在蓬勃发展。不同的 MAPF 研究论文做出了不同的假设，例如，智能体是否能同时穿越同一条道路，并具有不同的目标函数，例如，最小化时间跨度或智能体行动成本总和。这些假设和目标有时是隐含假设或非正式描述。这就很难在研究论文中建立适当的比较基线，也使实践者很难找到与其具体应用相关的论文。本文旨在填补这一空白，为研究人员和从业人员提供支持，为描述常见的 MAPF 假设和目标提供统一的术语。此外，我们还提供了两个 MAPF 基准的指针。特别是，我们为 MAPF 引入了一个新的基于栅格的基准，并通过实验证明它对当代 MAPF 算法构成了挑战。 1 IntroductionMAPF 是多智能体规划问题的一种重要类型，其任务是为多个智能体规划路径，其中的关键约束条件是这些智能体能够同时沿着这些路径前进而不会相互碰撞。MAPF 在当代有一系列相关应用，包括自动仓库、自动驾驶汽车和机器人。因此，近年来这一问题受到了各研究小组和学术界的关注（Standley，2010 年；Felner 等，2017 年；Surynek 等，2016 年；Bart ́ ak、ˇ Svancara 和 Vlk，2018 年；Cohen 等，2018a；Li 等，2019 年；Ma 等，2019a）。 不同的 MAPF 研究论文考虑了不同的智能体假设，旨在实现不同的目标。这些假设和目标有时是隐含的，有时是非正式描述的。即使在对假设和目标函数进行正式描述的情况下，所使用的 MAPF 术语仍然存在差异。这就很难浏览和理解现有文献，也很难建立适当的比较基线。此外，从业人员也很难找到与其具体应用相关的论文。 本文旨在通过引入统一术语来描述 MAPF 问题，并建立用于评估 MAPF 算法的通用基准和评估措施，来应对这一日益严峻的挑战。本文提出的统一 MAPF 术语是我们对目前研究的 MAPF 变体进行分类的尝试。我们希望这一术语能成为未来研究人员的共同基础，并被他们用来简洁准确地描述自己的贡献。 在本文的第二部分，我们向社区介绍了一种新的栅格 MAPF 基准。该基准包括一组不同的地图以及生成的源顶点和目标顶点。我们报告了标准 MAPF 算法在该基准上的性能，作为未来研究的比较基准。该基准旨在帮助未来的研究人员，对现有和未来的 MAPF 算法进行更科学严谨的实证比较。我们并不声称这些基准是完美的，因为它们可能存在一些偏差。但是，通过使用和研究，我们可以发现并纠正这些偏差。同样重要的是要强调，本文无意成为对最先进 MAPF 算法的调查。有关此类调查，请参见（Felner 等人，2017 年；Ma 和 Koenig，2017 年）。此外，新创建的网站 http://mapf.info 包含与 MAPF 相关的教程和其他资源。 2 Classical MAPF我们首先描述一个经典的 MAPF 问题。有 k 个智能体的经典 MAPF 问题的输入是一个元组 $〈G, s, t〉$，其中 $G =(V, E)$ 是一个无向图，$s :[1,…,k] → V$ 将一个智能体映射到一个源顶点，$t :[1,…,k] → V$ 将一个智能体映射到一个目标顶点。假定时间是离散的，在每个时间步中，每个智能体都位于图顶点中的一个，并可以执行一个动作。经典 MAPF 中的动作是一个函数 $a: V → V, a(v)=v’$ 表示如果一个智能体位于顶点 v 并执行了 a，那么在下一个时间步中它将位于顶点 $v′$。每个智能体都有两种行动：等待和移动。等待行动是指智能体在下一个时间步停留在当前顶点。移动动作意味着智能体从当前顶点 v 移动到图中相邻的顶点 $v′(i.e (v, v′) \\in E)$。 对于一个行动序列 $π =(a1,…an)$ 和一个智能体 $i$，我们用 $\\pi_{i}[x]$ 表示从智能体的源 $s(i)$ 出发，执行完 $\\pi$ 中前 $x$ 个行动后智能体的位置。形式上，$\\pi_{i}[x]=a_{x}(a_{x-1}(…a_{1}(s(i))))$。如果在 $s(i)$ 中执行该行动序列的结果是处于 $t(i)$，即如果 $\\pi_{i}[|\\pi|]=t(i)$，那么行动序列 $\\pi$ 就是智能体 $i$ 的单个智能体计划。解决方案是一组 k 个智能体规划，每个智能体一个规划。 2.1 Types of Conflicts in Classical MAPFMAPF 求解器的首要目标是找到一个解决方案，即每个智能体的单个智能体规划，该规划可以在不发生冲突的情况下执行。为了实现这一目标，MAPF 求解器在规划过程中使用了冲突的概念，如果任意两个智能体计划之间不存在冲突，则称 MAPF 解决方案有效。冲突的定义取决于环境，相应地，经典 MAPF 文献中也包含了几种不同的冲突定义。下面我们将列出常见的冲突定义。设 $\\pi_{i}$ 和 $\\pi_{j}$ 是一对智能体规划。 顶点冲突 如果根据这些规划，智能体计划在同一时间步占据相同的顶点，那么$\\pi_{i}$和 $\\pi_{j}$ 之间就会发生顶点冲突。从形式上看，如果存在一个时间步 x，使得 $\\pi_{i}[x]=\\pi_{j}[x]$ ，那么 πi 和 πj 之间就会发生顶点冲突。 边冲突 如果根据这些规划，智能体计划在同一时间步长沿同一方向穿越同一条边，那么$\\pi_{i}$ 和 $\\pi_{j}$ 之间就会发生边冲突。从形式上看，如果存在一个时间步 $x$，使得 $\\pi_{i}[x]=\\pi_{j}[x]$ 和 $\\pi_{i}[x +1]=\\pi_{j}[x +1]$ ，那么 $\\pi_{i}$ 和 $\\pi_{j}$ 之间就存在边缘冲突。 跟随冲突 如果一个智能体计划占据另一个智能体在前一时间步中占据的顶点，则 $\\pi_{i}$ 和 $\\pi_{j}$ 之间发生跟随冲突。从形式上看，如果存在一个时间步 $x$，使得 $\\pi_{i}[x +1]=\\pi_{j}[x]$ ，那么 $\\pi_{i}$ 和 $\\pi_{j}$ 之间就存在跟随冲突。 循环冲突 如果在同一时间步中，每个智能体都移动到之前被另一个智能体占据的顶点，形成 “旋转循环 “模式，那么一组单一智能体规划 $\\pi_{i},\\pi_{i+1},…\\pi_{j}$ 之间就会发生循环冲突。从形式上看，如果存在一个时间步 $x$，其中 $\\pi_{i}(x+1)=\\pi_{i+1}(x)，\\pi_{i+1}(x+1)=\\pi_{i+2}(x)$……且 $\\pi_{j-1}(x+1)=\\pi_{j}(x)$和 $\\pi_{j}(x+1)=\\pi_{i}(x)$，则一组规划 $\\pi_{i},\\pi_{i+1},…\\pi_{j}$ 之间会发生循环冲突。 交换冲突 如果智能体计划在一个时间步内交换位置，则 $\\pi_{i}$ 和 $pi_{j}$ 之间会发生交换冲突。从形式上看，如果存在一个时间步 $x$，使得 $\\pi_{i}[x +1]=\\pi_{j}[x]$ 和 $\\pi_{j}[x +1]=\\pi_{i}[x]$ ，那么 $\\pi_{i}$ 和 $\\pi_{j}$ 之间就存在交换冲突。在目前的 MAPF 文献中，这种冲突有时被称为边缘冲突。 图 1 展示了不同类型的冲突。请注意，上述冲突定义集肯定不是所有可能冲突的完整集合。考虑到这些冲突的形式定义，它们之间显然存在支配关系：（1）禁止顶点冲突意味着也禁止边冲突；（2）禁止跟随冲突意味着也禁止循环冲突和交换冲突；（3）禁止循环冲突意味着也禁止交换冲突。反之亦然，(1) 允许边冲突意味着也允许顶点冲突，(2) 允许交换冲突意味着也允许循环冲突1，(3) 允许循环冲突意味着也允许跟随冲突。 要正确定义一个经典的 MAPF 问题，我们需要指定解决方案中允许哪些类型的冲突。最少的限制是只禁止边冲突。然而，据我们所知，之前所有关于经典 MAPF 的研究都禁止顶点冲突。一些关于带有效载荷传输的 MAPF 的研究允许交换冲突（Ma 等人，2016 年）。大多数基于搜索的 MAPF 算法（Standley，2010 年；Felner 等，2017 年）禁止交换冲突，但允许跟随冲突。一些关于基于编译的 MAPF 算法的研究，以及所有将 MAPF 视为卵石运动问题的研究，也都禁止跟随冲突（Surynek 等人，2016 年；Bart ́ ak 等人，2017 年）。 2.2 Agent Behavior at Target in Classical MAPF在经典 MAPF 问题的解法中，智能体可能会在不同的时间步达到目标。因此，在定义经典 MAPF 问题时，必须定义智能体在到达目标后和最后一个智能体到达目标前的时间步中的行为方式。 对于智能体在目标处的行为方式，有两种常见的假设。 停留在目标位置(Stay at target) 在此假设下，一个智能体在其目标位置等待，直到所有智能体都到达目标位置。这个等待的智能体将会与任何在它到达目标后经过其目标的规划产生顶点冲突。从形式上看，在停留在目标假设下，如果存在一个时间步长 $t≥|\\pi_{i}|$ ，使得 $\\pi_j[t]=\\pi_{i}[|\\pi_{i}|]$ ，那么一对智能体规划 $\\pi_{i}$ 和 $\\pi_{j}$ 将发生顶点冲突。 在目标处消失(Disappear at target) 根据这一假设，当一个智能体到达目标处时，它会立即消失。这意味着在相应智能体到达目标的时间步之后，该智能体的规划将不会有任何冲突。 之前关于经典 MAPF 的研究大多假设目标停留，但最近的研究也考虑了目标消失假设（Ma 等人，2019a）。 2.3 Objective Functions in Classical MAPF可以说，在 MAPF 的大多数实际应用中，一些 MAPF 解决方案比其他解决方案更好。为了把握这一点，经典 MAPF 的工作考虑了用于评估 MAPF 解决方案的目标函数。在经典 MAPF 中，用于评估解决方案的两个最常用的函数是时间跨度（makespan）和成本总和（sum of costs）。 时间跨度(Makespan) 所有智能体到达目标所需的时间步数。对于 MAPF 解决方案 $\\pi = {\\pi_{1},…\\pi_{k}}$ 的 Makepan 定义为 $max_{1 ≤ i ≤ k} |\\pi_{i}|$。 成本总和 每个智能体到达目标所需的时间步骤总和。$\\pi$ 的成本总和定义为 $\\sum_{1≤i≤k} |\\pi_{i}|$。成本总和也称为流动时间。 如果智能体在目标处的行为是停留在目标处，而目标函数是成本总和，那么就需要说明停留在目标处会如何影响成本总和。例如，我们可以定义，如果智能体在目标处等待，那么它不会增加成本总和。大多数前期工作的共同假设是，除非智能体不打算再次远离目标，否则停留在目标地就算是等待行动。例如，假设智能体 $i$ 在时间步长 $t$ 到达目标，在时间步长 $t′$ 离开目标，在时间步长 $t′′$ 回到目标，然后停留在目标，直到所有智能体都到达目标。那么，这个单智能体规划将对相应解的成本总和贡献 $t′′$。 我们并不声称这些是经典 MAPF 唯一可能的目标函数。我们还可以定义其他目标函数，例如到达目标所需的非等待行动总数（有人称之为燃料总和），以及智能体不在目标中花费的总时间。不过，据我们所知，上述目标函数是经典 MAPF 先前研究中使用的唯一目标函数。基于编译的 MAPF 算法广泛使用了时间跨度，而大多数基于搜索的 MAPF 算法则使用了成本总和。不过，两种类型的 MAPF 算法也都曾使用过这两种目标函数（Surynek 等人，2016 年）。此外，还有人研究如何在给定的 makespan（即截止时间）内最大化达到目标的智能体数量（Ma 等人，2018 年）。 3 Beyond Classical MAPF上述所有经典 MAPF 变体都有如下假设：(1) 时间被离散化为一个个时间步；(2) 每个行动正好需要一个时间步；(3) 在每个时间步中，每个智能体正好占据一个顶点。接下来，我们将简要列出几种放宽这些假设的 MAPF 变体。 3.1 MAPF on Weighted Graphs假设每个动作–移动或等待–正好需要一个时间步长，这就隐含地假设了智能体的运动模型有些简单。MAPF 文献中研究了更复杂的运动模型，其中不同的行动可能有不同的持续时间。这意味着表示智能体可能占据的位置的底层图（前面用 G 表示）现在是一个加权图，其中每条边的权重代表智能体穿越这条边所需的时间。 Bartak 等人（2018 年）提出了一种基于调度的加权图 MAPF 方法，Walker 等人（2018 年）提出了一种递增成本树搜索（ICTS）算法的变体。Yakovlev 和 Andreychuk（2017）提出了针对加权图的 SIPP 算法（Phillips 和 Likhachev，2011 年）和优先级规划的混合算法。 迄今为止，用于 MAPF 研究的加权图类型包括： MAPF in $k^2$-neighbor grids 这种映射是加权图的一种受限形式，其中每个顶点代表二维栅格中的一个单元格。一个智能体在一个单元格中的移动行动是其所有 $k^2 $个相邻单元格，其中 k 是一个参数。成本基于欧氏距离，因此当 k&gt;2 时，会产生不同成本的行动。例如，在一个 8 个相邻单元的栅格中，对角线移动的成本为 √2，而向其中一个红心方向移动的成本为 1。图 2 显示了 k =2、3、4 和 5 时 2k 个邻居栅格中可能的移动行动。 欧几里得空间中的 MAPF(MAPF in Euclidean space) 欧几里得空间中的 MAPF 是 MAPF 的一般化，其中 G 中的每个节点都代表一个欧几里得点（x，y），边代表允许的移动操作。例如，当底层图是为连续欧氏环境生成的路线图时，就会出现这种设置（Khatib，1986 年；Wagner、Kang 和 Choset，2012 年）。 3.2 Feasibility Rules经典 MAPF 中使用的 “无冲突 “有效解决方案的定义只是解决方案要求的一种。我们使用 “可行性规则 “一词来指对 MAPF 解决方案的要求。还有人提出了其他 MAPF 可行性规则。 **鲁棒性规则(Robustness rules)**：这些规则旨在确保 MAPF 解决方案考虑到执行中的意外延迟。k-robust MAPF 规划为智能体建立了足够的缓冲区，使其在不导致冲突的情况下被延迟到 k 个时间步（Atzmon 等人，2018 年）。当未来延迟的概率已知时，鲁棒性规则可以要求智能体在执行过程中发生冲突的概率低于给定的约束（Wagner 和 Choset，2017 年），或者与执行策略相结合以保证无冲突执行（Ma、Kumar 和 Koenig，2017 年）。 **编队规则(Formation rules)**。这些是对智能体允许的移动行动的限制，取决于其他智能体的位置，但与碰撞无关。例如，限制智能体保持指定队形（Barel、Manor 和 Bruckstein，2017 年），或与一组相邻智能体保持通信联系（Stump 等，2011 年；Gilboa、Meisels 和 Felner，2006 年）。 3.3 From Pathfinding to Motion Planning在经典的 MAPF 中，智能体被假定只占据一个顶点，从某种意义上说，没有体积，没有形状，并且以恒定的速度移动。相比之下，运动规划算法直接考虑了这些特性。在这里，智能体在每个时间步都位于一个配置中，而不仅仅是一个顶点，其中配置指定了智能体的位置、方向、速度等，而配置之间的边代表了运动学运动。一些著名的 MAPF 变体正在逐步缩小经典 MAPF 与运动规划之间的差距。 **大型智能体的 MAPF(MAPF with large agents.)**。一些 MAPF 研究考虑了具有特定几何形状和体积的智能体（Li 等人，2019 年；Walker、Sturtevant 和 Felner，2018 年；Yakovlev 和 Andreychuk，2017 年；Thomas、Deodhare 和 Murty，2015 年）。智能体有体积这一事实提出了它们在底层图 G 中的位置以及如何在其中移动的问题。特别是，如果一个智能体位于一个顶点，它可能会禁止其他智能体占据附近的顶点。同样，如果一个智能体沿着一条边移动，它可能会禁止其他智能体沿着相交的边移动或停留在离边太近的顶点。这可能会引入新类型的冲突，如顶点到顶点、边到边和边到顶点的冲突（H ̈ onig 等人，2018 年）。 文献中出现了几种求解具有大型智能体的 MAPF 的方法，包括基于 CBS 的方法（Li 等人，2019 年）、基于 ICTS 的方法（Walker、Sturtevant 和 Felner，2018 年）以及优先规划方法（Yakovlev 和 Andreychuk，2017 年）。具有体积的智能体的一个特例是车队设置，其中智能体占据一串顶点及其连接边（Thomas、Deodhare 和 Murty，2015 年）。 具有运动学约束的 MAPF(MAPF with kinematic constraints) 其他 MAPF 研究考虑了智能体移动动作的运动学约束（H ̈ onig 等人，2017 年；Walker、Chan 和 Sturtevant，2017 年）。也就是说，智能体可以执行的移动动作不仅取决于其当前位置，还取决于速度和方向等状态参数。这种约束的一个副产品就是底层图变成了有向图，因为由于智能体的运动学约束，可能有一些边只能在一个方向上通过。例如，MAPF-POST 就是一种 MAPF 算法，它通过对 MAPF 算法创建的解决方案进行后处理，来考虑这些运动学约束。还有一种基于还原的方法，假定旋转动作是运动学约束的一半（Bart ́ ak 等人，2018 年）。 3.4 Tasks and Agents在经典的 MAPF 中，每个智能体只有一个任务，即把它送到目标地点。在 MAPF 文献中，已经进行了一些扩展，其中智能体可以被分配多个目标。 匿名 MAPF(Anonymous MAPF) 在这个 MAPF 变体中，目标是将智能体移动到一组目标顶点，但哪个智能体到达哪个目标并不重要（Kloder 和 Hutchinson，2006 年；Yu 和 LaValle，2013 年）。另一种将这种 MAPF 变体视为 MAPF 问题的方法是，每个智能体都可以被分配到任何目标，但必须是智能体和目标之间的一一映射。 彩色 MAPF(Colored MAPF) 这种 MAPF 变体是匿名 MAPF 的广义化，其中将智能体分组为团队，每个团队都有一组目标。目标是将每个团队中的智能体移动到它们的目标处（Ma 和 Koenig，2016 年；Solovey 和 Halperin，2014 年）。另一种将这种 MAPF 变体视为 MAPF 问题的方法是，每个智能体只能从为其团队指定的目标集合中分配目标。我们可以将彩色 MAPF 进一步推广，将一个目标和一个智能体分配给多个团队。 在线 MAPF(Online MAPF) 在在线 MAPF 中，一连串的 MAPF 问题是在同一个图上求解的。这种设置也被称为 “终身 MAPF”（Ma 等人，2017 年；2019b）。在线 MAPF 问题可分为以下几类。 **仓库模型(Warehouse model)**。这是由一组固定的智能体解决 MAPF 问题的设置，但在一个智能体找到一个目标后，它可能会被委派去不同的目标（Ma 等人，2019b）。这种设置受到了自主仓库 MAPF 的启发。 交叉模型(Intersection model.) 这是新智能体可能出现的环境，每个智能体只有一个任务–到达目标（ˇ Svancara et al. 2019）。这种情况的灵感来自于自动驾驶车辆进出交叉路口（Dresner 和 Stone，2008 年）。 当然，在混合模型中，智能体在到达目标后可以接受新的任务，新的智能体也可以随着时间的推移而出现，这也是可能的。 4 Benchmarks在本节中，我们将介绍如何对经典 MAPF 算法进行评估，为此提出一个有组织的基准，并指出其他相关的基准套件。 4.1 Characteristics of a MAPF BenchmarkMAPF 问题由一个图形和一组源顶点和目标顶点定义。因此，MAPF 的基准包括一组图形，以及每个图形的一组源顶点和目标顶点。 用于评估 MAPF 算法的图 以往工作中常用的地图类型包括： Dragon Age Origins (DAO) maps 这些栅格取自游戏《龙腾世纪起源》，可在 Sturtevant 的 movingai.com 储存库中公开获取（Sturtevant，2012 年）。这些栅格相对较大且开放，其中一些栅格大到 1000 × 1000 甚至更大。 开放式 N × N 栅格(Open N × N grids) 这些网格为 N×N 网格，其中常见的 N 值为 8、16 和 32。这种栅格允许进行智能体与空间比例或智能体密度较高的实验，其中没有智能体的顶点较少。 带有随机障碍物的 N × N 栅格(N × N grids with random obstacles) 这些栅格为 N×N 栅格，其中一组栅格单元被随机选中，并被认为是无法通过的（障碍物）（Standley，2010 年）。 仓库栅格(Warehouse grids) 受现实世界中自主仓库应用的启发，最近的 MAPF 论文还尝试了形状类似于自动化仓库的栅格，其中有长长的走廊（Ma 等人，2017 年；Cohen 等人，2018a）。图 4 显示的是一个仓库栅格的图示（Cohen 等人，2018a）。 4.2 Sources and targets assignments选择地图类型后，需要设置智能体的源顶点和目标顶点。文献中使用了多种方法来设置智能体的源顶点和目标顶点，其中包括 随机 通过随机选择顶点来设置源顶点和目标顶点，并确保它们之间在图形中存在路径。 聚类 在图中随机选择顶点，设置第一个智能体的来源和目标。将所有其他智能体的来源和目标分别设置为与第一个智能体的来源和目标的距离最多为 $r$，其中 $r$ 是一个参数。 指定 通过从指定的一组可能的源顶点中随机选择来设置每个智能体的源，并通过从一组指定的可能的目标顶点中选择来类似地设置每个智能体的目标。 随机分配可能是文献中最常见的方法。聚类分配法的使用使 MAPF 问题更具挑战性。指定分配法已在先前的工作中用于模拟自动化仓库（Cohen、Uras 和 Koenig，2015 年；Ma 等人，2019a；2019b）和交叉路口的自动驾驶车辆（ˇ Svancara 等人，2019 年）。在自动化仓库中，通常会有人类在特定位置对交付的垃圾箱进行包装，大多数任务都是将包裹交付给这些位置的人类，或从人类手中取回包裹。在自动驾驶车辆驶入和驶出交叉路口的情况下，指定的来源和目标就是交叉路口的终点（ˇ Svancara 等人，2019 年）。 4.3 Publicly Available MAPF Benchmarks我们在此介绍两个公开的 MAPF 研究基准，其中第一个是本文首次介绍的新基准集。 基于栅格的 MAPF 这一公开4 基准由 24 幅地图组成，这些地图分别来自：（1）真实城市地图；（2）视频游戏《龙腾世纪起源》和《龙腾世纪 2》；（3）有随机障碍物和无随机障碍物的开放栅格；（4）类似迷宫的栅格；以及（5）类似房间的栅格。所有地图均来自 MovingAI 寻路资源库（Sturtevant，2012 年）5。图 5 显示了上述每种类型的地图示例，表 1 显示了这些地图的尺寸。 每张地图有 25 个场景。每个场景都有一个源顶点和目标顶点列表，这些顶点是用随机方法的变体设置的（见第 4.2 节）。每个地图最大可达区域内的所有点都是随机配对的，然后将前 1000 个问题放入场景中。因此，我们可以通过选择任意的源顶点和目标顶点子集，从每个场景中创建一组 MAPF 问题。 我们建议按以下方式使用该基准。对于选定的 MAPF 算法、地图类型和场景，尝试在每个场景中解决尽可能多的智能体问题，按连续顺序添加。也就是说，从创建两个智能体的 MAPF 问题开始，使用与所选场景相关的前两个源-目标对，并运行所选的 MAPF 算法来解决这个问题。如果所选算法在合理的时间内成功解决了这个 MAPF 问题，则使用该方案的前三个源-目标对创建一个包含 3 个智能体的新 MAPF 问题，并尝试使用所选 MAPF 算法解决该问题。如此反复进行，直到所选算法无法在合理时间内解决所创建的 MAPF 问题。然后，经过评估的算法就可以报告其在合理时间内能够解决的每个场景的最大智能体数量。 为了提供一个比较基线，我们使用 ICBS（Boyarski 等人，2015 年）执行了这一评估过程。使用本文介绍的术语，我们的设置是在 4 邻网格上的经典 MAPF 设置，其中：（1）禁止边、顶点和交换冲突；（2）允许跟随和循环冲突；（3）目标是成本之和；（4）智能体在目标处的行为是停留在目标处。 表 1 显示了评估结果。我们将运行时间限制为 30 秒。不同的行对应不同的地图。大小 “列显示了每个地图的行数和列数。问题 “列报告了每个地图中可用问题的数量。请注意，这个数字是 25 个方案的总和，其中一个方案中可用问题的数量就是为其定义的源-目标对的数量。已解决 “一栏报告的是 ICBS 在指定时限（30 秒）内解决的问题数量。可以看出，虽然 ICBS 能够解决很多问题，但该基准中的问题足够复杂，因此 ICBS 无法在规定时间内解决很多问题。因此，这个栅格 MAPF 基准中的问题难度足以对当代 MAPF 求解器构成挑战。 表 1 增加了两列–”最小 “和 “最大”。这两列报告了 ICBS 在该数字最小（”Min”）和最大（”Max”）时所解决的最大智能体数量。例如，地图 brc202d 的 “最小 “值为 2，”最大 “值为 22。这意味着该地图存在这样一种情况，即 ICBS 在超时前最多只能解决 2 个智能体的问题，而该地图也存在另一种情况，即 ICBS 最多能解决 22 个智能体的问题。我们报告这些数值是为了显示同一张地图不同场景之间的难度差异。 Asprilo 对 MAPF 研究有用的另一个工具是 Asprilo。Asprilo 是一个用于模拟自动化仓库的公开可用框架（Gebser 等人，2018 年）。它包括用于定义和生成标准自动化仓库规划问题的工具，以及用于验证和可视化解决这些问题的规划的工具。 Asprilo 支持的规划问题类型包括机器人在仓库中拾取并将箱子从一个地方运送到另一个地方的问题。这些场景被分为不同的领域，代表不同类型的问题。MAPF 社区特别感兴趣的是领域 M，它基本上代表了 MAPF 问题。因此，我们可以将该领域的问题作为 MAPF 算法的基准。图 6 显示了来自 Asprilo 的两个场景。左侧的场景是一个完整的仓库场景，智能体的任务是将箱子从一个地方移到另一个地方。右侧的场景是一个纯移动场景，即经典的 MAPF 问题。有关 ASPRILO 的详细信息，请参阅（Gebser 等人，2018 年）以及该项目的网站。 5 Conclusion在本文的第一部分，我们定义了 “经典 “多智能体寻路（MAPF）问题中的常见假设，并讨论了它们之间的关系。然后，我们定义了之前发表的经典 MAPF 的显著扩展。在本文的第二部分，我们介绍了一套新的 MAPF 基准问题，并指出了另一套 MAPF 基准问题。本文的两个部分都旨在为 MAPF 研究提出一种通用语言、术语和实验环境。我们希望未来的 MAPF 研究人员能够遵循我们的术语，并发现这些基准是有用的。","link":"/2023/12/01/Multi-Agent-Pathfinding-Definitions-Variants-and-Benchmarks/"},{"title":"Ubuntu_CLion安装","text":"Ubuntu系统CLion安装参考官网安装过程：官网安装过程 下载linux tar.gz包 123# 解压sudo tar -xzvf CLion-*.tar.gz -C /opt/sh /opt/clion-*/bin/clion.sh 其中第二个命令是启动CLion命令 clion安装完以后，不会在桌面或者菜单栏建立图标 可以使用如下命令 1gnome-desktop-item-edit ~/.local/share/applications --create-new 没安装过gnome的安装一下（该工具18.04以后就不支持这样子用了） 1sudo apt install gnome-panel 如果Ubuntu系统是更高的版本的话，建议使用如下命令 123sudo apt install alacarte# 安装好后，使用alacarte 点击new item生成一个新的启动图标， name自己填写，command是该软件的启动命令，可能是.sh文件。","link":"/2023/11/28/Ubuntu-CLion%E5%AE%89%E8%A3%85/"},{"title":"Ubuntu GDAL安装","text":"Ubuntu GDAL轻量安装sqlite3安装GDAL库依赖于sqlite，所以需要先安装sqlite3，如果有sqlite3，可以使用以下命令查看版本 1sqlite3 -version 如果没有就使用命令来安装 1sudo apt-get install sqlite3 也可以使用源码编译安装，但是真的是非常的麻烦，所以这里也就不去给出该过程了。使用sqlite3 -version查看安装情况，我的输出是 13.31.1 2020-01-27 19:55:54 3bfa9cc97da10598521b342961df8f5f68c7388fa117345eeb516eaa837balt1 PROJ 安装proj官网下载proj官网下载，我下载的是8.2.0的版本，直接下载tar.gz包。 下载好后，进行解压，编译即可。 1234567891011121314151617181920tar -xzvf proj-8.2.0.tar.gzcd proj-8.2.0/mkdir buildcd buildcmake .. # cmake 命令需要互联网环境，需要联网下载cmake --build .ctestcd .../configuremake make install# 如果报permission denied的话，就使用sudo make install############## 在内网中，不用cmake，直接# ./configure# make # make install#############sudo ldconfig 安装好后，使用以下命令，查看安装是否成功。 1proj --version GDAL安装在GDAL官网GDAL官网下载源代码包，编译安装。之前也用过命令行安装，python这样安装比较容易，ubuntu好像没成功，忘了记录了。如果是python使用gdal，可以直接pip install gdal来安装，在pycharm中使用就可以了，python安装的时候好像是带有sqlite3等库的，没用的库也用pip install xxx来安装就行了。 先尝试如下安装方式 1sudo apt install gdal-bin 如果这样安装后，自己可以调用gdal那就可以了。 如果不行，再尝试下述命令。 123456789# 下载好后tar -xzvf gdal-*.tar.gz./configure --with-proj=/usr/localmakemake installldconfig# 使用命令查看gdal安装情况gdalinfo --version GEOS这个部分可以考虑安装。 参考：GDAL安装","link":"/2023/11/28/Ubuntu-GDAL%E5%AE%89%E8%A3%85/"},{"title":"Ubuntu系统安装Opencv","text":"Ubuntu系统安装Opencv 进入官网下载opencv release包opencv下载 下载opencv_contrib[opencv_contrib下载列表](Tags · opencv/opencv_contrib (github.com))， 下载好后，将其放置到自己常用的文件夹下，使用以下命令解压 12tar -xzvf opencv-*.tar.gztar -xzvf opencv_contrib-*.tar.gz 将解压好的opencv_contrib放置到opencv文件夹下。 安装opencv依赖的库 1sudo apt-get install build-essential libgtk2.0-dev libgtk-3-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev 进入opencv文件夹进行编译： 123456cd opencvmkdir buildcd build# 进行编译sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 编译 12345sudo make -j8或者sudo make -j4# j 表示使用几个核心（或进程）进行编译，# 有时候并行编译可能会出错 安装 1sudo make install 添加路径 12345sudo gedit /etc/ld.so.conf# 向文件中写入这条语句/usr/loacal/lib# 执行下ldconfigsudo ldconfig 配置环境 123456sudo gedit /etc/bash.bashrc # 在/etc/bash.bashrc文件中添加下两行代码PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfigexport PKG_CONFIG_PATH# 关闭文件，执行下sourcesource /etc/bash.bashrc 查看opencv安装情况 1pkg-config opencv --modversion","link":"/2023/11/28/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Opencv/"},{"title":"pandas dataframe学习","text":"pandas dataframe学习如何向pandas.dataframe添加一行内容： 情景：现有一个pandas.dataframe结构，向其中添加一行内容。 1data = pd.DataFrame(columns=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]) 有两种方法： 1.将一个新的一行内容添加到末尾 12# 向dataframe末尾添加一行df.loc[len(df.index)] = [value1, value2, value3, ...] 2.使用**df.append()**函数将现有 DataFrame 的几行附加到另一个 DataFrame 的末尾： 12# 向dataframe中添加几行dataframe结构数据，就是把一个dataframe数据复制到另一个dataframe的末尾df = df.append(df2, ignore_index = True) DataFrame删除某一行按行名删除：它由第一个参数labels和第二个参数axis指定。行指定axis= 0。 首先，自己得设置一个行名，没有行名是无法按行名删除的。 1df.drop('row_name', axis=0) 从0.21.0或更高版本开始，它也可以由参数索引指定。 1df.drop(index='row_name') 请记住，drop函数，不是在原表上做删减，而是返回一个新的表，删减后的信标。所以，如果是上述方式的话，建议 123data = df.drop('row_name', axis=0)# 或data = df.drop(index='row_name') 这样，才看data数据，才是删减后的表，而df本身没有做删减。如果向原地删除的话，可以使用inplace参数。 123df.drop('row_name', axis=0, inplace=True)# 或df.drop(index='row_name', inplace=True) 按行号指定 如果要按行号指定，请使用DataFrame的index属性。 如果在index属性的[]中指定行号，则可以获得相应的行名。可以在列表中指定多个行号。 1df.drop(df.index[[1, 3, 5]], inplace=True) 删除了1，3，5行","link":"/2023/11/29/pandas-dataframe%E5%AD%A6%E4%B9%A0/"},{"title":"python 代码插桩方法","text":"Python 代码插桩方法什么是插桩技术？插桩技术是指在保持原有程序逻辑完整性的基础上，在程序中加入探针，通过探针来收集代码在执行过程中的信息（函数参数，返回值、变量变化信息、函数调用顺序等等）。插桩技术在调试代码的过程中也非常实用。通常实现方法是在特定位置插入代码段，从而收集程序运行时的动态上下文信息。 使用插桩调试使用插桩技术调试程序，可以有效的查看程序执行过程，并发现代码的逻辑错误（如果代码存在语法错误，编译器会报告该类错误）。逻辑错误往往难以发现，只是运行结果存在问题，但是程序可以正常运行。 例如：最近在写迪杰斯特拉算法和双向迪杰斯特拉算法，两种方法都使用python实现，都能正常运行。一开始，单次运行，两者给出的最短路径都是一样的，以为应该没什么问题，所以写了个测试片段，两个程序执行500次，看一下效率，然后就发现，这500次里，总有些时候，双向迪杰斯特拉和迪杰斯特拉算法的路径不一致，而且迪杰斯特拉算法的效果更好，故疯狂找原因。这时候就想到了插桩技术！ python插桩的一种实现方法简单地说就是在某些想要输出变量或者函数调用过程的位置，插入一些代码片段。 1234print_log = open(&quot;./logfile.txt&quot;, &quot;a&quot;, encoding='utf-8') # 打开一个txt文件作为输出print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), file=print_log)print(&quot;var1:&quot;, var1, &quot;function1:&quot;, function1, file=print_log)print(&quot;condition1:&quot;, condition1, file=print_log) 这个框架是这样的，利用print函数，将程序运行中的信息输出到txt文件中。 1234567891011121314151617181920212223import timedef dijkstra(graph, start, target): print_log = open(&quot;./logfile.txt&quot;, &quot;a&quot;, encoding='utf-8') # 打开一个txt文件作为输出 print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), file=print_log) print(&quot;\\n&quot;, file=print_log) if condition is True： print(&quot;condition:&quot;, condition, file=print_log) ... var1 = ? var2 = ? print(&quot;var1&quot;, var1, &quot;var2&quot;, var2, file=print_log) ... return path def main(): print_log = open(&quot;./logfile.txt&quot;, &quot;a&quot;, encoding='utf-8') print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), file=print_log) print(&quot;\\n&quot;, file=print_log) print(&quot;graph:&quot;, graph, &quot;start:&quot;, start, &quot;target:&quot;, target, file=print_log) dijs_path = dijkstra(graph, start, target) print(&quot;result:&quot;, dijs_path) 方式二有的人可能希望不喜欢上述代码插桩的输出格式： 上述代码插桩的输出格式是，程序运行的开始先输出一个程序运行的起始时间，然后开始运行，并输出自己想要的变量变动过程。 1print (&quot;[%s] %s 修改第 %d 个值，修改后值为:%d&quot; % (time.ctime(time.time()),threadName,counter,list[counter-1])) 该行代码的输出风格为： 123456[Fri Dec 1 09:54:06 2023] Thread-1 修改第 12 个值，修改后值为:1[Fri Dec 1 09:54:07 2023] Thread-2 修改第 12 个值，修改后值为:2[Fri Dec 1 09:54:07 2023] Thread-1 修改第 11 个值，修改后值为:1[Fri Dec 1 09:54:08 2023] Thread-3 修改第 12 个值，修改后值为:3[Fri Dec 1 09:54:08 2023] Thread-1 修改第 10 个值，修改后值为:1[Fri Dec 1 09:54:09 2023] Thread-2 修改第 11 个值，修改后值为:2 总体框架： 12345678910111213141516171819202122import timedef dijkstra(graph, start, target): print_log = open(&quot;./logfile.txt&quot;, &quot;a&quot;, encoding='utf-8') # 打开一个txt文件作为输出 print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), file=print_log) print(&quot;\\n&quot;, file=print_log) if condition is True： print(&quot;condition:&quot;, condition, file=print_log) ... var1 = ? var2 = ? print(&quot;var1&quot;, var1, &quot;var2&quot;, var2, file=print_log) ... return path def main(): print_log = open(&quot;./logfile.txt&quot;, &quot;a&quot;, encoding='utf-8') print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), file=print_log) print(&quot;\\n&quot;, file=print_log) print (&quot;[%s] %s 修改第 %d 个值，修改后值为:%d&quot; % (time.ctime(time.time()),threadName,counter,list[counter-1]), file=print_log) dijs_path = dijkstra(graph, start, target) print(&quot;result:&quot;, dijs_path) python 绘图方面的知识注释有三种，分别为 ax.text()：文本注释，只能填写文本 ax.arrow()：箭头标记，不能填写文本 ax.annotate()：箭头注释，在箭头的位置可以填写文本 python 使用matplotlib绘图要注意的事情： 123456789101112131415161718192021222324# 导入库from matplotlib import pyplot as pltimport mpl_toolkits.axisartist as axisartistfrom matplotlib import colors#用来正常显示中文标签plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示负号 #有中文出现的情况，需要u'内容'plt.rcParams['axes.unicode_minus']=False # 先声明画布# figsize=(xx, xx)设置画布大小，画布不能设置太大，不然会报错，最大设置过(64, 64)fig = plt.figure(figsize=(30, 30)) # 一个figure 画布对象可以有多个子图axes，通过调用subplot来返回一个子图对象，类似的方法还有add_subplot()# 函数原型 subplot(numRows, numCols, plotNum), 例如(111)表示共生成一个1行1列的子图对象，即只有一个子图，第三个1表示对第一个子图进行操作ax = plt.subplot(111) # ax = plt.subplot(221)，则表示生成2行2列的子图，则共有4个子图对象，1表示对第一个对象进行操作。# 子图的编号从左上角第一个子图开始，依照从左到右，从上到下的顺序标记# 保存当前画布上的图像plt.savefig(&quot;./test_fig.png&quot;)# 显示图像，注意这两步不能颠倒，不然会保存一个白板。plt.show()","link":"/2023/11/08/python-%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9%E6%96%B9%E6%B3%95/"},{"title":"python 常见错误","text":"Python常见错误集合[toc] python 常见错误集合：持续更新 TypeError: ‘list’ object cannot be interpreted as an integer1234567891011121314map = [ [1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0 ], [0, 1, 1, 1, 0, 0, 1, 1, 1, 1 ], [1, 1, 1, 0, 0, 1, 1, 1, 0, 1 ], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1 ], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1 ], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0 ], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1 ], [0, 1, 1, 0, 0, 1, 1, 1, 1, 1 ]]map_input = np.ndarray(map)# 会报错：TypeError: 'list' object cannot be interpreted as an integer 本意就是想把二维list转为numpy的ndarray类型，因为list类型实际上没有shape属性，作为二维矩阵不好用。 原因可能是ndarray是一个class，初始化函数中，无法把一个二维list初始化，只能对一维list进行初始化。 什么是ndarray？ 这是numpy下面的一个class，是numpy的核心特征，核心数据结构，是python中一个快速的，灵活的大型数据集容器，可以轻松地对其中的数据进行科学运算。 123456789101112131415map = [ [1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0 ], [0, 1, 1, 1, 0, 0, 1, 1, 1, 1 ], [1, 1, 1, 0, 0, 1, 1, 1, 0, 1 ], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1 ], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1 ], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0 ], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1 ], [0, 1, 1, 0, 0, 1, 1, 1, 1, 1 ]]map_input = np.array(map)print(type(map_input))# 输出&lt;class 'numpy.ndarray'&gt;","link":"/2023/12/01/python-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"title":"XTDrone仿真平台配置","text":"XTDrone仿真平台配置环境： VMWare 16.0 Ubuntu 22.04 （因为没人配过）Ubuntu 20.04 参考文章： 仿真平台基础配置 (yuque.com) Ubuntu20.04搭建PX4仿真环境及XTDrone开发平台（最详细最明白）_ubuntu安装px4_哒哒哒，啥也不会的博客-CSDN博客 安装过程： 简单地说，XTDrone安装包括几个部分：ROS安装、Gazebo安装、marvos安装和PX4 安装，XTDrone下载和配置。 依赖安装首先安装一个aptitude==以解决出现的依赖问题== 依赖问题的报错形式： 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件包尚未被创建或是它们已被从新到(Incoming)目录移出。下列信息可能会对解决问题有所帮助：下列软件包有未满足的依赖关系：fcitx : 依赖: fcitx-data 但是它将不会被安装E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 使用sudo apt install aptitude 安装aptitude，在一定程度上能解决依赖问题 先从语雀下载压缩包PX4_Firmware，并将该zip压缩包放置到Ubuntu主目录下，使用unzip命令解压，没用unzip命令工具，使用sudo apt install unzip或sudo pip install unzip，然后解压后，将其命名为PX4_Firmware，使用cd PX4_Firmware/Tools/setup，其中有一个requements.txt文件： 12345678910111213141516171819202122232425262728argcompleteargparse&gt;=1.2cerberuscoverageempy&gt;=3.3futurejinja2&gt;=2.8jsonschemakconfigliblxmlmatplotlib&gt;=3.0.*numpy&gt;=1.13nunavut&gt;=1.1.0packagingpandas&gt;=0.21pkgconfigpsutilpygmentswheel&gt;=0.31.1pymavlinkpyros-genmsgpyserialpyulog&gt;=0.5.0pyyamlrequestssetuptools&gt;=39.2.0six&gt;=1.12.0toml&gt;=0.9 这是官当给出的PX4所需依赖。 在PX4_Firmware/Tools/setup目录下执行命令： 12bash ubuntu.sh --no-sim-tools 不加参数 --no-sim-tools，就会自动安装ubuntu版本对应的gazebo及gazebo-dev，和javsim等仿真依赖 1sudo apt install ninja-build exiftool ninja-build protobuf-compiler libeigen3-dev genromfs xmlstarlet libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev python-pip python3-pip gawk 1pip2 install pandas jinja2 pyserial cerberus pyulog==0.7.0 numpy toml pyquaternion empy pyyaml 1pip3 install packaging numpy empy toml pyyaml jinja2 pyargparse 记录 语雀文档中提到的一个错误： 123456789101112Collecting pandas Using cached https://files.pythonhosted.org/packages/64/f1/8fdbd74edfc31625d597717be8c155c6226fc72a7c954c52583ab81a8614/pandas-1.1.2.tar.gz Complete output from command python setup.py egg_info: Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-qtvsjq8t/pandas/setup.py&quot;, line 349 f&quot;{extension}-source file '{sourcefile}' not found.\\n&quot; ^ SyntaxError: invalid syntax ----------------------------------------Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build-qtvsjq8t/pandas/ 如果出现该错误，可以先更新setuptools 和 pip。（我没出现过） 更新setuptools命令： 123pip install --upgrade setuptools#若未报错不需要输入这两行命令python -m pip install --upgrade pip 放置一个清华源安装地址： 1https://pypi.tuna.tsinghua.edu.cn/simple 如果报错：网络连接不上，或者下载一半就不下了，然后报错的情况，就在上面的命令后面写上： 1pip2 install pandas jinja2 pyserial cerberus pyulog==0.7.0 numpy toml pyquaternion empy pyyaml -i https://pypi.tuna.tsinghua.edu.cn/simple 可能的报错如下： 12ERROR: Could not install packages due to an EnvironmentError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Max retries exceeded with url: /packages/ec/1a/610693ac4ee14fcdf2d9bf3c493370e4f2ef7ae2e19217d7a237ff42367d/packaging-23.2-py3-none-any.whl (Caused by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7fd53ca02c10&gt;: Failed to establish a new connection: [Errno 101] Network is unreachable')) ROS一键安装鱼香肉丝开发的ubuntu一键安装挺不错的，避免了自己安装的很多麻烦，包括编译上的麻烦，换源等诸多问题。 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros Ubuntu 20.04是最后一个支持ROS1的，对应安装ROS1的Noetic，（Ubuntu 22.04只能安装ROS2，ROS2都不是很熟，我安装试了一下，不太会用，所以又用20.04了） 安装时间会比较漫长：安装结束后，使用roscore命令启动ros（ROS2中不再这样启动），出现一大段信息，包括如下信息，即安装成功。 123456789101112131415161718192021222324Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://ubuntu:37819/ros_comm version 1.16.0SUMMARY========PARAMETERS * /rosdistro: noetic * /rosversion: 1.16.0NODESauto-starting new masterprocess[master]: started with pid [34913]ROS_MASTER_URI=http://ubuntu:11311/setting /run_id to 28b04b30-835b-11ee-87ca-e5b945730283process[rosout-1]: started with pid [34924]started core service [/rosout] 文档里有推荐安装rosdep， rosdep是ros的依赖项管理工具，在安装完ros之后建议安装此工具，但是在rosdep init和 rosdep update时国外的网站实在令人头疼。所以使用rosdepc 所以安装一下： 1sudo pip install rosdepc rosdepc需要进行初始化和更新 12sudo rosdepc initrosdepc update 如果之前没有catkin_ws，则需要新建工作空间，之后除去PX4仿真环境启动外，其余ROS相关工程在此工作空间下管理。 文档中推荐做法，估计是为了集中管理？ 12345678mkdir -p ~/catkin_ws/srcmkdir -p ~/catkin_ws/scriptscd catkin_ws &amp;&amp; catkin init # 使用catkin_make话，则为cd catkin_ws/src &amp;&amp; catkin_init_workspacecatkin build # 使用catkin_make话，则为 cd .. &amp;&amp; catkin_make gedit ~/.bashrc在下面写入：source ~/catkin_ws/devel/setup.bash #先写好source路径关闭文件，在终端执行source ~/.bashrc catkin build需要先装catkin-tools（sudo apt install python3-catkin-tools），安装好Ubutu系统应该会有这个命令工具。 文档里说要卸载之前的Gazebo，CSDN博客里给出以下原因 XTDrone一般用gazebo9进行仿真，而在安装ros noetic时会自动安装gazebo11以及对应的gazebo-ros插件，这里我们需要卸载，然后安装gazebo9以及肖老师修改过的gazebo-ros插件。 感觉也可以用gazebo11来进行仿真，如果比较有时间的话，可以试一试。 感觉Gazebo 11也不是不行，文档里给出可以 选用Alternative installation: step-by-step的安装方式 如果安装有依赖问题，可以使用sudo aptitude install ==gazebo11==，选择合理的依赖解决办法（别把ROS删了） 按步骤装完Gazebo后，升级所有的包 sudo apt upgrade，这样能保证gazebo所有依赖版本一致 卸载Gazebo 123sudo apt-get remove gazebo* sudo apt-get remove libgazebo*sudo apt-get remove ros-noetic-gazebo* #kinetic melodic对应修改 安装Gazebo 12a、添加软件仓库 sudo sh -c 'echo &quot;deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/gazebo-stable.list' 12b、获取密钥wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - 12c、更新软件源sudo apt-get update 123456d、安装Gazebo 9sudo apt-get install gazebo9sudo apt-get install libgazebo9-dev #一定要记得这个安装Gazebo 11 sudo apt-get install gazebo11sudo apt-get install libgazebo11-dev 插件修改的重新编译 安装依赖： 1sudo apt-get install ros-noetic-moveit-msgs ros-noetic-object-recognition-msgs ros-noetic-octomap-msgs ros-noetic-camera-info-manager ros-noetic-control-toolbox ros-noetic-polled-camera ros-noetic-controller-manager ros-noetic-transmission-interface ros-noetic-joint-limits-interface 然后克隆并编译Gazebo的插件gazebo_ros_pkgs，放在~/catkin_ws/src下（如果编译时还缺其他的依赖，同上方法安装） 1234cd ~/catkin_ws/srcgit clone https://github.com/ros-simulation/gazebo_ros_pkgs.gitcd ~/catkin_wscatkin build 上面需要使用git命令工具，如果没安装过 1sudo apt install git catkin build后的结果，成功的情况是不会有Error的，（红色的Error看得人心惊肉跳） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-----------------------------------------------------------------------Profile: defaultExtending: [env] /opt/ros/noetic:/home/sunx/catkin_ws/develWorkspace: /home/sunx/catkin_ws-----------------------------------------------------------------------Build Space: [exists] /home/sunx/catkin_ws/buildDevel Space: [exists] /home/sunx/catkin_ws/develInstall Space: [unused] /home/sunx/catkin_ws/installLog Space: [exists] /home/sunx/catkin_ws/logsSource Space: [exists] /home/sunx/catkin_ws/srcDESTDIR: [unused] None-----------------------------------------------------------------------Devel Space Layout: linkedInstall Space Layout: None-----------------------------------------------------------------------Additional CMake Args: NoneAdditional Make Args: NoneAdditional catkin Make Args: NoneInternal Make Job Server: TrueCache Job Environments: False-----------------------------------------------------------------------Buildlisted Packages: NoneSkiplisted Packages: None-----------------------------------------------------------------------Workspace configuration appears valid.-----------------------------------------------------------------------[build] Found 6 packages in 0.0 seconds. [build] Updating package table. Starting &gt;&gt;&gt; gazebo_dev Starting &gt;&gt;&gt; gazebo_msgs Finished &lt;&lt;&lt; gazebo_dev [ 1.2 seconds ] Finished &lt;&lt;&lt; gazebo_msgs [ 9.4 seconds ] Starting &gt;&gt;&gt; gazebo_ros Finished &lt;&lt;&lt; gazebo_ros [ 20.6 seconds ] Starting &gt;&gt;&gt; gazebo_plugins Starting &gt;&gt;&gt; gazebo_ros_control Finished &lt;&lt;&lt; gazebo_ros_control [ 25.8 seconds ] Finished &lt;&lt;&lt; gazebo_plugins [ 3 minutes and 41.5 seconds ] Starting &gt;&gt;&gt; gazebo_ros_pkgs Finished &lt;&lt;&lt; gazebo_ros_pkgs [ 1.3 seconds ] [build] Summary: All 6 packages succeeded! [build] Ignored: None. [build] Warnings: None. [build] Abandoned: None. [build] Failed: None. [build] Runtime: 4 minutes and 13.0 seconds total. [build] Note: Workspace packages have changed, please re-source setup files to use them. **==问题==**：git clone https://github.com/ros-simulation/gazebo_ros_pkgs.git有时候无法正常克隆库，会报错。 解决方案一： 在github网站上下载适用于自己ROS版本的压缩包ros-simulation/gazebo_ros_pkgs: Wrappers, tools and additional API’s for using ROS with Gazebo (github.com) 将压缩包放到~/catkin_ws/src目录下解压缩，一般下载下来的压缩包是zip文件，需要使用unzip命令工具。使用pip install unzip命令安装 使用cd ~/catkin_ws和catkin build进行编译。 编译通过后使用命令： 1roscore 开始ros服务，使用命令 12source ~/catkin_ws/devel/setup.bashrosrun gazebo_ros gazebo 开启gazebo，查看安装是否成功。 Gazebo有很多开源的模型文件，📎models.zip下载后将该附件解压缩后放在~/.gazebo中，此时在~/.gazebo/models/路径下可以看到很多模型。如果不做这一步，之后运行Gazebo仿真，可能会缺模型，这时会自动下载，Gazebo模型服务器在国外，自动下载会比较久。 Marvos安装注意，mavros-extras一定别忘记装，否则视觉定位将无法完成 12345sudo apt install ros-noetic-mavros ros-noetic-mavros-extras # for ros-noeticwget https://gitee.com/robin_shaun/XTDrone/raw/master/sitl_config/mavros/install_geographiclib_datasets.shsudo chmod a+x ./install_geographiclib_datasets.shsudo ./install_geographiclib_datasets.sh #这步需要装一段时间 PX4 安装安装方式：从语雀下载压缩包PX4_Firmware，使用该压缩包解压编译，==从git上下载的代码可能很多方面都要修改，而且下载速度很慢。== 使用该包会报错： 1234567[0/1] Re-running CMake...CMake Error: The source directory &quot;/home/robin/PX4_Firmware_13&quot; does not exist.Specify --help for usage, or press the help button on the CMake GUI.FAILED: build.ninja /usr/bin/cmake -H/home/robin/PX4_Firmware_13 -B/home/robin/PX4_Firmware_13/build/px4_sitl_defaultninja: error: rebuilding 'build.ninja': subcommand failedmake: *** [Makefile:230: px4_sitl_default] Error 1 主要是编译的CMakeCache.txt文件中的路径都是/home/robin/PX4_Firmware_13（肖老师自己电报的路径），可能编译过不了，然后自己改也是比较麻烦，我尝试改了CMakeCache.txt文件中路径问题，还是报错，还需要改build.ninja文件、cmake_install.cmake等等。这两个文件都在PX4_Firmware_13/build/px4_sitl_default目录下。~~（==反正要改很多文件，你就改吧，我是把这个目录下的编译文件都改了一遍，但还是有报错==） 这样看用git命令也是可以，可以通过git 克隆代码 1234567git clone -b v1.13.2 https://github.com/PX4/PX4-Autopilot.git --recursivegit clone -b v1.13.2 https://github.com.cnpmjs.org/PX4/PX4-Autopilot.git --recursivemv PX4-Autopilot PX4_Firmwarecd PX4_Firmwaregit checkout -b xtdrone/dev v1.13.2git submodule update --init --recursivemake px4_sitl_default gazebo 好叭，最后还是用的VS code整体修改才可以编译 12chmod +x Tools/check_submodules.sh chmod +x Tools/sitl_run.sh 最好发现还是不行，报错是： 1Error creating PX4_Firmware/build/px4_sitl_default/etc -&gt; /home/sunx/PX4_Fir 这个错误还显示不全，应该是软连接问题。 克隆又克隆不下来，编译又编译不过，丢。 ==新的可行方法==： 下载语雀文档中的PX4包，解压后进入PX4_Firmware然后使用命令rm -rf build，删除build文件夹，然后使用命令mkdir build 使用命令重新编译 123cd buildcmake ..make 使用命令 123git checkout -b xtdrone/dev v1.13.2git submodule update --init --recursivemake px4_sitl_default gazebo 终于编译成功了。花了一天和一个晚上 修改 ~/.bashrc，加入以下代码,注意路径匹配，前两个source顺序不能颠倒 1234567891011#配好好路径gedit ~/.bashrc在里面写入：source ~/catkin_ws/devel/setup.bashsource ~/PX4_Firmware/Tools/setup_gazebo.bash ~/PX4_Firmware/ ~/PX4_Firmware/build/px4_sitl_default#确保文件最底部是export，而不是source export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4_Firmwareexport ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4_Firmware/Tools/sitl_gazebo关闭文件，在终端执行source ~/.bashrc 然后运行如下命令,此时会启动Gazebo,如下图所示。 12cd ~/PX4_Firmwareroslaunch px4 mavros_posix_sitl.launch 安装QTGroundControl第一次安装该软件： 12345sudo usermod -a -G dialout $USERsudo apt-get remove modemmanager -ysudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -ysudo apt install libqt5gui5 -ysudo apt install libfuse2 -y XTDrone下载安装1234567FAILED: /home/sunx/PX4_Firmware/Tools/sitl_gazebo/models/typhoon_h480/typhoon_h480.sdf cd /home/sunx/PX4_Firmware/build/px4_sitl_default/build_gazebo &amp;&amp; /usr/bin/python3 /home/sunx/PX4_Firmware/Tools/sitl_gazebo/scripts/jinja_gen.py /home/sunx/PX4_Firmware/Tools/sitl_gazebo/models/typhoon_h480/typhoon_h480.sdf.jinja /home/sunx/PX4_Firmware/Tools/sitl_gazebo --generate_ros_models trueTraceback (most recent call last): File &quot;/home/sunx/PX4_Firmware/Tools/sitl_gazebo/scripts/jinja_gen.py&quot;, line 96, in &lt;module&gt; raise Exception(&quot;ERROR: generation would overwrite changes to `{}`. &quot;.format(filename_out) + \\Exception: ERROR: generation would overwrite changes to `/home/sunx/PX4_Firmware/Tools/sitl_gazebo/models/typhoon_h480/typhoon_h480.sdf`. Changes should only be made to the template file `/home/sunx/PX4_Firmware/Tools/sitl_gazebo/models/typhoon_h480/typhoon_h480.sdf.jinja`. Remove `typhoon_h480.sdf` (after extracting your changes) to disable this overwrite protection. 解决方案： 12find . -name &quot;typhoon.sdf&quot;然后使用rm 命令删除该文件 12FAILED: external/Stamp/sitl_gazebo/sitl_gazebo-build cd /home/sunx/PX4_Firmware/build/px4_sitl_default/build_gazebo &amp;&amp; /usr/bin/cmake --build /home/sunx/PX4_Firmware/build/px4_sitl_default/build_gazebo -- -j 2 删除文件后，这个问题就可以解决了。 注意，用ctrl+c关闭仿真进程，有可能没有把Gazebo的相关进程关干净，这样再启动仿真时可能会报错。如果出现这种情况，可以用killall -9 gzclient，killall -9 gzserver 这两个命令强行关闭gazebo所有进程。 12killall -9 gzclientkillall -9 gzserver","link":"/2023/11/14/XTDrone%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E9%85%8D%E7%BD%AE/"},{"title":"Theta*: Any-Angle Path Planning on Grids","text":"Theta*: Any-Angle Path Planning on Grids翻译摘要在机器人和视频游戏中，通常使用带有阻塞和非阻塞单元的栅格来表示地形。然而，栅格边缘形成的路径可能比地形中真正的最短路径更长，因为它们的方向受到人为限制。为了避免这一缺陷，我们提出了两种适用于任意角度的新的正确、完整的路径规划算法。==基本 Theta* 算法和角度传播 Theta* 算法都是 A* 算法的变种，它们沿栅格边缘传播信息，而不将路径限制在栅格边缘==。==基本 Theta* 算法易于理解和实现，速度快，能找到短路径。但是，它不能保证找到真正的最短路径。==角度传播 Theta* 通过在顶点展开时传播角度范围，在每个顶点进行展开时，角度传播Theta* 实现了比基本 Theta* 更佳最坏情况复杂度，但更复杂、更慢，而且找到的路径稍长。我们将基本 Theta* 和角度传播 Theta* 统称为 Theta。Theta 具有独特的特性，我们将对其进行详细分析。我们通过实验证明，它找到的路径比具有反向平滑路径的 A* 和 Field D* （我们所知的唯一一个沿着栅格边缘传播信息而不将路径限制在栅格边缘的 A* 版本）都要短，而且运行时间与栅格上的 A* 相当。最后，我们将 Theta* 扩展到包含非阻塞单元且遍历代价不均匀的栅格，并引入了 Theta* 的变体，在路径长度和运行时间之间做出了不同的权衡。 1.Introduction在本文中，我们研究的是机器人和视频游戏（Choset, Lynch, Hutchinson, Kantor, Burgard, Kavraki, &amp; Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002）的路径规划，其中二维连续地形被离散化为一个栅格，栅格中有受阻单元和未受阻单元。我们的目标是从给定的起点顶点到给定的目标顶点（均位于单元的四角）找到一条短的无阻塞路径。A* 能快速找到栅格路径（即受限于栅格边的路径），但栅格路径往往不是真正的最短路径（即地形中的最短路径），因为它们的潜在方向被人为限制为 45 度的倍数，如图 1(a) 所示（Yap，2002 年）。这一缺陷导致我们提出了所谓的任意角度路径规划（Nash、Daniel、Koenig 和 Felner，2007；Ferguson 和 Stentz，2006）。如图 1(b) 所示，任意角度路径规划算法可以在不限制路径标题的情况下找到路径。我们提出了两种新的正确、完整的任意角度路径规划算法。基本 Theta* 和角度传播 Theta* 都是 A* 的变种，它们沿着栅格边缘传播信息（以实现较短的运行时间），而不将路径约束在栅格边缘（以找到任意角度路径）。与可见性图上的 A* 不同，它们不能保证找到真正的最短路径。因此，它们名称中的星号并不表示它们的最优性，而是表示它们与 A* 的相似性。基本 Theta* 容易理解和实现，速度快且能找到短路径。角度传播 Theta* 通过在扩展顶点时传播角度范围，实现了每个顶点扩展的最坏情况复杂度，该复杂度是恒定的，而不是与单元格数量成线性关系（就像基本 Theta* 的复杂度），但复杂度更高，速度不快，找到的路径稍长。我们将基本 Theta* 和角度传播 Theta* 统称为 Theta。Theta 具有独特的特性，我们将对其进行详细分析。我们通过实验证明，它找到的路径比带有后平滑路径的 A* 和 Field D* （我们所知道的唯一一种沿着栅格边缘传播信息而不将路径限制在栅格边缘的 A* 版本）都要短，而且运行时间与 A* 在栅格上的运行时间相当。最后，我们将 Theta* 扩展到包含具有非均匀遍历成本的无阻塞单元格的栅格，并引入了 Theta* 的变体，这些变体在路径长度和运行时间之间做出了不同的权衡。 2. Path-Planning Problem and Notation在本节中，我们将介绍本文所研究的路径规划问题，即在具有大小一致的阻塞和非阻塞单元的八邻栅格上进行路径规划。单元格被标记为受阻（灰色）或未受阻（白色）。我们使用单元格的边角（而不是中心）作为顶点。S 是所有顶点的集合。路径规划问题是找到一条从给定起点顶点 $s_{start}$ 到给定目标顶点 $s_{goal}$ 的畅通路径。 如果路径上的每个顶点都能看到路径上的后继顶点，那么这条路径就是畅通无阻的。如果从顶点 $s$ 到顶点 $s′$ 的直线既不经过受阻单元的内部，也不经过共享一条边的受阻单元之间，则顶点 $s$ 与顶点 $s′$ 具有视线，记为 $LineOfSight(s,s′)$。附录 A 给出了实现视线函数的伪代码。==为简单起见，我们允许一条直线在对角相邻的受阻单元之间通过。== $c(s,s′)$ 是顶点 $s$ 到顶点 $s′$ 的直线长度。$nghbr s_{vis}(s)$ 是顶点 $s$ 在八个罗盘方向上的可见相邻点集合，即顶点 $s$ 的相邻点中与顶点 $s$ 有视线的那些。图 1 显示了一个例子，顶点 B4 的可见邻域是顶点 A3、A4、A5、B3、B5、C3 和 C4。 3. Existing Terrain Discretizations连续地形需要离散化才能进行路径规划。在本节中，我们将栅格与其他现有的地形离散化方法进行比较。我们使用栅格对地形进行离散化，因为栅格被广泛应用于机器人和视频游戏中（Deloura, 2000; Murphy, 2000; Rabin, 2004），并具有一些理想的特性： 栅格是一种简单的数据结构，可以实现简单的路径规划算法。 通过在地形上铺设栅格，并将所有部分或完全受阻的单元标注为受阻，就可以轻松地将地形离散成栅格。 栅格提供了连续地形中所有可穿越表面的全貌。当路径规划算法在动态环境中使用并必须与导航规划器交互时，这一点至关重要。例如，如果一个机器人或视频游戏角色的路径遇到临时阻塞，它可以很容易地判断是向左转（未受阻）还是向右转（受阻）最好（Tozour，2004 年）。 除了可穿越性之外，单元格还可以存储其他信息，例如该单元格对应的地形区域中隐藏的黄金数量，或者在显示地形时该区域的渲染效果。 由于栅格是随机存取数据结构，因此可以快速访问存储在单元中的信息。 只需提高栅格分辨率，就能提高路径和导航规划的精度。 为简单起见，假定地形中的障碍物是多边形的，我们现在列出一些可供选择的地形离散方法。 Voronoi 图（Aurenhammer，1991 年）通过使路径偏离受阻多边形，将地形离散化。这样得到的路径可能比真正的最短路径要长得多。 Mitchell 和 Papadimitriou（1991 年）的离散化研究将地形划分为具有线性边缘和双曲线边缘的区域，这样就可以找到真正的最短路径，其时间和空间复杂度为 $O(m^{5/3})$，其中 $m$ 是受阻多边形的角数。因此，路径规划的运行时间可随受阻多边形的角数呈超线性增长。 标准的四叉树（Yahja、Stentz、Singh 和 Brumitt，1998 年）会递归地将地形细分为四个大小相等的单元，直到所有单元都被完全遮挡、完全无遮挡或面积足够小为止。==由此产生的路径可能会出现不必要的航向变化==（即航向变化发生在自由空间而不是受阻多边形的角落）。 概率路线图（Kavraki、Svestka、Latombe 和 Overmars，1996 年）喝快速探索随机树（LaValle 和 Kuffner，2001 年）随机放置顶点（除了起点和目标顶点）。如果两个顶点有视线，则它们通过直线相连。顶点的随机放置需要仔细调整，因为它会影响路径规划的运行时间、找到路径的可能性以及路径的长度。 可见度图（Lee，1978 年；Lozano-P ́ erez &amp; Wesley，1979 年）使用每个受阻多边形的角作为顶点（除了起点和目标顶点）。如果两个顶点有视线，则它们通过直线相连，这样就能找到真正的最短路径。==路径规划的运行时间会随着顶点数量的增加而呈超线性增长==，因为边的数量会随着顶点数量的增加而呈二次曲线增长。 4.Existing Path-Planning Algorithms在本节中，我们将介绍一些现有的路径规划算法，它们都是 A* （Hart、Nilsson 和 Raphael，1968 年）的变体。A* 是机器人和视频游戏中常用的路径规划算法。算法 1 显示了 A* 的伪代码。第 13 行将被忽略。A* 为每个顶点 s 保留三个值： g 值 $g(s)$ 是目前发现的从起始顶点到顶点 $s$ 的最短路径长度，因此是顶点 $s$ 的起始距离的估计值。 用户提供的 $h$ 值 $h(s)$ 是顶点 $s$ 目标距离的估计值。$f$ 值 $f (s) = g(s) + h(s)$ 是对从起始顶点经顶点 $s$ 到目标顶点的最短路径长度的估计。 在 A* 终止后，使用父级 $parent(s)$ 提取从起始顶点到目标顶点的路径. A* 还维护两个全局数据结构： open list是一个优先队列，包含 A* 考虑扩展的顶点。在伪代码中，$open.Insert(s, x)$ 将关键字为 $x$ 的顶点 $s$ 插入优先级队列 $open$ 中，$open.Remove(s)$ 从优先级队列 $open$ 中移除顶点 $s$，$open.Pop()$ 从优先级队列 $open$ 中移除关键字最小的顶点并返回。 close list是一个包含 A* 已经展开过的顶点的集合。它确保 A* 最多扩展每个顶点一次。 A* 第一次遇到顶点时，会将每个顶点的 g 值设为无穷大，并将每个顶点的父顶点设为 NULL [第 17-18 行]。它将起始顶点的 g 值设置为零，并将起始顶点的父顶点设置为起始顶点本身 [第 2-3 行]。将打开列表和关闭列表设置为空列表，然后将起始顶点插入以 f 值为键的打开列表中 [4-6]。然后 A* 重复执行以下程序： 如果打开列表为空，则报告没有路径[第 20 行]。否则，它会找出开放列表中 f 值最小的顶点 s [第 8 行]。如果这个顶点是目标顶点，那么 A* 就会报告它找到了一条路径 [第 10 行]。路径提取[未在伪代码中显示]是沿着从目标顶点到起始顶点的父节点，反向检索从起始顶点到目标顶点的路径。否则，A* 会从打开列表 [第 8 行] 中删除顶点，并将该顶点插入到封闭列表 [第 11 行] 中，然后生成其每个未展开的可见相邻顶点，展开过程如下： A* 检查顶点 s 的 g 值加上顶点 s 到顶点 s′ 的直线长度是否小于顶点 s′ 的 g 值 [第 23 行]。如果是，则将顶点 s′ 的 g 值设为顶点 s 的 g 值加上从顶点 s 到顶点 s′ 的直线长度，将顶点 s′ 的父节点设为顶点 s，最后将顶点 s′ 插入以 f 值为键的开放列表，如果顶点 s′ 已在开放列表中，则将其键设为 f 值[第 24-28 行]。然后重复上述步骤。 概括地说，当 A* 在更新顶点（Update Vertex）过程中更新顶点 s 的未展开可见邻居 s′ 的 g 值和父节点时，会考虑从起始顶点到顶点 $s$ 的路径$[=g(s)]$，以及从顶点 $s$ 到顶点 $s′$ 的直线路径$[=c(s, s′)]$，结果长度为 $g(s) + c(s, s′)$ [第 23 行]。如果考虑的路径短于目前找到的从起始顶点到顶点 $s′$ 的最短路径 $[= g(s′)]$，则 A* 更新顶点 $s′$ 的 $g$ 值和父节点。 现在，我们将介绍几种现有的路径规划算法，它们都是 A* 的版本，以及它们如何在运行时间和路径长度这两个相互冲突的标准之间进行权衡，如图 2 所示。我们按照路径长度递减的顺序介绍这些算法。 4.1 A* on Grids我们可以在栅格上运行 A* ，即在由栅格顶点和边给出的图形上运行。得到的路径被人为地限制为由栅格的边构成，如图 1(a) 所示。因此，A* 在栅格上找到的路径并不等同于真正的最短路径，而且看起来很不现实，因为它们要么与真正的最短路径有很大偏差，要么有更多的航向变化，这就为平滑它们提供了动力。我们在实验中使用算法 5 计算出的八分位距作为 h 值。 A* with Post-Smoothed Paths (A* PS) 可以使用后平滑路径（A* PS）运行 A* （Thorpe，1984 年）。A* PS 在栅格上运行 A* ，然后在后处理步骤中平滑得到的路径，这通常会在增加运行时间的同时缩短路径。算法 2 显示了 A* PS 在我们的实验中使用的简单平滑算法的伪代码（Botea, Muller, &amp; Schaeffer, 2004），该算法在运行时间和路径长度之间取得了良好的平衡。假设栅格上的 A* 找到路径 $[s_0, s_1, … , s_n]$，其中 $s_0 = s_{start}$，$s_n = s_{goal}$。A* PS 将路径上的第一个顶点作为当前顶点。然后，它会检查当前顶点 $s_0$ 是否与其路径上的后继顶点 $s_2$ 有视线连接。如果是，A* PS 会从路径上删除中间顶点 $s_1$，从而缩短路径。然后，A* PS 重复这一过程，再次检查当前顶点 $s_0$ 是否与其路径上的后继顶点 $s_3$ 有视线连接，以此类推。一旦当前顶点与其路径上的后继顶点的后继顶点不存在视线距离，A* PS 就会向前推进当前顶点并重复这一过程，直到到达路径的终点。我们在实验中使用直线距离 $h(s) = c(s, sgoal)$ 作为 $h$ 值。 A* PS 在栅格上找到的路径通常比 A* 短，但不能保证找到真正的最短路径。图 3 显示了一个例子。假设 A* PS 找到的蓝色虚线路径是众多最短栅格路径之一。然后，它将这条路径平滑为蓝色实线路径，但这并不是一条真正的最短路径。红色虚线路径在受阻单元格 B2-B3-C3-C2 的上方（而非下方）移动，是一条真正的最短路径。A* PS 不能保证找到真正的最短路径，因为它在 A* 搜索过程中只考虑栅格路径，因此无法在 A* 搜索过程中对其他路径做出明智的决策，这也是交错搜索和平滑的动机。事实上，Theta* 除了交错搜索和平滑之外，与 A* PS 类似。 4.3 Field D* (FD*)我们可以运行 Field D* (Ferguson &amp; Stentz, 2006) (FD* )。FD* 沿栅格边缘传播信息，而不限制栅格边缘的路径。FD* 设计使用 D* Lite（Koenig &amp; Likhachev，2002 年）进行快速重新规划（通过重复使用上一次 A* 搜索的信息来加速下一次搜索），并从目标顶点搜索到起始顶点。我们的 FD* 版本使用 A* ，并从起始顶点搜索到目标顶点，就像本文中的所有其他路径规划算法一样，这使得我们可以公平地比较它们，除了它们的重新规划能力。(Theta* is currently in the process of being extended for fast replanning in Nash, Koenig, &amp; Likhachev, 2009.) 当 FD* 更新顶点 s 的未扩展可见邻居 $s′$ 的 $g$ 值和父节点时，会考虑从起始顶点到顶点 $s′$ 的周长$[=g(X)]$ 上与顶点 $s′$ 有视线的任意点 X（不一定是顶点）的所有路径、 其中，周长由连接顶点 $s′$ 的所有相邻点以及从点 X 到顶点 $s′$ 的直线 $[= c(X, s′)]$ 构成，长度为 $g(X) + c(X, s′)$ 。如果考虑的路径比目前发现的从起始顶点到顶点 s′ 的最短路径 $[= g(s′)]$ 短，则 FD* 更新顶点 $s′ $ 的 $g$ 值和父节点。我们在实验中使用直线距离 $h(s) = c(s, sgoal)$ 作为 $h$ 值。图 4 显示了一个例子。如粗体所示，顶点 $s′ = B4$ 的周长由顶点 B4 的所有相邻点连接而成。考虑周长上的点 X。FD* 不知道点 X 的 $g$ 值，因为它只存储顶点的 $g$ 值。因此，它在 $g(B3) = 2.41$ 和 $g(C3) = 2.00$ 之间进行线性插值，得到 $g(X) = 0.55 × 2.41 + 0.45 × 2.00 = 2.23$，因为 0.55 和 0.45 分别是 X 点到顶点 B3 和 C3 的距离。尽管顶点 B3 和 C3 的 g 值都等于它们的真实起始距离，但计算出的点 X 的 $g$ 值与其真实起始距离 $[= 2.55]$ 不同。出现这种错误的原因很简单。从起始顶点经过顶点 C3 或顶点 B3 到目标顶点存在真正的最短路径。因此，根据线性插值假设，从起始顶点经过连接顶点 B3 和 C3 的边上的任意点到目标顶点也一定存在一条短路径。但事实并非如此，因为这些路径需要绕过阻塞单元 B2-B3-C3-C2，这使得它们比预期的要长。由于错误计算了 X 点的栅格值，FD* 将顶点 B4 的父节点设置为 X 点，导致路径在 X 点出现不必要的航向变化，甚至比最短栅格路径还长。 FD* 的作者认识到，FD* 找到的路径经常会出现不必要的航向变化，因此建议在路径提取过程中使用一步前瞻算法（Ferguson &amp; Stentz, 2006），FD* 在我们的实验中使用了这种算法。==这种一步前瞻算法允许 FD* 避免一些不必要的航向变化，如图 4 中的航向变化，但并不能消除所有航向变化==。图 5 显示了红色的 FD* 路径和蓝色的相应真实最短路径。FD* 路径仍有许多不必要的航向变化。 4.4 A* on Visibility Graphs我们可以在可视图上运行 A* 。栅格的可见度图包含起始顶点、目标顶点和所有受阻单元的边角（Lozano-P ́ erez &amp; Wesley，1979）。我们在实验中使用直线距离 $h(s) = c(s, sgoal)$ 作为 $h$ 值。如图 6(a)所示，可见度图上的 A* 可以找到真正的最短路径。真正的最短路径只有在受阻单元的拐角处才会有航向变化，而栅格上的 A* 、A* PS 和 FD* 找到的路径可能会有不必要的航向变化。另一方面，可见度图上的 A* 可能比较慢。它沿着可见度图边传播信息，而可见度图边的数量会随着单元格数量的增加而呈二次增长，而栅格上的 A* 、A* PS 和 FD* 则沿着栅格边传播信息，而栅格边的数量只会随着单元格数量的增加而呈线性增长。如果在进行 A* 搜索之前构建可视图，则需要对每一对被遮挡单元的角进行视线检查，以确定它们之间是否应该有可见性图边，这对于图 6(b) 中的房间来说至少需要 2,556 次视线检查（Tozour，2004 年）。 通过在 A* 搜索过程中构建可见性图，可以减少 A* 对可见性图进行视线检查的次数。当它扩展一个顶点时，会在扩展顶点和所有受阻单元的角落（以及目标顶点）之间执行视线检查。虽然这在某些环境下（如简单的室外地形）可以大大减少视线检查的次数，但在其他环境下（如杂乱的室内地形）却无法做到这一点。更复杂的优化方法（如减少可见度图）可以进一步减少视线检查的次数，但并不能充分提高可见度图上的 A* 速度（Liu 和 Arimoto，1992 年）。 Basic Theta*在本节中，我们将介绍 Theta* （Nash 等人，2007 年），它是我们的任意角度路径规划 A* 版本，可沿着栅格边缘传播信息，而不会将路径限制在栅格边缘。它结合了可视图上的 A* （航向变化仅发生在受阻单元的角落）和栅格上的 A* （边的数量仅随单元数量线性增长）。如图 2 所示，它的路径只比真正的最短路径（如 A* 在可视图上找到的路径）稍长，却只比 A* 在栅格上的路径稍慢。Theta* 和 A* 在栅格上的主要区别在于，使用 Theta* 时，顶点的父节点可以是任何顶点，而使用 A* 时，顶点的父节点必须是该顶点的邻居。我们首先介绍基本 Theta* ，它是 Theta* 的一个简单版本 算法 3 显示了基本 Theta* 的伪代码。程序 Main 与算法 1 中的 A* 相同，因此没有显示。第 13 行忽略不计。我们在实验中使用直线距离 $h(s) = c(s, sgoal)$ 作为 $h$ 值。 Operation of Basic Theta*基本 Theta* 非常简单。它与 A* 相同，只是在更新顶点 $s$ 的未展开可见邻居 $s′$ 的 $g$ 值和父级时，会考虑两条路径，而不是 A* 所考虑的一条路径。图 7(a) 显示了一个示例。基本 Theta* 正在扩展具有父节点 A4 的顶点 B3，并需要更新未扩展的可见邻居 C3 的 $g$ 值和父节点。基本 Theta* 考虑了两条路径： 路径 1： 基本 Theta* 考虑的路径是从起始顶点到顶点 $s [= g(s)]$ 以及从顶点 $s$ 到顶点 $s′$ 的直线 $[= c(s, s′)]$，结果长度为 $g(s) + c(s, s′)$ [第 52 行]。路径 1 是 A* 考虑的路径。它与图 7(a) 中红色虚线路径 [A4, B3, C3] 相对应。） 路径 2： 基本 Theta* 还考虑了从起始顶点到顶点 $s$ 的父顶点的路径 $[= g(parent(s))]$ 以及从顶点 $s$ 的父顶点到顶点 $s′$ 的直线路径 $[= c(parent(s), s′)]$，结果长度为 $g(parent(s)) + c(parent(s), s′)$ [第 44 行]。路径 2 不在 A* 的考虑范围之内，它允许 Basic Theta* 构建任意角度的路径。它与图 7(a) 中的蓝色实线路径 [A4, C3] 相对应。 由于三角形不等式，路径 2 不比路径 1 长。三角形不等式指出，三角形任意一边的长度都不长于其他两边长度之和。由于路径 1 由起始顶点到顶点 $s$ 的父顶点的路径、顶点 $s$ 的父顶点到顶点 $s$ 的直线（直线 A）和顶点 $s$ 到顶点 $s′$ 的直线（直线 B）组成，路径 2 由起始顶点到顶点 $s$ 的父顶点的相同路径和顶点 $s$ 的父顶点到顶点 $s′$ 的直线（直线 C）组成，且直线 A、B 和 C 构成一个三角形，因此三角形不等式在这里适用。路径 1 可以保证畅通无阻，但路径 2 却不能。因此，如果顶点 $s′$ 与顶点 $s$ 的父节点有视线相交，且路径 2 没有阻塞，则基本 Theta* 会选择路径 2 而不是路径 1。图 7(a) 显示了一个例子。图 7(b) 是一个示例。如果选择的路径短于目前发现的从起始顶点到顶点 $s′$ 的最短路径 $[= g(s′)]$，基本 Theta* 会更新顶点 $s′$ 的 $g$ 值和父节点。我们在实验中使用直线距离 $h(s) = c(s, sgoal)$ 作为 h 值。 5.2 Example Trace of Basic Theta*图 8 显示了基本 Theta* 的示例轨迹。顶点标有其 $g$ 值和父代。箭头指向其父节点。红色圆圈表示正在展开的顶点，蓝色箭头表示在当前展开过程中生成的顶点。首先，Basic Theta* 以父顶点 A4 展开起始顶点 A4，如图 8(a) 所示。它将顶点 A4 的未扩展可见相邻顶点的父顶点设置为顶点 A4，就像 A* 所做的那样。其次，基本 Theta* 将顶点 B3 与父节点 A4 展开，如图 8(b) 所示。顶点 B2 是顶点 B3 的未扩展可见邻居，与顶点 A4 没有视线关系。因此，基本 Theta* 根据路径 1 对其进行更新，并将其父节点设置为顶点 B3。另一方面，顶点 C2、C3 和 C4 是顶点 B3 的未展开可见邻居，与顶点 A4 有视线相交。因此，基本 Theta* 将根据路径 2 更新它们，并将它们的父节点设置为顶点 A4。(顶点 B3 的其他未扩展可见邻域的 g 值和父级不会更新）。第三，基本 Theta* 将顶点 B2 与父顶点 B3 展开，如图 8(c) 所示。顶点 A1 和 A2 是顶点 B2 的未扩展可见相邻顶点，与顶点 B3 没有视线关系。因此，基本 Theta* 根据路径 1 对其进行更新，并将其父节点设置为顶点 B2。另一方面，顶点 B1 和 C1 是顶点 B2 的未展开可见相邻顶点，与顶点 B3 有视线连接。因此，基本 Theta* 会根据路径 2 更新这两个顶点，并将它们的父顶点设置为顶点 B3。第四，如图 8(d)所示，Basic Theta* 将目标顶点 C1 与父顶点 B3 展开并终止。然后，路径提取会沿着目标顶点 C1 到起始顶点 A4 的父节点，反向检索出从起始顶点到目标顶点的真正最短路径 [A4, B3, C1]。 5.3 Properties of Basic Theta*现在我们讨论基本 Theta* 的特性。 5.3.1 CORRECTNESS AND COMPLETENESS基本 Theta* 是正确的（即只找到从起始顶点到目标顶点的无阻塞路径）和完整的（即找到一条从起始顶点到目标顶点的路径（如果存在的话））。我们在证明中使用了下面的定理。 定理 1. 如果两个顶点之间存在一条畅通无阻的路径，那么同样的两个顶点之间也存在一条畅通无阻的栅格路径。 证明 如果两个顶点之间存在一条畅通无阻的任意角路径 $[s_0, … , s_n]$，那么这两个顶点之间就存在一条畅通无阻的任意角路径。考虑这条任意角度路径的任意路径段 $s_k,s_{k+1}$。如果路径段是水平或垂直的，则考虑与路径段重合的从顶点 $s_k$ 到顶点 $s_{k+1}$ 的无阻塞栅格路径。否则，考虑该路径段经过的无阻塞单元的序列 $(b_0, … , b_m)$。任何两个连续的单元格 $b_j$ 和 $b_{j+1}$ 至少共享一个顶点 $s′_{j+1}$，因为这两个单元格要么共享一条边，要么对角相邻。(考虑栅格路径 $[s′_{0} = s_{k}, s′_{1}, … , s′_{m}, s′_{m+1} = s_{k+1}]$。这条从顶点 $s_{k}$ 到顶点 $s_{k+1}$ 的栅格路径是无阻塞的，因为上面任意两个连续的顶点都是同一个无阻塞单元的角，因此是可见的邻居。对任意角度路径的每个路径段重复此步骤，并将得到的栅格路径串联成一条从顶点 $s_0$ 到顶点 $s_n$ 的无阻塞栅格路径（如果栅格路径上的几个连续顶点相同，则可以删除除一个顶点以外的所有顶点）。 定理 2. 在基本 Theta* 执行过程中的任何时刻，从开放或封闭列表中的任何顶点到起始顶点的父节点，都能检索到一条从起始顶点到该顶点的反向无阻塞路径。 证明 我们通过归纳法证明该定理成立，并且在开放列表或封闭列表的结合部中的任何顶点的父顶点本身也在开放列表或封闭列表的结合部中。这句话最初成立的原因是，起始顶点是开放列表或封闭列表联合体中的唯一顶点，而且它是自己的父顶点。我们现在证明，只要顶点改变了它的父顶点或它在开放列表或封闭列表的联合体中的成员身份，该声明就会继续成立。顶点一旦成为开放或封闭列表联盟的成员，它就会一直是联盟的成员。只有当基本 Theta* 扩展了某个顶点 $s$，并在更新顶点（UpdateVertex）过程中更新了顶点 $s$ 的未扩展可见邻居 $s′$ 的 $g$ 值和父级时，顶点才能成为开放或封闭列表联盟中的成员。因此，顶点 $s$ 位于封闭列表中，根据归纳假设，其父节点位于开放列表或封闭列表的结合部。因此，根据归纳假设，沿着顶点 $s$（或其父节点）到起始顶点的父节点，可以反向检索出一条从起始顶点到顶点 $s$（或其父节点）的无阻塞路径。如果基本 Theta* 根据路径 1 更新顶点 $s′$，那么语句继续成立，因为顶点 $s$ 和 $s′$ 是可见的相邻顶点，因此从顶点 $s$ 到顶点 $s′$ 的路径段是畅通的。如果基本 Theta* 根据路径 2 更新顶点 $s′$，那么语句继续成立，因为基本 Theta* 明确检查了从顶点 $s$ 的父节点到顶点 $s′$ 的路径段是否畅通无阻。顶点的父节点没有其他变化方式。 定理 1.​ 如果存在从起始顶点到目标顶点的无阻塞路径，则基本 Theta* 会终止，路径提取会检索到该路径。否则，基本 Theta* 将终止并报告不存在无阻塞路径。 证明 下列性质共同证明了本定理。它们的证明利用了这样一个事实，即如果open list的顶点为空或扩展了目标顶点，基本 Theta* 就会终止。起始顶点最初位于 open list 中。任何其他顶点最初既不在 open list 中，也不在 close list 中。既不在打开列表中也不在关闭列表中的顶点可以插入到open list中。open list中的顶点可以从open list中移除，并插入到close list中。close list中的顶点会一直保留在封闭列表中。 性质 1： 基本 Theta* 终止。每次迭代都会在 open list 中扩展一个顶点。在此过程中，它会将顶点从 open list 中移除，然后再也无法将其插入 open list 中。由于顶点的数量是有限的，open list 最终会变空，如果基本Theta* 没有提前终止，就必须终止。 性质 2： 如果基本 Theta* 因其 open list 为空而终止，则不存在从起始顶点到目标顶点的无阻塞路径。我们证明反证。假设存在一条从起始顶点到目标顶点的畅通无阻的路径。我们通过矛盾证明，Basic Theta* 不会终止，因为它的 open list 是空的。因此，也假设 Basic Theta* 终止是因为其 open list 为空。那么，根据定理 1，存在一条从起始顶点到目标顶点的无阻塞栅格路径 $[s_0 = s_{start}, … , s_n = s_{goal}]$。选择顶点 si 作为栅格路径上的第一个顶点，当 Basic Theta* 终止时，该顶点不在 close list 中。基本 Theta* 终止时，目标顶点不在封闭列表中，因为基本 Theta* 在扩展目标顶点时会终止。因此，顶点 $s_i$ 存在。顶点 $s_i$ 不是起始顶点，因为起始顶点本应在打开列表中，而 Basic Theta* 不可能终止，因为它的打开列表是空的。因此，顶点 $s_i$ 在栅格路径上有一个前置顶点。由于顶点 $s_i$ 是栅格路径上的第一个顶点，在 Basic Theta* 终止时不在封闭列表中，因此当 Basic Theta* 终止时，这个前置顶点在封闭列表中。当 Basic Theta* 扩展前置顶点时，会将顶点 $s_i$ 添加到开放列表中。因此，当 Basic Theta* 终止时，顶点 $s_i$ 仍在打开列表中。但是，Basic Theta* 不可能终止，因为它的打开列表是空的，这是一个矛盾。 性质 3: 如果基本 Theta* 因为扩展了目标顶点而终止，那么路径提取会检索出一条从起始顶点到目标顶点的畅通无阻的路径，因为根据引理 2，沿着从目标顶点到起始顶点的父节点，可以反向检索出一条从起始顶点到目标顶点的畅通无阻的路径。 5.3.2 OPTIMALITY基本 Theta* 并不是最优的（==也就是说，它不能保证找到真正的最短路径==），因为顶点的父节点必须是该顶点的可见邻居或可见邻居的父节点，而真正的最短路径并非总是如此。图 9(a) 显示了这样一个例子：红色虚线路径 [E1, B9] 是一条从起始顶点 E1 到顶点 B9 的真正最短路径，因为顶点 E1 与顶点 B9 是视线相交。但是，顶点 E1 既不是顶点 B9 的可见邻居，也不是其可见邻居的父顶点，因为顶点 E1 与这些顶点（红色突出显示）之间没有视线。因此，Basic Theta* 无法将顶点 B9 的父顶点设置为顶点 E1，也无法找到从顶点 E1 到顶点 B9 的真正最短路径。 同样，图 9(b) 显示了一个示例，红色虚线路径 [E1, D8, C10] 是一条从顶点 E1 到顶点 C10 的真正最短路径。然而，顶点 D8 既不是顶点 C10 的可见邻居，也不是其可见邻居的父节点，因为起始顶点 E1 要么有视线通向它们，要么 Basic Theta* 找到了从顶点 E1 到它们的不包含顶点 D8 的路径。事实上，从顶点 E1 到顶点 C10 的所有可见相邻顶点的真正最短路径，顶点 E1 没有视线移动到受阻单元格 C7C8-D8-D7 的上方（而不是下方）。因此，Basic Theta* 无法将顶点 C10 的父节点设置为顶点 D8，也就无法找到从顶点 E1 到顶点 C10 的真正最短路径。图 9(a) 中从顶点 E1 到顶点 B9 的蓝色实线路径和图 9(b) 中从顶点 E1 到顶点 C10 的蓝色实线路径比真正的最短路径长不到 1.002 倍。 5.3.3 HEADING CHANGESBasic Theta* 利用了真正的最短路径只在受阻单元格的角上有方向变化这一事实。然而，Basic Theta* 找到的路径偶尔会出现不必要的方向变化。图 10 显示了一个示例，Basic Theta* 找到了从顶点 A1 到顶点 D6 的蓝色实线路径 [A1，D5，D6]。出现这种错误的原因很简单。假设 open list 同时包含顶点 C5 和 D5。顶点 C5 的 f 值为 $f (C5) = g(C5) + h(C5) = 4.61 + 1.41 = 6.02$，其父顶点为顶点 C4。顶点 D5 的 $f$ 值为 $f (D5) = 5.00 + 1.00 = 6.00$，其父顶点为顶点 A1。因此，Basic Theta* 先于顶点 C5 展开顶点 D5（因为其 $f$ 值更小）。当基本 Theta* 以父顶点 A1 展开顶点 D5 时，会生成顶点 D6。顶点 D6 是顶点 D5 的未展开可见邻居，与顶点 A1 没有视线关系。因此，基本 Theta* 根据路径 1 对其进行更新，将其 f 值设置为 $f (D6) = 6.00 + 0.00 = 6.00$，将其父节点设置为顶点 D5，并将其插入到 open list 中。因此，基本 Theta* 会在顶点 C5 之前扩展目标顶点 D6（因为其 f 值更小）并终止。然后，路径提取会从目标顶点 D6 开始，沿着父级顶点 A1 提取出蓝色实线路径 [A1、D5、D6]。因此，Basic Theta* 从未扩展顶点 C5，这将导致它根据路径 2 将顶点 D6 的父节点设置为顶点 C4，而路径提取将检索到红色虚线路径 [A1、C4、D6]，这才是真正的最短路径。图 10 中从顶点 A1 到顶点 D6 的蓝色实线路径比真正的最短路径长不到 1.027 倍。 6. Angle-Propagation Theta* (AP Theta*)==由于每次视线检查的运行时间与单元格数呈线性关系，因此每次顶点扩展（即在扩展顶点时生成未扩展的可见邻域所消耗的运行时间）的基本 Theta* 运行时间与单元格数呈线性关系。==在本节中，我们将介绍角度传播 Theta* (AP Theta* )，它将基本 Theta* 每个顶点扩展的运行时间从线性减少为常数1。AP Theta* 与 Basic Theta* 的主要区别在于，AP Theta* 传播角度范围，并利用它们来确定两个顶点是否有视线。 如果顶点处有光源，而光线无法穿过被遮挡的单元格，那么阴影中的单元格与顶点没有视线接触，而所有其他单元格与顶点有视线接触。每个与顶点有视线的点的连续区域都可以用两条从顶点发出的光线来描述，因此也可以用两个角度边界定义的角度范围来描述。图 11 显示了一个示例，由两个角度边界 $\\theta_1$ 和 $theta_2$ 定义的红色角度范围内的所有点都与顶点 $s$ 有视线接触。 AP Theta* 在扩展顶点时计算顶点的角度范围，然后沿栅格边缘传播，因此每次顶点扩展的运行时间是恒定的，因为角度范围可以在恒定时间内传播，视线检查也可以在恒定时间内执行。 算法 4 显示了 AP Theta* 的伪代码。程序 Main 与算法 1 中的 A* 相同，因此没有显示。第 13 行将被执行。在实验中，我们使用直线距离 $h(s) = c(s, sgoal)$ 作为 $h$ 值。 6.1 Definition of Angle Ranges现在我们讨论角度范围这一关键概念。AP Theta* 为每个顶点 s 保留两个附加值，即顶点 s 的下角边界 $lb(s)$ 和顶点 s 的上角边界 $ub(s)$，它们共同构成顶点 s 的角度范围 $[lb(s), ub(s)]$。角度边界对应于从顶点 s 的父顶点出发的射线的方向（以度为单位），从顶点 s 的父顶点到顶点 s 的射线方向为零度。如果（但不一定只有）从顶点 $s$ 的父顶点到顶点 $s$ 的可见邻居的射线的方向包含在顶点 $s$ 的角度范围内，则保证顶点 s 的可见邻居与顶点 $s$ 的父顶点有视线相交。图 12 显示了这样一个例子：==顶点 C3 的父顶点 A4 的角度范围为 $[-18, 27]$==。因此，红色区域中顶点 C3 的所有可见邻居都保证与顶点 C3 的父顶点有视线接触。例如，顶点 C4 保证与顶点 C3 的父顶点有视线接触，但顶点 B2 却没有。因此 AP Theta* 假设顶点 B2 与顶点 C3 的父节点不存在视线关系。 现在我们更正式地定义角度范围的概念。$\\Theta(s, p, s′) ∈ [-90, 90]$ 是顶点 p 到顶点 s 的射线与顶点 p 到顶点 $s′$ 的射线之间的夹角（以度为单位），AP Theta* 也因此而得名。如果从顶点 p 到顶点 $s$ 的射线与从顶点 p 到顶点 $s′$ 的射线顺时针方向相反，则角度为正；如果从顶点 p 到顶点 $s$ 的射线与从顶点 p 到顶点 $s′$ 的射线方向相同，则角度为零；如果从顶点 p 到顶点 $s$ 的射线与从顶点 p 到顶点 $s′$ 的射线逆时针方向相反，则角度为负。图 12 显示了一个 $\\Theta(C3, A4, C4) = 27$ 和 $\\Theta(C3, A4, B3) = -18$ 的例子。如果（但不一定只有）$lb(s) ≤ \\Theta(s, parent(s), s′) ≤ ub(s)$，则保证顶点 $s$ 的可见邻居 $s′$ 与顶点 $s$ 的父顶点有视线接触（可见性属性）。 6.2 Update of Angle Ranges现在我们讨论 AP Theta* 在扩展顶点时如何计算顶点的角度范围。由于顶点展开的顺序取决于多种因素，例如 $h$ 值，因此 AP Theta* 无法保证拥有足够的信息来精确确定角度范围，这使得计算变得复杂。在这种情况下，AP Theta* 可以对角度范围进行超出必要的限制，以保证可见性属性成立，并找到未阻塞的路径。 AP Theta* 扩展顶点 $s$ 时，最初会将顶点 $s$ 的角度范围设置为 $[-\\infty, \\infty]$，这意味着该顶点的所有可见邻居都能保证与该顶点的父顶点有视线接触。然后，如果顶点 s 不是起始顶点，角度范围的限制会越来越大。 AP Theta* 根据与顶点 $s$ 相邻的每个受阻单元 $b$（即顶点 $s$ 是 $b$ 的一个角，写成 $s∈ corners(b)$）来限制顶点 $s$ 的角度范围，前提是至少满足两个条件中的一个： 情况 1：如果受阻单元 b 的每个角 $s′$ 至少满足以下条件之一： $parent(s)= s′$ 或 $\\Theta(s,parent(s), s’) &lt; 0$ 或 $\\Theta(s,parent(s), s’)=0$ 且 $c(parent(s), s′) ≤ c(parent(s), s),$ 那么 AP Theta* 假设，如果从顶点 $s$ 的父顶点到顶点 $s$ 的射线与从顶点 $s$ 的父顶点到顶点 $s′′$ 的射线逆时针方向，即如果 $\\Theta（s, parent(s), s′′）&lt; 0$，则顶点 $s′′$ 没有视线到顶点 $s$ 的父顶点。因此 AP Theta* 将顶点 s 的下角边界设为 $\\Theta(s, parent(s), s) = 0$ [第 83 行]。 情况 2：如果受阻单元 b 的每个角 $s′$ 至少满足以下条件之一： $parent(s) = s′$ 或 $\\Theta(s, parent(s), s′) &gt; 0$ 或 $\\Theta(s, parent(s), s′) = 0$ 且 $c(parent(s), s′) ≤ c(parent(s), s)$ 则 AP Theta* 假设，如果从顶点 s 的父顶点到顶点 $s$ 的射线与从顶点 $s$ 的父顶点到顶点 $s′′$ 的射线顺时针方向，即如果 $\\Theta(s, parent(s), s′′)&gt; 0$，则顶点 s′′ 没有视线到顶点 s 的父顶点。因此 AP Theta* 将顶点 s 的角度上限设为 $\\Theta (s, parent(s), s) = 0$ [第 86 行]。 AP Theta* 还会根据顶点 $s$ 的每个可见邻居 $s′$ 来限制顶点 $s$ 的角度范围，前提是满足两个条件中的至少一个： 情况 3：如果顶点 $s′$ 满足以下所有条件： $s′ ∈ closed$ 且 $parent(s) = parent(s′)$ 且 $s′ \\not= sstart$, 则 AP Theta* 通过与顶点 $s′$ 的角度范围相交来限制顶点 $s$ 的角度范围 [第 90 和 92 行]。为此，它首先将顶点 $s′$ 的角度范围移动 $\\Theta (s, parent(s), s′)$度，以考虑顶点 $s′$ 的角度范围已校准为从顶点 $s$ 和 $s′$ 的共同父顶点到顶点 $s′$ 的射线方向为零度、 同时校准顶点 $s$ 的角度范围，使顶点 $s$ 和 $s′$ 的父顶点到顶点 $s$ 的射线方向为零度。第 89 和 91 行分别确保角度下限值始终为非正值和角度上限值始终为非负值。角度下限值应为非正值（角度上限值应为非负值）这一事实很直观，因为如果顶点 $s$ 被指定为父顶点 p，那么从顶点 p 到顶点 s 的射线角度应包含在顶点 s 的角度范围内。 情况 4：如果顶点 s′ 满足以下所有条件： $c(parent(s), s′) &lt; c(parent(s), s)$ 且 $parent(s) \\not= s′$ 且 $s′ \\not∈ closed$ 或 $parent(s) \\not= parent(s′),$ 那么 AP Theta* 没有足够的顶点 $s′$ 的信息。因此，AP Theta* 无法准确确定顶点 $s$ 的角度范围，只能做一个保守的假设，即顶点 $s′$ 几乎看不到顶点 $s$ 的父点 [第 95 和 97 行]。 AP Theta* 在更新边界（UpdateBounds）过程中更新了顶点 $s$ 的角度范围后，可见性属性保持不变。因此，当 AP Theta* 检查顶点 $s$ 的可见邻居 $s′$ 是否与顶点 $s$ 的父节点有视线时，它现在会检查 $lb(s) ≤ \\Theta(s, parent(s), s′) ≤ ub(s)$ [第 60 行] 是否为真，而不是 $LineOfSight(parent(s), s′)$ [第 42 行] 是否为真。这就是 AP Theta* 和 Basic Theta* 之间的唯一区别。 图 13(a) 显示了 AP Theta* 计算顶点 A4 的角度范围的示例。它将角度范围设置为 $[-\\infty, \\infty]$。图 13(b) 是 AP Theta* 计算顶点 B3 的角度范围的示例。它将角度范围初始设置为 $[-\\infty，\\infty]$。然后根据 A2-A3-B3-B2 单元 [第 83 行]，按照情况 1 将角度下限设置为 0 度。根据情况 4，它将顶点 B4 的角度上限设置为 45 度，因为顶点 B4 尚未展开，因此不在 close list 中 [第 97 行]。图 13(c) 显示了 AP Theta* 计算顶点 B2 的角度范围的示例。它将角度范围初始设置为 $[-\\infty，\\infty]$。然后根据 A2-A3-B3-B2 单元[第 83 行]的阻塞情况，按照情况 1 将角度下限设为 0 度。假设顶点 C1 不是目标顶点。图 13(d) 显示了 AP Theta* 计算顶点 C1 的角度范围的示例。它最初将角度范围设置为 $[-\\infty, \\infty]$。然后，它根据情况 3，以顶点 B2 为基础，将角度下限设为 -27 度[第 90 行]，并根据情况 4，以顶点 C2 为基础，将角度上限设为 18 度，而顶点 C2 是未展开的，因此不在 close list 中[第 97 行]。 6.3 Example Trace of AP Theta*图 13 是利用图 8 中的路径规划问题绘制的 AP Theta* 曲线示例。顶点的标签现在包括了角度范围。 6.4 Properties of AP Theta*现在我们来讨论 AP Theta* 的特性。AP Theta* 的运行方式与基本 Theta* 相同，因此具有与基本 Theta* 相似的特性。==例如，AP Theta* 是正确和完整的。它不能保证找到真正的最短路径，而且其路径偶尔会出现不必要的航向变化。== AP Theta* 有时会对角度范围进行超出必要的限制，以保证找到无遮挡的路径，这意味着它的视线检查有时会错误地失败，在这种情况下，它必须根据路径 1 而不是路径 2 更新顶点。AP Theta* 仍然是完整的，因为如果所有视线检查都失败，它也能找到一条无遮挡的栅格路径；如果存在一条无遮挡的任意角度路径，它也总是存在一条无遮挡的栅格路径。不过，AP Theta* 找到的路径可能比 Basic Theta* 找到的路径更长。图 14 显示了一个示例。当 AP Theta* 用父 B1 展开顶点 C4 并计算顶点 C4 的角度范围时，顶点 C3 未展开，因此不在 close list 中。这意味着 AP Theta* 没有关于顶点 C3 的足够信息，例如，它不知道单元格 C2-C3-D3-D2 是否未封锁。因此，AP Theta* 无法准确确定顶点 C4 的角度范围，只能做出顶点 C3 与顶点 B1 几乎没有视线的保守假设，并根据顶点 C3 按照情况 4 设置顶点 C4 的角度下限。然后，它使用得到的角度范围确定顶点 C4 的未扩展可见邻居 D4 不能保证与顶点 B1 有视线接触。但是，如果单元格 C2-C3-D3-D2 未被遮挡，顶点 D4 确实与顶点 B1 有视线连接。AP Theta* 最终找到了从起始顶点 B1 到顶点 D4 的蓝色实线路径 [B1，C3，D4]，而 Basic Theta* 找到了红色虚线路径 [B1，D4]，这是真正的最短路径。 由于 AP Theta* 执行视线检查的方式不同，Basic Theta* 的正确性和完整性证明需要针对 AP Theta* 稍作修改。 定理 2. AP Theta* 终止后，如果存在从起始顶点到目标顶点的无阻塞路径，路径提取将检索到该路径。否则，AP Theta* 终止并报告不存在无阻塞路径。 证明 证明与定理 1 的证明类似，因为 AP Theta* 只使用角度范围来确定路径 2 是否受阻，而不是确定路径 1 是否受阻。唯一需要证明的不同属性是，如果（但不一定只有当）AP Theta* 的视线检查成功，两个顶点确实有视线，见附录 B。 7. Experimental Results在本节中，我们将基本 Theta* 和 AP Theta* 与栅格上的 A* 和可视图上的 A* 、 A* PS、FD* 进行比较，比较它们的路径长度、顶点扩展次数、运行时间（以秒为单位）和航向变化次数。 我们在 100 × 100 和 500 × 500 的栅格上对这些路径规划算法进行了比较，这些栅格包含不同比例的随机阻塞单元（随机栅格）和来自即时战略游戏《博德之门 II》的缩放地图（游戏地图）。图 15（Bulitko、Sturtevant 和 Kazakevich，2005 年）显示了游戏地图的一个示例。起始顶点和目标顶点是单元格的西南角。对于随机栅格，起始顶点位于西南方的单元格中。目标顶点位于从最东边的单元格列中随机选择的单元格中。单元是随机阻塞的，但未阻塞单元的一单元边界保证了从起点顶点到目标顶点的路径。对于游戏地图，起始顶点和目标顶点是从未被阻塞的单元格的角上随机选择的。我们对 500 个随机 100 × 100 栅格、500 个随机 500 × 500 栅格和 118 个游戏地图进行了平均计算。","link":"/2023/11/22/Theta-Any-Angle-Path-Planning-on-Grids/"},{"title":"双向Dijkstra算法","text":"双向迪杰斯特拉算法Python实现简介双向迪杰斯特拉算法（Bi Directional Dijkstra Algorithm）是一种用于在加权图中查找两个顶点之间最短路径的算法，是Dijkstra算法的一个变种，基本思想是：从两个搜索方向同时开始搜索——从起点到终点方向和从终点到起点方向同时进行迪杰斯特拉算法搜索，如果存在路径，那么最终两个方向的搜索会在某点相遇并终止，而这条路径就是最短距离路径。在某些情况下，双向迪杰斯特拉算法可以减少搜索空间大小，从而提高算法效率。==其中也有分治法的思想== 双向迪杰斯特拉算法优势与迪杰斯特拉算法相比，双向迪杰斯特拉算法在以下情况更有优势： 大规模图搜索：如果图的规模很大，双向迪杰斯特拉算法很可能会比迪杰斯特拉算法更快。 稀疏图：在稀疏图中，双向迪杰斯特拉算法很可能会比迪杰斯特拉算法更快。 最主要是因为双向搜索可以减少一定的搜索空间，从终点开始搜索和从起点开始搜索，相当于做了一次剪枝。 （我觉得这张图很形象的解释了为什么双向迪杰斯特拉算法能够减少搜索空间，而单项迪杰斯特拉算法在大规模图中，会越来越发散） 局限性 复杂性：双向迪杰斯特拉算法需要更复杂的数据结构来跟踪记录两个方向的搜索路径。算法需要更多时间维护两个方向的队列。 权重不均等的图、负权重图：对于边权重差异比较大和负权重的图，双向迪杰斯特拉算法可能不会表现得很好。 当终点和起点距离比较近的时候，双向迪杰斯特拉算法算法可能不如单项迪杰斯特拉算法算法。 但是双向迪杰斯特拉还是具有减少搜索空间和更快搜索到最短路径的优点。 算法的基本步骤终止条件双向迪杰斯特拉算法最重要的是，终止条件，算法在什么时候应该终止，如何确定相遇的点是应该终止算法的。双向迪杰斯特拉算法需要维护两个队列，一个是从起点到终点方向的队列queue_from_start和queue_from_target，设：$top_f$是queue_from_start优先级队列的队头元素，$top_r$是queue_from_target优先队列的队头元素，$\\mu$用来记录相遇点构成的路径值，初始化$\\mu = \\infty$。在进行路径搜索的时候，当存在一条边$(u,v)$满足$u$在前向搜索中，而$v$在反向搜索中，如果$d_f(u)+c(u,v)+d_r(v) &lt; \\mu$，则更新$\\mu$值。 终止条件：$top_f + top_r \\ge \\mu$ 基本步骤 初始化：将起点加入到正向搜索的待处理队列中，将终点加入到反向搜索的待处理队列中。 迭代搜索：在每一次迭代中，算法分别对正向和反向的待处理队列中的顶点进行处理，选择当前距离最小的顶点进行扩展。 扩展顶点：对于选中的顶点，算法更新其邻接顶点的最短路径估计，并将这些邻接顶点加入到相应的待处理集合中。 检查相遇：在每次扩展后，算法检查正向和反向的搜索是否在某个顶点上相遇。相遇的条件通常是检查某个顶点是否同时出现在正向和反向的访问表中。 路径重构：一旦搜索相遇，算法使用正向和反向的路径信息来重构出从起点到终点的最短路径。 终止条件：如果两个搜索在中间某处相遇，或者一个方向的搜索已经找不到新的顶点进行扩展，算法终止。 伪代码程序结构： 1234567891011121314151617181920212223242526272829303132333435function BidirectionalDijkstra(graph, start, end) create priority queues queueFromStart, queueFromEnd add start to queueFromStart with priority 0 add end to queueFromEnd with priority 0 create distance maps distanceFromStart, distanceFromEnd and set all distances to infinity set distanceFromStart[start] to 0 set distanceFromEnd[end] to 0 create parent maps parentFromStart, parentFromEnd and set all parents to null set parentFromStart[start] to start set parentFromEnd[end] to end while queueFromStart and queueFromEnd are not empty nodeFromStart = extract minimum from queueFromStart for each neighbor of nodeFromStart if distance through nodeFromStart to neighbor is less than distanceFromStart[neighbor] update distanceFromStart[neighbor] update parentFromStart[neighbor] add neighbor to queueFromStart with priority distanceFromStart[neighbor] nodeFromEnd = extract minimum from queueFromEnd for each neighbor of nodeFromEnd if distance through nodeFromEnd to neighbor is less than distanceFromEnd[neighbor] update distanceFromEnd[neighbor] update parentFromEnd[neighbor] add neighbor to queueFromEnd with priority distanceFromEnd[neighbor] if any node v is in both queueFromStart and queueFromEnd path = shortest path from start to v according to parentFromStart path = path + reverse of shortest path from v to end according to parentFromEnd return path return no path Python 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def bidirectional_dijkstra_b(graph, start, target, i): queue_from_start = [] hq.heappush(queue_from_start, (0.0, start)) distance_from_start = {node: float('infinity') for node in graph} distance_from_start[start] = 0.0 parents_of_start = {start: None} queue_from_target = [] hq.heappush(queue_from_target, (0.0, target)) distance_from_target = {node: float('infinity') for node in graph} distance_from_target[target] = 0.0 parents_of_target = {target: None} close_of_start = set() # 访问禁闭表 close_of_target = set() # 访问禁闭表 miu = math.inf global node node = None while queue_from_start and queue_from_target: if queue_from_start[0][0] + queue_from_target[0][0] &gt;= miu: return reverse_traversal(node, parents_of_start, parents_of_target) cur_dist, cur_node = hq.heappop(queue_from_start) close_of_start.add(cur_node) for adjacent, weight in graph[cur_node].items(): if adjacent in close_of_start: continue distance = cur_dist + weight[&quot;weight&quot;] if distance &lt; distance_from_start[adjacent]: distance_from_start[adjacent] = distance parents_of_start[adjacent] = cur_node hq.heappush(queue_from_start, (distance, adjacent)) # 更新miu值 if adjacent in close_of_target: dist = distance + distance_from_target[adjacent] if miu &gt; dist: miu = dist node = adjacent cur_dist, cur_node = hq.heappop(queue_from_target) close_of_target.add(cur_node) for adjacent, weight in graph[cur_node].items(): if adjacent in close_of_target: continue distance = cur_dist + weight[&quot;weight&quot;] if distance &lt; distance_from_target[adjacent]: distance_from_target[adjacent] = distance parents_of_target[adjacent] = cur_node hq.heappush(queue_from_target, (distance, adjacent)) if adjacent in close_of_start: dist = distance + distance_from_start[adjacent] if miu &gt; dist: miu = dist node = adjacent return [] 双向迪杰斯特拉与单向迪杰斯特拉算法比较双向迪杰斯特拉算法写了两个版本，主要是控制方式不同。 实验中生成稀疏图标准是，$e=n*\\log{n}$ 可以看出，随着节点和边的数量增多，算法的耗时越大，在节点数=50000，边数=252959时，迪杰斯特拉算法的速度远远高于双向迪杰斯特拉算法。 从上图来看，在50，500数量级的节点数下，第二种控制流的迪杰斯特拉算法更快，但是随着节点数数量级增大，第一种控制流双向迪杰斯特拉算法更优。推测结论：双向迪杰斯特拉算法是内含分治法思想的，如果两侧探索数量越均等越好。","link":"/2023/11/13/%E5%8F%8C%E5%90%91Dijkstra%E7%AE%97%E6%B3%95/"},{"title":"Python 线程编程（类内多线程编程）","text":"Python线程编程（类内多线程编程）多线程可以同时执行一段代码的多个程序。使用多线程可能使程序运行速度更快。 线程和进程不同：可以这样来简单理解，一个程序包含一个或多个进程，一个进程包含一个或多个线程。也就是说程序 &gt; 进程 &gt; 线程。进程之间、线程之间、进程和线程之间可以共享数据。线程也被称为轻量级进程。 线程是操作系统能够运行的最小单位，线程包含在进程中，是进程中的实际运作单位。 Python 线程编程提供了两个模块，即 _thread和threading，其中 _thread是低级模块，threading 是高级模块，它对 _thread模块进行了封装。 123import threading# 或者from threading import thread python 多线程编程方法主要有两种，一种是针对Function的，一种是针对Class的。 多线程编程的函数 方法名 说明 用法 Thread 创建线程 Thread(target,args) start 启动线程 start() join 阻塞直到线程执行结束 join(timeout=None) run 用来重载，表示线程活动的方法 run() getName 获取线程的名字 getName() setName 设置线程的名字 setName(name) is_alive 判读线程是否存活 is_alive() setDaemon 守护线程 setDaemon(True) Function级多线程编程Function级别多线程主要是调用Thread模块，Thread模块在Threading库中，Thread本身也是一个类class 该类的接口为 123Thread([group [, target [, name [, args [, kwargs]]]]])# 我们记住这几个就可以了Thread(target, name, args[, kwargs]) target表示一个可调用的对象，可以是一个函数function。 name表示线程的名字，默认创建一个Thread-N格式的唯一名称。 如果target是一个带有参数的函数，则需要使用到args或[kwargs]。 12from threading import Threadt1 = Thread(target=function_name) 上述代码，就是初始化了一个Thread类的对象，其中function_name填写自己的函数名称，这样就新建了一个该函数的线程。 我们可以使用for循环初始化多个线程 1234from threading import Threaddef task(value): print(&quot;I am &quot;, value) time.sleep(3) 一个稍微复杂一点的程序： 12345678910111213141516171819202122list_a = [0, 0, 0, 0, 0, 0]def task(value): list_a[value] += value print(&quot;[%s] %s 修改第 %d 个值，修改后值为:%d&quot; % (time.ctime(time.time()), threading.current_thread().name, value, list_a[value]))print(&quot;--------------程序开始--------------&quot;)threads_pool = []for i in range(len(list_a)): t = Thread(target=task,name=i, kwargs={&quot;value&quot;: i}) # 初始化6个线程 threads_pool.append(t)# 第一个for循环更高级的写法是threads_pool = [Thread(target=task,name=i, kwargs={&quot;value&quot;: i}) for i in range(len(list_a))]# 初始化的线程需要start命令启动，start会自动调用线程中的run命令运行for t in threads_pool: t.start()for t in threads_pool: t.join()print(&quot;---------------程序结束------------&quot;) 输出： 12345678--------------程序开始--------------[Fri Dec 1 21:41:13 2023] Thread-1 修改第 0 个值，修改后值为:0[Fri Dec 1 21:41:13 2023] 1 修改第 1 个值，修改后值为:1[Fri Dec 1 21:41:13 2023] 2 修改第 2 个值，修改后值为:2[Fri Dec 1 21:41:13 2023] 3 修改第 3 个值，修改后值为:3[Fri Dec 1 21:41:13 2023] 4 修改第 4 个值，修改后值为:4[Fri Dec 1 21:41:13 2023] 5 修改第 5 个值，修改后值为:5---------------程序结束------------ 注意：==看来线程的名字不能被命名为数字0。== 上面一个稍微复杂的代码共开了六个线程，每个线程对指定为的list_a数组进行加值的操作， class级多线程编程class级多线程编程通过定义一个继承Thread线程类的子类来创建线程。 继承于threading.Thread类的子类，需要对init等方法进行重写： 该段代码来自Python 多线程 | 菜鸟教程 (runoob.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threadingimport timefrom threading import Thread# list = [0,0,0,0,0,0,0,0,0,0,0,0]class myThread(threading.Thread): def __init__(self,threadId,name,counter): threading.Thread.__init__(self) self.threadId = threadId self.name = name self.counter = counter global list list = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] def run(self): print (&quot;开始线程:&quot;,self.name) # 获得锁，成功获得锁定后返回 True # 可选的timeout参数不填时将一直阻塞直到获得锁定 # 否则超时后将返回 False # threadLock.acquire() print_time(self.name,self.counter,list.__len__()) # 释放锁 # threadLock.release() def __del__(self): print (self.name,&quot;线程结束！&quot;)def print_time(threadName,delay,counter): while counter: time.sleep(delay) list[counter-1] += 1 print(&quot;[%s] %s 修改第 %d 个值，修改后值为:%d&quot; % (time.ctime(time.time()),threadName,counter,list[counter-1])) counter -= 1 threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1,&quot;Thread-1&quot;,1)thread2 = myThread(2,&quot;Thread-2&quot;,2)thread3 = myThread(3, &quot;Thread-3&quot;,3)# 开启新线程thread1.start()thread2.start()thread3.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)threads.append(thread3)# 等待所有线程完成for t in threads: t.join()print(&quot;主进程结束！&quot;)print(&quot;list:&quot;, list) 该段代码实现了对Thread继承的一个类，并重写了run()函数。 输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748开始线程: Thread-1开始线程: Thread-2开始线程: Thread-3[Fri Dec 1 21:56:13 2023] Thread-1 修改第 12 个值，修改后值为:1[Fri Dec 1 21:56:14 2023] Thread-1 修改第 11 个值，修改后值为:1[Fri Dec 1 21:56:14 2023] Thread-2 修改第 12 个值，修改后值为:2[Fri Dec 1 21:56:15 2023] Thread-3 修改第 12 个值，修改后值为:3[Fri Dec 1 21:56:15 2023] Thread-1 修改第 10 个值，修改后值为:1[Fri Dec 1 21:56:16 2023] Thread-1 修改第 9 个值，修改后值为:1[Fri Dec 1 21:56:16 2023] Thread-2 修改第 11 个值，修改后值为:2[Fri Dec 1 21:56:17 2023] Thread-1 修改第 8 个值，修改后值为:1[Fri Dec 1 21:56:18 2023] Thread-3 修改第 11 个值，修改后值为:3[Fri Dec 1 21:56:18 2023] Thread-2 修改第 10 个值，修改后值为:2[Fri Dec 1 21:56:18 2023] Thread-1 修改第 7 个值，修改后值为:1[Fri Dec 1 21:56:19 2023] Thread-1 修改第 6 个值，修改后值为:1[Fri Dec 1 21:56:20 2023] Thread-2 修改第 9 个值，修改后值为:2[Fri Dec 1 21:56:20 2023] Thread-1 修改第 5 个值，修改后值为:1[Fri Dec 1 21:56:21 2023] Thread-3 修改第 10 个值，修改后值为:3[Fri Dec 1 21:56:21 2023] Thread-1 修改第 4 个值，修改后值为:1[Fri Dec 1 21:56:22 2023] Thread-2 修改第 8 个值，修改后值为:2[Fri Dec 1 21:56:22 2023] Thread-1 修改第 3 个值，修改后值为:1[Fri Dec 1 21:56:23 2023] Thread-1 修改第 2 个值，修改后值为:1[Fri Dec 1 21:56:24 2023] Thread-3 修改第 9 个值，修改后值为:3[Fri Dec 1 21:56:24 2023] Thread-2 修改第 7 个值，修改后值为:2[Fri Dec 1 21:56:24 2023] Thread-1 修改第 1 个值，修改后值为:1[Fri Dec 1 21:56:26 2023] Thread-2 修改第 6 个值，修改后值为:2[Fri Dec 1 21:56:27 2023] Thread-3 修改第 8 个值，修改后值为:3[Fri Dec 1 21:56:28 2023] Thread-2 修改第 5 个值，修改后值为:2[Fri Dec 1 21:56:30 2023] Thread-3 修改第 7 个值，修改后值为:3[Fri Dec 1 21:56:30 2023] Thread-2 修改第 4 个值，修改后值为:2[Fri Dec 1 21:56:32 2023] Thread-2 修改第 3 个值，修改后值为:2[Fri Dec 1 21:56:33 2023] Thread-3 修改第 6 个值，修改后值为:3[Fri Dec 1 21:56:34 2023] Thread-2 修改第 2 个值，修改后值为:2[Fri Dec 1 21:56:36 2023] Thread-3 修改第 5 个值，修改后值为:3[Fri Dec 1 21:56:36 2023] Thread-2 修改第 1 个值，修改后值为:2[Fri Dec 1 21:56:39 2023] Thread-3 修改第 4 个值，修改后值为:3[Fri Dec 1 21:56:42 2023] Thread-3 修改第 3 个值，修改后值为:3[Fri Dec 1 21:56:45 2023] Thread-3 修改第 2 个值，修改后值为:3[Fri Dec 1 21:56:48 2023] Thread-3 修改第 1 个值，修改后值为:3主进程结束！list: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]FalseThread-1 线程结束！Thread-2 线程结束！Thread-3 线程结束！Process finished with exit code 0 该段代码实现了，开3个线程，每个线程对list数组每个数据进行加1操作。 进阶 类内多线程有的时候，我们可能在一个类class内部，再实现一个类class，该类被称为内部类，我们希望通过内部类来实现多线程，它的方法和外部类的方法总体比较相似，只要把内部类看作是self的一部分即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Ant_Colony(object): class ant(Thread): def __init__(self, initital_location, ant_id): Thread.__init__(self) self.route = [] self.initital_location = initital_location self.id = ant_id def run(self): print(&quot;开始线程 ant_id: &quot;, self.id) self.calcute_route() def calcute_route(self): offsets = [(-1, 1), (0, 1), (1, 1), (-1, 0), (1, 0), (-1, -1), (0, -1), (1, -1)] cur_pos = self.initital_location for offset in offsets: pos_x = cur_pos[0] + offset[0] pos_y = cur_pos[1] + offset[1] if map[pos_x][pos_y] != 0 and pos_x &gt;= 0 and \\ pos_x &lt; 5 and pos_y &gt;= 0 and pos_y &lt; 5: pheromone[pos_x][pos_y] += 1 print(&quot;ant_id = %d, pos_x = %d, pos_y = %d&quot; % (self.id, pos_x, pos_y)) else: continue def __del__(self): print(&quot;ant_id &quot;, self.id, &quot; 线程结束！&quot;) def __init__(self, map, pheronome, ant_num): self.map = map global pheromone pheromone = pheromone # self.pheromone = pheronome self.ant_num = ant_num self.ants = self._init_ants() def _init_ants(self): return [self.ant([0, 1], i) for i in range(self.ant_num)] def run(self): for ant in self.ants: ant.start() for ant in self.ants: ant.join() self.print() def print(self): print(&quot;1&quot;) print(&quot;类内&quot;, pheromone) 输出： 12345678910111213141516171819202122232425262728293031323334353637类外： [[0.85956061 0.1645695 0.48347596 0.92102727 0.42855644] [0.05746009 0.92500743 0.65760154 0.13295284 0.53344893] [0.8994776 0.24836496 0.03017182 0.07244715 0.87416449] [0.55843035 0.91604736 0.63346045 0.28325261 0.36536881] [0.09223386 0.37251258 0.34742278 0.70517077 0.64850904]]开始线程 ant_id: 0ant_id = 0, pos_x = 0, pos_y = 2ant_id = 0, pos_x = 1, pos_y = 2ant_id = 0, pos_x = 1, pos_y = 1ant_id = 0, pos_x = 0, pos_y = 0ant_id = 0, pos_x = 1, pos_y = 0开始线程 ant_id: 1ant_id = 1, pos_x = 0, pos_y = 2ant_id = 1, pos_x = 1, pos_y = 2开始线程 ant_id: ant_id = 1, pos_x = 1, pos_y = 1ant_id = 1, pos_x = 0, pos_y = 0ant_id = 1, pos_x = 1, pos_y = 02ant_id = 2, pos_x = 0, pos_y = 2ant_id = 2, pos_x = 1, pos_y = 2ant_id = 2, pos_x = 1, pos_y = 1ant_id = 2, pos_x = 0, pos_y = 0ant_id = 2, pos_x = 1, pos_y = 01类内 [[3.85956061 0.1645695 3.48347596 0.92102727 0.42855644] [3.05746009 3.92500743 3.65760154 0.13295284 0.53344893] [0.8994776 0.24836496 0.03017182 0.07244715 0.87416449] [0.55843035 0.91604736 0.63346045 0.28325261 0.36536881] [0.09223386 0.37251258 0.34742278 0.70517077 0.64850904]]类外 [[3.85956061 0.1645695 3.48347596 0.92102727 0.42855644] [3.05746009 3.92500743 3.65760154 0.13295284 0.53344893] [0.8994776 0.24836496 0.03017182 0.07244715 0.87416449] [0.55843035 0.91604736 0.63346045 0.28325261 0.36536881] [0.09223386 0.37251258 0.34742278 0.70517077 0.64850904]]ant_id 2 线程结束！ant_id 1 线程结束！ant_id 0 线程结束！","link":"/2023/12/01/%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E7%B1%BB%E5%86%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%89/"},{"title":"迪杰斯特拉算法-python实现","text":"迪杰斯特拉算法简介迪杰斯特拉算法的是用于图搜索的一种算法，其作用是图中搜索出单源最短路径。单源最短路径问题是一个给定起始点和目标点，在图中搜索出由起始点到目标点最短路径问题。 核心思想迪杰斯特拉算法是贪心算法。表现在于每次只扩展累计代价值最小的节点。 贪心算法的优缺点 优点：逻辑正确的贪心算法有复杂度低、代码量小、运行效率高、空间复杂度低等优点 缺点：贪心算法的缺点表现在”非完美性“，通常很难找到一个简单可行并且保证正确的贪心思路，即使我们找到一个看上去很正确的贪心思路，也需要严格的正确性证明。这往往给我们直接使用贪心算法带来了巨大的困难。往往不能保证求得的最后解是最佳的；同时贪心算法也不能用来求最大或最小解的问题，只能求满足某些约束条件的可行解的范围。 运行过程 初始化：在开始时，将起始节点的距离设为0，将所有其他节点的距离设为无穷大。这是因为在开始时，只知道起始节点的距离，而不知道其他节点的距离。 选择代价值最低的未访问：然后，我们从未访问的节点中选择一个距离最近的节点。在第一次迭代中，这将是起始节点，因为其距离是0。 更新邻居节点的距离：查看所选节点的每个邻居。如果通过当前节点到达邻居节点的距离小于已知的最短距离，就更新邻居节点的最短距离。并记录下如何到这个邻居节点。 标记为已访问节点：当查看了一个节点的所有邻居并更新了其距离后，将这个节点标记为已访问。已访问的节点将不再被考虑。 重复：重复步骤2和3，直到所有可达的节点都被访问。 算法的关键在于每一次决策都做出了”贪心选择“，即只扩展代价值最小的节点，尽管着这种决策并非全局最优，但确实能够找到最小路径。 ==迪杰斯特拉算法只适用于权重非负的图，如果一个图中的某些边权重是负值，那可能找不到最短路径，这种情况就要使用Bellman-Ford或Floyd-Warshall== 代码伪代码123456789101112131415161718192021222324function Dijkstra(Graph, source): create vertex set Q for each vertex v in Graph: distance[v] ← INFINITY previous[v] ← UNDEFINED add v to Q distance[source] ← 0 while Q is not empty: u ← vertex in Q with min distance[u] remove u from Q for each neighbor of u: alt ← distance[u] + length(u, neighbor) if alt &lt; distance[neighbor]: distance[neighbor] ← alt previous[neighbor] ← u return distance[], previous[] Graph是一个图，其中包含了所有的节点和边的信息。 source是源节点，即从哪个节点开始计算。 distance[v]是从源节点到节点v的最短路径长度。 previous[v]是在最短路径上，节点v的前一个节点。 Q是一个集合，包含了所有待处理的节点。 u是当前正在处理的节点。 neighbor是u的邻居节点。 alt是从源节点到邻居节点的候选最短路径长度。 参考：贪心算法综述_贪心算法的优缺点-CSDN博客 Python代码1234567891011121314151617181920212223242526272829def dijkstra(graph, start, target): queue_from_start = [] heapq.heappush(queue_from_start, (0.0, start)) distances = {node: flaot(&quot;inf&quot;) for node in graph} parents_of_start = {start:None} close_of_start = set() distances[start] = 0.0 while queue_from_start: cur_dist, cur_node = heapq.heappop(queue_from_start) if cur_node is target: return traversal(target, parents_of_start) close_of_start.add(cur_node) for adjacent, weight in graph.items() if adjacent in close_of_start: continue dist_temp = distances[cur_node] + weight{&quot;weights&quot;} if dist_temp &lt; distances[adjacent]: distances[adjacent] = dist_temp parents_of_start[adjacent] = cur_node heapq.heappush(queue_from_start, (dist_temp, adjacent))def traversal(T,pred): path = [] while T is not None: path.append(T) T = pred[T] return path[::-1]","link":"/2023/11/09/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"},{"title":"配置icarus","text":"配置icarus步骤一：下载icarusgithub网址：[hexo-theme-icarus](ppoffice/hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo. (github.com)) 可以从这个网址上下载zip文件，解压后，重命名为icarus，并将这个文件夹放置到hexo的theme文件夹下面 也可以通过git命令获取 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 或者 1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 步骤二：修改_config.yml文件需要将_config.yml文件中的theme进行修改 1theme: icaurs 步骤三：使用shell命令，来配置主题在对应的文件夹下面，使用Git Bash Here打开shell窗口 1hexo config theme icarus 配置中可能会出现的错误（主要就是缺库）： 缺少semver 1Error: Cannot find module 'semver' 该错误是缺少’semver’库，使用npm命令安装即可 1npm install semver 缺少相应的依赖 12345678910ERROR Package bulma-stylus is not installed.ERROR Package hexo-component-inferno is not installed.ERROR Package hexo-pagination's version (3.0.0) does not satisfy the required version (^2.0.0).ERROR Package hexo-renderer-inferno is not installed.ERROR Package inferno is not installed.ERROR Package inferno-create-element is not installed.ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^2.0.2 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3ERROR or:ERROR yarn add bulma-stylus@0.8.0 hexo-component-inferno@^2.0.2 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 使用npm命令进行安装即可 1npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^2.0.2 hexo-pagination@^2.0.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 安装好这一切后，就可以进行相应的配置 icarus配置配置icarus，主要参考了以下的内容 Getting Started with icarus [icarus用户配置](Icarus用户指南 - 主题配置 - Icarus (ppoffice.github.io)) Hexo主题配置 搭建自己的技术博客系列（六）酷炫主题icarus常用配置整合版，快速搞定博客首页 - 知乎 (zhihu.com) 首先，要在hexo目录下的_config.yml目录进行修改，主要是对theme设置。 1theme: icarus 然后需要根据这个配置文件重新配置hexo，在git bash中输入 1hexo config theme icarus 命令执行后，可以发现会在_config.yml文件中生成一个 _config.icarus.yml 文件，这是icarus的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246# Version of the Icarus theme that is currently usedversion: 5.1.0 # Icarus的版本# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicon.svg# Additional HTML meta tags in an array.meta: # Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/hxx.jpg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # Navigation bar link settingsnavbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: 'https://github.com/h2pl/'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-dark # Show code copying button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Searchsearch: # Name of the search plugin type: insight# 评论插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Commentcomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin avatar: retro # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: 要不要说点啥... # Comment Box placeholder type: valine shortname: 黄小斜# 打赏功能# https://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/hxx.jpg' - # 微信 type: wechat # 二维码图片 qrcode: '/images/hxx.jpg'# 分享插件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Shareshare: # Share plugin name type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # right sidebar settings right: # 是否不随页面滚动 # https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# https://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # Widget name type: profile # Where should the widget be placed, left or right position: left # Author name to be shown in the profile widget author: 黄小斜 # Title of the author to be shown in the profile widget author_title: 蚂蚁金服Java工程师 # Author's current location to be shown in the profile widget location: 浙江 杭州 # Path or URL to the avatar to be shown in the profile widget avatar: /images/gzh.jpg # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: false # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/h2pl/' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/h2pl' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # Widget name type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: CSDN: 'https://blog.csdn.net/a724888' 知乎: 'https://www.zhihu.com/people/h2pl/activities' 简书: 'https://www.zhihu.com/people/h2pl/activities' - # Widget name type: category # Where should the widget be placed, left or right position: left - # Widget name type: tagcloud # Where should the widget be placed, left or right position: left - # Widget name type: recent_posts # Where should the widget be placed, left or right position: right - # Widget name type: archive # Where should the widget be placed, left or right position: right - # Widget name type: tag # Where should the widget be placed, left or right position: right# Other plugin settingsplugins: # Enable page animations animejs: true # Enable the lightGallery and Justified Gallery plugins # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/ gallery: true # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated-browser: true # Enable the MathJax plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/ mathjax: true # Show the back to top button on mobile devices back-to-top: true # Google Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics google-analytics: # Google Analytics tracking id tracking_id: # Baidu Analytics plugin settings # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics baidu-analytics: # Baidu Analytics tracking id tracking_id: 2289335dd443797b5867abbd156e7575 # Hotjar user feedback plugin # https://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar hotjar: # Hotjar site id site_id: # Show a loading progress bar at top of the page progressbar: true # BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: truebusuanzi: enable: true# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 page_pv_footer:providers: # Name or URL of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL of the webfont CDN provider fontcdn: google # Name or URL of the webfont Icon CDN provider iconcdn: fontawesome Hexo配置好后，使用命令进行更新，并在本地进行查看 12hexo ghexo s 当一切配置完成后，需要讲配置好的文件，传输到gitee上，并进行更新。 123hexo cleanhexo ghexo d 然后需要在gitee上进行更新，才能在gitee上看出来。 这样就可以完成icarus主题配置。","link":"/2023/11/06/%E9%85%8D%E7%BD%AEicarus/"},{"title":"Python多进程编程","text":"Python 多进程编程进程和线程： 进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位。 一个程序，包含一个或多个进程，一个进程包含一个或多个线程。 每个进程在执行过程中，拥有独立的内存单元，而线程再执行过程中，共享内存。 Python中，如果是计算密集型（耗费CPU）建议使用多进程方式，如果是IO密集型（读取操作多的）建议使用多线程。因为Python多线程在CPU上实际上是间断的工作，达不到并发的目的。 Python 多进程Python在Linux系统下实现多进程，可以调用fork()来实现。fork()函数是一个系统函数。调用一次，有两次返回，因为操作系统再调用该函数时，会自动把当前进程（父进程）复制一份（子进程），然后在父进程和子进程中都返回一次。子进程永远返回0，父进程返回子进程ID。并且父进程要记录下子进程的ID。 Linux下Python多进程： 123456789import osprint('Process (%s) start...' % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 上述代码在Windows系统中会报错 1234Traceback (most recent call last): File &quot;D:\\Project\\PycharmProjects\\PathPlanningAlgorithmTestFramework\\python_Thread_learn.py&quot;, line 36, in &lt;module&gt; pid = os.fork()AttributeError: module 'os' has no attribute 'fork' 因为windows系统函数中，没有fork()函数。 这可以看Procee的类中的初始化方式代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344if sys.platform != 'win32': class ForkProcess(process.BaseProcess): _start_method = 'fork' @staticmethod def _Popen(process_obj): from .popen_fork import Popen return Popen(process_obj) class SpawnProcess(process.BaseProcess): _start_method = 'spawn' @staticmethod def _Popen(process_obj): from .popen_spawn_posix import Popen return Popen(process_obj) class ForkServerProcess(process.BaseProcess): _start_method = 'forkserver' @staticmethod def _Popen(process_obj): from .popen_forkserver import Popen return Popen(process_obj) class ForkContext(BaseContext): _name = 'fork' Process = ForkProcess class SpawnContext(BaseContext): _name = 'spawn' Process = SpawnProcess class ForkServerContext(BaseContext): _name = 'forkserver' Process = ForkServerProcess def _check_available(self): if not reduction.HAVE_SEND_HANDLE: raise ValueError('forkserver start method not available') _concrete_contexts = { 'fork': ForkContext(), 'spawn': SpawnContext(), 'forkserver': ForkServerContext(), } _default_context = DefaultContext(_concrete_contexts['fork']) 如果不是win系统，就会调用fork()函数。 在Windows下，多进程编程 Python 提供了一个用于进程编程的库 （multiprocessing），利用该库可以在Windows系统下实现多进程编程。这个方式和windows下的多线程编程方法类似，都是利用一个类实现进程/线程对象。multiprocessing使用Process类来实现进程对象。该类的调用接口为： 12345# 调用multiprocessing库import multiproscessingProcess(target, name, args[, kwargs])# 其完全形式为：Process([group [, target [, name [, args [, kwargs]]]]]) 参数含义： group参数未使用，值始终为None target表示调用对象，即子进程要执行的任务 name为子进程的名称 args表示调用对象的位置参数元组，args=(1,2,’egon’,) kwargs表示调用对象的字典,kwargs={‘name’:’egon’,’age’:18} 需要记住的是，==函数初始化需要使用关键字的方式来指定参数。==，即 1Process(target=function_name, name=&quot;xx&quot;, args=(&quot;&quot;, ), kwargs={'xx':xx,}) Process类介绍介绍函数方法介绍 方法名 功能说明 用法 Process 创建进程 p=Porcess(target, name, args) start 启动进程 p.start() run 进程启动时运行的方法 p.run() join 主线程等待p终止 p.join(timeout=None) is_alive 判断线程是否仍然运行 p.is_alive terminate 强制终止进程 p.terminate() 属性介绍 属性名 属性说明 用法 daemon 守护进程 p.dameon name 进程名称，该名称必须是唯一的 p.name pid 进程ID p.pid exitcode 进程结束信号，进程在运行时为None，返回-N，表示被信号N结束 p.exitcode authkey 进程的身份验证键 p.authkey 实现多进程的两种方式实现多进程分为两种，一种是针对函数级的，也就是针对fuction实现多进程；另外一种是针对类的，就是对class实现多进程（通过继承来实现）。 Function级多进程编程Function级别多进程主要是调用Process模块，如上所述，Process模块在multiprocessing库中，Process本身也是一个类class。 123456789101112131415161718192021222324from multiprocessing import Processimport osimport timeimport randomdef task(name): print(&quot;Parent process is:&quot;, os.getppid()) print('Child process is %s (%s)...' % (name, os.getpid())) time.sleep(random.randrange(1,5)) print('%s task end' %name)if __name__=='__main__': print('Parent process %s.' % os.getpid()) p1 = Process(target=task, args=('test1',)) p2 = Process(target=task, args=('test2',)) p3 = Process(target=task, args=('test3',)) print('Child process will start.') p1.start() p2.start() p3.start() p1.join() p2.join() p3.join() print('Child process end.') 输出： 1234567891011121314Parent process 41380.Child process will start.Parent process is: 41380Child process is test2 (1504)...Parent process is: 41380Child process is test1 (29364)...Parent process is: 41380Child process is test3 (23944)...test2 task endtest1 task endtest3 task endChild process end.Process finished with exit code 0 进程池如果想启动大量子进程，可以使用进程池方式批量创建子进程。 1234567891011121314151617181920212223from multiprocessing import Poolimport osimport timeimport randomdef task(name): print(&quot;Parent process is:&quot;, os.getppid()) print('Child process is %s (%s)...' % (name, os.getpid())) sleep_time = random.randrange(1,5) print(&quot;%s process sleeps %0.2f seconds&quot; % (os.getpid(), sleep_time)) time.sleep(sleep_time) print('%s task end' %name) if __name__=='__main__': print('Parent process %s.' % os.getpid()) pool = Pool(3) for i in range(4): name_str = &quot;test&quot; + str(i) p.apply_async(task, args=(name_str,)) print('Waiting for all subprocesses done...') p.close() p.join() print('Child process end.') 输出： 1234567891011121314151617181920Parent process 29336.Waiting for all subprocesses done...Parent process is: 29336Child process is test2 (15304)...15304 process sleeps 2.00 secondsParent process is: 29336Child process is test0 (36088)...36088 process sleeps 2.00 secondsParent process is: 29336Child process is test1 (28392)...28392 process sleeps 1.00 secondstest1 task endParent process is: 29336Child process is test3 (28392)...28392 process sleeps 2.00 secondstest0 task endtest2 task endtest3 task endChild process end. 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 class级多进程编程12345678910111213141516171819class myProcess(Process): def __init__(self, name, counter): Process.__init__(self) self.name = name self.counter = counter def run(self): print (&quot;start process: %s, parent process is: %s&quot; %(self.name, os.getpid())) def __del__(self): print (self.name,&quot;线程结束！&quot;)if __name__ == '__main__': print('Parent process %s.' % os.getpid()) p1 = myProcess(&quot;test0&quot;, 12) p2 = myProcess(&quot;test1&quot;, 12) p3 = myProcess(&quot;test2&quot;, 12) p1.start() # start会自动调用run p2.start() p3.start() Python的类级多进程编程是继承于Process的。 12345678910Parent process 14688.start process: test0, parent process is: 23596start process: test1, parent process is: 23512start process: test2, parent process is: 11144test1 线程结束！test0 线程结束！test2 线程结束！test0 线程结束！test1 线程结束！test2 线程结束！ 由于Process的内存是隔离的，所以在处理数据时，需要进行通信，如果不进行通信就会造成一个问题， 1234567891011121314151617181920212223242526272829303132global listlist = [0, 0, 0, 0, 0, 0 ,0 ,0 ,0, 0, 0, 0]class myProcess(Process): def __init__(self, name, counter): Process.__init__(self) self.name = name self.counter = counter def run(self): print (&quot;start process: %s, parent process is: %s&quot; %(self.name, os.getpid())) print_time(self.name, 1, 12) def __del__(self): print (self.name,&quot;线程结束！&quot;)def print_time(process_name,delay,counter): while counter: time.sleep(delay) list[counter-1] += 1 print(&quot;[%s] %s 修改第 %d 个值，修改后值为:%d&quot; % (time.ctime(time.time()),process_name,counter,list[counter-1])) counter -= 1if __name__ == '__main__': print('Parent process %s.' % os.getpid()) print(list) p1 = myProcess(&quot;test0&quot;, 12) p2 = myProcess(&quot;test1&quot;, 12) p3 = myProcess(&quot;test2&quot;, 12) p1.start() # start会自动调用run p2.start() p3.start() print(list) 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Parent process 25080.[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]start process: test0, parent process is: 34052start process: test2, parent process is: 25640start process: test1, parent process is: 28816[Mon Dec 4 11:29:18 2023] test0 修改第 12 个值，修改后值为:1[Mon Dec 4 11:29:18 2023] test2 修改第 12 个值，修改后值为:1[Mon Dec 4 11:29:18 2023] test1 修改第 12 个值，修改后值为:1[Mon Dec 4 11:29:19 2023] test0 修改第 11 个值，修改后值为:1[Mon Dec 4 11:29:19 2023] test2 修改第 11 个值，修改后值为:1[Mon Dec 4 11:29:19 2023] test1 修改第 11 个值，修改后值为:1[Mon Dec 4 11:29:20 2023] test0 修改第 10 个值，修改后值为:1[Mon Dec 4 11:29:20 2023] test1 修改第 10 个值，修改后值为:1[Mon Dec 4 11:29:20 2023] test2 修改第 10 个值，修改后值为:1[Mon Dec 4 11:29:21 2023] test0 修改第 9 个值，修改后值为:1[Mon Dec 4 11:29:21 2023] test2 修改第 9 个值，修改后值为:1[Mon Dec 4 11:29:21 2023] test1 修改第 9 个值，修改后值为:1[Mon Dec 4 11:29:22 2023] test0 修改第 8 个值，修改后值为:1[Mon Dec 4 11:29:22 2023] test1 修改第 8 个值，修改后值为:1[Mon Dec 4 11:29:22 2023] test2 修改第 8 个值，修改后值为:1[Mon Dec 4 11:29:23 2023] test0 修改第 7 个值，修改后值为:1[Mon Dec 4 11:29:23 2023] test2 修改第 7 个值，修改后值为:1[Mon Dec 4 11:29:23 2023] test1 修改第 7 个值，修改后值为:1[Mon Dec 4 11:29:24 2023] test0 修改第 6 个值，修改后值为:1[Mon Dec 4 11:29:24 2023] test1 修改第 6 个值，修改后值为:1[Mon Dec 4 11:29:24 2023] test2 修改第 6 个值，修改后值为:1[Mon Dec 4 11:29:25 2023] test0 修改第 5 个值，修改后值为:1[Mon Dec 4 11:29:25 2023] test2 修改第 5 个值，修改后值为:1[Mon Dec 4 11:29:25 2023] test1 修改第 5 个值，修改后值为:1[Mon Dec 4 11:29:26 2023] test0 修改第 4 个值，修改后值为:1[Mon Dec 4 11:29:26 2023] test2 修改第 4 个值，修改后值为:1[Mon Dec 4 11:29:26 2023] test1 修改第 4 个值，修改后值为:1[Mon Dec 4 11:29:27 2023] test0 修改第 3 个值，修改后值为:1[Mon Dec 4 11:29:27 2023] test1 修改第 3 个值，修改后值为:1[Mon Dec 4 11:29:27 2023] test2 修改第 3 个值，修改后值为:1[Mon Dec 4 11:29:28 2023] test0 修改第 2 个值，修改后值为:1[Mon Dec 4 11:29:28 2023] test1 修改第 2 个值，修改后值为:1[Mon Dec 4 11:29:28 2023] test2 修改第 2 个值，修改后值为:1[Mon Dec 4 11:29:29 2023] test0 修改第 1 个值，修改后值为:1[Mon Dec 4 11:29:29 2023] test2 修改第 1 个值，修改后值为:1[Mon Dec 4 11:29:29 2023] test1 修改第 1 个值，修改后值为:1test0 线程结束！test2 线程结束！test1 线程结束！test0 线程结束！test1 线程结束！test2 线程结束！ 这个输出，和设想的并不一样，涉及到数据的进程之间需要进行良好的通信，才能实现自己的想法。 进程通信未完待续。","link":"/2023/12/04/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"title":"路径规划方向研究（四方向、八方向、十六方向等）","text":"路径规划 方向数量对算法效率的影响 四方向的位移序列： 1offsets = [(0, -1), (1, 0), (0, 1), (-1, 0)] 八方向的位移序列 1offsets = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0), (-1, 0), (-1, -1)] 十六方向的位移序列 12offsets = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0), (-1, 0), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2)] 三十二方向的位移序列 1234offsets = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0), (-1, 0), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -3), (2, -3), (3, -2), (3, -1), (3, 1), (3, 2), (2, 3), (1, 3), (-1, 3), (-2, 3), (-3, 2), (-3, 1), (-3, -1), (-3, -2), (-2, -3), (-1, -3)]","link":"/2023/12/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%96%B9%E5%90%91%E7%A0%94%E7%A9%B6%EF%BC%88%E5%9B%9B%E6%96%B9%E5%90%91%E3%80%81%E5%85%AB%E6%96%B9%E5%90%91%E3%80%81%E5%8D%81%E5%85%AD%E6%96%B9%E5%90%91%E7%AD%89%EF%BC%89/"},{"title":"PRIMAL项目踩坑记录","text":"PRIMAL项目，module ‘tensorflow’ has no attribute ‘variable_scope’，tf.placeholder() is not compatible with eager execution整个项目是基于tensorflow 1.x版本的。众所周知，tf 1.0 和 2.0 的兼容有点差。 AttributeError: module ‘tensorflow’ has no attribute ‘variable_scope’ 12345678Traceback (most recent call last): File &quot;primal_testing.py&quot;, line 133, in &lt;module&gt; primal=PRIMAL('model_primal',10) File &quot;primal_testing.py&quot;, line 25, in __init__ self.network=ACNet(&quot;global&quot;,5,None,False,grid_size,&quot;global&quot;) File &quot;/root/WorkSpace/PRIMAL/ACNet.py&quot;, line 23, in __init__ with tf.variable_scope(str(scope)+'/qvalues'):AttributeError: module 'tensorflow' has no attribute 'variable_scope' 解决方案：使用compat接口 1tf.compat.v1.variable_scope 类似的错误 12345AttributeError: module 'tensorflow' has no attribute 'variable_scope'AttributeError: module 'tensorflow' has no attribute 'Session'AttributeError: module 'tensorflow' has no attribute 'ConfigProto'AttributeError: module 'tensorflow' has no attribute 'GPUOptions'AttributeError: module 'tensorflow' has no attribute 'placeholder' tf.placeholder() is not compatible with eager execution.参考文章：TensorFlow报错：tf.placeholder() is not compatible with eager execution.，内容详细。 12345678910Traceback (most recent call last): File &quot;primal_testing.py&quot;, line 133, in &lt;module&gt; primal=PRIMAL('model_primal',10) File &quot;primal_testing.py&quot;, line 25, in __init__ self.network=ACNet(&quot;global&quot;,5,None,False,grid_size,&quot;global&quot;) File &quot;/root/WorkSpace/PRIMAL/ACNet.py&quot;, line 25, in __init__ self.inputs = tf.placeholder(shape=[None,4,GRID_SIZE,GRID_SIZE], dtype=tf.float32) File &quot;/root/miniconda3/envs/myconda/lib/python3.8/site-packages/tensorflow/python/ops/array_ops.py&quot;, line 3268, in placeholder raise RuntimeError(&quot;tf.placeholder() is not compatible with &quot;RuntimeError: tf.placeholder() is not compatible with eager execution. 解决方法： 在调用tf.placeholder()方法之前使用该语句。 1tf.compat.v1.disable_eager_execution() 即 12tf.compat.v1.disable_eager_execution()self.inputs = tf.placeholder(shape=[None,4,GRID_SIZE,GRID_SIZE], dtype=tf.float32) AttributeError: module ‘tensorflow.compat.v1’ has no attribute ‘contrib’这个问题最难解决： 原因是tensorflow1.x的contrib包被整合进了2.0的其他包里。 12import tensorflow.compat.v1 as tftf.disable_v2_behavior() 最基本的解决方法👆。 如果解决不了，就参考官方文档TensorFlow API Versions | TensorFlow v2.14.0 (google.cn)。 查看自己当前的环境的tensorflow版本的api，然后查看项目的tensorflow版本api，两个对照以后进行修改。 D:\\Project\\PycharmProjects\\PRIMAL\\od_mstar3\\mstar_type_defs.hpp(8): fatal error C1083: 无法打开包括文件: “boost/graph/graph_traits.hpp”: No such file or directory该项目要编译一个python的C++扩展模块，然后在CPP文件中，调用boost库中的一些文件。 当然这还涉及一些东西，python setup.py的知识，这一次仅用到构建C++扩展。 123456setup(ext_modules = cythonize(Extension( &quot;cpp_mstar&quot;, sources=[&quot;cython_od_mstar.pyx&quot;], extra_compile_args=[&quot;-std=c++11&quot;] ))) 该项目中，源码是👆的，在项目中的一个CPP文件中，包含了&lt;boost/graph/graph_traits.hpp&gt;头文件，并且我也安装了boost库，库中也有这个头文件，还是找不到。猜测可能是路径错误，即，没有向编译文件中说明boost库所在位置。 参考了python文档：4. 构建C/C++扩展 — Python 3.11.7 說明文件和fatal error C1083: 无法打开包括文件: “boost/shared_ptr.hpp”: N o such file or directory_有包含文件,但是还是出现fatal error: boost/archive/text_oarchi-CSDN博客 发现官方文档上，扩展库的构建中，包括include_dirs等参数 1234567module1 = Extension('demo', define_macros = [('MAJOR_VERSION', '1'), ('MINOR_VERSION', '0')], include_dirs = ['/usr/local/include'], libraries = ['tcl83'], library_dirs = ['/usr/local/lib'], sources = ['demo.c']) 表明需要写明扩展。 123456setup(ext_modules = cythonize(Extension( &quot;cpp_mstar&quot;, include_dirs = [r'D:\\Tool\\boost_1_81_0'], sources=[&quot;cython_od_mstar.pyx&quot;], extra_compile_args=[&quot;-std=c++11&quot;] ))) 所以在上述代码中增加了include_dirs = [r'D:\\Tool\\boost_1_81_0'],，指明需要包含的库的路径。问题得到解决。 ==windows下编译这些项目，即使把这些需要的库地址写入到系统环境变量中，在编译的时候也是没有办法找到的，但是在Linux下编译，是可以的。== error C2065: “uint”: 未声明的标识符windows下会报的错误，我在Ubuntu中编译这个项目，说实话还是容易的。 1234#include &lt;wtypes.h&gt;#include &lt;stdint.h&gt;#define ulong ULONG #define uint UINT windows下boost安装有exe安装，编译安装。 不适用PCL点云库，建议直接exe安装，主要是简单。 网站下载exe文件。Boost C++ Libraries - Browse /boost-binaries at SourceForge.net，我下载的是1.83.0的exe文件；下载好后，放置到自己工作空间的文件夹下，然后双击exe文件开始安装。 配置环境变量：（不要忘） 配置 BOOST_INCLUDEDIR 和 BOOST_LIBRARYDIR和 PATH 中添加 , 12BOOST_INCLUDEDIR=&quot;D:\\Tool\\boost_1_81_0&quot; # 自己boost的安装目录BOOST_LIBRARYDIR=D:\\Tool\\boost_1_81_0\\lib64-msvc-14.3 编译的方式可以参考：Windows VS2019编译Boost库学习记录-CSDN博客 编译方式，文件的下载地址为：Boost Downloads","link":"/2023/12/05/PRIMAL%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"Markdown 公式书写","text":"Markdown 公式书写公式风格Markdown公式方面主要是用的Latex数学公式的写法（也是不完全相同，比Latax少了一些内容）。 Latex数学公式主要有两种，一种是行内公式（公式与文字相连，并被包裹），一种是行间公式（公式单独成行），例如$c^2 = a^2 + b^2$就是行间公式，而：$$\\begin{aligned}c^2=a^2 + b^2\\end{aligned}$$就是行间公式。$$\\begin{equation}c^2 = a^2 + b^2\\end{equation}$$可以看到两种行间公式，一种是无编号行间公式，一种是有编号行间公式。 12345678910111213141516行内公式使用$...$方式书写，如$c^2 = a^2 + b^2$无编号行间公式$$\\begin{aligned}...\\end{aligned}$$有编号公式：$$\\begin{equation}\\end{equation}$$或者$$...$$ 上下标以及希腊字母上一段中可以看到公式是有上标的，即$c^2$，同样一个式子也可以有下标$c_i$。 Latex中使用“^+{…}”符号表示上标，并使用“__{…}”表示下标。具体来说： 12$c^2 = a^2 + b^2$$C_i$ 记住“^”和“__”只对其后面的一个单位产生效果，所以什么是一个单位对象？a是一个单位对象，2也是一个单位对象，{2222}也是一个单位对象。例如，对于一个 3x3 矩阵的第一个矩阵元素来说，其下标写法应该是 1$a_{11}$而不是$a_11$ 效果：$a_{11}$、$a_11$，这两个是完全不同的。同理对于上标符号也是一样的。==一个良好的习惯（个人建议）是：尽量加{}，尽管这样编辑公式的时候可能看起来很长，且复杂，但是在显示的时候效果一样，而且不会出错，项与项之间最好也空一格。== 123$$a_{11}^{2} = a_{12}^2 + a_{13}^2$$ $$a_{11}^{2} = a_{12}^2 + a_{13}^2$$ 上述式子也展示了，多个符号一同使用的效果，实际上，“^”和“__”对于同一对象并不强调使用顺序： 123$$a^{2}_{11} = a^2_{12} + a^2_{13}$$ $$a^{2}{11} = a^2{12} + a^2_{13}$$ $$ $$ 希腊字母表： 符号 代码 符号 代码 符号 代码 $\\alpha$ \\alpha $\\lambda$ \\lambda $\\phi$ \\phi $\\beta$ \\beta $\\mu$ \\mu $\\chi$ \\chi $\\gamma$ \\gamma $\\nu$ \\nu $\\psi$ \\psi $\\delta$ \\delta $\\xi$ \\xi $\\omega$ \\omega $\\epsilon$ \\epsilon $\\omicron$ \\omicron $\\zeta$ \\zeta $\\pi$ \\pi $\\eta$ \\eta $\\rho$ \\rho $\\theta$ \\theta $\\sigma$ \\sigma $\\iota$ \\iota $\\tau$ \\tau $\\kappa$ \\kappa $\\upsilon$ \\upsilon 上述代码均是希腊字母小写，当把每一个代码的第一个字母大写后，就会得到它们的大写方式 符号 代码 符号 代码 符号 代码 $\\Alpha$ \\Alpha $\\Lambda$ \\Lambda $\\Phi$ \\Phi $\\Beta$ \\Beta $\\Mu$ \\Mu $\\Chi$ \\Chi $\\Gamma$ \\Gamma $\\Nu$ \\Nu $\\Psi$ \\Psi $\\Delta$ \\Delta $\\Xi$ \\Xi $\\Omega$ \\Omega $\\Epsilon$ \\Epsilon $\\Omicron$ \\Omicron $\\Zeta$ \\Zeta $\\Pi$ \\Pi $\\Eta$ \\Eta $\\Rho$ \\Rho $\\Theta$ \\Theta $\\Sigma$ \\Sigma $\\Iota$ \\Iota $\\Tau$ \\Tau $\\Kappa$ \\Kappa $\\Upsilon$ \\Upsilon 也存在希腊字母的变量写法 符号 代码 符号 代码 $\\varepsilon$ \\varepsilon $\\varGamma$ \\varGamma $\\vartheta$ \\vartheta $\\varDelta$ \\varDelta $\\varkappa$ \\varkappa $\\varTheta$ \\varTheta $\\varpi$ \\varpi $\\varLambda$ \\varLambda $\\varrho$ \\varrho $\\varXi$ \\varXi $\\varsigma$ \\varsigma $\\varPi$ \\varPi $\\varphi$ \\varphi $\\varSigma$ \\varSigma $\\varUpsilon$ \\varUpsilon $\\varPhi$ \\varPhi $\\varPsi$ \\varPsi $\\varOmega$ \\varOmega 分式根式等结构 符号 代码 符号 代码 符号 代码 $\\frac{abc}{xyz}$ \\frac{abc}{xyz} $\\overline{abc}$ \\overline{abc} $\\overrightarrow{abc}$ \\overrightarrow{abc} $\\sqrt{abc}$ \\sqrt{abc} $\\underline{abc}$ \\underline{abc} $\\overleftarrow{abc}$ \\overleftarrow{abc} $\\sqrt[n]{abc}$ \\sqrt[n]{abc} $\\widehat{abc}$ \\widehat{abc} $\\overleftrightarrow{abc}$ \\overleftrightarrow{abc} $a/b$ / $\\widetilde{abc}$ \\widetilde{abc} $\\underrightarrow{abc}$ \\underrightarrow{abc} $\\mid_{3}^{2}$ \\mid_{3}^{2} $\\overbrace{abc}$ \\overbrace{abc} $\\underleftarrow{abc}$ \\underleftarrow{abc} $\\mathop{lim} \\limits_{n \\to \\infty}$ \\mathop{lim} \\limits_{n \\to \\infty}（极限符号） $\\underbrace{abc}$ \\underbrace{abc} $\\underleftrightarrow{abc}$ \\underleftrightarrow{abc} 函数名 符号 代码 符号 代码 符号 代码 符号 代码 $\\arccos$ \\arccos $\\arcsin$ \\arcsin $\\arctan$ \\arctan $\\arg$ \\arg $\\cos$ \\cos $\\cos$ \\cos $\\cot$ \\cot $\\inf$ \\inf $\\csc$ \\csc $\\deg$ \\deg $\\det$ \\det $\\dim$ \\dim $\\exp$ \\exp $\\gcd$ \\gcd $\\hom$ \\hom $\\max$ \\max $\\ker$ \\ker $\\lg$ \\lg $\\lim$ \\lim $\\limsup$ \\limsup $\\ln$ \\ln $\\log$ \\log $\\min$ \\min $\\Pr$ \\Pr $\\sec$ \\sec $\\sin$ \\sin $\\sup$ \\sup $\\tan$ \\tan 运算符参考：Markdown 数学符号大全_markdown数学符号-CSDN博客 符号 代码 符号 代码 符号 代码 符号 代码 $+$ + $=$ = $&lt;$ &lt; $\\ast$ \\ast $-$ - $\\simeq$ \\simeq $&gt;$ &gt; $\\star$ \\star $\\times$ \\times $\\cong$ \\cong $\\leqslant$ \\leqslant or \\leq $\\circ$ \\circ $\\div$ \\div $\\sim $ \\sim $\\geqslant$ \\geqslant or \\geq $\\bullet$ \\bullet $\\cdot$ \\cdot $\\approx $ \\approx $\\ll$ \\ll $\\bigcirc$ \\bigcirc $\\pm$ \\pm $\\doteq $ \\doteq $\\gg$ \\gg $\\diamond$ \\diamond $\\mp$ \\mp $\\equiv $ \\equiv $\\prec$ \\prec $\\circledast$ \\circledast $\\centerdot$ \\centerdot $\\not =$ \\not = $\\succ$ \\succ $\\circledcirc$ \\circledcirc $\\divideontimes$ \\divideontimes $\\ne$ \\neq $\\propto$ \\propto $\\circleddash$ \\circleddash $\\amalg$ \\amalg $\\triangleq$ \\triangleq $\\cap$ \\cap $\\lhd$ \\lhd $\\odot$ \\odot $\\models$ \\models $\\cup$ \\cup $\\rhd$ \\rhd $\\ominus$ \\ominus $\\approxeq$ \\approxeq $\\subseteqq$ \\subseteqq $\\triangleleft$ \\triangleleft $\\oplus$ \\oplus $\\backsimeq$ \\backsimeq $\\supseteqq$ \\supseteqq $\\triangleright$ \\triangleright $\\otimes$ \\otimes $\\doteqdot$ \\doteqdot $\\Supset$ \\Supset $\\unlhd$ \\unlhd $\\Box$ \\Box $\\fallingdotseq$ \\fallingdotseq $\\supset$ \\supset $\\unrhd$ \\unrhd $\\risingdotseq$ \\risingdotseq $\\supseteq$ \\supseteq $\\bigtriangledown$ \\bigtriangledown $\\leqq$ \\leqq $\\in$ \\in $\\bigtriangleup$ \\bigtriangleup $\\lessapprox$ \\lessapprox $\\ni$ \\ni $\\perp$ \\perp $\\lll$ \\lll $\\notin$ \\notin $\\parallel$ \\parallel $\\geqq$ \\geqq $\\nsubseteq$ \\nsubseteq $\\Join$ \\Join $\\geqslant$ \\geqslant $\\nsupseteq$ \\nsupseteq $\\ltimes$ \\ltimes $\\gtrapprox$ \\gtrapprox $\\nsubseteqq$ \\nsubseteqq $\\blacktriangleleft$ \\blacktriangleleft $\\ggg$ \\ggg $\\nsupseteqq$ \\nsupseteqq $\\blacktriangleright$ \\blacktriangleright 符号 代码 符号 代码 符号 代码 符号 代码 $\\infty$ \\infty $\\forall$ \\forall $\\cdots$ \\cdots $\\angle$ \\angle $\\therefore$ \\therefore $\\exists$ \\exists $\\vdots$ \\vdots $\\measuredangle$ \\measuredangle $\\because$ \\because $\\nexists$ \\nexists $\\ldots$ \\ldots $\\sphericalangle$ \\sphericalangle $\\nabla$ \\nabla $\\empty \\emptyset$ \\empty or \\emptyset $\\ddots$ \\ddots $\\int$ \\int $\\bigstar$ \\bigstar $\\clubsuit$ \\clubsuit $\\oint$ \\oint 矩阵写法$$\\left[\\begin{matrix}1 &amp; 2 \\3 &amp; 4 \\\\end{matrix}\\right]$$ 123456789$$\\left[ \\begin{matrix}1 &amp; 2 \\\\3 &amp; 4 \\\\\\end{matrix} \\right]\\tag{4}$$ 语法解释：{matrix} 矩阵标签值，一个标签必须有开始和结束， &amp; 对齐空格符， \\\\表示换行符。\\tag{4}表示公式标号。 123456789$$\\left\\{\\begin{matrix}1 &amp; 2 &amp; 3\\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9\\end{matrix}\\right\\}\\tag{4}$$ $$\\left{\\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\\end{matrix}\\right}\\tag{4}$$ 12345678910$$\\left[ \\begin{array}{c|cc} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{array}\\right]$$ $$\\left[ \\begin{array}{c|cc} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{array}\\right]$$ 1234567\\left[ \\begin{array}{l} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{array}\\right] $$\\left[ \\begin{array}{l} 1 &amp; 2 &amp; 3 \\ \\hline 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{array}\\right]$$ 行列式写法$$\\left|\\begin{matrix}1 &amp; 2 \\3 &amp; 4 \\\\end{matrix}\\right|$$ 12345678910111213141516$$\\left|\\begin{matrix}1 &amp; 2 \\\\3 &amp; 4 \\\\\\end{matrix} \\right|$$$$\\left(\\begin{matrix}1 &amp; 2 \\\\3 &amp; 4 \\\\\\end{matrix} \\right)$$ 多行公式$$\\begin{cases}a = 1 \\b = 2 \\cc = 3 \\\\end{cases}$$ 1234567$$\\begin{cases}a = 1 \\\\b = 2 \\\\cc = 3 \\\\\\end{cases}$$ 如果希望等号可以对齐，则$$\\begin{cases}a &amp;=&amp; 1 \\b &amp;=&amp; 2 \\cc &amp;=&amp; 3 \\\\end{cases}$$ 不需要括号括起来的多行式子$$\\begin{array}{l}a = 1 \\b = 2 \\\\end{array}$$ 123456$$\\begin{array}{l}a = 1 \\\\b = 2 \\\\\\end{array}$$ 右大括号$$\\left.\\begin{array}{l}a = 1 \\b = 2 \\\\end{array}\\right }$$ 12345678$$\\left. \\begin{array}{l}a = 1 \\\\b = 2 \\\\\\end{array}\\right \\}$$ 空格 符号 代码 说明 $123~123$ 123~123 空格距离：3/18 em $123\\quad123$ 123\\quad123 空格距离：1 em $123\\qquad123$ 123\\qquad123 空格距离：2 em 上表中的em是指当前文本中文本的字体尺寸 数学字母样式1$\\mathcal{A}$ $\\mathcal{A}$、$\\mathcal{B}$ 1$\\mathbb{A}$ $\\mathbb{A}$、$\\mathbb{B}$ 1$\\mathbf{A}$ $\\mathbf{A}$、$\\mathbf{B}$ 1$\\mathfrak{A}$ $\\mathfrak{A}$、 $\\mathfrak{B}$ 1$\\mathsf{A}$ $\\mathsf{A}$、$\\mathsf{B}$","link":"/2023/12/06/Markdown-%E5%85%AC%E5%BC%8F%E4%B9%A6%E5%86%99/"},{"title":"Overview of Multi-Agent Path Finding","text":"Overview of Multi-Agent Path Finding (MAPF) 翻译作者：Wolfgang Hönig,∗ Jiaoyang Li, Sven Koenig — University of Southern California 1 Introduction 多智能体路径搜索（MAPF）对于包括自动化仓储在内的许多应用都非常重要。例如，亚马逊订单执行中心（图 1）在仓库周边设有库存站（图中仅左侧显示），中心设有存储点。每个存储点可以存储一个库存舱。每个库存舱可存放一种或多种货物。大量仓库机器人在仓库中自主运行。每个仓库机器人一次可以拾取、搬运和放下一个库存吊舱。仓库机器人将库存吊舱从其存储位置移动到库存站，从库存吊舱中取出所需的货物（装箱并最终运送给客户），然后返回相同或不同的空存储位置，将库存吊舱归还[8]。亚马逊在其订单执行中心的地板上贴上贴纸，以划定栅格，实现机器人的稳健导航。然而，机器人的路径规划非常棘手，因为大部分仓库空间都用于存储位置，导致走廊狭窄，运载库存吊舱的机器人无法相互通过。准时化生产是自动化仓储的延伸，但迄今为止还没有商业安装。在准时化生产中，仓库的四周都是生产设备，而不是库存站。机器人在仓库和制造机器之间来回穿梭，一个方向运送原材料，另一个方向运送制成品。准时制生产增加了将所有所需原材料几乎同时运送到生产设备的重要性。MAPF 问题是这些问题和许多其他多机器人或多智能体路径规划问题的简化版本，可描述如下： 在数字地图，一些单元被堵塞。所有阻塞单元的位置和数量已知，并且当前所有智能体的位置和数量也是已知的。为每个智能体分配一个不同的未堵塞单元作为其目标单元。问题是在离散的时间步长内，将智能体从当前单元移动到各自的目标单元，并让它们在那里等待。优化目标是最大限度地减少智能体的移动时间总和，直到它们到达目标小区（并能永远停留在那里）。在每个时间步长内，每个智能体可以在当前小区等待，也可以从当前小区向四个主要罗盘方向之一的未受阻邻近小区移动。一个智能体的路径是一系列移动和等待动作，这些动作将智能体从它的起始单元引向它的目标单元，或者，等同于它在每个时间步（从时间步 0 开始）执行这些动作时的单元序列。路径的长度就是智能体到达目标单元（之后永远停留在那里）之前的行进时间。一个解决方案由 n 条路径组成，每个智能体有一条路径。其成本是所有路径长度的总和。不允许智能体与环境或彼此发生碰撞。只有当且仅当两个智能体在同一时间步都位于同一单元时，它们才会发生碰撞（称为顶点碰撞或同义词顶点冲突），或者在同一时间步都移动到另一个智能体的当前单元时，它们才会发生碰撞（称为边碰撞或同义词边冲突）。(当另一智能体从 y 单元移动到与 x 和 y 单元不同的单元时，允许该智能体在同一时间步从其当前单元 x 移动到另一智能体的当前单元 y）。寻找无碰撞的最优解是 NP 难的 [9]。 2 MAPF Example图 2：我们的 MAPF 实例。圆圈代表起始单元。正方形代表目标单元。图 2 显示了一个有两个智能体的 MAPF 实例，其中智能体 1 需要从当前单元 A 导航到目标单元 E，而智能体 2 需要从当前单元 B 导航到目标单元 D。其中一个最优无碰撞解（代价为 5）由智能体 1 的路径 [A, C, E]（长度为 2）和智能体 2 的路径 [B, B, C, D]（长度为 3）组成。另一个最优无碰撞解（成本也是 5）由智能体 1 的路径 [A, A, C, E]（长度为 3）和智能体 2 的路径 [B, B, C, D]（长度为 2）组成。 3 Planning in Joint Location Space图 3：我们的 MAPF 实例的联合位置空间，其中包含 20 个顶点和 36 条边。每个圆形顶点中的两个字母分别代表智能体 1 和 2 的单元。红圈和红线代表最优解，即智能体 1 的路径 [A、A、C、E]（长度为 3）和智能体 2 的路径 [B、C、D]（长度为 2）。理论上，我们可以通过为所有智能体同时规划联合位置空间来找到 MAPF 实例的最佳无碰撞解决方案，方法是在一个图上找到一条最短路径，该图的顶点与单元元组相对应，即每个智能体有一个单元元组。图 3 显示了 MAPF 实例的图。然而，图的顶点数随智能体的数量呈指数增长，这使得这种搜索算法在实际应用中速度太慢。因此，我们需要开发能更好地利用问题结构的搜索算法，以提高效率。我们现在讨论两种这样的搜索算法，即优先规划和基于冲突的搜索。 4 Prioritized Planning优先级规划 [1] 通过为每个智能体分配不同的优先级，对智能体进行完全排序。然后，它按照优先级递减的顺序，一个接一个地为智能体规划路径。它为每个智能体找到一条不会与环境或所有优先级更高的智能体的（已规划的）路径相撞的路径（可以快速完成）。优先级规划虽然速度快，但却是次优的（也就是说，它并不总是能找到最优的无碰撞解决方案），甚至是不完整的（也就是说，即使存在无碰撞解决方案，它也并不总是能找到）。如果它找到了一个解，那么这个解是无碰撞的，但解的代价在很大程度上取决于智能体的优先级。关于优先级规划的更多信息，请参阅 [3]。考虑我们的 MAPF 实例，假设智能体 1 的优先级高于智能体 2。那么，优先级规划首先为智能体 1 找到最短路径 [A、C、E]（长度为 2），之后为智能体 2 找到不与智能体 1 的路径相撞的最短路径 [B、B、C、D]（长度为 3）（结果是成本为 5 的无碰撞解）。 图 4：在我们的 MAPF 实例中，如果智能体 1 的优先级高于智能体 2，且智能体 1 的路径为 [A，C，E]，则智能体 2 的时空 A* 搜索树。每个椭圆形节点中的一对代表一个单元和一个时间步长。节点的 f 值是其 g 值（等于时间步长）和 h 值（等于其单元到环境中目标单元 D 的距离）之和。节点 (C,1) 被剪枝是因为智能体 1 在时间步长 1 时占据了单元格 C，而智能体 2 必须防止与智能体 1 发生顶点碰撞。红色节点和边代表智能体 2 的最优解，即路径 [B, B, C, D]。 优先规划使用时空 A* [7] 为每个智能体规划路径。顶点（x, t）与顶点（x, t + 1）之间有一条有向边，条件是且仅当智能体在时间步长为 t 时可以在单元 x 处等待。可以从时间步长 t 到时间步长 t + 1 从单元 x 移动到单元 y 6= x。图 4 显示了在我们的 MAPF 实例中，智能体 2 的时空 A* 搜索树。 5 Conflict-Based Search基于冲突的搜索（CBS）[5, 6]首先为所有智能体独立规划最短路径（可以快速完成）。这些路径不会与环境发生碰撞，但允许与其他智能体的路径发生碰撞。如果这样做的结果是无碰撞解，那么它就找到了最佳无碰撞解。否则，它就会选择两个智能体之间的碰撞（例如，智能体 a 和 b 在时间步长 t 时都在 x 小区），并递归考虑两种情况，即一种是（负）约束条件禁止智能体 a 在时间步长 t 时出现在 x 小区，另一种是（负）约束条件禁止智能体 b 在时间步长 t 时出现在 x 小区。希望 CBS 在施加完所有可能的约束条件之前，就能找到无碰撞解。CBS 的速度比优先规划慢，但完整且最优。CBS 是一种两级搜索算法。下面我们将详细介绍它的运行过程。 高层 CBS 搜索二叉约束树。约束树的每个节点 N 包含 (1) 对智能体施加的一组约束，其中对智能体 a 施加的约束要么是（负）顶点约束〈a，x，t〉，即禁止智能体 a 在时间步长为 t 时出现在单元 x 中，要么是（负）边约束〈a，x，y，t〉，即禁止智能体 a 在时间步长为 t 时从单元 x 移动到单元 y； (2) 满足所有约束条件但不一定无碰撞的解决方案；以及 (3) 解决方案的成本。约束树的根节点包含一组空约束和一个由 n 条最短路径组成的解。高层对约束树执行最佳优先搜索，总是选择约束树中代价最小的边缘节点进行下一步扩展。如果节点之间的路径碰撞较少，则会打破平局，优先选择该节点CBS 选择节点 N 进行扩展后，会检查节点 N 的解是否无碰撞。如果是，那么节点 N 就是目标节点，CBS 会返回它的解。否则，CBS 会选择其中一个碰撞节点，并通过拆分节点 N 来解决它。假设 CBS 选择解决一个顶点碰撞，在该碰撞中，智能体 a 和 b 在时间步长 t 时都在单元 x 中。在任何无碰撞解中，最多有一个智能体在时间步长 t 时在单元 x 中。因此，必须满足至少一个约束条件〈a，x，t〉（禁止智能体 a 在时间步骤 t 出现在单元格 x 中）或〈b，x，t〉（禁止智能体 b 在时间步骤 t 出现在单元格 x 中）。因此，CBS 通过生成节点 N 的两个子节点来拆分节点 N，每个子节点都有一个约束集，将这两个约束中的一个添加到节点 N 的约束集中。现在假设 CBS 选择解决边缘碰撞，即在时间步长 t 时，智能体 a 从单元 x 移动到单元 y，智能体 b 从单元 y 移动到单元 x。那么，新增的两个约束条件就是两条边约束条件〈a，x，y，t〉（禁止智能体 a 在时间步长 t 时从单元 x 移动到单元 y）和〈b，y，x，t〉（禁止智能体 b 在时间步长 t 时从单元 y 移动到单元 x）。对于每个子节点，CBS 的低层都会根据新施加的约束条件为智能体找到一条新的最短路径，这可以通过时空 A* 快速完成（如前所述，在 [6] 中也有解释）。例如，顶点约束只是修剪搜索树中的一个特定节点。这条路径不会与环境发生碰撞，必须遵守子节点中对智能体施加的所有约束，但允许与其他智能体的路径发生碰撞。请看我们的 MAPF 实例。图 5 显示了相应的约束树。其根节点 N 包含空约束集，低级 CBS 为智能体 1 找到最短路径 [A、C、E]（长度为 2），为智能体 2 找到最短路径 [B、C、D]（长度为 2）。因此，节点 N 的成本为 2 + 2 = 4。节点 N 的解有一个顶点碰撞，即智能体 1 和 2 在时间步骤 1 时都在单元 C 中。因此，CBS 拆分了节点 N。节点 N 的新左子节点 N1 增加了约束条件〈1, C, 1〉。低级 CBS 在节点 N1 中为智能体 1 找到了长度为 3 的新的最短路径 [A，A，C，E]（其中包括一个等待动作），而智能体 2 的最短路径与节点 N 的路径完全相同，因为没有对智能体 2 施加新的约束。因此，节点 N1 的成本为 3 + 2 = 5。同样，节点 N 的新右子节点 N2 增加了约束条件〈2, C, 1〉。低级 CBS 在节点 N2 中为智能体 2 找到了长度为 3 的新最短路径 [B, B, C, D]（其中包括一个等待动作），而智能体 1 的最短路径与节点 N 的路径完全相同，因为没有对智能体 1 施加新的约束条件。因此，节点 N2 的成本为 2 + 3 = 5。现在，CBS 高层的最佳优先搜索选择约束树中成本最小的边缘节点进行下一步扩展。假设它打破了节点 N1 和 N2 之间的平局，选择了节点 N1。由于节点 N1 的解是无碰撞的，因此它是目标节点，CBS 返回其无碰撞解（代价为 5），该解由智能体 1 的路径 [A, A, C, E]（长度为 3）和智能体 2 的路径 [B, C, D]（长度为 2）组成。 6 Additional InformationAdditional information on the MAPF problem and solution approaches can be found at http: //mapf.info, a website that contains tutorials, publications, data sets, and additional software for MAPF. 记录Just-in-time manufacturing：实时生产，实时加工 什么是实时生产？它是自动化仓储物流的一个延申，目前还没有商业实施。实时生产的场景：在一个仓库基地，原材料统一放置在仓库中，实时生产的机器就放置在货架的外围，自动化的机器人可以从货架上取出所需原材料，然后运送到生产机器上，生产机器进行加工包装，完成生产。该问题的实时性在于，原材料被取下后，能同时送到加工机器上。 多智能体路径规划定义：在一个栅格地图中，某些格子处于阻塞状态，并且，地图中阻塞格子和智能体的数量均是已知的，所有处于未被阻塞状态的格子均可以作为通行格，来分配给智能体，成为智能体由起始状态通向目标状态的路径的一部分，即 如果$cell_i$可通行，那么$cell_i$可以是智能体$Agent_i$的路径$path_i$的一部分。也即 $path_i = [cell_i, cell_{i+1},…, cell_{i+x}]$。多智能体路径规划的解则是$n$条路径$solution = [path_1, path_2, …, path_n]$，每个智能体都有自己的一条路径$path_i$。每个智能体不能产生碰撞，即智能体与智能体之间，智能体与障碍物都不会发生碰撞。$path_i(t) \\cap path_i(t) \\cap …\\cap path_n(t) = \\empty$ $num_blocked_cell$ MAPF问题的优化目标包括所有Agent的运行时间总和、路径距离总和等。在每个时间步中，每个智能体的状态转移包括：移动和原地等待。 什么是联合位置空间规划？ 理论可行，并且能够实现同时性。人们可以在联合位置空间上同时为所有的智能体规划出一条无碰撞最优路径。 联合位置空间图 联合位置空间图，由顶点和边组合，顶点是所有智能体当前所在网格组成的元组，边则表示可行的转移规则，即如果所有智能体可以由当前状态转移到另一个状态，则两个顶点之间存在一条边。 什么是优先级规划？ 为智能体设置一个优先级（次序），按照这个优先级来进行路径规划。优先级规划可以为每一个智能体一个接一个的规划出一个无碰撞路径（智能体与智能体之间，智能体与障碍物之间）。 优点：相对较快。 缺点： 路径是次优（并不总是能找到最优无碰撞解） 不完整性（即使存在最优无碰撞解，也不总是可以找到该解） 以上图为例，对智能体1设置一个更高的优先级，智能体2的优先级低于智能体1，那么优先级算法就会先给智能体构建一个路径[A, C, E]，随后智能体2进行搜索。 什么是基于冲突的搜索？基于冲突的搜索，首先为每个智能体规划出一条路径（这些路径不会与环境发生碰撞，但是可能会与其他智能体发生碰撞），规划好后，如果路径不存在冲突，则已经找到最优吴鹏路径，否则，解决冲突。","link":"/2023/12/06/Overview-of-Multi-Agent-Path-Finding/"},{"title":"Windows下boost安装","text":"Windows下boost库安装Boost库 Boost是一个功能强大、构造精巧、跨平台、开源并且完全免费的C++程序库，在1998年由Beman G.Dawes发起倡议并建立。使用了许多现代C++编程技术，内容涵盖字符串处理、正则表达式、容器与数据结构、并发编程、函数式编程、泛型编程、设计模式实现等许多领域，极大地丰富了C++的功能和表现力，能够使C++软件开发更加简洁、优雅、灵活和高效 在这里提前放一个Visual studio版本号 MSVC版本的对应表，后面可能用到 IDE 发布时间 工具集版本 MSC_VER MSVC++ Visual C++6.0 1998 V60 1200 MSVC++ 6.0 Visual Studio 2002 2002 V70 1300 MSVC++ 7.0 Visual Studio 2003 2003 V71 1310 MSVC++ 7.1 Visual Studio 2005 2005 V80 1400 MSVC++ 8.0 Visual Studio 2008 2008 V90 1500 MSVC++ 9.0 Visual Studio 2010 2010 V100 1600 MSVC++ 10.0 Visual Studio 2012 2012 V110 1700 MSVC++ 11.0 Visual Studio 2013 2013 V120 1800 MSVC++ 12.0 Visual Studio 2015 2015 V140 1900 MSVC++ 14.0 Visual Studio 2017 2017 V141 1910 MSVC++ 14.1 Visual Studio 2019 2019 V142 1920 MSVC++ 14.2 Visual Studio 2022 2022 V143 1930 MSVC++ 14.3 Boost库下载地址： Boost C++ Libraries - Browse /boost-binaries at SourceForge.net msvc版本应该与自己的visual studio的版本相对应，比如说我的visual studio版本是2022，我会下载msvc 14.3的.exe文件。 Linux系统下安装也可以自己下载编译：Boost C++ Libraries - Browse Files at SourceForge.net 我在Linux系统下是这么做得，下载一个版本的tar文件，在Ubuntu系统下解压安装。 解压命令 1tar -xzvf boost*.tar.gz 编译安装，–prefix 表示安装到/usr目录下。 123cd boost_1_80_0/./bootstrap.sh --with-libraries=all --with-toolset=gcc./b2 install --prefix=/usr 配置环境 123vim /etc/profile ## 打开环境配置文件， 在该文件最后增加如下两句export BOOST_PATH=&quot;/usr/local/include&quot;export BOOST_LIBS=&quot;/usr/local/lib&quot; source 一下 1source /etc/profile ## source环境变量文件， 使其生效","link":"/2023/12/06/Windows%E4%B8%8Bboost%E5%AE%89%E8%A3%85/"},{"title":"Cooperative Path Planning of Multi-Agent Based on Graph Neural Network","text":"Cooperative Path Planning of Multi-Agent Based on Graph Neural Network摘要多智能体合作规划问题的目标是为每个智能体提供一条无障碍、高效率、无碰撞的路径，关键是智能体之间的有效沟通与合作。本文的研究范围是提出一种新颖的多智能体协调规划的合作方法。我们提出了一种在未知环境中进行多智能体路径规划的组合架构，每个智能体只有本地通信和本地观测，可以与其他智能体协作并分享感知信息。该架构由一个从本地感知中提取适当特征的卷积神经网络（CNN）、一个在智能体之间融合特征的图形采样和聚合门（GraphSAGE）以及一个将 GraphSAGE 的输出解码为行动原语的多层感知器（MLP）组成。我们对组合神经网络进行了训练和测试，并通过在未知环境中的多次模拟结果对所提出方法的整体功效进行了全面评估。","link":"/2023/12/10/Cooperative-Path-Planning-of-Multi-Agent-Based-on-Graph-Neural-Network/"},{"title":"图论知识1","text":"图论知识1本文参考书籍：《离散数学》作者：左萧凌等 图定义：一个图是一个三元组$&lt;V(G), E(G), \\varphi_{G}&gt;$，其中$V(G)$是一个非空集合，$E(G)$是边集合。$\\varphi_{G}$是从边集合$E$到结点无需偶（有序偶）集合上的函数。 简言之：一个图是由顶点、边和边的指向关系构成的。顶点对应顶点集合，边对应边集合，边的指向关系指的是$\\varphi_{G}$，即序偶关系。 ​ 如图所示，顶点集合为$V(G) = {A, B, C, D, E }$，边集合为$E(G) = {e1, e2, e3, e4, e5, e6 }$，由于该图是无向图，故$\\varphi(e1)=(A, B)$，$\\varphi(e2)=(A, E)$，$\\varphi(e3)=(B, E)$，$\\varphi(e4)=(B, C)$，$\\varphi(e5)=(C, D)$，$\\varphi(e6)=(D, E)$。同样由于是无向图，$\\varphi(e1)=(B, A)$，$\\varphi(e2)=(E, A)$，$\\varphi(e3)=(E, B)$，$\\varphi(e4)=(C, B)$，$\\varphi(e5)=(D, C)$，$\\varphi(e6)=(E, D)$这样写也可以。 有向边与无向边： 无向边：若边$e_{i}$与结点无序偶$(v_j,v_k)$相关联，则称该边为无向边。 有向边：若边$e_{i}$与结点有序偶$&lt;v_j,v_k&gt;$相关联，则称该边为有向边。 ==简言之==：有向边表示边有明确的指向关系。$&lt;v_j, v_k&gt;$表示从$v_j$指向$v_k$。 有向图、无向图和混合图 无向图：若图中的每一条边都是无向边，则称该图为无向图。如第一张图所示。 有向图：若图中的每一条边都是有向边，则称该图为有向图。 混合图：若图中既存在无向边，又存在有向边称为混合图。 孤立结点 在一个图中不与任何结点相邻接的结点，称为孤立结点。即如果一个结点没有任何边，则该结点为孤立结点。 自回路或环：关联于同一结点的一条边称为自回路或环。如上图所示$(E,E)$是环。 结点的度定义：在图$G=&lt;V, E&gt;$中，与结点$v(v \\in V)$关联的边数，称作该节点的度数，记作$deg(v)$。 如上图所示，结点A的度数为2，结点B的度数为3，结点E的度数为5（约定，每个环在其对应的结点上度数加2）。 定理：每个图中，结点的度数总和是边数的两倍。即$$\\sum \\limits_{v \\in V} deg(v) = 2|E|$$显而易见，一条边有两端点，每个端点都会使度数加1。 定理：在任何图中，度为奇数的结点必定是偶数个。 显而易见，对于每个图，其结点的度数总和必定为偶数。故，度为奇数的结点必定有偶数个，其和才为偶数。 入度和出度 定义：在一个==有向图==中，射入一个结点的边数称为该结点的入度，由一个结点射出的边数称为该结点的出度。结点的出度与入度之和就是该结点的度数。 定理：在任何图中，所有结点的入度之和必然等于所有结点的出度之和。 显而易见，一个有向图的每条边必有一个入度和出度。（双箭头的边？双箭头边应该不能作为最基本组成元素，双箭头边可以被拆解为两条单箭头边） 定义：含有平行便的任何一个图称为多重图。 如该图所示，$e1$、$e2$、$e3$是一组平行边，$e4$、$e5$是一组平行边。 如该图所示，$e1$、$e3$是一组平行边，而$e4$和$e5$并不是平行边，原因是：$e1$、$e3$的序偶关系一致，都是$&lt;B,A&gt;$，而$e4$和$e5$的序偶关系并不一致，分别为$&lt;B,D&gt;$和$&lt;D,B&gt;$。 ==简单图==：把不存在平行边和环的图称为简单图。 ==完全图==：简单图$G=&lt;V,E&gt;$中，若对每一对结点间都有边相连，则称该图为完全图。 定理：$n$个结点的无向完全图的边数为$\\frac{1}{2}n(n-1)$ 显而易见，对于有$n$个结点的无向完全图，每个结点都与其他$(n-1)$个结点存在一条边，故有$n(n-1)$条边，由于一半是重复的，$\\frac{1}{2}n(n-1)$。","link":"/2023/12/12/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%861/"},{"title":"查找文本行数的最快方法","text":"C语言查找文本行数的最快方法转载来源：c++ - 查找文本行数的最快方法 (C) - SegmentFault 思否 请记住，所有 fstream 都是缓冲的。因此，它们实际上确实以块的形式读取，因此您不必重新创建此功能。所以你需要做的就是扫描缓冲区。不要使用 getline() ，因为这会迫使你调整字符串的大小。所以我只会使用 STL std::count 和流迭代器。 12345678910111213141516171819202122232425262728293031 #include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;struct TestEOL{ bool operator()(char c) { last = c; return last == '\\n'; } char last;};int main(){ std::fstream file(&quot;Plop.txt&quot;); TestEOL test; std::size_t count = std::count_if(std::istreambuf_iterator&lt;char&gt;(file), std::istreambuf_iterator&lt;char&gt;(), test); if (test.last != '\\n') // If the last character checked is not '\\n' { // then the last line in the file has not been ++count; // counted. So increement the count so we count } // the last line even if it is not '\\n' terminated.}","link":"/2023/12/10/%E6%9F%A5%E6%89%BE%E6%96%87%E6%9C%AC%E8%A1%8C%E6%95%B0%E7%9A%84%E6%9C%80%E5%BF%AB%E6%96%B9%E6%B3%95/"},{"title":"Path Planning for Lunar Surface Robots Based on Improved Ant Colony Algorithm","text":"Path Planning for Lunar Surface Robots Based on Improved Ant Colony Algorithm作者：SONG Ting，SUN Yuqi，YUAN Jianping，YANG Haiyue，WU Xiande* Abstract摘要： 在现实世界中，月球任务的规模和地形因不同的作业区域或工作表而各不相同，这就需要一种更灵活、更高效的算法来生成任务路径。针对月球空间尺度大、地形复杂的特点，设计了一种月球机器人多尺度蚁群规划方法。在该算法中，实际的月球表面图像被网格化为一个栅格图，路径规划算法在此基础上建模，然后将实际路径投影到原始的月球表面和任务中。经典的蚁群规划算法利用多尺度方法重新编写，以解决多样化任务问题。此外，还考虑了路径的平滑性，以减小转向角的大小。最后，介绍了几种典型条件，以验证所提算法的效率和可行性。 作者改进蚁群算法，以适应月球表面大尺度、复杂地形的路径规划。该方法应用于月球表面栅格化地图，并在栅格化地图完成路径规划后，重新投影到经纬度地图上。 Introduction月球基地建设和资源开发是未来人类拓展太空乐园的重要方面。月面机器人将是宇航员开发利用月球资源的重要助手和重要工具。随着机器人数量的不断增加，月面机器人任务分配和路径规划将成为大规模规划问题。==随着机器人性能的提高和规划规模的扩大，路径规划应用场景和地形条件的不确定性进一步增加。==多样化的规划场景要求搜索算法具有适应各种尺度的灵活性和适应复杂地形的高计算能力。因此，为机器人规划一条短小、安全、平滑的路径以到达月球表面的目标位置尤为关键。 对路径规划的深入研究已有几十年的历史，主要分为两类，一类是基于理论模型的规划方法，另一类是基于随机搜索算法的规划方法。在基于随机搜索的规划方法方面，李［1］ 提出了一种改进的 A* 算法。该方法将 AGV 状态与模糊逻辑规则相结合作为启发式信息，并动态调整启发式功能权重。Alireza 等［2］改进了变异杜鹃优化算法（MCOA），该算法具有处理多个未映射对象的能力，且耗时少于GA 和A* 算法。Li等人提出了一种基于路径网络的新遗传算法［3］，在更大规模上比A*算法效率更高。为了提高计算效率，减少节点数量，徐晓明等［4］讨论了概率路标算法（PRM）和基于概率的双向快速探索随机树（P-BiRRT）的组合算法。 蚁群算法以其稳定性和可靠性被广泛应用于最优路径的搜索。蚁群算法通过模仿蚂蚁的觅食行为，提高了优化能力的智能性、高效性、准确性和适用范围。与 A* 算法、GA 算法和其他随机搜索算法相比，蚁群算法具有正反馈性，且该算法可采用分布式计算框架⁃ 工作和启发式概率搜索方法，使其更容易、更高效地找到全局最优解。因此，蚁群算法被广泛应用于解决路径规划问题。Shi 等［5］提出了一种分段和全局路径规划的融合方法，利用势能蚁群算法进行全局搜索，利用改进的人工势能场（APF）方法进行局部搜索。方法进行全局搜索。Chen等人［6］的文章提出，蚁群优化算法可以解决无人机（UAV）路径规划问题，具有突出的鲁棒性和可扩展性。在蚁群算法的基础上，赵晓东等［7］通过在启发式函数中增加自适应调整，提高了计算效率。Shao等［8］提出设置信息素衰减系数的dy⁃namical限值可以提高搜索效率，降低局部最优解出现的概率。而对于复杂地形的大规模路径规划问题，目前的蚁群算法仍存在初始阶段盲目搜索和搜索规模受限的问题。 本文提出了一种多尺度改进蚁群算法，结合平滑性方法用于月球机器人智能路径规划，以适应大规模复杂月面，提高路径搜索效率、算法适应灵活性和路径安全性。提出的算法能够适应各种搜索尺度，降低局部最优概率，提高收敛效率。与现有方法相比，本文主要有以下三个方面的贡献：==（1）将全局空间矩阵映射为具有相应地形复杂度的新矩阵，以提高蚁群算法的搜索规模；== ==（2） 提出快速摆脱局部优化的多尺度方法；== ==（3） 提出蚁群算法可以满足月球表面大规模复杂地形的要求。== 本文的结构安排如下。第 1 节介绍了多尺度蚁群模型的基本思想。第 2 节详细介绍了多尺度蚁群模型的算法设计。第 3 节，将所提出的算法用于月面路径规划，并将结果与 A* 算法的结果进行比较，以说明多尺度蚁群算法的有效性。最后，在第 4 节中得出一些结论。 作者提出了多尺度改进蚁群算法，估计平滑方法主要是在后期优化路径时使用。算法的特性是能够适应各种搜索尺度，估计是地图规模？多尺度的具体含义是什么？，提高收敛效率。 Conclusion本文提出了一种基于蚁群算法的多尺度方法。其基本思想是路径映射法和空间分割法。本文进行了多次仿真，证明了理论结果的有效性。多尺度蚁群算法提高了搜索速度，有效地找到了全局最优解。多尺度蚁群算法有利于高效、稳定地规划月球机器人的路径。多尺度蚁群算法有利于高效、稳定地规划月球机器人的路径，未来可推广应用于不同领域复杂地形要求的大规模路径规划问题。 1 Problem Description（1）符号设计 为了解释路径规划问题，设计了一个模拟数学模型，如图 1 所示。 在坐标 $XOY$ 中，路径节点表示为一个集合 $Node = { node_i }$，$node_i $是第 $i$ 个节点，$nodei = { node_{x_{i}}，node_{y_{i}}}$，其中 $node_{x_{i}}$ 和 $node_{y_{i}}$ 是节点 $i$ 的位置。第一个节点 $node_0$ 也记为 S，最后一个节点 $node_n$ 也记为 T，其中 $n$ 表示最后的节点数。 相邻节点之间的路径分段记为一个集合 $R_t = { R_{tij}}$，其中 $R_{tij}$ 是第 $i$ 个节点与第 $j$ 个节点之间的路径分段。这里 $j = i + 1，0 ≤ i &lt; n$。 路径段角度表示为一个集合 $Ang = { θ_i }，θ ∈ [ 0，π )$，其中 $θ_i$ 是 $R_{tij}$ 与 $R_{t( i- 1)i}$ 的延长线之间的钢化角。 障碍物表示为一个集合 $Obs = { O_i }$，其中 $O_i$ 是第 $i$ 个障碍物。$O_i$ 表示为第三个元组集合 $O_i = { O_{xi}，O_{yi}，R_{Oi} }$，其中 $O_{x_i}$ 和 $O_{y_i}$ 是 $O_i$ 的位置，$R_{O_i}$ 是 $O_i$ 的边长。 搜索空间为 $R_{search}$。$R$ 搜索的平均高度为 $A_R$，月球机器人的运动高度极限为 $A_{lim}$。 （2）Path planning model 月球机器人路径规划问题可定义为寻找从 $S$ 到 $T$ 的最优或最佳路径，如图 2 所示。路径规划模型可以用 $S，T，R_t，Ang，Obs$ 等来描述。 路径点不与障碍物不相交，且路径点与障碍物点保持一定的距离。并且要找一条更短的平滑路径，计算时间更短，且转向角度更小。 ==( 2 )将月球图像网格化为不同尺度的栅格地图。==文章说将月球地表栅格化为不同尺度的栅格图，多尺度的意思是，对于同一个栅格图，每个栅格大小是不一样的意思，还是栅格化了多个尺度？但是，看图3，并没有看出来栅格大小不一致的情况，也没看出存在多个不同尺度的栅格图。 经典的蚁群算法存在初始阶段搜索效率低的缺点，尤其是在大空间中。由于月球任务的区域尺度可能很大，$L$ 可能包含大量元素。蚂蚁信息素参数 $\\tau$ 难以在几个周期内以巨大的计算量扩散到整个空间。因此，在大规模问题中，计算效率会大大降低。在算法中利用改变初始矩阵元素个数和缩小搜索范围来降低尺度的影响。 在路径规划之前，将每一堆元素 $h × h$ 映射为一个元素。换言之，将初始矩阵 $L$ 拆分为一组矩阵 $L_{small}$，并将每个矩阵整合为新矩阵 $L_{New}$ 中的一个元素。$L_{small_m}$ 是 $L_{small}$ 中的第 $m$ 个矩阵，它与 $L_{New_m}$ 即 $L_{New}$ 中的第 $m$ 个元素相关联。矩阵 $L_{New}$ 由地形复杂度 TC 的新元素组成，用不同的灰度表示，如图 4 所示。起点 $S$ 和目标点 $T$ 也被映射到 $L_{New}$ 中。 用新矩阵 $L_{New}$ 规划路径，让经过的元素映射到初始矩阵，在 $L_{small}$ 中找到经过的矩阵 $L_{pass}$。如图 5 所示，用传递矩阵 $L_{pass}$ 规划路径 $R_{t_small}$，依次将它们相互组合，成长为初始路径 $R_t$。 ==使用卷积来检测矩形范围是否有意义？== 初始路径 $R_t$ 仍需使用蚁群算法进行优化。首先，通过随机方法收集路径分段 $R_{t_seg}$，得到相应的矩阵 $M_{New}$。其次，在不改变起点和终点的情况下，优化 $M_{New}$中的路径 $R_{t_seg}$，得到优化结果 $R_{t_New}$。最后，用 $R_{t_New}$ 替换 $R_{t_seg}$，并更新上述局部优化后的路径 $R_t$，如图 6 所示。 实际的月球机器人无法在多⁃线路径上行驶，因此栅格图中生成的路径仍需平滑处理。该算法利用曲线平滑方法完成平滑度控制，最终路径的可行性和效率都得到了提高，如图 7 所示。 2 Algorithm Design2. 1 Image process首先，将彩色月亮图像转换成灰度图像，然后获取图像的像素，得到每个像素 MG 的灰度值矩阵。计算像素的平均值 $mean_{rgb}$，它反映的是平均海拔。将 $mean_{rgb}$ 作为像素参考值，设置值比例范围 $p_{rgb}$。最后，生成全局矩阵 $L = { l_{rc} }$，其中 $l_{rc}$ 为第 $r$ 行第 $c$ 列的元素。根据月面环境假设，全矩阵可定义为$$high_{rgb} = floor ( ( max_{rgb} - mean_{rgb} )× p_{rgb} + mean_{rgb} )\\tag{2}$$ $$low_{rgb} = floor(mean_{rgb} -( mean_{rgb} - min_{rgb} )× p_{rgb})\\tag{3}$$ $$l_{rc} =\\begin{cases}0 &amp; low_{rgb}\\le MG_{\\tau} \\le high_{rgb}\\1 &amp; else\\\\end{cases}\\tag{4}$$ 其中，0 表示可访问，1 表示不可访问；$max_{rgb}$ 和 $min_{rgb}$ 分别表示 MG 中的最大值和最小值；$high_{rgb}$ 和 lowrgb 分别表示 MG 中的上界和下界，对应 $p_{rgb}$。 floor ($A$) 将 $A$ 中的元素舍入为小于等于 $A$ 的整数。 Improved ant colony algorithm表示启发式函数 $\\eta_{ij}(t)$ 与下一节点 $j$ 到目标的距离成正比［9］。$$\\eta_{ij}(t) = \\frac{1}{d(j, T)}\\tag{5}$$设置 $\\tau_{ij}$ 的下限，以模拟蚁群中的错误概率，增加搜索多样性。$$\\tau_{ij}=\\begin{cases}\\tau_{ij} &amp; \\tau_{ij} \\gt \\tau_{min} \\\\tau_{min} &amp; \\tau_{ij} \\le \\tau_{min} \\\\end{cases}\\tag{6}$$取消信息素的记录［10-11］。只记录到达 T 的蚂蚁的信息素，这些蚂蚁在第 t 代的集合为 $arrive_{t，T}$。这里 $L_k$ 表示第 $k$ 只蚂蚁在 $arrive_{t，T}$ 中走过的路径长度。 在传统的蚁群算法中，信息素的值在每次迭代中都会下降。然而，改进蚁群算法的主要思想是随机选择路径段进行优化，从而获得全局优化结果。由于这种随机性，这一假设并不适用于改进的蚁群算法。 ==Note：这个形式很像蚁周模型（好久之前看得）== 2. 3 Path mapping method采用路径映射法生成初始解，提高计算效率。其总体思路是将全局栅格分割成若干小串矩阵 $L_{small}$，并将 $L_{small}$ 中的每个矩阵映射为矩阵 $L_{New}$ 中的每个元素，其地形复杂度为 TC。在 $L_{New}$ 中生成最优路径 $R_{t_New}$ 后，映射对应的矩阵 $L_{pass}$，并依次将最优路径 $R_{t_small}$ 互相组合，生成初始路径 $R_t$。 区域分割过程如下（1）确认 $L$ 中元素 $M_1×M_2$ 的个数。（2）设定 $L$ 中元素 $h × h$ 的数量 $L_{small_m}$。（3） 在 $L_{small}$ 中将 $L$ 分成 $ceil (\\frac{M_{1}}{h}) × ceil(\\frac{M_2}{h})$ 矩阵。 $ceil(A)$ 将 A 中的元素舍入到与 A 最接近的大于或等于 $A$ 的整数。（4） 矩阵 $L_{New}$ 由新元素组成，每个元素的取值范围为 $[ 0，1 ]$。$L_{New}$ 中的元素与 $L_{small}$ 中的矩阵之间的映射关系由 TC、起点 $S$ 和目标点 $T$ 反映出来。 其中，$num_{obs}$ 是 $L_{small}$矩阵中的障碍物数量，$num_{total}$ 是 $L_{small}$ 矩阵中的栅格总数。 在 $L_{New}$ 中生成 $R_{t_New}$ 的过程中，取消蚂蚁运动的自由度（DOF） 在 $L_{New}$ 中生成 $R_{t_New}$ 的过程中，取消左上、左下、右上和右下的自由度（DOF），以确保 $L_{small}$ 中相邻矩阵之间存在无障碍路径。然后，将 $R_{t_New}$ 节点映射到矩阵 $L_{pass}$ 中。 在 $L$ 中从 $S$ 到 $T$ 生成 $R_t$ 的映射方法如下。 （1） 遍历 $L_{pass}$ 中的每一对相邻矩阵，选择相邻矩阵之间的可达路径。$L_{pass_n}$ 和 $L_{pass_m}$ 指 $L_{pass}$ 中的上矩阵和后矩阵。$J_n$ 和 $J_m$ 是 $L_{pass_n}$ 和 $L_{pass_m}$ 中的连边集合。 （2） 选取 $J_{nm}$ 中值为 0 的元素，将其作为可访问集合放入 $J_{nm0}$ 中。通过随机方法选择 $J_{nm0}$ 中的后元素 $J_{pos}$。$L_{pass_n}$ 中的目标位置为 $T_{pass_n}$，$T_{pass_n}$ = $J_{n} \\cap J_{pos}$，$L_{pass_m}$ 中的起始位置为$S_{pass_m}$，$S_{pass_m} = J_m \\cap J_{pos}$。 （3） 根据流程 (1) 和 (2) 计算每个 $L_{pass}$ 矩阵中的起始位置和目标值。 （4）在 $L_{pass}$ 矩阵中生成路径，并逐一拼接。然后，在全局矩阵 $L$ 中得到 $R_t$，如图 8 所示。 ==PathMapping Method的目的是：有点分段优化的意思，把一个nxn的栅格图，收缩为mxm的栅格图，且$m &lt; n$，每个收缩的栅格，都包含原nxn栅格的一部分，然后针对这每个部分进行重新路径生成。收缩栅格后，需要生成新的路径，并且还要映射到最初的nxn的栅格。== 2. 4 Space splitting optimal method空间分割优化法可以利用随机方法优化 $R_t$，降低局部最优解的概率，提高计算效率。空间分割最优法的整体过程如下。 （1） 设置路径段优化参数：$O_{num}$ 为优化次数，$Pmax(0 &lt; Pmax &lt; 1)$为路径段与 Rt 的比值上限；$P_{min}(0 &lt; P_{min} &lt; P_{max})$为路径段与 Rt 的比值下限；$N_{Opt0}$ 为初始代数；$M_{Opt0}$ 为算法中蚂蚁的初始数量。 ==第一步：限制了分割比例，具体来说，并不是把最初的路径$R_t$分为固定的段数，而是每次分的路径段$P_{min} &lt; (R_{seg_i} / R_t) &lt;P_{max}$== 在区域路径优化过程中，这一步设置了禁区列表。使用过的 $S_{Opt}$ 位置被记录在 Tabu 列表中，Tabu = { $S_{small} (1)$，$S_{small}(2)$，⋯，$S_{small}(N_{small})$ }。如果新的起始位置已经在 Tabu 中，则重新选择。 ==步骤2提出具体的截断$R_t$的方式，优化次数$N_{opt}$和每次优化的蚁群数$M_{opt}$，是由截断方式来决定的。$num$是一个变值，其他都是定值。== （3）得到 $R_{t_Seg}$ 对应的矩阵 $M_{Seg}$。遍历 $R_{t_Seg}$ 中的每个节点，找出 x⁃ 轴和 y⁃ 轴上的最大值和最小值。根据上述最大值和最小值得到 $M_{Seg}$。在 $M_{Seg}$ 中实施路径规划，得到解 $R_{t_Opt}$。 （4） 用 $R_{t_Seg}$ 替换 $R_{t_Opt}$，并通过上述局部优化更新路径 $R_t$。 （5）重复步骤（2-4），直到达到 $O_{num}$。 2. 5 Path smoothing process经过路径映射和空间分割方法⁃ od，得到需要平滑的 $Node = { node_i }$。本文采用文献 ［12-14］ 提出的平滑方法，减小转向角的大小，提高路径安全性。 3 Simulation and Result Analysis月面图像如图 9 所示。 将图 9 转为栅格图 L，其中包含 658 × 800 个元素。然后，将 L 分割为 $L_{small}$ 矩阵。（a） 表示 $L_{small}$ 中矩阵的尺度为 50 × 50，（b）表示 $L_{small}$ 中矩阵的尺度为 20 × 20，如图 10-15 所示。 设置 $TC_{max} = 0.4$，栅格水平与 $L_{New_m}$ 的值成正比。$L_{New}$ 中的路径规划参数为：$N = 30$，$M = 60$，$\\tau_{min} = 0.1$。如图 11 所示，$L$ 的起始位置在第 150 行第 1 列，目标位置在第 350 行第 375 列。 $L_{pass}$中的路径规划参数为：$N = 10$，$M = 50$，$\\tau_{min} = 0.1$。初始路径$R_{t}$如图12所示。 区域优化参数设置为： $O_{num} = 200$，$P_{max} = 0.085$，$P_{min} = 0.05$，$N_{small0} = 60$，$M_{small0} = 50$，其他常量参数与 $L_{pass}$ 中的参数相同。路径长度与区域最优值之间的关系如图13所示。 平滑前的最佳路径如图14所示，其中平均转向角 $\\bar \\theta = 14.408 867$，大角度转向个数为122。本工作将大于20°的转向角视为大角度，如图14所示。 经过路径平滑处理后，$\\bar \\theta = 1.981138$，大角度的个数为0，如图15所示。 路径映射方法中 $L_{small}$ 的大小是一个可调整的参数，应根据任务确定。在这种情况下，其他参数与上述参数相同。$L_{small}$ 的大小从 15 × 15 到 50 × 50。在8组仿真中去除最高值和最低值后的平均结果如图16—21所示。 从实验数据来看，在$L_{New}$中生成路径的计算时间与$L_{small}$的大小成反比，在$L_{pass}$中生成初始路径的计算时间与$L_{small}$的大小成正比。当 $L_{small}$ 的大小为 19 × 19 时，总计算时间具有最小值。$L_{small}$的大小与空间分割最优方法计算时间的关系如下。","link":"/2023/12/13/Path-Planning-for-Lunar-Surface-Robots-Based-on-Improved-Ant-Colony-Algorithm/"},{"title":"Ubuntu anaconda使用（新建环境、最小化安装Tensorflow）","text":"Ubuntu anaconda使用（新建环境、最小化安装Tensorflow）清华源地址： 1https://pypi.tuna.tsinghua.edu.cn/simple pip安装使用的时候， 1pip install xxx(库名) -i https://pypi.tuna.tsinghua.edu.cn/simple 请先安装好anaconda，再继续下面步骤。 tensorflow, tensorflow-gpu, tensorflow-cpu的区别 有必要说明一下tensorflow的这些版本的区别了。 首先说明：==TensorFlow 1.x版本 与 TensorFlow 2.x版本有非常多的不同== tensorflow， tensorflow-gpu只有在tensorflow 1.x版本进行区分！！！（官网说的） 旧版TensorFlow，即tensorflow 1.x版本， CPU和GPU软件包是分开的。 例如： tensorflow==1.15 仅支持CPU的版本 tensorflow-gpu==1.15 支持GPU版本 没有tensorflow-cpu这个说法 TensorFlow 2.x版本就不进行区分了，tensorflow 2.x 同时支持CPU和GPU。 例如： tensorflow==2.5.0 同时支持CPU和GPU 这里给一个tensorflow 和 CUDA 和 cudnn的对应关系（针对Ubuntu系统），尽量是版本对应的。 新建虚拟环境 打开terminal（请先安装好anaconda） 1conda create -n xxxx(名字) python=x.xx(版本号) 指定名字xxxx，指定python版本。例如想建一个名为tensorflow的虚拟环境，python版本为3.11 1conda create -n tensorflow python=3.11 ==新建虚拟环境不代表安装了tensorflow！只是创建了一个虚拟环境，方便各种库统一管理，以后再tensorflow环境下安装的库，可以统一管理和删除== pip安装Tensorflow 也可以源码安装，官网从源代码构建 | TensorFlow (google.cn)给方法了，比较麻烦。 1pip install tensorflow==x.x.x(版本) -i https://pypi.tuna.tsinghua.edu.cn/simple 例如想安装Tensorflow 2.14。==（安装尽量用pip，方便管理和打包，打包的时候，如果版本不一致会报错）== 1pip install tensorflow==2.14.0 -i https://pypi.tuna.tsinghua.edu.cn/simple 启动虚拟环境/切换虚拟环境 1conda activate xxx(环境名字) 例如，启动tensorflw。 1conda activate tensorflow 验证是否安装成功 查看自己安装的tensorflow是不是自己想要的版本 1pip list 我的环境中显示 123456789101112131415161718...shellsmach 2.5.2smach-ros 2.5.2smclib 1.8.6stack-data 0.2.0tensorboard 2.14.1tensorboard-data-server 0.7.2tensorflow 2.14.0tensorflow-estimator 2.14.0tensorflow-io-gcs-filesystem 0.34.0termcolor 2.4.0tf 1.13.2tf-conversions 1.13.2tf-slim 1.1.0tf2-geometry-msgs 0.7.7tf2-kdl 0.7.7tf2-py 0.7.7... 表明安装的是tensorflow 2.14.0，然后在tenminal中输入到python，启动python 1import tensorflow tensorflow安装成功。输入quit()，退出python。 1&gt;&gt;&gt; quit() 退出当前虚拟环境 1conda deactivate 使用conda打包虚拟环境情景：想要把某台设备上已经配置好的环境，打包好，放到另一台设备上运行。例如，在自己的电脑上配好环境，然后放置到服务器环境下运行。可以省去配置环境时间，有时候，服务器是离线的，可以在自己电脑上配置好，然后再放到离线服务器上。 安装打包工具 1pip install conda-pack -i https://pypi.tuna.tsinghua.edu.cn/simple 打包环境 1conda pack -n env_name -o xxxx.tar.gz(输出地址) 例如，我想打包tensorflow环境 1conda pack -n tensorflow -o tensorflow.tar.gz 查看已创建的环境1conda info --envs 或 1conda env list 会输出自己已创建的虚拟环境名，以及各自的位置。 删除虚拟环境1conda remove -n xxx(环境名) --all 例如删除上面安装好的虚拟环境tensorflow。 1conda remove -n tensorflow --all 命令下运行.ipynb文件利用ipython来运行 1ipython -c &quot;%run test.ipynb&quot; 或者jupyter自带的功能（但是得安装） 1234567jupyter nbconvert --to notebook --execute test.ipynb --output test.ipynb# 跳过部分有错的cell继续执行jupyter nbconvert --to notebook --execute mynotebook.ipynb --output mynotebook.ipynb# cell执行超时jupyter nbconvert --to notebook --execute --allow-errors --ExecutePreprocessor.timeout=180 mynotebook.ipynb # 原地运行文件jupyter nbconvert --to notebook --execute --inplace mynotebook.ipynb","link":"/2023/12/13/Ubuntu-anaconda%E4%BD%BF%E7%94%A8%EF%BC%88%E6%96%B0%E5%BB%BA%E7%8E%AF%E5%A2%83%E3%80%81%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85Tensorflow%EF%BC%89/"},{"title":"C++学习：使用std::fstream处理文件","text":"C++学习：使用std::fstream处理文件参考来源：std::basic_fstream - cppreference.com fstream类定义在&lt;fstrea &gt;头文件中。 1234template&lt; class CharT, class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_fstream : public std::basic_iostream&lt;CharT, Traits&gt; 使用fstream既然fstream是一个类，就需要初始化一个类的对象。 1#include &lt;fstream&gt; //需要包含的头文件 初始化对象 12345//方式一std::fstream read_file; //初始化类对象read_file.open(filename, openmode) //filename-文件名，openmode-文件打开方式//方式二std::fstream read_file(filename, openmode) 例子： 123456//方式一初始化std::fstream myFile; myFile.open(&quot;test.txt&quot;, std::ios_base::in | std::ios_base::out | std::ios_base::trunc); //方式二初始化std::fstream read_file(&quot;test.txt&quot;, read_file.in | read_file.out| read_file.trunc)std::fstream read_file(&quot;test.txt&quot;, std::ios_base::in | std::ios_base::out | std::ios_base::trunc) ==openmode== 常量值 说明 app 添加模式（在每次进行写文件时，将指针指向文件末尾再开始写入） binary 以二进制方式打开 in 读取文件 out 写文件 trunc 打开文件时，丢弃流中原来的内容 ate 打开后立即搜索到流的末尾 noreplace(C++23) 以独占模式打开 ==类函数== 成员函数 说明 示例 构造函数 构造文件流 std::fstream read_file(“test.txt”, read_file.in 析构函数~ 销毁basic_fstream和关联的缓冲区，关闭文件 operator=(C++11) 赋值=，应该是可以用文件流对fstream对象赋值 sawp(C++11) 交换两个文件流 rdbuf 返回基础原始文件设备对象 native_handle(C++26) 返回基础实现定义的句柄 is_open() 检查流是否具有关联的文件，如果文件成功打开，返回true，否则是false open() 打开文件并将其与流关联 read_file.open(filename, openmode) close() 关闭关联的文件 read_file.close() 读文件错误处理使用is_open()函数，判断fstream是否成功打开文件 123std::fstream read_file(&quot;test.txt&quot;, read_file.in | read_file.out| read_file.trunc)if (!read_file.is_open()) std::cout &lt;&lt; &quot;failed to open file&quot; &lt;&lt; '\\n'; 一个完整的例子12345678910111213141516171819202122232425int map_size(const char* filename, int &amp;xSize, int &amp;ySize){ std::fstream ReadFile(filename, std::ios_base::in|std::ios_base::trunc); int n = 0; TestEOL test{}; std::string buf; std::getline(ReadFile, buf); std::cout &lt;&lt; &quot;buf is: &quot; &lt;&lt; buf &lt;&lt; std::endl; for (int i = 0; i &lt; buf.length(); i++) { if (buf[i] != '\\n' &amp;&amp; buf[i] != ' ') n++; } std::size_t count = std::count_if(std::istreambuf_iterator&lt;char&gt;(ReadFile), std::istreambuf_iterator&lt;char&gt;(), test); ySize = n; if (test.last != '\\n') { count++; } xSize = int(count); ReadFile.close() return 0;}","link":"/2023/12/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8std-fstream%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"},{"title":"C++错误处理异常抛出","text":"C++错误处理异常抛出使用throw抛出异常时，如果想要特别提示一些信息，请使用std::logic_error初始化一个错误对象，再作为参数传给std::exception。 12std::logic_error ex((&quot;List to string failed,&quot;+ std::to_string(this-&gt;data.size() - str.size())+&quot; byte(s) are missing&quot;).c_str());throw std::exception(ex);","link":"/2023/12/20/C-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA/"},{"title":"Cpp:函数声明、定义及使用","text":"Cpp:函数声明、定义及使用C/C++函数声明形式： 1返回值类型 函数名(形参列表); 声明不要忘记;，有些时候会忘记以分号结束。 声明是声明函数原型，就是告诉编译器函数的类型。函数原型指明了函数的返回值类型、和函数接受的参数类型；这些信息称为函数的签名（signature）。 C/C++函数定义形式： 123返回值类型 函数名(形参列表){ ...}; 调用函数 1函数名（实参传递）; 使用带有默认参数的函数声明、定义和使用","link":"/2023/12/21/Cpp-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E3%80%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"title":"Linux私房菜：计算机概论","text":"Linux私房菜：计算机概论（组装台式机很有帮助）绕不过的，冯诺依曼机的五个组成部分：输入单元、输出单元、控制单元、算术逻辑单元和内存。 内存所有的数据（数据包括软件程序和数据文件）都要先读入内存后，才能由CPU处理，运算。 个人电脑中的内存主要为随机存取内存（Dynamic Random Access Memory，DRAM），DRAM性质的硬件必须通电才能读写，并且掉电后数据会消失。 DRAM又细分为几类，SDRAM和DDR SDRAM。市面上比较常见的是DDR 4.0，再厉害一点的DDR 5.0也已经推出，但是稍贵。DDR的含义是双倍数据传输速度（Double Data Rate），即在一个工作周期内，使用该技术的硬件可以进行两次数据的传输。 内存是沟通CPU和外存的桥梁。可以这样想象，桥梁越宽，那么通行速度越快，能够通过的车辆就越多。所以，对于一台电脑来说，内存越大，通常运行速度就越快，或者说，内存大能够提升电脑的运行速度。 为了加快数据交换速度，硬件制造者提出多通道设计。目前，使用比较多的是双通道。如果想使用双通道技术，尽可能购买两个型号相同，容量相同的内存（就是尽可能确保两个硬件的参数相同），如果硬件容量不同，双通道技术使用起来会出错。 显卡显卡又称为VGA（Video Graphics Array），现在的显卡也被称为GPU（Graphic Process Unit）；显卡最初的功能是用来处理图像显示的，一般来说，图像的显示的重点在于分辨率和颜色深度。显卡也具有存储能力，并且也是DRAM，即通电后才能读写，掉电后数据会小时。图像实际是由众多的像素组成的，对于一张图，像素越多，粒度越细，看起来越清晰，而每个像素实际是一个数据值，也即每个像素需要存储，这些像素值就存储在显卡中。故，显存容量会影响到屏幕的分辨率和颜色深度。 由于显卡有较大的显存容量，并且具有一定的计算能力，同时，由于CPU需要负责太多事情（控制+运算），制造商就希望能够利用显卡的数值计算能力，（显卡本身的设计是为处理图像，图像本身是矩阵数据堆叠，使得显卡本身就具有不错的计算能力），故，制造商在显卡中增加了一个3D加速芯片，这就是GPU称谓的由来。 同样，显卡的容量越大，能够处理的数据就越多。对于需要大量数据渲染的应用，一张好的显卡是必要的。同样，在深度学习等场景，GPU扮演了很重要的数值计算的角色，也是容量越大越好。但如果主机仅仅作为网络服务器，只要一般的显卡即可。网络服务器并不需要很强的图像显示、处理能力。","link":"/2023/12/24/Linux%E7%A7%81%E6%88%BF%E8%8F%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/"},{"title":"眼镜相关","text":"眼睛相关配眼镜可以事先了解的事情： 折射率：先说结论，高度数可以考虑选高折射率，低度数没必要。 折射率：1.50折射率 1.56折射率 1.60折射率 1.67折射率 1.71折射率 1.74折射率. 折射率越高，镜片越薄，镜片不是越薄越好， 折射率高的镜片，阿贝系数会低。 ==阿贝系数==对于眼镜镜片的选择非常重要。在选择镜片时，较高的阿贝系数意味着镜片具有更好的成像能力，可以提供更为清晰和舒适的视觉体验。特别是对于需要长时间使用眼镜的人群来说，选择具有高阿贝系数的镜片可以减轻眼睛疲劳和不适感。 结论：阿贝系数越高，成像越清晰，可以减轻眼睛疲劳，折射率越高，眼镜越薄，眼镜轻，折射率与阿贝系数成反比，阿贝系数越高，折射率越低。 阿贝数在30以下的，国家标准中不能使用，对人眼有极大的影响与伤害，产生不良的视觉效果，对于青少年近视来说，有加深近视的情况产生，对颜色与形状辨别上也产生不良现象，因此国家不准使用阿贝数低于30的材料当镜片。 球面镜、非球面镜、双非球面镜 球面镜：球面镜片，镜片变形比较严重，不是特别推荐（很多都不是很推荐），定制性非球面设计除外 非球面的设计，修正了影像，解决视界歪曲等问题，同时，使镜片更轻、更薄、更平。而且，仍然保持优异的抗冲击性能，使配戴者安全使用。 双非球面镜片：接近裸眼感受，成像质量更高，镜片的边缘区域变形也更小，对于高散人群会更合适。（视觉效果比较好，价格比较高） 价格上：非球面镜 &lt; 双非球面镜 （这个好像确实挺贵） 镜片材质基本都是树脂的。 镜架：纯钛、含钛、β钛、不锈钢、合金。 纯钛最轻，价格稍高。如果你追求性价比，选国产镜架，甚至不知名的，只要材质对，基本没问题。 简单点说：钛质镜架、1.56、1.60折射率估计挺够用的，非球面镜。 镜片镜片主要分两个部分：基片，镀膜。 没必要考虑树脂之外材质的，象玻璃、PC都在长期的博弈中被时间淘汰了 拒水、防尘、防雾、防污、防蓝光 蔡司系列：佳锐 &lt; A系列莲花膜 &lt; 新清锐 &lt; 臻锐 &lt; 铭睿 蔡司镜片的膜： 佳锐（非球面 冰蓝光高清膜）： 折射率 1.56 1.59 1.60 1.67 1.74 阿贝系数 35.0/37.0 29.0 40.5/40.0 32.0 33.0 价格（一片装）（配镜服务京东自营专区） 到手154.1 211 282 677.37 网址： 佳锐 防蓝光膜 折射率 1.56 1.59 1.60 1.67 1.74 阿贝系数 35.0/37.0 29.0 40.5/40.0 32.0 33.0 价格（一片装）（配镜服务京东自营专区） 到手244.55 佳锐 钻立方防蓝光膜 折射率 1.56 1.59 1.60 1.67 1.74 阿贝系数 35.0/37.0 29.0 40.5/40.0 32.0 33.0 价格（一片装）（配镜服务京东自营专区） 到手369.84 544.71 794.62 依视路镜片依视路钻晶A+： 防水、耐磨、耐污、减少反光、防紫外线、 折射率 1.56 1.60 1.67 1.74 阿贝系数 36.1 40.1 32.0 33.0 价格（一片装）（配镜服务京东自营专区）防蓝光 178 231 430 【依视路镜片】依视路（ESSILOR）1.60非球面钻晶A4防蓝光膜层光学镜片 1片装(现片)【1000度以内】【行情 报价 价格 评测】-京东 (jd.com) 依视路（ESSILOR）钻晶膜 防水、耐磨、耐污、减少反光、防紫外线。 钻晶膜岩 折射率 1.56 1.60 1.67 1.67双非球面 阿贝系数 36.1 40.1 32.2 32.2 价格（一片装）（配镜服务京东自营专区）防蓝光 178 236.91 398.73 904.85 钻晶膜御防水、耐磨、耐污、减少反光、防紫外线、防蓝光 折射率 1.56 1.60 1.67 阿贝系数 价格（一片装）（配镜服务京东自营专区）防蓝光 245 236.91 599.21 钻晶膜致 防水、耐磨、耐污、减少反光、防紫外线、防蓝光 折射率 1.56 1.60 1.67 阿贝系数 价格（一片装）（配镜服务京东自营专区）防蓝光 315 412.61 693.01 明月 明月日常系列 折射率 1.56 1.60 1.67 1.71 1.74 阿贝系数 35.5 33 32 37 33 价格（两片装）（明月京东自营店） 215 294 572 737 1651 双重防蓝光 折射率 1.56 1.60 1.67 1.71 阿贝系数 41 33 32 37 蓝光阻隔率 19% 21% 32% 20% 价格（两片装）（明月京东自营店）防蓝光 285 381 798 911 PMC超亮 折射率 1.56 1.60 1.71 阿贝系数 价格（两片装）（明月京东自营店）防蓝光 372 485 903 明月智能变色 折射率 1.56 1.60 1.67 1.71 阿贝系数 价格（两片装）（明月京东自营店）防蓝光 485 607 1033 1216 万新https://item.m.jd.com/product/100011308801.html?utm_user=plusmember&amp;gx=RnAomTM2CUKtt-1Q3PM3OkzYd5wIdQ&amp;gxd=RnAoxjJZbzfenZwU_IYkW8CR9T4lD4s&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL 高清绿膜 折射率 1.56 1.60 1.67 1.74 阿贝系数 价格（两片装）（） 128 209 255.2 400 防蓝光 折射率 1.56 1.60 1.67 1.71 阿贝系数 价格（两片装）（）防蓝光 158.4 263.2 293.6 437.6","link":"/2023/12/24/%E7%9C%BC%E9%95%9C%E7%9B%B8%E5%85%B3/"},{"title":"算法分析","text":"算法分析参考书籍： 《算法》，作者：Robert Sedgewick，Kevin Wayne 对大多数程序的第一个定量观察就是计算性任务的困难程度可以用问题的规模来衡量。 什么是问题规模？一般来说，问题规模可以是输入的大小，也可以是命令行的某个参数值。例如，对一个排序算法来说，问题的规模就是需要排序的数据，其数据量的大小。 直观上讲，随着问题规模的逐步增长，程序的运行时间也会增长。 幂次法则公式猜测$$T(N)=a N^b$$Knuth观点：一个程序的运行的总时间主要和两点有关 执行每条语句的耗时 执行每条语句的频率 前者取决于计算机、编译器和操作系统，后者取决于程序本身和输入。如果知道所有这些形式，可以将它们相乘并将程序中所有指令的成本相加得到总运行时间。 通常来说，我们考虑的算法时间复杂度为程序中语句的频率。即通过程序中语句执行条数来衡量运行时间。 ==一般用到的近似方式都是$g(N)$~$af(N)$，其中$f(N)=N^{b}(logN)^{c}$==，其中$a$，$b$，$c$均为常数。将$f(N)$称为$g(N)$增长的数量级。 描述 函数 常数级别 $1$ 对数级别 $logN$ 线性级别 $N$ 线性对数级别 $NlogN$ 平方级别 $N^2$ 立方级别 $N^3$ 指数级别 $2^N$ 对于一个程序来说，通常是执行最频繁的指令决定了程序执行的总时间——我们称这些指令为程序的内循环。 1234567891011121314int main(){ int count = 0; int N = 0; scanf(&quot;%d&quot;, &amp;N); for(i = 0; i &lt; N; i++)//循环N次 { for(j = 0; j &lt; 3; j++)//i的每一个值都进行三次 { count++;//3N次 } } return 0;} 对于这段程序，count++是执行最频繁的语句，总共执行了$3N$次。 123456789def Three_sum(arr): N = length(arr) cnt = 0 for i in range(0, N): for j in range(i+1, N): for k in range(j+1, N): if arr[i]+arr[j]+arr[k] == 0: cnt ++; return cnt 书中提及使用一个==成本模型==来评估算法的性质，这个模型定义了我们所研究的算法中的基本操作。 对于上述图片ThreeSum程序，书中给出一个成本模型是访问数组元素的次数。 书中使用术语==命题==来表示某个成本模型下，算法的数学性质。 例如针对ThreeSum程序，成本模型为访问数组元素的次数。提出如下命题： 命题：ThreeSum程序的暴力算法使用了~$N^{3} / 2$ 次数组访问来计算N个整数中和为0的整数三元组的数量。 证明：显而易见，三层循环共执行if块为~$N^{3}/6$，if块中共访问3次数组。 对于大部分程序，得到其运行时间的数学模型所需的步骤如下： 确定输入模型，定义问题的规模 识别内循环 根据内循环中的操作确定成本模型 对于给定的输入，确定这些操作的执行频率","link":"/2023/12/18/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"},{"title":"excel 实现某一区域数据统一加减乘除某一数据","text":"excel 实现某一区域数据统一加减乘除某一数据例如：想要对某一列数据进行缩小/或者扩大一千倍（或者一万倍，例如当前数据单位是 万元，我希望将数据转为 以元为单位）。 首先，在附近一个数据格中填入想要缩小/放大的倍数值，然后右击该值，点击复制。 其次，选择想要进行放大/缩小的数据（想要操作的数据），例如绿框选中的数据，然后右击，可以看到又一项为“选择性粘贴”，点击该项。会弹出一个小框。 如果是想要放大列数据，选择乘，如果是想要缩小数据，选择除，也可以进行加减插座。","link":"/2023/12/25/excel-%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%80%E5%8C%BA%E5%9F%9F%E6%95%B0%E6%8D%AE%E7%BB%9F%E4%B8%80%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%9F%90%E4%B8%80%E6%95%B0%E6%8D%AE/"},{"title":"A tutorial on heuristic methods","text":"A tutorial on heuristic methods作者：Edward A. Silver, R. Victor V. Vidal, Dominique de Wearra 1. Introduction本文的目的有两个。首先，我们希望为决策分析人员和对运筹学基本技术略有了解的管理人员介绍启发式方法。我们的目的并不是要给出一个构建启发式方法的通用秘诀，也不是要对许多现有的启发式程序及其性能进行详尽的比较。不过，我们的第二个目标是确定与启发式方法的使用有关的重要问题，这些问题需要进行更多的研究。关于解决问题的启发式方法，有许多可能的定义。尼科尔森[42]将启发式方法定义为”……通过直观方法解决问题的程序，在这种方法中，问题的结构可以被智能地解释和利用，从而得出合理的解决方案。我们将采用这一定义，此外，我们还将在本文中假定，我们从一个适当的、定义明确的现实问题数学模型开始。 更具体地说，==知道了建议解决方案所隐含的决策（或可控）变量的值，我们就能确定 (i) 解决方案是否可行，以及 (ii) 解决方案的有效性度量值。==换句话说，我们有了约束条件和目标函数的数学表达式。该程序在数学上定义明确，但不能保证给出数学上的 “最优 “解决方案。上述定义中的 “直觉 “一词是指决策者（提出问题者）的实际直觉和/或分析者的数学直觉可能会指导程序的选择和阐述。我们将使用 “启发式解决方案 “来表示通过启发式方法获得的解决方案。最后，有时我们会使用 “启发式 “一词作为名词来代替 “启发式方法或程序”。 诚然，在假设我们对现实世界的问题有一个适当的数学表述时，我们可以说我们忽略了运筹学研究中最困难的方面，即数学模型本身的开发。在这方面，怀特[66]对运筹学研究中所谓的次要决策进行了有趣的讨论，例如，要考虑哪些目标、包括哪些约束条件以及测试哪些替代方案？然而，我们必须认识到，特别是当我们处理更复杂的决策问题时，现实的表述很可能导致数学问题很难甚至不可能精确求解（这在很大程度上是由于许多实际问题的组合性质造成的）。因此，我们认为，对于决策分析师来说，定义明确的数学问题的近似解法程序这一课题越来越重要。 有关启发式方法的文献浩如烟海。不过，我们要特别提到 Klein [25]、MiJller–Merbach [36-38]、Newell [41]、Streim [55] 和 Weinberg mad Zehnder [61] 的全面研究。这些研究大多试图对现有的启发式方法进行系统化和分类。此外，Streim [55] 还列出了大量参考文献。 2. Why use a. heuristic method?使用启发式解法可能有几个原因。这些原因包括： (a) 数学问题的性质决定了其分析（封闭形式）或迭代求解程序是未知的。 (b) 虽然可能存在精确的分析或迭代求解程序，但其计算成本可能过高，或其数据要求可能不现实。枚举法尤其如此，从理论上讲，枚举法通常适用于找不到分析和迭代程序的情况。Ronald Graham[16]就此指出： “关于 NP-完备性的发现改变了调度问题的研究方向。早期的努力是为了找到调度问题的最优解或精确解，但现在大部分注意力都转向了更容易确定近似解的方向，即找到能保证给出接近最优结果的高效方法”。 (c) 启发式方法在设计上可能更容易为决策者所理解，因此明显增加了实施的机会。例如，在某些存货控制问题中，虽然可以得到数学上的最优解，但管理者更倾向于实施比最优解更简单的特定形式的解。用Woolsey和Swanson 的话说[68，第 169 页]：”人们宁愿忍受一个他们无法解决的问题，也不愿接受一个他们无法理解的解决方案”。 (d) 对于可以优化求解的明确问题，启发式方法可用于学习目的，例如，对哪些变量是重要的形成直觉（这与运筹学中使用模拟方法的一个主要原因密切相 似）。(这与运筹学中使用模拟方法的主要原因之一非常相似）。 (e) 启发式方法可作为保证找到最优解的迭代程序的一部分。有两种不同的可能性： i. 容易获得初始可行解，例如，用所谓的西北角规则（Northwest Corner Rule）（见 Wagner [60]）获得运输问题的初始解。该规则通常不会给出特别好的解，但这在本例中并不重要，因为随后的计算机优化程序可以从任何初始可行解中快速找到最优解。 ii. 在精确求解程序的中间步骤做出决定，例如，在单纯形法中选择变量输入基数的规则是启发式的，因为它不一定能使达到最优解所需的步骤数最小化。 (f) 在隐式枚举解决问题的方法中，一个好的起始解可以给出一个极大减少计算量的约束。启发式方法可以用来给出这种 “好 “的起始解。 有了所有这些使用启发式方法的可能原因，读者可能会开始思考 “为什么会有人费尽心机去获得问题的最优解”。我们并不主张在适当的情况下放弃使用优化方法（包括实施方面的考虑）。此外，使用启发式方法并不是一条简单的出路。正如我们将看到的那样，正确地开发和评估启发式程序并不简单。 3. Measuring the quality of a heuristic我们对启发式方法的定义包括 “通过……获得合理的解来解决（数学上定义明确的）问题”。在本节中，我们将解释’合理’一词的含义。(Wheeling[64，第 372 页]很早就讨论过这个问题）。 我们认为，一个好的启发式应该具备以下四个特性： (1) 求解所需的实际计算量。 (2) 解决方案的平均值应接近最优值，也就是说，我们希望平均值表现良好。 (3) 出现极差解（即远离最优解）的几率应该很低。 (4) 启发式方法应尽可能简单，便于用户理解，最好能用直观的语言加以解释，特别是在手动使用的情况下。在这方面，精心准备的文档应有所帮助。 如果启发式方法涉及重复尝试解法，只保留最佳解法，那么在性质 2 和 3 中，我们指的只是这个 “最佳 “解法（而不是从中选出的所有解法）。 决定属性 2 和属性 3 相对重要性的一个重要因素是采用启发式的问题的求解次数。随着求解次数的增加，人们会认为属性 2 相对于属性 3 的权重更大。 属性 4 比其他三个属性更难量化，在文献中大多被忽视，但它很可能是四个理想特性中最重要的一个。Peterson 和 Silver [45] 提供了一个例子，说明这一理念在开发库存管理和生产规划决策系统中的应用。 在此，我们主要从特性 2 和 3 的角度来衡量质量。我们将讨论几种不同的测量方法，但在讨论之前，以下几点值得强调。与其精确地确定某一启发式的质量度量值，不如找出该启发式在什么条件下（即不可控变量的值）表现特别差，因而不应该使用。举例来说，在向随机到达的客户提供服务的问题情境中，用于确定最佳服务通道数量的启发式，只要通道的利用率不是太高，就可能表现得非常好。第二个例子是 Blackburn 和 Millen [3]，他们为动态批量大小问题（面对确定但随时间变化的需求模式，对单一物品的补货时间和规模进行选择）提供了从几种启发式求解方法中进行选择的指导。 3.1. Comparison with the optimum solution我们希望能够将启发式解决方案与大量问题实例中的最佳解决方案进行比较。通常这是不可能的，因为正如前面所讨论的，首先使用启发式程序的一个主要原因是，从计算的角度来看，获得最优解可能是不可能的或令人望而却步的。我们可能不得不借助模拟来估算最佳解决方案的值（在目标函数只能用可控和不可控变量间接表示的情况下）。此外，可能有必要集中精力解决小规模问题（其规模至少小于某些感兴趣的实例），以将计算工作量降至合理水平。 即使找到了最优解，还存在一个问题，即使用什么样的问题实例进行测试，也就是给不可控变量分配一组什么样的值。这显然是一个实验设计的问题，这方面的文献很多（参见文献[7,18 和 35]）。通常情况下，不可控因素太多，无法进行完整的因子实验设计。洞察力（部分来自对相关理论的理解）以及对初步实验结果的调查可以提示哪些变量可能是重要的。通常，维度分析（如 Naddor [40]）可以减少需要考虑的不同参数的数量。 在理想情况下，最好能确定与使用启发式解法而非最优解法相关的成本惩罚大小的概率分布。要做到这一点，首先必须确定不可控变量的适当概率分布。从理论上讲，我们可以开发出所需的分布。然而，一些研究人员的初步研究表明，即使是在不可控变量独立这一值得商榷的简化假设下，分析也会变得极其复杂。==因此，从实用的角度来看，概率分析的主攻方向似乎是根据不可控变量的指定概率分布，即所需概率分布的数值确定，通过经验生成不可控变量的值，从而绘制成本惩罚直方图。==条件分布也很重要，例如，特定参数取特定值时的误差分布。这种条件分布有助于决定在什么情况下使用所考虑的启发式更有吸引力。 3.2. Problem relaxation-bounding当无法找到最优解时（通常是在使用启发式的情况下），另一种方法是对问题进行松弛，以便可以评估出至少与最优解一样好的解，从而为最优解的值提供一个约束，即最优解的值不能优于约束值。松弛解本身并不需要得到，我们需要的只是它的值，或者更少，它的值的界限。然后，我们检查启发式解与这个界限有多接近。这实际上只是一个单向测试。==我们知道，最优解的值必须介于启发式解的值和边界值之间。==因此，==如果启发式解法的值非常接近边界，那么它也一定非常接近最优解的值。==另一方面，==启发式求解值与约束值之间的巨大差距可能是由于启发式太差、约束太松或两者兼而有之造成的。==请注意，==启发式方法本身给出的约束条件正好相反，即最优解的值不能比启发式解的值差。== 最优解的值不能比启发式值差指的是：对于最优解函数o()和启发式函数h()，每一个自变量的函数值o(v)不能差于启发式值，如果启发式是从下界逼近最优解值，则o(v) 不能小于 h(v)，如果启发式是从上界逼近最优解值 o(v)不能大于h(v)，最优解函数o()如果是希望最小化目标函数，则需要h()从下界逼近，如果最优解函数o()如果希望最大化目标函数，则需要h()从上界逼近。 放松问题的最常见方法是忽略一个或多个约束条件。下面介绍两个例子： (i) 在整数线性规划问题中，忽略整数约束条件，求解简单得多的连续变量问题，就可以得到约束。(Peterson 和 Silver [45, 第 536-5371 页提供了协调控制库存问题求解约束的 8 个相关例子）。 (ii) 在 “旅行推销员问题 “中，求解的困难是由每座城市必须在一次旅行中准确地游览一次这一约束条件造成的。去掉单次游览的约束条件，就可以直接得到原问题的约束条件。 随着问题的放宽，我们仍然必须面对使用哪些示例进行测试的问题。 3.3. Extreme value statistical methods通常使用的启发式方法包括生成许多解决方案并从中选出最佳方案。在这种情况下，生成的每个解的值都可视为一个随机变量。极值统计理论可用于估算当前问题的最优解的值。有关这一主题的有趣参考文献有 Clough [6]、Dannenbring [lo] 和 Golden [15]。 3.4. Other comparisons为了便于讨论，我们假定正在处理的问题是我们希望最大化某个目标函数。因此，在第 3.2 节中得到的任何界限都是上限。如果不容易得到这样的边界或怀疑边界不佳，我们可以将启发式解法与其他类型的解法进行比较，后者会产生最优解值的下限。可能的方法包括 (i) 与枚举法比较 枚举法需要的计算量要大得多，计算量很大，但很可能找不到最优解。例如，分支与边界程序（关于此类程序的描述，请参见瓦格纳[60]）在产生了一定数量的分支后就停止了。这种 “截断式 “分支与边界程序也能为我们提供最优解值的上限（在最大化问题中）。 (ii) 与决策者的绩效进行比较 可以在较早的时间段内进行，也可以直接进行平行比 较–这类比较有令人信服的理由。与现有程序相比，发现重大改进可能比任何最优或接近最优的证明对鼓励实施更为重要。Bowman 的文章 [43. (iii) 与其他启发式程序比较 如果已经提出和/或使用了其他启发式求解方法，当然可以将 “我们的 “启发式与 其他启发式进行比较。危险在于，其他启发式解法可能特别糟糕，因此，即使 “我们的 “启发式解法的性能被评为最佳，它仍可能是一种糟糕的解法。 (iv)与 “随机 “决策规则比较一种极端的启发式是完全随机决策。举例来说，一些研究人员（如 Conway [8]）在研究工作中心作业排序的启发式时，使用了在工作中心等待的作业中随机选择下一个作业的决策规则作为基准比较。一般来说，”随机 “规则会对最优解的值产生一个相当差的约束，因此可以用来快速否定一个差的启发式方法。 3.5. Worst case behaviour最近，==关于大规模、确定性、组合型问题的许多研究的重点是确定在使用特定启发式求解程序时可能出现的最差误差（见 [10,11 ]）。==知道启发式的成本惩罚永远不会比某个特定值更差，这一点令人欣慰。然而，这一信息几乎肯定不足以在相互竞争的启发式程序中做出选择。如前所述，决策者可能更关心平均性能和/或成本惩罚大于特定值的概率。某一启发式可能会因不可控制变量的罕见值（本质上是病态值）而导致最差易错行为，但同一启发式在几乎所有其他条件下都可能表现出色。Quicksort 就是一个例子，它是运筹学相关软件中常用的排序程序（见 Nievergelt 等人[43]）。另一方面，最差易用性分析的另一个好处是，它可以指出启发式在哪些条件下表现不佳，从而提示何时不应使用该方法。 4. Types of heuristic methods现在我们对启发式方法进行分类。需要强调的是，这些分类并不是相互排斥的。事实上，在解决某一类问题时，往往可以混合使用两种或更多的启发式方法。此外，我们也不应忽视并行使用两种不同的启发式方法来解决同一问题的可能性，选择两种解决方案中较好的一种，即不一定要依赖单一方法的良好性能。最后，在可能的情况下，启发式方法的开发者最好首先对所考虑的特定问题的理论研究有一个正确的认识；这些理论往往会提出一些具体的思路，这些思路可能对开发有效的启发式程序很有帮助。 顺便提一下，由于复杂问题的启发式解法往往是从较简单问题的精确解法发展而来的（参见 de Werra [63]），这就是向学生传授简单学术问题精确解法的一个很好的理由，也许是最重要的理由。 4.1. Decomposition methods在这里，所考虑的问题被分解成更小的部分，分别解决，并且至少需要粗略地考虑到各部分之间可能存在的相互作用。分解法在传统的将问题划分为组织的各个职能领域的过程中十分普遍。第二种常见的分解方式是将系统设计与系统运行分开。通常在设计阶段忽略运行效果，然后根据已选定的设计制定运行规则。Hax 和 Meal[17]的分层规划工作是分解的另一个很好的例子，在他们的工作中，中程总体规划决策与短程调度问题分离开来，但两个问题领域又有适当的耦合。这种分解的一个重要优点是，它符合大多数组织的实际运作方式。 4.2. Inductive methods这里的思路是从同一问题的较小（或较简单）版本中归纳出来的。例如，在一个涉及多个设施（如工厂和仓库）的选址以满足客户需求的问题中，对于只有几个设施的情况，求解可能相对容易。利用这种较简单情况下的解的特性，可以有效地开发出一种启发式方法，用于更广泛的几种设施的情况（见 Bilde 和 Vidal [2]）。此外，有时某个参数变得非常大的情况特别容易分析，这也为分析参数的中间值（不大也不小）提供了启示。例如，在更新过程的一般领域，大量过程的总体效应具有泊松行为。(西尔弗[54]在开发概率需求下库存物品协调控制程序时利用了这一特性）。 4.3. Feature extraction (or reduction) methods 特征提取法这里采用的一般方法是，首先获取所考虑的几种数值情况的最优解。提取这些解的共同特征，并假定这些特征在一般情况下成立。例如，某个变量的值总是为 0，或者某些控制变量具有高度相关性，或者某个约束条件从未出现过。更极端的还原法是（通过分析问题的简单版本或仅仅凭 “直觉”）假定好的解决方案必须满足某些属性，而这些属性大大简化了分析。然后，一旦求得解，就可以验证是否满足这些属性（见 White [65]）。这种方法的一个很好的例子是，假设在任何合理的库存控制策略中，缺货的频率都会很低。另一个例子是 Hitchings 和 Cottam [19] 在设施布局问题中提出的。他们认识到，如果明智地固定某些设施的位置，或限制某些设施对彼此相邻，那么就可以降低问题的维度，从而更快地评估每个潜在的解决方案。 4.4. Methods involving model manipulation这里的意思是以某种方式改变模型的性质，以便于求解，然后用修正模型的解来代表原始数学问题的解。从更普遍的意义上说，这就是使用数学模型来解决现实世界中的问题，然后将模型的解解释为原始问题的解的过程。模型操作的例子包括 i. 目标函数的修正，如非线性函数的线性化。 ii. 放宽某些限制，其中有些限制在任何情况下都可能是灵活的（例如，预算限制 不一定是刚性的）。 iii. 改变概率分布的性质，例如，假设正态分布而不是更复杂的分布。 iv. 变量的聚合，其目的是减少决策变量的数量（然而，聚合变量的值最终必须在原 有的分解变量之间进行分配）。Geoffr,ton [14]的研究是关于聚合的成本影响的一个有趣参考。 4.5. Constructive methods这里介绍的方法与局部改进方法形成对比，后者将在下一节讨论。构造方法的基本思想是建立（即构造）一个单一的可行解，通常采用确定性的顺序方式。解决旅行推销员问题的所谓 “最近邻规则 “就是一个例子（见 Rosenkrantz 等人 [48]）。要建立一条只经过每个城市一次的线路，需要从某个城市（比如 i）开始，首先去离它最近的城市（称作i）。这就是所谓 “贪婪 “算法的一个例子，贪婪的意思是在每一步中都尽力而为。对于某些类别的问题（旅行推销员问题并非如此），贪婪启发式会带来非常好的解决方案（Comuejols 等人 [9]、Jenkyns [21 ] 和 Lawler [27]）。然而，最近邻规则通常不能很好地解决旅行售货员问题；它的缺陷在于只考虑下一个节点的近视观点。这与使用所谓 “前瞻 “规则的启发式方法形成了鲜明对比（见 MiiUer-Merbach [37]）；MiiUer-Merbach [36, 第 3.3 节] 给出了旅行推销员问题的一个例子，其中的前瞻规则是基于约束计算的（见本文第 3.2 节）。 另一个建设性方法的例子是，在制造工厂的多个潜在地点（m）设置多个工作中心（n），以尽可能降低材料处理成本。一种可能的建设性启发式方法（见 Lee 和 Moore [28]）是，首先在特定地点（如 ]1）定位一个特定的中心（称作 il）。现在，我们选择第二个中心 i2，并将其置于另一个位置 ]2，然后是第三个中心 i3，置于 ]3，等等。在找到最后一个剩余的中心之前，没有完整的解。要生成新的解，整个过程要重复进行。 另一种构造方法涉及的问题有许多决策变量，但总体约束条件相对较少。举例来说，在同一台产能受限的机器上生产的几种产品，如何选择补货的时间和规模就是一个问题。一种建设性的方法（见 van Nunen 和 Wessels [44]）是先分别选择每个单项的批量大小，忽略产能限制（这是一组相对容易解决的问题）。然后，如果隐含的总生产小时数超过了任何一个产能，则对单个项目的解决方案进行调整，直到获得可行的解决方案。 4.6. Local improvement methods与上一节的建构过程不同，这里我们从可行解开始，对 R 进行迭代改进。工作中心位置问题可以用这种方法求解（参见 Hitchings 和 Cottam [19]）。初始可行解可能是制造工厂的现有布局，也可能是一个构造过程的解。局部改进的一种方法是尝试切换成对的中心；当发现有吸引力的切换时，就进行切换，然后继续这个过程，直到任何一次切换都无法实现进一步的改进。一个相关的问题是，当剩余的可能开关数量极大时，是否要继续搜索；换句话说，什么是合适的停止规则？同样，如果使用建构法进行重复试验，我们也希望有一个合理的规则来确定何时停止生成解。伦道夫等人[47]研究了使用贝叶斯（主观概率）方法来构建此类规则。即使使用精确的枚举法（例如分支与边界法），我们也经常会面临同样的停止问题，即进一步的大量计算可能只会导致解的微小改进。启发式推理很可能有助于停止规则的制定。 关于局部改进方法和邻域搜索的更多详情，请参阅 Miiller-Merbach [38] 和 Wheeling [64]。Lin 和 Kemighan [30] 在解决旅行推销员问题时使用了局部改进方法。 5. Interactive role of humans during the execution of a heuristic method在执行启发式程序的过程中，设计合理的交互式系统可以带来以下优势： i. 能够相互指导寻找好的解决方案，特别是利用决策者的经验（见 Segal 和 WeJnberger [52] 和 Tobin [56]）。在对旧方案进行评估时，人类有能力提出新的方案，而详细计算的繁琐工作则留给计算机来完成。交互式程序经常用于工程设计，例如 AIDES（自适应初始设计合成器）程序（Rudd 等人[50]）。 ii. 分析人员了解系统的能力，特别是数学本身的行为方式，以便根据观察到的 行为方式修改模型或启发式程序。 iii. 方便决策者了解系统和/或模型，并获得使用模型的信心。Little [31] 在谈到营销领域的决策时强调了这一点。 在本节的最后，我们将提出三点意见，它们实际上与获得精确解的方法以及启发式程序相关： i. 在许多重要问题中，很难事先从决策者那里获得有关目标和限制条件的明确说明。在互动模式下，可以通过计算机提问的方式，在制定解决方案的过程中，根据需要获取这些信息。这正是 Roy 和 Bertier [49] 、Zionts 和 Wallenius [69] 以及 Little [31] 等人在多目标决策问题上所做工作的精神所在（另见 Keeney 和 gaiffa [241.） ii. 交互式系统是否有效的一个重要因素很可能是能否以图形方式描述解 决方案，例如在车辆路由系统中显示地图（Krolak 等人[26]）。 iii. 随着微型计算机的日益普及，交互式方法的使用将大幅增加。 6. Factors that may be important in the choice or testing of a heuristic method在本节中，我们试图找出一些在选择特定启发式方法或对其进行评估时可能很重要的因素。这些因素并不是独立的，尤其是前三个因素肯定是相互关联的。一个重要的研究领域是为设计和测试启发式方法制定更明确的指导方针。 (a) 战略（系统设计）与战术（系统运行）问题–战略决策（如工厂设施的资本投 资）是一次性的重大决策，需要进行相当细致的分析，而战术决策（如质量控 制、生产调度等）则是次要的、重复性的决策。此外，在战术决策中，还有机会进行调整，以弥补先前决策的失误。 (b) 决策的频率–是一次性决策问题还是重复决策问题？如前所述，对于重复性决策，平均绩效好的标准更有意义。 (c) 允许的计算工作量 这个因素显然与决策的重要性和频率有关。一般来说，启发式方法的选择取决于允许的求解时间和/或资金预算。 (d) 决策者的分析能力 如前所述，启发式方法最好能为决策者所理解。因此，决策者对分析推理的理解能力应影响启发式方法的选择，尤其是在手动使用启发式方法的情况下。 (e) 决策（可控）变量的数量 此类变量的数量首先影响对启发式的需求，并应影响方法的选择。 (f) 不可控变量的数量 –这一因素对启发式方法的测试尤为重要。不可控变量的数量越多，就越不可能进行概率分析。 (g) 问题的规模–以旅行推销员问题为例。一种启发式方法可能最适合 30 个城市的情况，而另一种启发式方法可能更适合 100 个城市的情况。 (h) 离散变量与连续变量–关于启发式方法的一般文献大多与涉及整数变量的组合 问题有关。当变量是连续变量时，也许不同的方法更合适。 (i) 确定性变量与概率变量 大多数文献都涉及大规模确定性模型。 同样，对于通常只涉及数量有限的变量的概率问题，设计出截然不同的启发式程序或许也是有意义的。霍华德[20]和纳多[39]等人研究了在处理特定决策问题时，仅使用概率分布的前几个时刻而不是整个分布的效果。 7. Summary在本文中，我们讨论了解决定义明确的数学问题的启发式方法。其中包括启发式方法的性能测量、不同类型的启发式程序，以及在选择和测试用于任何特定问题的启发式方法时可能涉及的一系列因素。希望本文能达到两个目的，即：(i) 向决策分析人员介绍启发式方法的基本概念；(ii) 激发分析人员对启发式程序的一些重要方面进行研究。与后一点相关，一个具有挑战性的研究课题是，在给定一个特定问题和最大允许计算时间（或复杂度）的情况下，找到一种能在这些条件下给出最佳解决方案的求解方法。","link":"/2024/01/03/A-tutorial-on-heuristic-methods/"},{"title":"Python-画图知识","text":"Python 画图知识参考：Matplotlib 绘制多图 | 菜鸟教程 (runoob.com) 最全Python绘制多子图总结 - 知乎 (zhihu.com) python 使用matplotlib绘图要注意的事情： 123456789101112131415161718192021222324# 导入库from matplotlib import pyplot as pltimport mpl_toolkits.axisartist as axisartistfrom matplotlib import colors#用来正常显示中文标签plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示负号 #有中文出现的情况，需要u'内容'plt.rcParams['axes.unicode_minus']=False # 先声明画布# figsize=(xx, xx)设置画布大小，画布不能设置太大，不然会报错，最大设置过(64, 64)fig = plt.figure(figsize=(30, 30)) # 一个figure 画布对象可以有多个子图axes，通过调用subplot来返回一个子图对象，类似的方法还有add_subplot()# 函数原型 subplot(numRows, numCols, plotNum), 例如(111)表示共生成一个1行1列的子图对象，即只有一个子图，第三个1表示对第一个子图进行操作ax = plt.subplot(111) # ax = plt.subplot(221)，则表示生成2行2列的子图，则共有4个子图对象，1表示对第一个对象进行操作。# 子图的编号从左上角第一个子图开始，依照从左到右，从上到下的顺序标记# 保存当前画布上的图像plt.savefig(&quot;./test_fig.png&quot;)# 显示图像，注意这两步不能颠倒，不然会保存一个白板。plt.show() 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 导入库from matplotlib import pyplot as pltimport numpy as npimport mathfrom matplotlib import colorsx = np.linspace(-2*math.pi, 2*math.pi, 100)y1 = np.sin(x)y2 = np.cos(x)#用来正常显示中文标签plt.rcParams['font.sans-serif']=['SimHei']#用来正常显示负号 #有中文出现的情况，需要u'内容'plt.rcParams['axes.unicode_minus']=False# 先声明画布# figsize=(xx, xx)设置画布大小，画布不能设置太大，不然会报错，最大设置过(64, 64)fig = plt.figure(figsize=(15, 10))# 一个figure 画布对象可以有多个子图axes，通过调用subplot来返回一个子图对象，类似的方法还有add_subplot()# 函数原型 subplot(numRows, numCols, plotNum), 例如(111)表示共生成一个1行1列的子图对象，即只有一个子图，第三个1表示对第一个子图进行操作ax = plt.subplot(111)# ax = plt.subplot(221)，则表示生成2行2列的子图，则共有4个子图对象，1表示对第一个对象进行操作。# 子图的编号从左上角第一个子图开始，依照从左到右，从上到下的顺序标记# 使用plot来绘制曲线ax.plot(x, y2, color='blue', linewidth=5.0, linestyle='--')# 设置坐标轴名称ax.set_xlabel('x-label', fontsize=12)ax.set_ylabel('y-label', fontsize=12)ax.set_title('Title', fontsize=12)# 设置坐标轴范围ax.set_xlim((-2*math.pi, 2*math.pi))ax.set_ylim((-1.5, 1.5))# 设置坐标轴刻度x_ticks = np.arange(-2*math.pi, 2*math.pi, 0.5)y_ticks = np.arange(-1.5, 1.5, 0.5)ax.set_xticks(x_ticks)ax.set_yticks(y_ticks)# 保存当前画布上的图像plt.savefig(&quot;./test_fig.png&quot;)# 显示图像，注意这两步不能颠倒，不然会保存一个白板。plt.show() 上述代码中用到的接口函数，如果我们使用子图(Axes)来调用接口函数，其形式为 set_xlim():设置x坐标轴范围 set_ylim():设置y坐标轴范围 set_xlabel():设置x坐标轴名称 set_ylabel():设置y坐标轴名称 set_xticks():设置x轴刻度 set_yticks():设置y轴刻度 如果使用的plt画布窗口，则调用函数为： xlim():设置x坐标轴范围 ylim():设置y坐标轴范围 xlabel():设置x坐标轴名称 ylabel():设置y坐标轴名称 xticks():设置x轴刻度 yticks():设置y轴刻度 ==绘制多个子图，使用ax方式调用，（如果调用plt的接口会直接在画布上绘制标题等等），一般情况下，也建议使用ax来调用，比较准确且规范。==","link":"/2023/12/25/Python-%E7%94%BB%E5%9B%BE%E7%9F%A5%E8%AF%86/"},{"title":"Hierachical path-finding for Navigation Meshes","text":"【原文翻译】 Hierachical path-finding for Navigation Meshes作者： Abstract随着虚拟环境的规模和导航智能体数量的增加，路径搜索可能成为一个重要的瓶颈。重要的是要开发出能有效应用于任何环境的技术，而不受环境抽象表示法的影响。在本文中，我们提出了一种分层 NavMesh 表示法，以加快寻路速度。分层路径搜索（HPAn）已成功应用于规则栅格，但有必要将这种方法的优势扩展到多边形导航网格。与规则栅格相比，导航网格能提供更高精度的底层几何图形，同时包含更少数量的单元格。因此，我们提出了一种自下而上的方法，==基于多级 k 路分割算法（MLkP）创建分层表示，并标注子路径，可通过我们的分层导航网格路径查找算法（HNAn）在线访问。==该算法得益于在单元数更少的图中进行搜索，因此在初始 NavMesh 上的搜索速度比传统的 An 算法快 7.7 倍。我们介绍了 HNAn 在各种情况下的结果，并讨论了该算法的优势和有待改进的地方。 问题：智能体数量增加 环境的规模扩大，使得传统A*算法的速度变慢 introduction大多数视频游戏都需要模拟数以千计或数以百万计的智能体，这些智能体在三维世界中互动和导航，并显示出追逐、寻找或拦截其他智能体等能力。路径搜索为角色提供了在虚拟环境中自主导航的能力。最著名的寻路算法是 Astar 算法，它在探索图形节点的同时，通过启发式平衡累积成本，快速找到最优路径。多年来，人们提出了许多算法来进一步加快基本的 Astar 算法，但这些算法的成本仍然与图的大小密切相关。分层寻路旨在减少在大型地形中计算路径时需要探索的节点数量。==在计算路径时，层级越高，节点数量越少，从而大大减少了执行时间和内存占用。== ==思考：分层路径规划的核心思想是减少计算路径时需要探索的结点的数量。传统A * 算法 在大规模地图上由于探索了大量不必要结点，而浪费了较多时间== 目前的分层技术可能会导致不平衡的抽象。例如，自上而下的层次结构是通过将环境分割成大型方形簇来创建的，所有簇都包含数量完全相同的低层栅格单元。这种结构的主要缺点是，由此产生的较高层次的层次结构中，节点之间的边的数量可能不均衡，可行走单元的数量也不均衡（因为有些簇中可能有很大比例的栅格单元被障碍物占据）。 与常规栅格相比，用多边形表示的导航网格能以较少的单元格数更接近地表示几何图形。由于较少的单元数可以大大加快寻路速度，因此有必要将分层寻路的概念扩展到以多边形为单元的导航网格的更一般表示方法。此外，在分层表示法中，每个节点的多边形数量和节点之间的入口数量保持平衡也是有益的。 在本文中，我们针对以多边形导航网格表示的大型三维环境提出了一种新的分层路径查找解决方案。==本文提出的解决方案适用于单元为凸多边形的导航网格，因此也包括三角形表示法。====我们的分层图表示法基于一种多级 k-way 分区算法，并注有子路径信息。==我们的方法在层次结构中使用的层次数量和层次结构之间合并的多边形数量方面都采用了灵活的方法。我们评估了使用我们的分层路径搜索所带来的性能提升，并讨论了合并多边形的数量与搜索所使用的层级数量之间的权衡。我们提出了一些基准，有助于在参数拟合过程中实现最佳加速，并对使用 HNA * 找到的路径的次优化边界进行了定量分析。我们还对在分层表示法中插入起点和目标位置时某些配置出现的瓶颈进行了评估。 2 Related work加快路径搜索速度的大量工作都集中在加强 A * 算法上，以减少计算路径所需的计算时间。这样做的代价是找到次优路径，或者在寻找最优路径时允许一定程度的误差，然后允许算法在未来的搜索中修复这些误差。 众所周知的 A * 算法[1]是一种稳健且易于实现的方法，可严格保证解的最优性和完整性。A * 算法使用启发式来限制在找到真正最优路径之前必须评估的状态数量，并保证比使用相同启发式的其他算法扩展相同数量或更少的状态。然而，对于大型场景来说，这种算法非常耗时。实时规划算法能找到最佳次优规划，并在重复使用之前规划工作的同时迭代改进该规划。其中最流行的一种 A * 算法叫做随时修复 A *（ARA * ）[2]。它在迭代降低松散边界（ε）的同时，执行一系列重复的加权 A * 搜索。它通过减少 ε 和重复使用之前的规划工作来加速后续搜索，从而迭代改进解决方案。不过，ARA * 解决方案不再保证是最优的。 D* Lite[3]通过执行 An 来生成初始解决方案，并通过尽可能多地重复使用之前的搜索工作来修复之前的解决方案，以适应世界的变化。D* 可以纠正 “错误”，而无需从头开始重新规划，但需要更多内存。Anytime Dynamic A* （AD* ）[4] 结合了 D* 和 ARA* 的特性，提供了一种能满足严格时间限制的规划解决方案。它能有效地更新解决方案，以适应环境的动态变化。 DBA* 算法[5]结合了为[6]开发的内存效率扇区抽象和[7]使用的路径数据库，以提高空间复杂性和优化性。Huang [8] 提出了一种在任意复杂导航网格环境中相干和持久群组的路径规划方法。该群组被建模为可变形和可分割的区域保留形状。群搜索的效率由三个因素决定：路径长度、变形最小化和分割最小化。 层次图表示法也被用于大型数据集的可视化目的 [9,10]。这些应用的目标是首先提供一个概览，然后能够根据需要缩放和过滤以提供细节。 通过分层表示进行规划来提高问题求解的性能由来已久[11]。Holte 等人[12] 引入了在抽象空间中进行搜索的分层表示法，并利用解决方案指导在原始空间中的搜索。也有研究基于自下而上的方法对一般图进行抽象 [13,14]，但没有考虑平衡节点数或最小化切边。Sturtevant 和 Jansen [15] 稍微扩展了理论工作，并提供了一些不同图抽象类型的示例。在这项工作中，通过为每个可行走的单元设置一个节点，从二维栅格状结构中创建了图。Bulitko 等人[16]的研究表明，路径的质量会随着抽象程度的增加而呈指数级下降。Sturtevant 和 Geisberger[17]研究了如何结合抽象和收缩层次来加快路径查找速度。抽象采用自上而下的方法，在较低层次的规则栅格上创建一个 16x16 叠加层。收缩则利用节点重要性的概念建立更高层次的图，这就要求正确设置节点的优先级，因为它们会影响收缩算法。 在[19]中，提出了一种自适应环境细分方法，在 GPU 上进行高效的索引、更新和查找邻居操作，从而降低了内存需求。另一种基于 HPA* 的类似方法是分层注释 A* （HAA* ）[20]，但考虑到了智能体的大小和地形穿越能力。它是 HPA* 的扩展，允许多智能体在异构地形环境中高效规划高质量路径。另一个有趣的实现是 DT-HPA* [21]，它使用决策树来创建一个分层细分路径。 Jorgensen 提出了一种基于层次结构的自动结构化方法，该方法将建筑物分为由楼梯连接的楼层，并将楼层表示为由门阶连接的房间[22]。这种方法具有严格的层次结构，无法扩展到大型室外环境，如视频游戏中经常出现的环境。Zlatanova[23]提出了一种专门用于室内导航的空间细分框架，该框架通过识别房间和走廊并包含语义信息来实现。 还有一些方法侧重于让智能体更多地感知环境[24]。在这项工作中，规划是基于随时动态A *（Anytime Dynamic A * ）的，规划的执行要满足对路径施加的多个特殊约束，例如：停留在建筑物后面、沿着墙壁行走或避开其他智能体的视线。文献[25]提出了一个多域随时动态规划框架，它可以通过使用一个域中的规划来加速和集中在更复杂域中的搜索，从而有效地跨域工作。它探索了不同领域的关系，包括使用航点和隧道。不同的域在空间细分方面只使用两种表示方法，即二维栅格和三角形网格。 分层表示法已被用于计算在两点之间移动的智能体，其复杂程度各不相同[26,27]；从寻找路线到三维角色动画，不一而足。它们还被用于将高级路径搜索与低级局部运动相结合[28]。在使用三角形表示法时，有可能优化数据结构和内置功能，如间隙，从而大大提高寻路过程中的性能 [29,30]。但要将这一实现方法扩展到多边形网格并不简单（也就是说，仅对多边形进行简单的三角剖分是不够的）。最近有一份技术报告将 HPA* 扩展到了三角形表示[31]。 在本文中，我们讨论了解决定义明确的数学问题的启发式方法。其中包括启发式方法的性能测量、不同类型的启发式程序，以及在选择和测试用于任何特定问题的启发式方法时可能涉及的一系列因素。希望本文能达到两个目的，即：(i) 向决策分析人员介绍启发式方法的基本概念；(ii) 激发分析人员对启发式程序的一些重要方面进行研究。与后一点相关，一个具有挑战性的研究课题是，在给定一个特定问题和最大允许计算时间（或复杂度）的情况下，找到一种能在这些条件下给出最佳解决方案的求解方法。 3. Framework我们的框架包括一个创建层次结构的预处理阶段，以及一个在该层次结构表示中执行在线搜索的基本 A * 算法的改编版本。 预处理阶段从多边形导航网格开始，该网格代表三维世界的一个抽象分区。第一个导航网格被视为层次树中的最低层。层级结构中的其余层级是通过递归将较低层次的图形划分为特定数量的节点来创建的。这种划分一直进行到最高层的图形无法进一步细分为止。因此，特定的路径规划搜索可以在这棵层次树的任何一级中执行。层次结构越高，需要搜索的节点数量就越少。与没有任何层次结构的普通 A* 相比，这种方法可以加快路径搜索计算速度。虽然我们使用基本的 A* 算法测试了结果，但所介绍的方法具有足够的通用性，可用于 A* 的改进版本，如 AD* 、DBA* 、ARA* 或 D*。 二维栅格的经典分层路径查找算法（HPA* [18]）包括将二维栅格作为低层，并通过将环境划分为由入口连接的平方簇来建立高层，其中所有簇具有相同数量的低层栅格单元。簇与簇之间用成本为 1.0 的内部边连接，而内部边的成本则通过在每个簇内搜索共享同一簇的所有抽象节点对的 A* [1] 算法计算。 Gravot 等人[35]提出了一种自上而下的方法，将大块瓦片的二维栅格分区与每个瓦片的低层导航网格相结合。因此，每个 32x32 米的方格都有自己的导航网格，这就迫使单元格的数量大于直接从原始地图生成多边形分解时的数量。这种两级表示法提高了性能，但轴对齐的瓦片和几何图形之间的错位会导致预存表的不一致，从而迫使瓦片进一步细分。 在这项工作中，我们提出了一种自下而上的方法，即从初始导航开始，在尊重多边形导航网格优点的基础上，合并单元格以获得更高层次的抽象。在一般导航网格中对低级单元进行分组并不像决定对 nxn 个单元的正方形进行分组那么简单。==我们的目标是要有一个良好的图形分区，组件大小均衡，组件之间的边数量较少，因为这将降低分层寻路算法的成本。==我们使用 Recast [33] 提供的多边形网格作为初始导航图，并使用多级 k-way 分区算法（MLkP）[36] 创建分层表示法。MLkP 通过折叠顶点和边来缩小图 Gi 的大小，从而创建 Gi+1。该算法已被证明比其他多级递归分割算法更快，并能生成高质量的图。 3.1. Hierarchical representation第一步是建立分层搜索框架，将其定义为图形树。我们首先通过搜索原始导航网格中的多边形来计算层次结构的最低图（G0=(V0, E0)）。每个多边形都会成为 G0 图中的一个节点，并且在原始网格中共享边界的多边形之间会创建边。 5. Conclusions and future work在本文中，我们提出了一种基于自下而上方法在导航网格上执行分层路径查找的新型算法。通过使用多级 k-way 分区算法，我们可以创建复杂度为几级的层次结构，每级的节点数量根据用户输入变量 μ 而递减，该变量决定了层次结构连续级别之间要折叠的节点的大致数量。与自上而下的方法相比，我们的自下而上方法的优势在于，我们的技术提供了均衡数量的可走单元和分区之间的交叉口。我们已经展示了我们的 HNAn 算法如何在这种表示法中比直接在导航网格上应用基本寻路方法更快地获得路径。 对 HNAn 和 HPAn 进行定量比较是很有意义的。不过，这种比较的主要困难在于，HPAn 对栅格的粒度非常敏感，而 HNAn 则没有这种限制。因此，很难找到合适的参数来进行公平的比较。尽管如此，我们预计随着环境复杂度的增加，HNAn 的优势会变得更加明显，因为我们采用 MLkP 分区的自下而上方法可以很好地平衡节点和最小边缘切割，而轴对齐的常规栅格分区则无法实现这一点。因此，随着环境规模和复杂度的增加，我们预计 HPAn 将开始受到这种缺乏平衡的影响。 我们展示了 A * 算法的结果，但本文介绍的架构也可用于 A * 算法的其他变体。 文章提出了一种分层的方法，其提出利用多边形分割方法，来确保分层后的较高级层次中的各个节点能够保持障碍物数量和边数量的平衡。 我们对各种情况下的改进进行了展示，以证明该方法的潜力，但也评估了其局限性。目前，该技术的主要局限性在于将起始位置和目标位置连接到分层表示的步骤，因为其性能会随着高层节点（多节点）中包含的 0 层节点数量的增加而下降。我们测试并比较了这一步骤的两种变体，一种是计算从 S 和 G 到各自上一级节点中每条边的 Astar，另一种是对包含 S 的节点和包含 G 的节点执行单一的 Dijkstra 搜索。尽管 Dijkstra 比 Astar 有所改进，但在关键情况下速度不够快，因此未来的工作将侧重于测试这一步骤的替代方案，例如并行搜索，或预先计算和存储额外的数据结构以进一步提高性能。与处理常规二维栅格时相比，按单元预计算信息更具挑战性，因为初始单元的形状和大小可能会有很大变化，从而难以估计 S 和 G 的可能位置。 我们观察到，如果采用只有一层的层次结构G1 的节点数比 没有层次结构的G0 少约 85%，或者采用两级层次结构，则G1 的节点数比 G0 少约 70%，G2 的节点数比 G0 少约 95%，就能达到最佳提速效果。尽管看起来最快和最简单的方案是采用一级层次结构，但必须强调的是，这些比较是根据图中各种路径的平均成本进行的。例如，目前的算法会检查 S 和 G 是否在同一个多节点中，如果是，则只需执行 An（这意味着这种情况无法从分层表示中获益，但也不会受到惩罚）。此外，我们还证明了当 S 和 G 位于最高层的相邻节点时，由于需要计算多个 An 搜索来连接 S 和 G，因此成本可能会很高，而找到高层路径的成本可以忽略不计。我们认为，在多级表示的下一级计算 HNAn 可以使这两种情况受益。 在今后的工作中，我们还将考虑 NavMesh 的动态更新，以及它们如何影响分层表示法。","link":"/2023/12/26/Hierachical-path-finding-for-Navigation-Meshes/"},{"title":"An improved heuristic mechanism ant colony optimization algorithm for solving path planning","text":"An improved heuristic mechanism ant colony optimization algorithm for solving path planningabstract随着人工智能算法的发展，智能路径规划因其广阔的应用前景和发展潜力吸引着研究人员的目光。蚁群优化（ACO）算法是目前应用最广泛的路径规划求解方法之一。然而，传统的 ACO 算法存在搜索效率低、容易停滞等缺点。本研究提出了一种新的 ACO 变体，名为改进的启发式机制 ACO（IHMACO）。IHMACO 包含四种改进机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整。具体而言，==自适应信息素浓度设置和带有方向判断的启发式机制可提高规划路径的目的性并减少转弯时间。改进的伪随机转移策略和信息素蒸发率的动态调整提高了搜索效率和全局搜索能力，进一步避免了陷入局部最优。==随后，通过一系列实验检验了四种机制的有效性，并验证了所提出的 IHMACO 的性能。与现有的 15 种求解路径规划的方法进行比较，包括 ACO 的 9 种变体和 6 种常用的确定性搜索算法。实验结果表明，所提出的 IHMACO 在路径转弯时间方面的相对改进率分别为 33.33%、83.33%、35.29%、38.46% 和 38.46%，证明了 IHMACO 在可用性和高效率方面的优越性。 1. Introduction全局路径规划是在已知障碍环境下，建立一条从起点节点到目标节点的有序可行路径，且必须保证规划路径不与任何障碍物发生碰撞。智能路径规划是许多领域的重要工具，如机器人路径规划[1]、无人战车（UCV）[2]、车辆路由问题（VRP）[3,4]、交通系统导航[5]、军事指挥系统[6]、巡航导弹轨迹规划[7]、无人机（UAV）轨迹规划[8,9]、火险逃生[10]、自动导引车（AGV）[11]等。由于应用广泛，路径规划问题得到了众多研究者的关注，大量优化算法被用于解决路径规划问题。 传统的路径规划算法主要包括最佳第一搜索算法[12]、Dijkstra算法[13]、A* 算法[14]、跳点搜索算法[15]、广度第一搜索算法[16]、跟踪算法[17]、快速探索随机树（RRT）算法[18]、概率路线图（PRM）算法[19]等。Kurdi 等人将 Dijkstra 算法应用于自动驾驶车辆问题[20]。然而，由于需要遍历大量节点，Dijkstra 算法效率较低，而且无法处理负边问题。==Luo 等人提出了一种扩展的 Dijkstra 算法，利用 Delaunay 三角剖分法解决曲面最优路径规划问题[21]。==Best-First Search 算法与 Dijkstra 算法的过程类似，不同之处在于它使用启发式函数快速引导目标节点[22]。El Baz 等人提出了一种改进的并行 Best-First Search 算法来解决多核处理器规划问题[23]。Breuker 等人将双基算法与 Best-First Search 算法相结合，解决了图历史交互（GHI）问题 [24]。A * 算法在路径规划问题中具有良好的鲁棒性、对环境信息响应快等优异性能[25]。Sang 等人引入了人工势场来改进无人水面飞行器编队的 A* 算法 [26]。Li 等人将双向 A* 应用于机器人路径规划 [27]。然而，==A* 算法并不适合高维空间，而且在复杂环境中会导致计算量骤增。 通过改进 A* 算法，引入了 JPS 算法，以避免扩展许多无用节点 [28,29]。== 广度优先搜索算法采用基于地毯的级联搜索策略，沿着树的宽度遍历节点。Li 等人采用 Breadth-First Search 提出了一种快速路径规划算法 [30]。==RRT 和 PRM 是基于图搜索的动态路径规划求解方法[31,32]。==广度优先搜索算法是一种盲搜索方法，无法确保找到最优路径 [33]。因此，Tripathy 等人提出了一种改进的基于广度优先搜索的识别方法，用于解决移动机器人导航问题 [34]。 近年来，许多启发式仿生算法被广泛应用于解决路径规划问题，如粒子群优化（PSO）[35]、遗传算法（GA）[36]、蚁群优化（ACO）[37]等。然而，传统的启发式算法在解决路径规划问题时存在局限性。为克服 GA 算法运行效率低的缺点[38]，Flores-Caballero 等人提出了一种改进的遗传算法来解决无人机的路径规划问题[39]。Cheng 等人提出了一种适用于可重构平铺机器人的新型遗传算法[40]。Chong 等人提出了一种改进的自适应遗传算法（IAGA）来解决自主水下航行器的路径规划问题[41]。此外，PSO 容易进入局部最优[42]。根据提出的 PSO 变体，Wang 等人介绍了一种用于 AUV 离线路径规划的量子 PSO 方法[43]。为了获得较高的最优精度，Zhao 等人提出了一种混合 PSO，用于求解串行机械手时空最优轨迹规划[44]。Kathen 等人提出了一种改进的 PSO 来解决高级安全飞行器的路径规划问题[45]。此外，随着路径规划问题复杂度的不断提高，许多学者提出了各种改进的优化算法。==Wu 等人引入了一种名为自主导航和避障（ANOA）的深度强化学习技术，以解决无人水面飞行器（USV）的自主导航和避障问题[46]。== SA 是一种基于概率的算法，源自固体退火原理。Xiao 等人提出了一种改进的 SA 来实现无人机覆盖路径规划，结果验证了改进 SA 的高质量效果[47]。==Xiong 等人从快速探索随机树星（RRT*）中汲取灵感，结合锦标赛选择方法和信息启发式算法，提出了一种独特的基于样本的路径规划算法[48]。==与其他启发式仿生算法相比，ACO 具有并行性、自组织性、正反馈能力等优点。然而，传统的 ACO 算法也存在一些缺点，如效率低、收敛慢、易停滞等。因此，许多研究人员提出了许多改进措施，以解决路径搜索策略和信息素更新方面的问题。Ma 等人提出了一种烟花蚁群混合算法，并通过考虑导航距离成本和能耗成本建立了新的数学模型[49]。Ajeil 等人提出了一种基于老化的 ACO，通过与栅格法相结合实现了路径规划的求解[50]。Liu 等人提出了一种改进的 ACO，它集成了信息素扩散和几何局部优化，用于移动机器人路径规划[51]。 ==Zhu 等人提出了一种用于月球机器人路径规划的自适应势场 ACO[52]==，引入了启发式因子和自适应状态转换来提高搜索能力和收敛速度。Yi 等人通过引入多目标编程模型对 ACO 进行了改进，以优化多自动制导车辆的信息素矩阵[53]。为了解决室内移动机器人路径规划问题，Miao 等人通过增强信息素更新策略和状态转换概率，提出了一种改进的 ACO（IACO）[54]。Jiao 等人提出了一种自适应多态 ACO，用于解决智能轮椅的路径规划问题，它主要改进了信息素更新策略[55]。Tao 等人提出了一种改进的 ACO，它结合了初始信息素的分布、修正的启发式函数和信息素更新规则来解决移动服务机器人的路径规划问题[56]。==为了改善 ACO 计算量大的缺点，Wang 等人提出了一种新的加权邻接矩阵用于路径规划[57]==。Zhao 等人通过引入信息素更新策略和路径选择策略，提出了一种改进的 ACO，用于解决全向移动车辆路径规划问题[58]。尽管 ACO 及其变体在解决路径规划问题时能产生令人满意的解，但就有效性和效率而言，ACO 的性能仍有进一步提高的空间。 本研究提出了一种改进的 ACO 来解决路径规划问题。为了克服经典 ACO 的缺点，==本文提出了四种新的机制，分别是自适应信息素浓度设置、具有方向判断能力的启发式机制、改进的伪随机转移策略以及信息素蒸发率的动态调整。==自适应信息素浓度设置是为了加强在初始搜索过程中优先选择可选区域的引导能力。提出了具有方向判断能力的启发式机制，以增强算法的搜索目的性和规划路径的平滑性。引入了改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。提出了一种动态调整信息素蒸发率的方法，以增加蜂群多样性和提高全局搜索能力。将上述四种机制与传统的蚁群优化算法相结合，提出了一种新的蚁群优化算法变体，即 IHMACO（改进的启发式机制蚁群优化）算法。为了验证 IHMACO 的有效性和优越性，我们进行了一组实验，将其与其他路径规划算法在不同实例中进行了比较。结果验证了 IHMACO 在收敛速度和最优解搜索能力方面的优势。 其余部分的结构如下： 第 2 节给出了建立全局路径规划数学模型的说明。然后，第 3 节介绍了传统 ACO 和 IHMACO 中的四种新型机制。第 4 节进行了实验和分析。最后，第 5 节给出结论。 2. Mathematical model of global path planning2.1. Grid environment model全局路径规划的环境模型是为了模拟实际应用场景，为算法实现提供仿真环境。==栅格法是路径规划中应用最为广泛的方式，可以降低环境模型的复杂度。==因此，本研究选择栅格法来构建全局路径规划的环境模型。一般来说，环境模型由自由栅格和障碍物栅格组成，自由栅格用白色栅格表示，也可以用数值 0 表示。障碍物栅格用黑色栅格表示，也可以用数值 1 表示。为方便起见，每个栅格都有唯一的序列号和坐标值。图 1 显示了一个带有 (20 × 20) 个栅格的环境模型示例。 如图 1 所示，起点节点和目标节点分别用 S 和 T 表示。黑色栅格代表障碍区域，白色栅格代表可行区域。相应坐标与栅格序列号之间的变换规则如式（1）所示。 其中，(xn, yn) 表示第 n 个栅格的坐标位置；n 是其序列对应的编号；mod () 表示余数函数；Rx 和 Ry 是环境模型的行列总和；ceil () 表示四舍五入函数。环境模型建立后，转而寻找一组连续的栅格来连接 S 和 T，任意栅格的可能方向如图 2 所示。在图 2 中，任何栅格都可以选择 8 个可能的方向，障碍物栅格为禁止栅格。 2.2. Mathematical model of path planning传统 ACO 的目标函数只考虑路径长度，但转弯次数对优化过程也有重要影响 [59]。我们知道，一条令人满意的路径应该具有最短的长度和最少的转弯次数。在本研究中，引入了多目标函数来建立路径规划的数学模型，该模型考虑了路径长度和转弯次数[60]。同时还采用了加权法来维持两个目标，如式（2）所示。 其中，L(p) 表示路径长度；T (p) 表示转弯时间；w1、w2 表示权重系数。实际上，w1 和 w2 与 L（p）和 T（p）的最小值有关。 ==w1 和 w2 应保证（w1×L(p)）和（w2×T (p)）的值处于同一振幅，以平衡路径长度和转弯时间的影响。== 3. Improved mechanisms and the proposed variant of ACO3.1. ACO algorithmACO 算法的灵感来源于蚂蚁的觅食行为。在蚁群中，每只蚂蚁都是独立的合作个体，觅食行为是通过蚁群内个体间的交流来实现的。 (1) 初始化参数设置 ACO 的基本参数可根据实验经验进行分配，主要包括蚂蚁数量 M、最大迭代次数 K、信息素启发因子 α、期望启发因子 β、信息素挥发因子 ρ 和信息素强度值 Q。 (2) 状态转换概率 在环境模型中，位于节点 i 上的蚂蚁 m 利用状态转换概率选择下一个节点 j，如公式 (3) 所示。 其中，$p_{ij}^{m}$ 节点 $i$ 和节点 $j$ 之间的转换概率；$$\\tau (i, j)$$ 代表信息素浓度值；$η(i, j)$ 代表能见度启发式信息，$η(i, j) = 1/d_{ij} * J{m}$ 代表可选节点集。 (3) 信息素更新规则 信息素更新规则复制了 ACO 中信息素的积累和蒸发，用公式 (4) 和 (5) 表示。 其中，ρ 的值在 [0, 1] 范围内；$\\tau^{m}{t}(i, j)$ 表示第 m 只蚂蚁从节点 i 到节点 j 的信息素；$\\Delta \\tau^{m}{t}(i, j)$ 表示当前迭代中从节点 i 到节点 j 的信息素增量；$L_m$ 表示路径长度。 3.2. A proposed variant of ACO本节提出了四种新的机制来改善传统 ACO 的缺点。首先，提出了一种自适应信息素浓度设置，以加强在初始搜索过程中选择先行可选区域的引导能力。然后，提出了一种具有方向判断能力的新型启发式机制，以提高规划路径的目的性和平稳性。随后，引入了一种改进的伪随机转移策略，以提高搜索效率，避免陷入局部最优。最后，提出了信息素蒸发率的动态调整机制，以增加蚁群的多样性，提高全局搜索能力。然后，结合上述四种机制，形成了一种新的 ACO 变种，即改进的启发式机制 ACO（IHMACO）。IHMACO 的流程图如图 3 所示。图 4 给出了 IHMACO 的伪代码。 3.3. Adaptive pheromone concentration setting在传统的 ACO 中，初始信息素值的设置是均匀分布的，如图 5（a）所示。这种方式会导致算法在早期阶段出现搜索盲区，收敛速度较慢。为了克服这一缺点，==引入了自适应信息素浓度设置来增强引导功能，即在初始搜索过程中优先选择优势可选区域，如式（6）所示。改进后的初始信息素分布如图 5(b) 所示。== 其中，$\\tau_{ij}(0)$ 是 $i$ 到 $j$ 的初始信息素浓度，存在 $\\tau_{ij}(0) \\neq \\tau_{ji}(0)$；$τ_0$ 是传统 ACO 中的初始信息素，取一常数；a 被定义为初始信息素奖惩因子。$d_{Si}$ 是节点 $i$ 到 $S$ 的欧拉距离，$d_{iT}$ 是节点 $i$ 到目标节点 $T$ 的欧拉距离，$d_{Sj}$ 是节点 $j$ 到节点 $S$ 的欧拉距离，$d_{jT}$ 是节点 $j$ 到节点 $T$ 的欧拉距离，$d_{ST}$ 表示 $S$ 到 $T$ 的距离。假设 $S$ 的坐标为（xS , yS ），T 的坐标为（xT , yT ），欧拉距离计算公式如式（7）所示。 对于特殊情况，==引入的欧拉距离 $d_{Si}$、$d_{iT}$、$d_{Sj}$、$d_{jT}$ 和 $d_{ST}$ 如图 6 所示。显然，dSi 和 diT、dSj 和 djT 之和的最小值就是 $d_{ST}$ 的值。当前节点 i 与直线 “ST “之间的距离越远，初始信息素浓度就越小。== 此外，在信息素浓度自适应设置方程中，a 是用来控制一般可选节点和优势区域可选节点的初始信息素浓度。如果 diT &gt; djT，则下一个节点 j 离目标节点位置更近，被视为优势区域节点。为确保当前节点尽可能选择优势区域的下一个节点，a 取其最大奖励值 1。另一方面，如果 diT &lt; djT，则需要进行综合统计实验以找出 a 的合适惩罚值。 具体而言，a 的惩罚值分别设置为 0.1、0.3、0.5、0.7 和 0.9。IHMACO 的其他主要参数设定为 K = 100、M = 50、α = 1、β = 7、Q = 1、ρ = 0.2。每组选定的参数组合模拟运行 20 次。不同 a 值的实验结果如图 8 所示。 从图 8 中可以看出，当 a 的惩罚值设置为 1/2 时，算法的性能在路径长度和转弯时间方面都有优势。总之，当 diT &gt; djT 时，a 的最大奖励值为 1，而当 diT &lt; djT 时，a 的惩罚奖励值为 1/2。在自适应信息素浓度设置功能的作用下，ACO 的初始搜索过程更有目的性，效率更高。 3.4. Heuristic mechanism with directional judgment对于当前节点 i，如果在传统 ACO 中没有障碍物包围，则它有八个可选节点。如图 9 所示，节点 i 及其八个可选节点分别用 j1、j2、j3、j4、j5、j6、j7 和 j8 表示。在路径规划中，==启发式函数 η(i, j) = 1/dij 只与当前节点 i 和下一个可选节点之间的距离有关，而欧拉距离 dij 是环境模型中的已知值，为 1 或 $\\sqrt{2} $。== 因此，==传统的启发式函数缺乏指导性和启发性。==这会导致蚂蚁随机选择搜索路径，进一步减慢 ACO 的收敛速度，尤其是在迭代初期。显然，为了保持搜索过程的效率，==希望节点 i 所选择的下一个节点 j 也是沿着从 S 到 T 的箭头方向==，==如图 9 所示。本节通过考虑 S 和 T 的位置信息，提出了一种新颖的带有方向判断的启发式机制==，从而使路径搜索过程变得有目的性和流畅性，进一步有效避免了搜索的盲目性。带有方向判断的启发式机制基于 S 和 T 的相对位置，与 S 和 T 的绝对位置无关。具体如图 9（a）所示，当前节点的八个可选节点被赋予不同的权重值。假设节点 i 的坐标为 (xi，yi)，下一个选定节点 j 的坐标为 (xj，yj)。 基于新颖的启发式方向判断机制，从 i 到 j 的向量应尽可能指向从 S 到 T 的箭头方向。这意味着（x = xj-xi ）-（X = xT -xS ）和（y = yj-yi ）-（Y = yT -yS ）的值应尽可能不小于 0。如果 x-X &gt; 0 或 y-Y &gt; 0，则表示下一个节点的 x 或 y 方向为正，可标记为 “+”；相反，如果 x - X &lt; 0 或 y - Y &lt; 0，则标记为”-“。如图 9（a）所示，八个可选节点的值分别为 j1（+，+）、j2（0，+）、j3（+，0）、j4（-，+）、j5（+，-）、j6（-，0）、j7（0，-）、j8（-，-）。共有五种情况：j1 有两个 “+”；j2 和 j3 有一个 “+”和一个 “0”；j4 和 j5 有一个 “+”和一个”-“；j6 和 j7 有一个”-“和一个 “0”；j8 有两个”-“。根据方向判断规则，对于当前节点 i 来说，选择 “+”符号较多的可选节点是更好的选择。因此，将八个可选节点的优先级顺序分为五组，分别为 j1&gt;j2 = j3&gt;j4 = j5&gt;j6 = j7&gt;j8，并赋予它们 5:4:3:2:1 的不同权重系数。经过归一化处理后，8 个可选节点的权重值 $\\pi$ 依次为 5/15、4/15、3/15、2/15、1/15，如表 1 所示。 如果起始位置（S）位于（n，n），目标位置（T）位于（0，0），则方向最一致的指向 S -→T 的下一个节点变为 j8，而方向相反的指向 S -→T 的 j1 变为（-，-），如图 9（b）所示。因此，带有方向判断的启发式机制只与 S 和 T 的相对位置有关，而与它们的绝对位置无关。此外，传统的 ACO 只考虑距离函数的影响，启发式函数中还应考虑转弯因素的影响，以提高路径的平滑度。带有方向判断的启发式机制在路径规划中考虑了下一节点、目标节点和转弯时间之间位置信息的联系。改进后的启发式函数详见公式 (8)-(10)。 其中，η（i，j）′为改进启发式函数；π为方向判断权重值；T（i，j）为上一节点（i-1）与下一节点 j 之间的转弯时间；T0 为初始转弯系数常数。改进后的启发式函数综合考虑了节点方向判断、距离信息和转弯时间。==选择正方向的节点，距离和转弯次数越小，启发式函数越好。如此一来，使得算法具有更好的方向引导性，有效提升规划路径的平滑度。== 3.5. Improved pseudo-random transfer strategy为了提高搜索效率，避免陷入局部最优，我们提出了一种改进的伪随机转移策略，如式（11）所示。 其中，$S_{ij}^{m}$ 是蚂蚁 $m$ 从节点 $i$ 转移到节点 $j$ 的概率；随机变量 q 在 [0, 1] 之间平均分布；argmax () 是函数达到最大值时的变量位置；$q_0$ 决定了选择确定性转移和随机性转移的概率。因此，如式（12）和图 10 所示，引入了 $q_0$ 的自适应调整机制，以实现确定性转移和随机转移的合理组合。 其中，$εq$ 表示 $q_0$ 的调整系数，$εq$ 取 0.1 较好。在==早期阶段，$q_0$ 取较大的值，选择确定性转移的概率较大，可以加快局部最优路径的搜索速度。在算法执行的中期，$q_0$ 取较小值，可以增加选择随机转移的概率，防止局部最优的出现。==当算法迭代到后期，其进化方向已基本确定，可逐渐增大 $q_0$ 值，加快收敛速度。如果某次迭代中有一半以上的蚂蚁获得了相同的路径，取 $q_0$ 的值为$(εq - q_0)$，可以增加选择其他路径的概率。改进后的伪随机转移策略在全局搜索能力和收敛速度之间取得了良好的平衡。 3.6. Dynamic adjustment of the pheromone evaporation rate当蚂蚁因信息素干扰次优路径而无法选择最优路径时，就会出现局部最优。当经过多次迭代仍未找到最优解时，算法就会停止搜索。传统的 ACO 在迭代后期很容易陷入局部最优解的困境。为了加强算法后期的全局搜索能力，==增加路径搜索的多样性，引入了信息素蒸发率的动态调整==。此外，还引入了多目标函数 $Fitness$ 来替代全局信息素更新中的路径长度 $L_m$，如式（13）和式（14）所示。 其中，$\\rho_0$ 是 $\\rho$ 的初始值，$\\rho$ 随迭代次数的增加而变大。在迭代初期，$\\rho$ 设置得较小，以增强蚂蚁的方向性，进一步加快收敛速度。随着迭代次数的增加，$\\rho$ 逐渐增大，以扩大蚁群的搜索空间，进一步增强全局搜索能力，避免陷入局部最优。 3.7. Parameter optimization of IHMACO==众所周知，ACO 参数的选择直接影响其性能。==迄今为止，还没有一种成熟的理论分析方法可以直接确定参数的最佳组合。因此，为了找到 IHMACO 的合适参数 $q_0$，我们进行了一次全面的统计实验。在每段测试实验中，只改变其中一个参数，其他参数设置为常数，以分析单一参数的影响。为减少偶然因素造成的误差，每组选定的参数组合都要模拟运行 10 次。测试实验的环境模型设置如图 11 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。 q0 的值分别设置为 0.1、0.2、……、0.9。, 0.9。IHMACO 的其他主要参数设定为 K = 100、M = 50、α = 1、β = 7、Q = 1、ρ = 0.2。不同 q0 值的实验结果如图 12 所示。如图 12 所示，当 q0 的取值范围在 [0.5, 0.6] 之间时，算法的转向时间和平均收敛生成量的性能都较好。考虑到图 12 所给出的结果，在仿真实验中将 $q_0$ 的初始值设为 0.5。 为了证明 q0 的大小对全局搜索能力和收敛速度有显著影响，我们又进行了一次综合统计实验。环境模型（20 × 20）设置为相同，如图 11 所示。起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。图 13 显示了不同 q0 值下最优解的演化曲线。从图 13(a) 可以看出，当 q0 值较小时，ACO 具有很好的全局搜索能力，但收敛速度较慢。相反，随着 q0 值的增大，ACO 的收敛速度较快，且容易陷入局部最优解。同时，当 q0 取中间值 0.5 时，最优解在算法初期具有良好的离散性。此外，在迭代的中后期，算法的全局搜索能力减弱，容易达到局部最优。从图 13（b）可以看出，当 q0 采用自适应调整机制时，算法在迭代初期能有效地搜索到最优路径，收敛速度较快。随着迭代次数的增加，蜂群多样性得到提高，算法的全局搜索能力得到加强，有效避免了算法陷入局部最优。因此，可以得出结论：q0 的自适应调整机制能够很好地平衡全局搜索能力和收敛速度。 3.8. Time complexity of IHMACO algorithm时间复杂度是判断算法运行效率的重要因素，也是反映算法性能的重要工具。一般来说，算法的时间复杂度由种群数量、实验环境空间维数和模型目标函数决定。假设参数初始化时间为 t0，信息素矩阵初始化时间为 G2-t1，其中 t1 为矩阵各节点初始化时间。初始化每只蚂蚁的时间为 t2。因此，初始化阶段的时间复杂度如式（15）所示。 在迭代过程中，最大迭代次数为 K，f (G) 是计算最优个体适应度值的时间。此外，从种群中选择最优个体的时间为 t3，替换最后一次迭代个体的时间为 t4。边界初始化阶段的时间复杂度如式（16）所示。 在单个位置更新阶段，假设计算权重的时间为 t5，则执行带有方向判断策略的启发式机制的时间为 8-t5。假设更新参数的时间为 t6，则通过式（12）和式（14）计算改进的伪随机转移策略和动态调整信息素蒸发率的时间为 2-t6，生成随机数的时间为 t7。然后，根据公式（8）选择下一个节点位置的时间为 M-t8。此外，信息素矩阵重新初始化的时间为 G2-t1。因此，单个位置更新阶段的时间复杂度可用公式（17）表示。 总之，IHMACO 的时间复杂度可以通过公式 (18) 计算出来。 4. Experiments and numerical analysis为了验证 IHMACO 在解决路径规划问题中的性能，本部分操作了一组实验。首先，第一组实验用于测试四种机制的改进效果。然后，第二组实验用于评估建议算法在四种不同实验环境中的适应性。此外，还比较了 ACO 的几个变体和六种广泛使用的算法（Dijkstra 算法、Bes-First Search 算法、A* 算法、Trace 算法、JPS 算法和 Breath-First Search 算法），以验证 IHMACO 在路径规划问题中的实用性和效率。所有算法均由 Matlab 2020a 进行编码，并在英特尔® 酷睿 i5-2400 CPU@3.0 GHz、2 GB 内存和 Windows 10 计算机上运行。 4.1. Performance verification of the four proposed mechanisms为了区分和检验四种机制的有效性，将每种机制与传统ACO有序结合，形成ACO的几种过渡变体，分别命名为ACO-1、ACO-2、ACO-3和IHMACO，如表2所示，并建立了一个空间环境模型（20×20）的实例，其中有几个凹陷的栅格陷阱，如图14所示。起始节点 S 和目标节点 T 用红点表示，它们的坐标分别为（0.5，19.5）和（19.5，0.5）。ACO 变体的初始参数设置如表 3 所示。由于智能算法的随机性，这些算法产生的解可能比新搜索过程中产生的解更好，也可能更差。因此，为了比较模拟结果，使用统计量是一个不错的选择。在本节中，每种算法独立运行 20 次来求解路径规划实例。这些算法得到的最优路径和收敛曲线如图 14 和图 15 所示，五种算法的结果如表 4 所示。 与 ACO 相比，增加了初始信息素浓度设置改进的 ACO-1 在最优路径长度（32.384&lt;34.042）、平均路径长度（33.213&lt;35.758）、转弯次数（8&lt;9）和收敛代数（68&lt;81）等方面都有更好的表现。特别是在收敛代数方面，表明这种改进能有效提高搜索效率，降低蚂蚁陷入僵局的概率。 然后，将 ACO-1 与进一步引入方向判断启发式机制的 ACO-2 进行比较。如表 4 所示，可以发现 ACO-2 在最优路径长度和平均路径长度方面都有明显更好的表现。ACO-2 的较好性能表明了所提出的带有方向判断的启发式机制的可用性。 将 ACO-2 与 ACO-3 进行比较，可以发现 ACO-3 在转弯时间（6&lt;8）方面表现出色。但是，ACO-3 产生的收敛生成次数更多（38&gt;32）。这说明改进后的伪随机转移策略减慢了收敛速度。将 ACO-3 与 IHMACO 比较，IHMACO 在所有指标上都有显著的表现。具体而言，IHMACO 可以获得最小的最优路径长度（31.556）、最小的转弯次数（4）和最少的收敛代数（19）。因此，所提出的信息素蒸发率动态调整方法可以很好地平衡全局搜索能力和收敛速度。 此外，图 14 和图 15 也显示了 IHMACO 更好的结果。对于这五种算法生成的最优路径，可以发现 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序有明显改善。同时，收敛曲线进一步验证了所提出的四种机制的有效性。总之，所提出的四种机制，包括自适应信息素浓度设置、带有方向判断的启发式机制、改进的伪随机转移策略和信息素蒸发率的动态调整，都具有提高 ACO 性能的作用。 4.2. Performance verification in different environments为了评估所提出的 IHMACO 的适应性，本实验设计了四种不同的环境模型。表 5 总结了每个环境模型的特征和设计目标。同时，还使用了传统 ACO 进行比较。环境模型的设置如图 16 所示。在（20 × 20）环境模型中，红点表示起点节点，蓝点表示目标节点，黑色区域表示障碍物。平心而论，IHMACO 的常用参数设置与传统 ACO 相同。具体来说，ACO 设置为 K = 100、M = 50、ρ = 0.3、Q = 1、α = 1、β = 4，IHMACO 设置为 K = 100、M = 50、ρ0 = 0.3、Q = 1、α = 1、β = 4、T0 = 1、τ0 = 1、εq = 0.1、w1 = 0.5、w2 = 1。然后，每种算法独立运行 20 次，求解路径规划实例。实验结果如表 6 所示，两种算法得到的最优路径如图 16 所示。表 6 说明了与传统 ACO 相比，路径长度和转弯时间都有所改善。此外，Path_L_Improve 表示与其他算法相比改进路径长度的百分比，Differ_Length 表示 IHMACO 与其他算法在路径长度上的差异，其他算法的路径长度用 Path_Length 表示。转弯时间也可以用同样的方法得到，如公式 (19) 和 (20) 所示。 如表 6 所示，可以看出在这四种不同环境下，IHMACO 的效率均高于传统 ACO。特别是转弯时间，IHMACO 产生的转弯时间更少（环境 1，5&lt;13；环境 2，6&lt;17；环境 3，4&lt;9；环境 4，4&lt;9；）。在四种不同环境下，转弯时间的改善百分比分别为 61.54%、64.71%、55.56% 和 55.56%。在其他性能指标方面，IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（’’Std’’. 具体而言，IHMACO 得到的 “最佳 “路径长度分别为 29.213、29.799、31.556 和 30.384，小于 ACO。其中，环境 3 中最佳路径长度的改进百分比最多可提高 7.31%。IHMACO 所获得的路径长度 “平均值 “分别为 29.213、29.799、31.556 和 30.384，也小于 ACO。在环境 3 中，改进后的平均路径长度最多可增加 11.75%。 图 16 也显示了 IHMACO 的性能，IHMACO 的结果进一步验证了其优越性。总之，实验结果证明了改进算法在不同环境模型下求解路径规划实例的优越性和适应性。 4.3. Comparison experiments with other variants of ACO4.3.1. Simulation Experiment I在这一部分中，采用了 ACO 和文献[54]中提出的 ACO 的另一种变体，即改进型自适应蚁群优化（IAACO），与 IHMACO 进行比较，以验证其优越性。此外，还采用了六种常用的路径规划算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。环境模型与文献 [54] 一致，如图 17 所示。本实例的起始节点 S 用红点表示，其坐标为（0.5，19.5），位于环境模型的左上角。目标节点 T 也用红点表示，其坐标为（19.5, 0.5），位于环境模型的右下角。为公平起见，ACO 变体（ACO、IAACO、IHMACO）的共同参数设置为相同值。具体来说，ACO 和 IAACO 的参数设置为 K = 100，M = 50，λ = 7，k = 0.9，Q = 2.5，α = 1，β = 7，σ1 = 0.1，σ2 = 0.9，Rs = 0.5，δ0 = 0.15，kL = 0.7，kS = 0.1，kE = 0.2。IAACO 的具体参数可参见文献[54]，如 σ1 和 σ2（距离权系数，σ1 + σ2 = 1）、λ（角度引导系数的权系数）、k（调整系数）。建议的 IHMACO 参数设置为 K = 100，M = 50，ρ0 = 0.2，Q = 2.5，α = 1，β = 7，T0 = 1，τ0 = 1，εq = 0.1。这些算法的详细参数见表 7。ACO 及其变体算法独立运行 20 次。 此外，还采用了六种常用的路径规划算法，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法，与 IHMACO 进行比较。由于这六种常用算法都是确定性搜索算法，它们可以在多次运行中产生相同的解。因此，这六种确定性搜索算法得到的最优路径的最佳值和平均值总是相等的，而且它们只进行一次迭代搜索。表 8 记录并列出了每种算法在 20 次实验中的最佳值、平均值和标准偏差（Std.），产生的最优路径详见图 17-19。此外，收敛速度也是衡量算法效率的一个重要指标，四种改进 ACO 算法的收敛迭代曲线见图 20。 如表 8 所示，与 ACO 的其他变体相比，IHMACO 的性能最好。具体而言，虽然 IHMACO 的最优路径长度（29.79）与 IAACO 相同，小于 ACO（29.79 = 29.79&lt;33.56），但从 “平均值”（29.79&lt;30.12&lt;36.61）和 “标准值”（0&lt;0.3953&lt;3.4189）来看，IHMACO 的性能更稳定。(0&lt;0.3953&lt;3.4189). 众所周知，”平均值 “和 “标准差 “是衡量智能算法总体性能的两个重要指标。IHMACO 产生的”‘Std’’. “值为 0，这意味着 IHMACO 总是能在 20 次独立操作中获得最佳路径长度（29.79）。上述 “平均值 “和 “标准值 “的统计结果证明，IHMACO 在稳定性能和收敛精度方面具有明显的优势。图 20 中的收敛迭代曲线也证明了 IHMACO 的出色稳定性。可以发现，IHMACO 不仅在收敛速度上占优势，而且在 ACO 陷入局部优化的情况下，IHMACO 的 “Std”.代找到了更精确的解，具有明显的优越性。因此，与 ACO 和 IAACO 相比，IHMACO 可以综合考虑长度和转弯次数等因素，在路径规划中取得更好的效果。 与六种常用算法相比，虽然IHMACO的最优路径长度（29.79）与Dijkstra算法、A* 算法、JPS算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和Trace算法（29.79&lt;31.56&lt;32.73）。在其他性能指标方面，IHMACO产生的最优路径的转弯次数均少于Dijkstra算法、A * 算法、Best-First Search算法、Trace算法和Breath-First Search算法。考虑到最优路径的路径长度、收敛生成和转弯时间的综合性能，表 8 中的结果验证了在本实例中，IHMACO 与 ACO、IAACO、Dijkstra 算法、A * 算法、最佳第一搜索算法、跟踪算法和呼吸第一搜索算法相比具有更优的性能。图 17-19 也证明了 IHMACO 更好的性能。事实上，IHMACO 所获得的最优路径的高质量得益于所提出的具有方向判断能力的启发式机制、信息素蒸发率的动态调整，而寻找最优路径的高效率则得益于所提出的改进的伪随机转移策略、自适应信息素浓度设置。 此外，如图 20 所示，考虑到收敛速度和求解精度，IHMACO 的优势更加明显，远远领先于 ACO 的其他变体。IHMACO 的平均收敛代小于 ACO 和 IAACO（5.8&lt;6.4&lt;23.1）。总之，与 ACO、IAACO、Dijkstra 算法、A* 算法、Best-First Search 算法、Trace 算法和 Breath-First Search 算法相比，IHMACO 能以更高的效率获得更好的最优解。为了进一步证明 IHMACO 的优越性，应使用更多的实例和采用更多的方法进行比较。 4.3.2. Simulation experiment II在这一部分，通过文献[55]中给出的一个智能轮椅的简单路径规划示例来测试 IHMACO 的性能。此外，文献[55]中提出的三种改进型 ACO（IACA、GPACA 和 APACA）、Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法也被用来进行比较。为公平起见，环境模型（20 × 20）的设置与文献[55]相同，如图 21 所示。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。此外，IHMACO、IACA、APACA 和 GPACA 的详细参数见表 9。十种算法的计算结果见表 10，其生成的最优路径见图 2123。图 24 给出了四种 ACO 算法的收敛迭代曲线。如图 21 所示，可以发现 IHMACO 的性能优于 IACA、GPACA 和 APAC。具体而言，在 “最佳 “结果中，IHMACO 获得了最佳路径长度（28.038 = 28.038&lt;29.210&lt;30.380）。就 “平均值 “而言，拟议的 IHMACO 得出的结果最佳（28.038&lt;29.184&lt;32.708&lt;35.357）。在 “标准值 “方面，IHMACO 的值为 0，表明在所有比较算法中，IHMACO 的偏差最小，稳定性最好（0&lt;1.0020&lt;4.2827&lt;4.3764）。图 24 中 IACA、GPACA、APAC 和 IHMACO 的收敛曲线也证明了所提出的 IHMACO 具有极佳的稳定性和鲁棒性，其他 ACO 变体在迭代后期缓慢收敛到某个最优解，而 IHMACO 在迭代过程中迅速接近最优解。IHMACO 的迭代次数为 4 次，少于 24 次（IACA）、12 次（GPACA）和 9 次（APACA）。 与六种确定性搜索算法相比，虽然 IHMACO、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法获得的最优路径长度相同（28.038），但 IHMACO 产生的转弯次数比 Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法最少，如表 10 所示。IHMACO 性能较好的原因在于所提出的机制，包括自适应信息素浓度设置和带有方向判断的启发式机制。图 22-23 也证明了 IHMACO 的优异性能。综上所述，与 IACA 算法、GPACA 算法、APACA 算法、Dijkstra 算法、A* 算法、Trace 算法和 JPS 算法相比，IHMACO 可以获得智能轮椅路径规划实例的最优解。 如表 11 所示，可以看出 IHMACO 的效率高于 ACO 和 IACO [56]。特别是在路径长度方面，IHMACO产生的最短路径长度为30.9706，小于ACO的39.6985和IACO的31.7990。在其他性能指标方面，IHMACO 产生的转弯次数为 11，是最小的（11&lt;13&lt;17）。图 25 也可以证明 IHMACO 的显著改进性能，可以看出 ACO 和 IACO 都陷入了死锁栅格，导致算法进入局部最优。此外，IHMACO 的最佳收敛代小于 IACO 和 ACO（8&lt;13&lt;62）。IHMACO 的较好结果进一步验证了其在提高全局搜索能力方面的优势，从而提高了 ACO 的收敛精度。与其他六种确定性搜索算法相比，所提出的 IHMACO 比 Best-First Search 算法和 Trace 算法性能更优。最佳第一搜索算法和跟踪算法生成的路径长度较长，且有很多多余的转弯时间。IHMACO 的出色表现表明了所介绍的四种机制的效率。IHMACO 和其他六种确定性搜索算法获得的最优路径如图 26-27 所示，IHMACO 的出色表现进一步证明了其优越性。 4.3.4. Simulation experiment IV在本节中，文献[57]中提出的一种方法与所提出的 IHMACO 在相同的模拟实验中进行了比较。此外，还采用了另外六种算法进行比较，包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法。在该空间环境模型中，起始节点 S 和目标节点 T 的坐标分别为（0.5，19.5）和（19.5，0.5）。为公平起见，IHMACO 与文献[57]中算法的公共参数设置相同。文献[57]中的算法参数设置为 M = 30，K = 200，ρ = 0.43，Q = 100，α = 1，β = 7，γ = 3，γ 表示导向系数。IHMACO 设为 M = 30，K = 200，ρ0 = 0.43，α = 1，β = 7，T0 = 1，Q = 100，w1 = 0.3，w2 = 1。随后，每种算法独立运行 20 次。这八种算法的模拟结果见表 12，其生成的最优路径见图 28-30。 从表 12 可以看出，虽然 IMHACO 的最优路径长度（29.79）与文献[57]中提出的 Dijkstra 算法、A* 算法和呼吸优先搜索算法相同，但小于最佳优先搜索算法和跟踪算法（29.79&lt;31.56 = 31.56）。特别是在这些不同算法得到的转弯时间中，IHMACO 可以得到最平滑的路径，转弯时间最少（8），其较好的性能也可以从图 2830 中得到证明。实际上，IHMACO 的主要性能得益于自适应信息素浓度设置的启发式机制、方向判断的启发式机制、改进的伪随机转移策略、信息素蒸发率的动态调整。这四种机制兼顾了 ACO 的全局探索和局部利用能力。总之，考虑到路径长度、收敛生成和转弯时间等综合性能，实验结果表明，在本实例中，IHMACO与文献[57]中提出的算法、最佳第一搜索算法、Dijkstra算法、A*算法、Trace算法和呼吸第一搜索算法相比具有更优越的性能。 4.3.5. Simulation experiment V本节使用文献[58]中提出的一个更复杂的路径规划实例进行比较。此外，还采用了 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法进行比较。在这个 30 × 30 空间环境模型中，S 和 T 的坐标分别为（0.5，8.5）和（25.5，28.5）。为了公平起见，文献[58]和 IHMACO 算法的常用参数设置相同。这八种算法的仿真结果见表 13，其生成的最优路径见图 31-33。 从表 13 中可以看出，与文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、Trace 算法、JPS 算法和呼吸优先搜索算法相比，IHMACO 的性能更优。尽管文献[58]中的算法、Dijkstra 算法、A* 算法、最佳优先搜索算法、跟踪算法和呼吸优先搜索算法获得的最优路径长度相同，但 IHMACO 能产生较小的转弯时间。JPS 算法的转弯次数略少于 IHMACO，但 IHMACO 无法保证最短路径长度。此外，IHMACO 生成的最优路径长度的 “平均值 “和 “最佳值 “均为 35.63，这表明了 IHMACO 的稳定性。图 31-33 也证明了 IHMACO 的出色性能。总之，IHMACO 的综合结果进一步证明了它在这一复杂环境模型中的优势。事实上，IHMACO 的优异结果得益于所提出的四种机制。 4.4. Summarization of case study在这一部分中，通过一系列实验将 IHMACO 应用于解决路径规划问题。在第一组实验中，采用了几种 ACO 的过渡变体，分别命名为 ACO-1、ACO-2、ACO-3 和 IHMACO，以区分四种机制的有效性。五种算法得到的最优路径和收敛曲线按照 ACO、ACO-1、ACO-2、ACO-3 和 IHMACO 的顺序逐渐变好，可以得出结论：四种机制对提高 ACO 的性能有一定的作用。 在第二组实验中，设计了四种不同的环境模型来评估所提出的 IHMACO 的适应性。与传统 ACO 相比，IHMACO 在路径长度和转弯时间方面更胜一筹。具体而言，IHMACO 在路径转弯时间方面的相对改进率分别为 61.54%、64.71%、55.56% 和 55.56%。而 IHMACO 在路径长度的 “最佳”、”平均 “和标准偏差（”Std”. 总之，本实验证明了 IHMACO 在不同环境模型中解决路径规划实例的有效性和适应性。 在第三组实验中，采用了五个实验来比较 IHMACO 与 ACO 的其他变体以及六种常用路径规划算法。具体而言，在所有实验中，IHMACO 的整体性能普遍优于 ACO 的九种变体。在 IHMACO 与六种常用路径规划算法的比较中，就路径长度和转弯时间的综合结果而言，IHMACO 在全部五组仿真实验中普遍优于 Best-First Search 算法和 Trace 算法，在三组实验中优于 Dijkstra 算法，在四组实验中优于 A* 算法，在三组实验中优于 JPS 算法，在三组实验中优于 Breath-First Search 算法。总之，实验结果验证了所提出的 IHMACO 算法的高效性和优越性。 5. Conclusion本研究提出了一种改进的启发式机制 ACO（IHMACO），以克服传统 ACO 在解决路径规划问题时的不足。首先，提出了一种自适应信息素浓度设置方法，以加强引导能力，避免早期阶段的过度发散。其次，提出了一种新颖的带有方向判断的启发式机制方法，有效增强了搜索目的性和规划路径的平滑性。第三，引入改进的伪随机转移策略，以最大限度地保持全局搜索能力和收敛速度。然后，提出了一种动态调整信息素蒸发率的方法，以增加蜂群的多样性，避免陷入局部最优。随后，进行了一组路径规划的仿真实验，验证了所提算法的适应性和优势。此外，IHMACO 还与现有的九种 ACO 变体和六种常用算法（包括 Dijkstra 算法、A* 算法、最佳第一搜索算法、Trace 算法、JPS 算法和呼吸第一搜索算法）进行了比较。由路径长度的’’最佳’’、’’平均’’、’’标准’’组成的实验结果验证了 IHMACO 在最优解搜索能力上的优势，尤其是在转弯次数上明显优于其他算法。总之，所提出的四种机制能有效提高 ACO 的性能，IHMACO 与其他算法相比，具有实用性和高效率的能力，能获得相应路径规划实例的最优解。 然而，IHMACO 的研究和应用仍处于起步阶段，存在一些不足之处，有待进一步研究。例如，与确定性搜索算法相比，IHMACO 的执行时间不具有竞争力，这主要是由算法机制造成的。下一步工作中，将着重提升算法的效率和精度，将其应用于动态空间环境和三维路径规划中求解。此外，还可以建议将 IHMACO 用于其他实际应用中，如管道路由设计，以进一步提高其在实际工程问题中的应用能力。","link":"/2024/01/17/An-improved-heuristic-mechanism-ant-colony-optimization-algorithm-for-solving-path-planning/"},{"title":"Classical and Heuristic Approaches for Mobile Robot Path Planning A Survey","text":"Classical and Heuristic Approaches for Mobile Robot Path Planning: A Survey作者：Jaafar Ahmed Abdulsaheb and Dheyaa Jasim Kadhim * 摘要： 机器人学最重要的研究领域是导航算法。机器人路径规划（RPP）是指在移动机器人移动前为其选择最佳路径的过程。寻找理想或接近理想的路径被称为 “路径规划优化”。其目标是找到满足单个或多个目标（如最短、最平滑和最安全的路径）的最佳解决方案值。本研究旨在概述移动机器人的导航策略，这些策略采用了三种经典方法，即 路线图方法（RM）、单元分解（CD）和人工势场（APF），以及十一种启发式方法，包括遗传算法（GA）、蚁群优化（ACO）、人工蜂群（ABC）和灰狼优化（GWO）、 蛙跳算法 (SFLA)、鲸鱼优化算法 (WOA)、细菌觅食优化 (BFO)、萤火虫算法 (FF)、布谷鸟搜索 (CS) 和蝙蝠算法 (BA)。本研究中介绍的不同文章涉及多个问题，包括动态目标、静态和动态环境、多机器人、实时模拟、运动学分析和混合算法。在本作品的最后将进行讨论，并提供详尽的表格和图表，以帮助读者了解开发了哪些类型的路径规划策略，可用于各种生态环境。因此，本作品的主要贡献在于，它为机器人路径规划提供了一个广阔的视角，这将为科学家们在不久的将来研究这一课题提供更多便利。 1. Introduction机器人是一种能够对周围环境做出反应，并（通过传感器）收集环境信息，从而安全执行各类任务的机器。自主机器人可以在没有人类直接控制的情况下自行操作和移动。与制造工厂中使用的机器人不同，在制造工厂中，机器人所处的环境受到严格控制且完全已知，而自主机器人则不可能总是通过编程来执行预定义的动作，因为机器人不可能预测可能遇到的各种情况。此外，环境可能是不可预测的，也可能随着时间的推移而发生变化，这就意味着机器人的动作必须在线快速改变[1]。自主机器人的应用包括医院的快递员、保安、军事监控、航空航天研究、环境监测、清洁工和割草机。一般来说，最重要的应用之一是在危险领域（如雷区或核电站内部）使用自主移动机器人。由于移动机器人与生俱来的自主性，必须克服一系列挑战，包括不确定性、感知误差、规划、学习、可靠性和实时响应[2]。机器人需要动态响应变化并适应环境。 机器人路径规划学科的雏形可以追溯到 20 世纪 60 年代中期。机器人路径规划问题，通常称为机器人路径规划（RPP），是移动机器人导航领域的一个重要问题。==其目标是确定在指定环境中，从预定位置出发，以目标目的地为终点，没有任何碰撞的最佳路径。==一般来说，机器人有无数条路线可以到达目的地，但最佳路线实际上是根据一系列规则来选择的。最广泛使用的标准是距离最短、耗能最少或时间最短、距离最短。由于路径规划的目标是找到最短路径，同时牢记给定环境和无碰撞运动等约束条件，==因此可以将其视为一个优化问题[3]==。移动机器人的地图、定位和导航可以通过环境模型来实现。然而，这些模型中的数据量必须易于管理，并能满足实时计算的要求。机器人领域一个非常棘手的问题是机器人路径的规划。主要目标是在不撞到任何东西的情况下，找到一条从起点到终点的路线。==在解决机器人导航问题时，必须考虑三个关键问题：效率、安全性和准确性。效率要求算法避免让机器人多走几步或反复停下来转弯，这样会浪费时间和精力，以便在最短的时间内确定最短的距离。安全性和准确性取决于找到一条不会撞到任何东西的路径，同时保持在该路径附近[4]。==机器人导航问题可分为定位、路径规划、运动控制和认知映射，如图 1 所示。路径规划可能是机器人导航最重要的方面 [5]。 根据其所在位置[6]，区域淘汰计划可分为两类： (a) 在静态环境中遇到固定障碍物时的 RPP。(b) 在动态环境中面对静止和移动障碍物时的 RPP。 这两类中的每一类又可细分为一个子群。==全局路径规划==，即环境中的机器人可以在开始移动之前（离线）规划好整体路径，因为它们掌握了静止障碍物的完整信息，而移动障碍物的轨迹也是事先已知的。由于设置新地图具有挑战性，因此全局导航中环境变化的成本非常高，尤其是在动态环境中。无法利用完整的环境知识规划本地路线是本地路径规划的一个局限。移动机器人在环境中移动时，会使用传感器收集信息（在线）。机器人必须反复移动到新的位置，感知周围环境，更新地图，规划下一步行动路线，从而绘制出周围环境的地图。局部路径规划面临着一系列挑战，包括传感器读数误差、传感器约束、多变的环境条件、机器人动力学、位置估计和机器人运动限制等[6]。在极其复杂和广阔的环境中，本地路径规划可能无法确定通往目标的路径。出现这种情况的主要原因是传感器无法提供足够的数据，将机器人送至理想位置[7]。机器人的基本位置、旋转以及整个链路的旋转或平移称为机器人的配置。所有可能配置的集合构成了配置空间或 c 空间，它需要几个元素： 描述机器人的形状，如是否有腿、轮子或没有四肢（运动）。 解释机器人所处的环境，包括其几何形状（二维或三维工作空间）。 环境必须有一个起点和目标配置，必须在这两个配置之间规划机器人的路径。 一些参数用于描述机器人的工作空间配置。例如，两个参数（通常称为 x 和 y）可用于描述机器人的配置，将其转换为二维工作空间。机器人工作区内的障碍物会阻止某些配置的使用。例如，配置为 C 的机器人如果与工作区的任何障碍物发生碰撞，就会被禁止使用。由此，配置空间 C 被划分为一组禁止配置 C forbited 和一组允许配置 C free。一般来说，路径被定义为一个连续函数 π : [ 0, L ] → C，以路径的长度 L 为参数。路径规划问题是在给定的起点配置 s∈C 和目标配置 g∈C 之间找到一条无（碰撞）路径。就配置空间 C 而言，通过找到一条路径 π，使 π ( 0 ) = s 和 π ( L ) = g，并且 ∀(t∈ [ 0, L ] :π ( t )∈C f ree ) [8]。绘制地图是构建环境模型的过程。为了绘制出足够精确的地图，显示机器人沿途所见，必须准确显示地形。有不同类型的地图可用于表示环境。其中一些使用栅格，栅格中的单元格要么是空的，机器人可以在其中自由行进，要么是被占满的，以表示障碍物，如图 2 所示。如图 3 所示，其他人使用二维（或三维）矩形或正方形工作空间，障碍物为多边形。 许多研究人员都提交了有关移动机器人导航的调查论文[9-11]；然而，这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在发现特定领域的研究空白和创新范围。它深入分析了静态环境中的单个算法、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合，以及在三维（3D）环境中的应用。 调查还强调了传统方法和反应式方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。在参考文献[9]中，该方法仅限于路径计算。[9]中，该方法仅限于三维路径规划，而参考文献 [10]综述了适用于各种机器人类型（包括空中、地面和水下机器人）的多机器人路径规划方法和决策策略。参考文献 [11 [11]主要研究了移动机器人路径规划的多目标优化算法。 本综述编排如下： 第 2 节讨论机器人路径规划技术，第 3 节讨论移动机器人导航建模，第 4 节是讨论。 2. Robot Path Planning Techniques机器人的路径需要优化以满足某些标准，因此路径规划问题是一种优化问题。过去几十年来，优化算法的研究吸引了众多研究人员的关注。优化方法和算法分为确定性和随机性两类 (12]。==随机方法更善于发现各种目标函数的全局最优解，而确定性方法则依赖于问题的数学属性。==相反，随机方法并不依赖于特定函数的数学属性，如参考文献[13]所述。然而，最初的方法也存在一些局限性，包括依赖梯度、容易出现局部最优、在==搜索大规模空间时效率低下==，以及无法处理离散函数。基于随机过程的技术被认为具有更高的用户友好性。由于现实世界中许多优化问题的复杂性，特别是在优化无差别、多模态和离散复杂函数时，随机方法是必要的–这些算法已被发现优于基于梯度的经典方法。这些受自然启发的范式目前正被广泛应用于众多工程领域 [14]。这些技术已被证明是可靠而强大的搜索方法。 多年来，众多科学家和研究人员提出了各种导航方法。移动机器人的导航方法大致可分为两类：经典方法和启发式方法（图 4）。==经典方法存在一些缺陷，导致其在实际应用中效果不佳，包括高维度下的高时间复杂性问题和陷入局部极小值的现象，这些都是该领域的重大问题。==启发式方法优于传统方法，并因 PP 问题的 NP 难度而广受欢迎。启发式技术在解决涉及多维度、复杂工作空间和局部极小值的问题方面也取得了成功，因此越来越受欢迎[15]。在下面的研究小节中，我们将考察一组使用经典方法和启发式方法寻找最佳单目标或多目标路径规划的科研成果。 2.1. Classical Approaches我们将在下文中讨论用于寻找最佳单目标或多目标路径的三种经典方法： 路线图（可视图 [16]；沃罗诺图 [17]）： 如图 5 所示，路线图方法（RM）涉及将自由 C 空间重新制定、缩小或映射到一维工作空间。Salzman 研究了 RM 在自主移动机器人导航中的应用[18]。在规划阶段，机器人的配置空间是随机生成的，会产生特定数量的节点。然后，在确保路径不与任何障碍物相交的前提下，通过直线连接节点对来构建路线图。根据规划阶段获得的结果，查询阶段设计出一条连接初始配置和目标配置的路径。如参考文献[19]所述，对 Voronoi 图的有效路径规划进行了改进，以优化其性能并减少突然转向和扩展环路等问题。如参考文献[20]所述，通过采用一种混合方法，将可视图、沃罗诺伊图和势场技术相结合，确定最佳路径。学者们强调，这种方法无法确定最佳路径，在实施过程中也面临挑战。 Yang 等人（21）采用骨架图和维诺图等技术，有效地制定了路线战略。Wein 等人[22]提出了一种新方法，它将可视图和维诺图整合在一起，以确定最佳路线。==Kavraki 等人在他们的工作（23）中展示了概率在机器人运动中的应用，目的是理解和产生路径规划解决方案。然而，该方法在获得理想路径长度方面效果不佳。Sanchez 等人（24）利用概率路线图方法对概率路径规划稍作修改，改进了最短路径确定方法（PRM），提出了懒碰撞检查策略作为实际路径规划问题的解决方案。==Yan 等人（25）成功测试了无人飞行器在三维环境中的导航能力。这种方法同时使用概率公式和路线图来确定飞行路径。一种在动态环境中避开障碍物的创新路径规划算法被称为 “时间-PRM”（26）。通过在原始概率路线图（PRM）中加入时间概念，该算法创建了一个可有效查询的增强结构。 Huang 等人在（27）中介绍了利用启发式机器人在线路径规划（HIRO）的方法，与传统方法相比，无论机器人是否事先了解环境，该方法都能显著加快发现无碰撞路径的速度。为了快速寻找路径，HIRO 同时采用了知情启发式和确定性路线图。概率路线图（PRM）因其简单易行而被广泛应用于移动机器人导航。==当环境中存在狭窄通道时，概率路线图的效率就会大大降低。==Zhang 等人 [28] 提出了一种改进的基于势场的概率路线图算法。在具有大量复杂约束和高维度的环境中，概率路线图（PRM）可以成功地解决路径规划问题。其缺点是在狭窄空间和动态环境中的路径规划质量和效率较差。最后，You 等人[29] 建议使用动态 PRM 混合势场来规划移动机器人在多维环境中的路径。 单元分解（Cell decomposition CD）[30]： 为了确定连接初始配置和目标配置的路径，无障碍配置空间被划分为一系列单元格。如图 6 所示，在开始单元和终止单元之间建立连接以及随后通过一系列中间单元建立连接决定了单元关系。Samet [31] 和 Noborio [32] 提出了利用四叉树进行分解的方法。大的栅格单元分割环境；然而，当一个栅格单元只填满一部分时，它就会被分解成四个相同大小的小部分，直到填满为止。该系统的缺陷在于，当有新信息（如障碍物的位置）出现时，它无法更新程序，因此在动态环境中效果不佳。==Lingelbach [33] 证明了路径规划的高维静态配置问题是存在的==。他为类似链条和迷宫的机器人平台找到了路径规划问题的解决方案。利用基于 CAD 的数据，Sleumer 等人[34]提出了一种移动机器人的路径规划策略。 Cai 等人 [35]的研究表明，使用传感器的粗糙 cell decomposition 可以将复杂环境中的许多固定目标分成不同的组。在静态环境中，所开发的方法效果最佳，因为它能选择最短的路线并覆盖整个环境。Dugarjav 等人（36）利用基于传感器的 CD 模型仍然适用于处理移动机器人不熟悉的直线工作空间。他们利用 CD 策略和激光扫描机制绕过了不熟悉的位置和物体。==Glavaski 等人[37]提出了一种混合方法，以解决路径规划问题中理论进展与实际考虑之间的差异。为了减少计算费用，他们开发了一种基于 APF 方法的精确 CD 路径规划器。==Tunggal 等人 [38] 介绍了如何利用 CD 和模糊逻辑来实现不确定性环境中的实时运行。 Mark 等人[39]的论文旨在阐明贪婪深度优先搜索算法和利用遗传算法 (GA) 的 CD 技术的机理，目的是规划机械手系统的三维路径。Gonzalez 等人[40] 通过改变图权重、航点计算方法和 CD，对路径进行了定量分析。Wahyunggoro 等人[41]介绍了利用 CD 方法探索三维环境在空中导航问题上的应用。在该方法中，CD 方法和模糊逻辑一起用于引导和控制航空飞行器。[42] 与垂直（VCD）算法相比，径向 CD（RCD）算法能产生更短的路径。==杂乱环境和走廊环境都能从 RCD 算法中受益。RCD 在路径长度和处理时间方面的有效性得到了仿真结果的支持。== 人工势场（APF）： 如图 7 所示，本方法涉及一个配置空间，该空间由两种不同的力组成，一种是排斥力，其作用方式是将机器人从障碍物中驱逐出去；另一种是吸引力，其作用方式是将机器人引向所需的目标配置。Khatib (43) 是 1986 年将 APF 方法引入移动机器人导航的先驱。按照他的说法，目标和障碍物就像通电的表面，机器人受到由它们的势能总和产生的假想力的作用。这个假想力（如图 7 所示）将机器人推向所需的方向，使其不会冲向障碍物。在这里，机器人沿着负梯度绕过障碍物，到达理想位置。Garibotto 等人[44]介绍了这种方法在移动机器人导航中的应用。Kim 等人（45）讨论了一种利用 APF 在未开发环境中避开障碍物的新技术。为了绕过局部最小值的问题，他们使用了谐函数。 Borenstein 等人[46] 提供了另一种解决局部最小条件问题的方法。他们在研究中考虑了机器人的动态导航特性。在参考文献[47,48]中，对动态避障背景下的 APF 进行了研究。通过利用静电定律，APF 方法在某些方面得到了改进[49]，利用静电可以产生势函数并即时确定无碰撞路径。在实时环境中，移动时避开障碍物是一项艰巨的任务；因此，Huang [50] 开发了一种控制速度的方法，以确定障碍物的位置和移动方式。==Shi 等人[51] 提出的 “超强势能 “和 “超强排斥势能 “指的就是这两种功能，以防止局部最小值并达到全局最大值。==Sfeir 等人[52]研究了移动机器人的导航问题，该问题可通过采用振荡和冲突等 APF 技术来解决。他们改变了 APF，使其在目标靠近障碍物时不易发生振荡和产生问题。 Pradhan 等人[53]使用 ROBOPATH 仿真工具测试了人工势场的适用性。人工势场法被认为是最流行的路径规划技术之一。为了解决无法到达目标的问题，文章[54]增强了斥力场函数。当它陷入陷阱时，它会选择一个虚拟目标点来帮助它解脱。文章[55]的主题是将人工势场方法应用于环境数据不可知的静态障碍物。通过 MATLAB 仿真证明，改进后的人工势场方法偶尔可以绕过局部极小值，顺利到达目的地。Shi 等人[56]涉及多智能体编队避障控制，研究了步长对路径规划的影响，并提出了两种使路径更高效的方法。==知情快速探索随机树星（RRT*）算法会进行质量检查，并重新优化采样路径==。Liu 等人提出了一种更有效的 APF 局部避障路径规划算法[57]。根据仿真结果，该算法提高了动态避障的稳定性，改进后的势场法得到的航向角变化减少了 84%。该算法可应用于车辆的实时避障。 随后，又有人尝试改进这些经典方法，如概率路线图（PRM）和快速探索随机树（RRT*）。此外，还出现了结合经典方法和启发式方法的混合方法，以利用两种技术的优势（模拟退火（SA）与人工势场（APF）[58]）。==启发式方法旨在克服传统方法的局限性，如陷入局部最小值的问题。==以下各小节列出了其中一些启发式方法： 2.2. Heuristic Approaches我们将在下文中讨论十一种用于寻找最佳单目标或多目标路径的启发式方法： 遗传算法（GA）： 这是一种著名的基于搜索的优化工具，秉承了 1958 年布雷默曼[59]对遗传学和自然选择的发现。1975 年，Holland [60] 首次将其引入计算机科学领域。机器人导航只是目前广泛应用的众多科技领域之一。机器人导航是科学和技术领域的一项普遍应用。该主题涉及复杂问题的优化，这些问题要求在遵守预先设定的约束条件的同时，实现目标函数的最大化或最小化。这种方法涉及将由具有独特遗传特征的个体组成的群体分配到特定问题中。随后，种群中的每个成员都会被分配一个由目标函数决定的适应度分数。根据个体的适应度值选择个体，并允许个体与后代进行交叉，以确保遗传物质的传递。变异可防止过早趋同，并保持群体的多样性。 如果种群已经收敛，则算法结束。==遗传算法具有一定的随机性，但由于它也可以使用历史数据，因此其性能优于随机局部搜索。==GA 的一般流程图如图 8 所示。机器人技术的难点之一是多机器人路径规划。==Kala [61] 借助 GA 探讨了多移动机器人的路径规划策略。通过他的研究，研究人员开发出一种有效的方法来协调多个机器人，以避免在静止环境中发生碰撞。参考文献[62]对静态环境下的多目标策略进行了说明。==[62] 针对静态环境，类似于多机器人路径规划。Yang 等人[63] 解决了动态环境中多移动机器人系统导航的问题。他们展示了在存在静态和移动障碍物时的结果。一些研究表明，==GA 具有一定的局限性，如收敛速度慢、无法保证获得最优解、选择突变率和种群规模参数的方法繁琐等。== Hong 等人[64]提出了改进的遗传算法路径规划器，其中包含了基于种群的机器人导航协同评估机制。通过应用改进的遗传算法，作者证明了在陌生环境中运行的多机器人系统在避障和路径优化方面的仿真结果得到了增强。建军等人[65] 提出了一种不同的用于路径优化的改进型遗传算法，为了达到最佳效果，他们的方法修改了染色体的长度。GA 方法被用于仿人机器人（66）的二维路径规划以及水下机器人（67）和空中机器人（68）的三维路径规划问题，因为它能有效地适应环境（包括已知环境和未知环境）。==Patle 等人 [69] 针对单机器人和多机器人系统，开发了一种利用二进制代码的基于矩阵的 GA（MGA）来解决移动目标问题。==在这种方法中，机器人可以快速、轻松地跟随移动目标和障碍物到达目的地。 Creaser 等人（70）展示了一个结合了模糊逻辑和 GA 方法的导弹控制演示。在为导弹创建制导法则的过程中，GA 起着至关重要的作用。Lin 等人（71）介绍了一种基于 GA 的军事和海洋监测创新方法。在 GA 的帮助下，他们能够确保关键军事资产的安全，并确定水下传感器网络的最佳定位策略。[72]的作者试图找到一种机器人路径规划问题的解决方案，以解决收敛速度慢和局部最优容易衰减的问题，并提出了一种基于种群多样性水平评估的自适应选择技术。为了证明该算法的可行性和有效性，我们在栅格环境中进行了多次仿真。在改进种群初始化方法后，(73) 采用双向 RRT 算法替换部分种群，以创建精英种群。结果表明，本文提出的精英种群遗传算法弥补了传统遗传算法的缺陷。 蚁群优化（ACO）： 1992 年，马可-多里戈（Marco Dorigo）在论文中提出了这一群体智能算法（74]。为了解决组合优化问题，该算法采用了基于种群的方法。蚂蚁群从巢穴到食物来源的有效导航是 ACO 算法的灵感来源（图 9）。ACO 算法已在许多科学和工程领域得到应用，包括图着色、二次赋值问题、车辆路由、旅行推销员问题、作业车间调度等。关正等人[75]将 ACO 应用于移动机器人的实时路径规划。与 GA 等其他算法相比，ACC 算法在动态收敛行为、解的变化、收敛速度和计算效率等方面都有所提高。Liu 等人（76）介绍了 ACO 在多移动机器人导航中的应用。他们为静止环境中的不同机器人系统提供了一种避免碰撞的方法。为了增强选择性策略，他们使用了一个特殊函数。当蚂蚁遇到死角时，会对轨迹强度施加惩罚函数，以防止机器人的路径无法移动。 Castillo 等人[77] 提出了一种基于 ACO-模糊的混合方法，用于移动机器人在静态环境中的导航。Kumar 等人(78) 提出了一种基于 RA-ACO 的方法，用于仿人机器人在杂乱环境中的导航。他们使用 Petri 网测试了所提出的用于多个仿人机器人实时导航的方法，发现仿真结果与实时结果之间具有良好的一致性。Liu 等人[79]就如何调整当前的 ACO 方法以便在静态环境中更好地工作提出了建议。当蚂蚁趋向于更高的效率子空间时，模式的搜索空间会缩小，沿当前路径的信息素会向势场力的方向扩散。他们结合信息素扩散和几何局部优化找到了最佳路径。Rajput 等人（80）针对动态环境提出了另一种修改方法。为了防止无意义的循环并实现更快的收敛，他们还提出了一种新颖的信息素更新技术。Purian 等人（81）将 ACO 算法应用于未知动态环境中的移动机器人导航。在模糊规则的选择和优化方面，他们使用了 ACO。 Brand 等人在（82）中比较了模拟和真实世界中移动机器人在相同环境下的运行情况。Liu 等（83）提出的水下机器人三维路径规划方案使用了一种基于 ACO 的搜索算法来寻找从一个位置到另一个位置的无碰撞路径。Chen 等人也提出了 ACO 算法（84）。利用强化学习可以解决无人驾驶飞行器在战场上确定最佳路径的问题，从而解决原始蚁群算法搜索速度慢和停滞不前的问题。蚁群算法还被应用于军事硬件。Gao 等人[85]将蚁群算法用于导弹路线规划时，发现其性能有所提高，包括最优路线长度和更快的收敛速度。Zong 等人(86) 建议使用改进的蚁群算法为移动机器人规划路径。该算法的信息素更新机制具有加速收敛的能力。大量模拟实验的结果表明。 通过修改通往目标点的路径，可以显著提高蚁群算法的收敛性 [87]。节点数量减少，更能满足机器人运动的需要。焊接路径的长度直接影响自动线的工作时间和生产效率 [87]。针对传统路径规划方法不适合多目标点的问题，提出了一种基于（ACO）算法的路径规划方法。虽然路径太长，转弯太多 [88]，但基本的蚁群算法（ACO）很容易进入局部最优。改进后的 ACO 会在地图上没有障碍物的区域随机设置可行走的位置点。对于移动机器人，提出了一种基于进化优化的自主路径规划方法。 粒子群优化（PSO）： 这种元优化方法从野生动物（如鱼群和鸟群）中获取群体动力学的线索。它是由 Eberhart 和 Kennedy 于 1995 年开发的[89]，是一种用户群迅速增长的优化工具，用于解决各种工程和科学问题。PSO 模仿社会性动物行为，但不需要群体领导者来完成工作。鸟群在寻找食物时不需要领导者，而是跟随离食物最近的成员（图 10）。通过这种方式，鸟群成功地与种群中的其他成员沟通，从而找到所需的解决方案。PSO 算法由一系列粒子组成，每个粒子都代表一个潜在的解决方案。PSO 现已成为移动机器人导航领域广泛使用的工具。Tang 等人[90]利用多智能体粒子过滤器，处理了移动机器人在未知环境中导航的测绘和定位问题。之所以使用 PSO，是因为它具有更稳定的收敛特性，有助于减少计算量。 为了获得精确的轨迹并防止陷入局部最优，Xuan 等人[91]采用了 PSO 算法与 MADS（网格自适应直接搜索）算法相结合的方法。PSO-MADS 算法与 GA 算法和 EKF 算法相结合，产生了有效的结果（扩展卡尔曼滤波器）。Atyabi 等人[92]创建了区域扩展 PSO（AEPSO）。此外，受时间和变化限制的移动机器人导航问题也可以用 PSO 来解决，该算法结合了基本 PSO 算法和其他优化技术。AEPSO 策略已成功应用于炸弹拆除和幸存者搜救。Tang 等人的[93]挑战环境下的合作运动路径规划解决了多移动机器人系统导航问题。在将 PSO 和多体系统动力学（由加速度、质量、力和惯性等机器人属性组成）都考虑在内的情况下，对所提出方法的容错性进行了研究。对于现实世界中众多移动机器人的导航，Couceiro 等人[94]做了一些修改。他们改变了 PSO 和达尔文 PSO（DPSO）系统，以解决通信和避障问题。他们发现，由 12 个物理机器人组成的系统可将最佳总体性能和最大通信距离提高 90%。 Chen 等人[95]利用多类别分类器为不确定环境制定了可学习的人类专家控制策略。在此背景下，粒子群优化（PSO）算法被用于及时有效地提高精度。与传统的栅格搜索法相比，它具有更高的精度。Li 等人提出的自适应学习粒子群优化（SLPSO）技术，旨在解决复杂环境中机器人路径规划的难题，同时满足各种约束条件。作者最初将路径规划问题转化为多目标优化问题，目的是满足路径长度和碰撞风险最小化以及平稳性最大化的导航目标。在实现这些目标之后，他们又加入了自适应学习机制，以增强粒子群优化（PSO）探索具有众多约束条件的环境的能力。Das 等人[96]为创建有效的路径规划提供了一种混合方法。他们提出了一种使用改进引力搜索算法（IGSA）和 PSO 的混合方法，用于评估杂乱环境中众多移动机器人的最佳行动路线。He 等人的研究[97]探讨了如何利用粒子群优化（PSO）来应对在多元、三维环境中水下环境导航的挑战。该研究采用了 PSO-UFastSLAM 组合方法来提高估计精度和限制粒子大小，从而取得了更好的结果。 粒子群优化（PSO）方法已被用于各类机器人的导航，包括水下机器人、三维未知环境中的空中机器人[98]、仿人机器人[99]和工业机器人[100]。值得注意的是，这些机器人都取得了成功的导航结果。Algabri M 等人[101] 对 GA、PSO、NN 和 FL 等各种导航控制技术进行了比较分析，以确定最佳方法。研究人员得出的结论是，FL 和 PSO 的融合产生了与穿越距离相关的最佳结果。==粒子群优化（PSO）在移动机器人导航领域之外也有潜在的应用，特别是在国防领域。Banks 等人[102]研究了 PSO 在非确定性无人机导航中的应用及其促进无人机间协作的潜力，以保护广大地区免受空中威胁。==文献[103]采用栅格法对环境进行划分，以实现粒子群优化。路径的距离由目标函数来衡量，避开途中的障碍物会受到惩罚。利用粒子群优化解决了涉及紧急车辆和普通车辆的两个路径规划问题。路径规划是当前机器人领域最活跃的研究领域之一。Chen 等人[104]提到了粒子群的局部搜索性能不达标这一问题；因此，可以更快地规划出理想路径，该算法可以在前期和后期提高粒子搜索的质量。Sarkar 等人[105]开发了一种自适应适配函数，解决了三个重要问题，包括避开障碍物和选择更短、更平滑的路径。该适应度函数通过使用粒子群优化（PSO）算法进行优化。 [103] Yuan, D. Research on path-planning of particle swarm optimization based on distance penalty. In Proceedings of the 2021 2nd International Conference on Computing and Data Science (CDS), Stanford, CA, USA, 28–29 January 2021; pp. 149–153.","link":"/2024/01/11/Classical-and-Heuristic-Approaches-for-Mobile-Robot-Path-Planning-A-Survey/"},{"title":"路径规划地图","text":"路径规划地图In robot path planning, various types of maps are used to represent the environment and assist in the navigation process. Each type of map provides a different way to model the space and the obstacles within it, and the choice of map can depend on the specific requirements of the application, such as the complexity of the environment, the level of precision needed, and the computational resources available. Here are some of the common types of maps used in robot path planning: Grid Maps (Occupancy Grids): Represent the environment as a grid of cells. Each cell indicates whether it is occupied, free, or unknown. Suitable for indoor environments and structured spaces. Topological Maps: Represent the environment as a graph of nodes and edges. Nodes represent specific places or landmarks, and edges represent the paths between them. Focus on the connectivity of the space rather than detailed geometry. Geometric Maps: Use geometric primitives (lines, polygons, etc.) to represent the shapes and locations of obstacles. Can provide a more accurate representation of the environment than grid maps. Feature-Based Maps: Constructed using distinct environmental features detected by sensors (corners, edges, etc.). Useful for localization and navigation based on recognizable landmarks. Semantic Maps: Include labels or annotations that provide additional information about the environment (e.g., “kitchen,” “office”). Useful for tasks that require context about the environment, not just geometry. Voronoi Diagrams: Partition the environment based on the nearest obstacle, creating a graph that can be used for path planning. Paths on a Voronoi diagram maximize the distance to the nearest obstacles, which can be useful for safe navigation. Visibility Graphs: Nodes represent the corners of obstacles, and edges represent lines of sight between nodes. Useful for finding the shortest path in an environment with polygonal obstacles. Probabilistic Roadmaps (PRMs): Consist of randomly placed nodes in the configuration space and edges that represent valid movements between these nodes. Particularly useful for high-dimensional spaces and complex environments. Rapidly-exploring Random Trees (RRTs): Incrementally build a tree by randomly expanding towards unexplored areas of the map. Suitable for real-time path planning and exploration in unknown or dynamic environments. Configuration Space (C-Space) Maps: Represent the space of all possible positions and orientations of the robot. Useful for understanding the robot’s movement capabilities and constraints. Elevation Maps: Represent the terrain with a 2.5D map that includes the height of the environment at each point. Important for outdoor robots or those operating in uneven terrain. 3D Maps and Point Clouds: Use three-dimensional models of the environment, often constructed from data collected by 3D sensors like LIDAR. Provide a detailed representation of the environment for navigation in three dimensions. Each type of map has its own strengths and weaknesses and can be used alone or in combination with others to achieve effective path planning for robots. The choice of map is influenced by factors such as the robot’s sensors, the environment’s complexity, and the computational resources available. Grid mapA grid map is a type of data structure commonly used in robotics, computer graphics, and geographic information systems (GIS) for spatial representation and navigation. It is a discretized representation of a space where the environment is divided into a grid of cells, each of which represents a portion of the environment. Here’s how a grid map is typically constructed and used: Discretization: The space is divided into a uniform grid of cells. Each cell corresponds to an area in the environment and can be in one of several states, such as free, occupied, or unknown. Representation: Each cell in the grid can hold different types of information. In the simplest case, a binary value is used, with ‘0’ indicating a free space and ‘1’ indicating an obstacle. In more complex implementations, cells can store additional information such as the probability of occupancy, cost of traversal, or height. Navigation and Pathfinding: Grid maps are often used in pathfinding algorithms, where the goal is to find a path from one point to another while avoiding obstacles. Algorithms like A*, Dijkstra’s, or various other search algorithms can be applied to grid maps to determine the shortest or least costly path. Sensing and Updating: In robotics, grid maps are frequently updated in real-time using sensor data. As a robot explores an environment, it uses sensors like LIDAR, sonar, or cameras to detect obstacles and free space, updating the grid map accordingly. Grid maps have several advantages: They are simple and easy to implement. They provide a clear and intuitive representation of space. They are compatible with many well-established pathfinding algorithms. However, grid maps also have some limitations: The resolution of the grid determines the precision of the map. Higher resolutions can capture more detail but require more memory and computational power. The representation is typically limited to two dimensions, although three-dimensional grid maps are also possible (often called voxel maps). They may not be efficient for large, open environments where much of the space is empty, as they do not compress or scale well in such cases. In summary, grid maps are a foundational tool in areas that require spatial representation and are particularly useful for navigation and path planning in discretized environments. 栅格地图是一种数据结构，通常用于机器人、计算机制图和地理信息系统（GIS）的空间表示和导航。它是空间的离散化表示，其中环境被划分为一个个栅格单元，每个单元代表环境的一部分。 下面是栅格地图的典型构造和使用方法： 离散化： 空间被划分为统一的栅格单元。每个单元格对应环境中的一个区域，可以处于空闲、被占用或未知等几种状态之一。 表示法： 栅格中的每个单元格可以保存不同类型的信息。最简单的情况是使用二进制值，”0 “表示自由空间，”1 “表示障碍物。在更复杂的情况下，单元格可以存储更多信息，如占用概率、穿越成本或高度。 导航和寻路： 栅格地图通常用于寻路算法，其目标是找到一条从一点到另一点的路径，同时避开障碍物。A*、Dijkstra’s 等算法或其他各种搜索算法都可应用于栅格地图，以确定最短或代价最小的路径。 传感和更新： 在机器人技术中，栅格地图经常利用传感器数据进行实时更新。机器人在探索环境时，会使用激光雷达、声纳或摄像头等传感器探测障碍物和自由空间，并相应地更新栅格地图。 栅格地图有几个优点： 它们简单且易于实现。 可清晰直观地显示空间。 与许多成熟的寻路算法兼容。 不过，栅格地图也有一些局限性： 栅格的分辨率决定了地图的精度。更高的分辨率可以捕捉到更多的细节，但需要更多的内存和计算能力。 虽然也可以绘制三维栅格地图（通常称为体素地图），但其表示方法通常仅限于二维。 对于大部分空间都是空的大型开放环境来说，网格地图可能并不有效，因为在这种情况下，网格地图不能很好地压缩或缩放。 总之，栅格地图是需要空间表示的领域的基础工具，尤其适用于离散环境中的导航和路径规划。","link":"/2024/01/17/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%9C%B0%E5%9B%BE/"},{"title":"A Survey of Path Planning Algorithms for Mobile Robots","text":"A Survey of Path Planning Algorithms for Mobile Robots 自动驾驶汽车（AV）有可能大大减少因人类驾驶员的失误和疏忽而造成的车辆碰撞事故。这些自动驾驶汽车必须在时间、距离、能量和其他因素方面安全高效地从 A 点行驶到 B 点。路径规划是确定和评估实现这些目标的合理轨迹的关键。 在执行导航任务时，机器人系统（如自动导航仪）需要利用环境建模、定位系统在环境中的位置、控制运动、检测和避开障碍物以及在从简单到高度复杂的动态环境中移动等能力。导航的四个一般问题是感知、定位、运动控制和路径规划 [1-3]。 其中，路径规划可以说是导航过程中最重要的问题。路径规划是在给定的环境中确定一条无碰撞的路径，而在现实世界中，环境往往可能是杂乱无章的[4]。为了充分利用这些功能，同时实现系统的设计和使用目标，必须确定并实施适当的路径规划技术。通常情况下，性能最佳的技术会因系统类型和运行环境而异。 随着移动视听设备的激增，对路径规划或路径寻找的需求也越来越多，这些功能已成为自主控制领域近期的一个重点领域。由于移动机器人的应用范围广泛，研究人员已开发出有效满足其要求的方法，以克服在杂乱环境中实现完全或部分自主导航时面临的一些重大挑战。 为了简化路径规划问题，确保机器人在杂乱环境中顺利运行/移动，同时避开障碍物，配置空间必须与所使用的算法相匹配。目前存在多种路径规划和路径查找算法，其适用性取决于系统的运动学、环境的动力学、机器人的计算能力以及传感器和其他来源信息的可用性。算法性能和复杂性的权衡也取决于使用情况。 对于新手来说，只选择一种方法是非常困难的，尤其是对于那些没有控制背景的人来说。然而，随着自动驾驶汽车的日益普及，工程师们在没有经过充分培训的情况下被迫承担起这样的角色。本文件旨在总结路径规划的常用基础技术，适合在控制方面专业知识有限的人员使用，并寻求确定探索领域，以支持新的自动驾驶汽车功能。 我们考虑了算法在静态和动态环境中的适用性，并回顾了自动驾驶汽车和机器人技术中常用的路径规划算法，为快速发展的自动驾驶领域的新手从业人员提供了入门指南。本文探讨了具有代表性的算法，但其覆盖范围并不全面，也无意反映自动驾驶汽车路径规划的最新水平。 1. Path Planning路径规划是一个非确定性多项式时间（”NP”）难题[5]，其任务是找到一条连接系统从初始目标配置到最终目标配置的连续路径。问题的复杂性随着系统自由度的增加而增加。要走的路径（最优路径）将根据约束条件和条件来决定，例如，考虑终点之间的最短路径或不发生任何碰撞的最短行进时间。有时，约束条件和目标是混合在一起的，例如，在不使行进时间超过某个临界值的情况下，寻求能耗最小化。 自 20 世纪 70 年代以来，路径规划一直备受关注，多年来，它已被用于解决从简单的空间路线规划到选择达到特定目标所需的适当行动序列等各个领域的问题。路径规划可用于完全已知或部分已知的环境，也可用于完全未知的环境，在这种环境中，系统安装的传感器会接收信息并更新环境地图，为机器人/自动机的预期运动提供信息。 路径规划算法根据可用的环境知识进行区分。通常情况下，机器人/自动机只能部分了解环境。路径规划可以是局部的，也可以是全局的。全局路径规划在环境信息基本完整的情况下寻求最优路径，在环境静止且机器人完全已知的情况下执行效果最佳。在这种情况下，路径规划算法会先生成一条从起点到终点的完整路径，然后机器人才开始按照规划的轨迹运行[6]。全局运动规划是环境穿越的高级控制。 相比之下，本地路径规划通常在未知或动态环境中执行。本地路径规划是在机器人移动过程中，通过本地传感器获取数据进行的。在这种情况下，机器人/AV 能够根据环境的变化生成新的路径。如果存在障碍物，障碍物可能是静态的（相对于已知的固定坐标系，其位置和方向在时间上是不变的），也可能是动态的（相对于固定坐标系，其位置、方向或两者都发生了变化）[6]。 有效的路径规划算法需要满足四个标准。首先，运动规划技术必须能够在现实的静态环境中始终找到最优路径。第二，必须能够扩展到动态环境。第三，它必须与所选的自参照方法保持兼容并增强其功能。第四，必须最大限度地减少复杂性、数据存储和计算时间[7]。本文概述了适用于机器人/AV 的最常用路径规划算法，并讨论了哪种算法最适合静态/动态环境。 2. Path Planning Algorithms本文从 Dijkstra 算法[8]及其变体开始，这些算法通常用于谷歌地图[9]和其他交通路由系统等应用中。为了克服 Dijkstra 算法在盲搜索时的计算密集度，本文介绍了 A* 算法[10]及其变体，它们是在静态环境下使用的最先进算法。 不过，A* 和 A* replanner 是根据环境中存在的障碍物信息进行最短路径评估的，而已知静态环境的最短路径评估是一个两级问题，包括选择可行的节点对和根据获得的可行节点对进行最短路径评估 [11]。上述两个标准在动态环境中都不存在，因此该算法在动态环境中效率低下且不实用。 为了支持动态环境中的路径规划，D* [12] 及其变体作为在杂乱环境中快速重新规划的有效工具得到了讨论。由于 D* 及其变体不能保证大型动态环境中的解质量，我们还探讨了快速探索随机树 (RRT) [13] 和一种结合了松弛 A* ( RA* ) [14] 和一种元启发式算法的混合方法。这种混合方法包括两个阶段：使用 RA* 算法的初始化阶段和使用一种启发式方法的后优化阶段，这种启发式方法可提高前一阶段找到的解决方案的质量。此外，还讨论了三种元启发式算法：即遗传算法、蚁群算法和萤火虫算法。这些算法旨在提供有效的功能，以追求路径规划的混合方法。 我们之所以选择这些算法，是因为它们代表了当代实时路径规划解决方案中使用的基础算法。新的研究以这些算法为基础，寻求更高的性能和效率。因此，所列算法并非详尽无遗，但涵盖了自动驾驶汽车和机器人系统路径规划中常用的几种算法。其他路径规划算法的讨论见 [15]。","link":"/2024/01/31/A-Survey-of-Path-Planning-Algorithms-for-Mobile-Robots/"},{"title":"Improved Heuristics for Optimal Pathfinding on Game Maps","text":"Improved Heuristics for Optimal Pathfinding on Game MapsAbstract随着计算机游戏世界变得越来越复杂，寻路性能瓶颈也变得越来越明显。通常用于指导基于 A∗ 的寻路的启发式函数过于简单，无法在如此复杂的大型游戏世界中为搜索提供必要的指导。这可能会导致 A∗ 搜索为了在两个遥远的地点之间找到一条路径而探索整个游戏地图。本文提出了两种有效的启发式方法，用于估算大型复杂游戏地图中不同地点之间的距离。前一种启发式，即死胡同启发式，可以从搜索地图中剔除与当前查询无关的区域，而第二种启发式则使用所谓的网关来改进其估计值。在实际游戏地图上进行的经验评估表明，与标准的八分距离度量法相比，这两种启发式方法都能显著降低 A∗ 搜索的探索复杂度和时间复杂度。 Introduction现代计算机游戏世界的规模和复杂程度逐年增加，这既体现在地图的大小上，也体现在世界中存在的单位数量上。例如，在即时战略（RTS）游戏中，可能有数百个单位同时在世界中航行。为所有这些单位实时计算路径对计算要求很高，可能会消耗掉为游戏逻辑预留的大部分可用 CPU 资源。在 RTS 游戏中，寻路查询还用于回答计算机控制的人工智能提出的各种战略问题（例如，距离特定资源有多远，或敌人可以从哪里发动攻击）。因此，在现代游戏中，使用高效（并经过仔细实施）的算法进行寻路计算至关重要。A∗ 算法（Hart、Nilsson 和 Raphael，1968 年）是游戏寻路事实上的行业标准。虽然不同游戏的状态空间表示可能不同（网格或网状都很常见），但 A∗ 搜索或其变体通常是首选算法。通常使用简单有效的启发式来指导搜索。例如，在基于网格的地图中，通常使用八分距离（曼哈顿距离的扩展，允许对角线移动）。然而，随着游戏地图变得越来越大、越来越复杂，这种简单的启发式方法无法提供足够有针对性的指导，导致在两个遥远的地图位置之间寻找最短路径时，搜索经常会探索几乎整个地图。 克服这一问题的一种技术是分层寻路。这种方法不是只使用单一的状态空间表示法，而是同时使用更高层次的抽象表示法。层级结构中的每一级都会使用越来越抽象的游戏地图视图，随后可以使用更小的状态空间来表示。在回答寻路查询时，会在其中一个高层中找到近似路径（然后可能会在基础层中使用小范围局部搜索进行细化）。由于 A∗ 搜索的状态空间更小，因此处理速度更快。这种方法的主要缺点是返回的路径不一定是最优的。这是因为在抽象过程中，通常会丢失地图的一些细节。不过，如果路径只是略微次优，这通常对游戏性影响不大。幸运的是，大多数情况下都是如此。然而，随着地图上单位和其他动态障碍物数量的增加，路径变得严重次优的风险也会增加。这是因为在抽象状态空间中进行的搜索通常不会（也无法）考虑这些动态障碍。 我们在本文中提出的方法在减少状态空间探索的同时，还能考虑动态障碍。我们不是利用状态空间抽象来创建分层视图，而是利用它来提供改进的启发式函数，以指导常规 A∗ 搜索。我们面临的挑战是==如何设计出既能高效计算，又能大大改进搜索引导的启发式方法。==我们引入了两种这样的新启发式，它们都是可容许的，因此保持了最优性。 本文的主要贡献有 改进了用于指导（游戏）地图寻路搜索的可接受启发式方法–我们在实际游戏地图上的实验表明，使用新启发式方法进行的 A∗ 搜索，无论从节点扩展还是从总搜索时间来看，都大大优于标准的八邻域距离启发式方法； ==2) 一种将游戏地图自动分解成较小区域的算法方法；该方法不仅有助于为我们的新启发式方法创建抽象视图，还有助于创建一般的分层寻路技术。== 下一节我们将介绍新的启发式函数，并提供详细示例和伪代码。下一节将介绍自动地图分解，随后将总结利用真实游戏地图对启发式方法进行广泛实证评估的结果。最后，我们总结并讨论了未来的研究方向。 Improved Heuristics图 1 中的地图描绘了一个典型的角色扮演游戏室内场景。这个世界由多个房间组成，房间之间通过门和走廊相连。最先进的游戏地图一般会更大更复杂，但为了便于演示，我们将使用图中的地图。 在地图上寻找两个遥远地点之间的最短路径时，==基于八英里距离的天真启发式会或多或少地探索地图上的所有地点。这部分是由于它无法事先知道是否存在一条穿过任何给定房间的路径，可以通往到达所需目的地的捷径。==为了更好地说明这一点，我们在地图上用深灰色标出了 A∗ 使用八分启发式在相距较远的两个地点之间寻找最优路径时探索到的所有地砖。最佳路径以深灰色显示，起点在左边，目标在右边。该算法花费了大量精力探索那些我们一眼就能看出不可能相关的区域，因为这些区域要么是死胡同，要么是明显劣质的路径。 本文提出的两种启发式方法的理念是通过事先识别并排除两个给定地点之间不可能在最佳路径上的所有区域（在我们的例子中是房间）来缓解这一问题。前者，即死胡同启发式，避免了通往死胡同的区域，而后者，即网关启发式，则更进一步，认识到穿过某些房间只能通往次优路径。接下来的两个小节将分别介绍死胡同启发式和网关启发式。启发式计算分为两个阶段。第一阶段是对地图进行预处理并创建抽象视图。==具体方法是自动将地图分解成较小的区域，然后计算路径信息。这种计算是离线完成的，每张地图只需计算一次。==在第二阶段，来自预处理阶段的抽象视图被用来为寻路搜索得出改进的启发式估计值。启发式是实时计算的，因此效率非常重要。 Dead-End Heuristic死胡同启发式可以立即判断出搜索是否进入了一个最终通向死胡同的房间，也就是说，从这个房间没有通向目标的路径（除了从我们进来时的入口出去）。显然，我们没有必要探索这样的房间。 预处理阶段 ==预处理阶段分为两个步骤==。第一步，将游戏地图分解成几个较小的区域，在本例中代表房间和走廊。在此地图上运行分解算法的结果如图 2 左侧所示。 这一阶段的第二步是构建一个高级图，用于表示不同的区域和它们之间的相互联系。图中的节点代表一个区域，节点之间的边代表两个相应区域之间的入口。请注意，连接同一两个房间的入口可能不止一个，因此图中连接一对节点的边也可能不止一条。因此，该图是一个所谓的无向多图。该图与区域信息一起存储在游戏地图中。 运行阶段 当地图加载到游戏中时，预处理阶段的数据也会随地图一起加载。这确实会导致一些额外的内存使用，但只要仔细实施，就能将内存使用量降到最低。 当我们收到寻路查询，要求找出起点和目标位置之间的最短路径时，会进行两次搜索。首先是在多图中进行搜索，以确定地图中与查询相关的区域子集；其他区域，即所谓的死胡同区域，可以完全排除在寻路搜索之外。让多图中的节点 S 和 G 分别代表地图中的起点和目标位置区域。我们在多图中搜索从节点 S 到节点 G 的所有可能路径，以确定相关区域。需要注意的是，在搜索过程中，我们需要标记所有已经访问过的边，以防止出现循环和其他重复搜索工作。事实证明，简单的深度优先搜索在这项任务中最为有效，这是因为多图非常小，而且我们必须找到所有可能的路径。 一旦我们确定了相关区域的子集，就会执行类似 A∗ 的常规寻路搜索。唯一不同的是，我们使用了一个改进的启发式函数，对于位于非相关区域的网格单元，该函数会返回一个无穷大的值。这样做非常有效。每个网格单元都标有所属区域（使用了几个额外的比特），因此我们可以在恒定时间内琐碎地询问该区域是否相关。死胡同启发式的主要优点之一就是计算效率非常高。 这种方法与分层寻路有着本质区别，因为我们并没有事先确定任何高级路径。例如，在分层寻路中，如果高层路径被动态障碍物阻挡，通常要到路径跟踪阶段才会被注意到，搜索可能不得不重新执行。而在我们的案例中，其他可能的路径都是开放的，如果存在另一条路径，A*搜索也会找到。 这种方法能否有效减少对状态空间的探索，在很大程度上取决于地图的结构。一方面，对于主要由通过相对较少的可能路径连接的区域组成的地图，这种简单的启发式方法有可能带来显著的改进。然而，可供选择的路径越多，启发式的效果就越差。例如，如果我们在示例地图的顶部房间开辟一条新的路径，那么死胡同启发式就只能从搜索中排除几个小区域。 此外，在自动分解地图时也需要小心谨慎，因为如果生成的区域太小，抽象多图就会变得很大。这样一来，多图搜索的开销就会变得很大。当然，在实时情况下，可以通过预处理所有相关的面积计算来避免这种开销，不过要付出额外的内存使用代价。 我们接下来介绍的启发式方法不存在上述问题。 Gateway Heuristic网关启发式会预先计算区域出入口之间的距离。它也分两个阶段进行。 预处理阶段 地图分解成区域的方法与死胡同启发式相同。我们将区域之间的边界定义为网关（或大门）。网关的大小可以是任意的，但我们分解算法的一个缺陷是它的方向总是水平或垂直的。接下来，我们使用多次 A* 搜索来预先计算门之间的（静态）距离。对于每个网关，我们都会计算其与所有其他网关的路径距离（如果不存在路径，则成本为无穷大）。或者，我们也可以只计算每个房间内网关之间的距离，然后在运行时使用小规模搜索来累计总成本。不过，我们的方法能带来更准确的启发式估计和更快的运行时间访问（当然，代价是额外的内存）。 我们的方法的一个重要元素是为每对网关存储四种不同的成本。每个关口都是双向的，因为我们想知道从关口出发和到达关口的每种可能性的不同距离。与只计算一个成本值相比，这能在运行时大大提高启发式估算的准确性。因此，我们需要对每对闸门进行四次单独的预计算寻路搜索（这是离线完成的，因此额外的时间并不重要）。在这些寻路搜索中，我们不允许通过出发和到达的闸门。 运行阶段 运行阶段是使用下面启发式函数的常规 A* 搜索： 启发式 hl(n, G) 计算网格单元 n 到门 G 中最近点的八分距离。这可以简单地计算为一个点到水平线/垂直线的距离。术语 H(Gi, Gj) 代表预先计算出的闸门 Gi 和 Gj 之间的最短距离（实际上，我们还必须通过闸门方向，但为了清晰起见，我们在这里省略了这一点）。我们需要查看当前区域的所有大门，并将每个大门与目标区域的所有大门进行比较，然后取最小成本。 网关启发式的准确性和计算效率与网关总数无关（尽管会影响内存使用）。启发式估算的计算效率主要受我们所经过区域，尤其是目标所在区域的门数量影响。这是因为在每个状态下，我们都会在所有门对中选择最小估计距离，前一个门在当前房间，后一个门在目标房间（见启发式函数方程）。另一方面，启发式的准确性受到两方面的影响：房间的形状和各个门的大小。由于我们使用八分启发式来估计当前状态（和目标）到最近的门的距离，因此很容易出现八分启发式带来的低估误差。不过，由于估算的距离通常较短，这些低估误差不会对整体距离估算产生重大影响。此外，我们的区域分解算法倾向于将地图分割成凸面区域，而八分启发式会在这些区域内给出准确的估计值。另一种低估与门的大小有关。在计算从一个州到一个门的距离时，我们总是使用门上最近的点来确保可接受性。这并不一定是我们在闸门距离预计算中使用的同一个闸门点。这两点之间的距离是造成低估的一个原因。闸门越大，这两点之间的距离就越远。 Decomposition Algorithm将地图划分为区域的算法是一种洪水填充算法。该算法无需输入边界，而是在遇到满足特定条件的地块时自动建立边界。该算法无需输入任何其他信息，只需输入基于地砖的地图，以及每个地砖是否可通行的信息。输出是每块瓦片的信息，说明它属于哪个区域（或无法通过）。 分解方法的伪代码如算法 1 所示。在创建区域时，算法首先找到最左上方可通行且尚未分配到区域的瓦片。从该瓦片开始，算法开始向右填充，直到填充到非空闲瓦片为止。之前分配的瓦块和无法通过的瓦块都被视为非空闲瓦块（第 9-15 行）。然后，算法开始下一行，使用与右侧类似的停止标准尽可能向左选择一个起点（第 27-36 行）。然后再开始向右填充，重复上述过程。 该算法会检测一行之间的左右边界是扩大还是缩小（第 17-26 行和第 37-42 行）。如果边框在缩小后重新增长，该区域的填充就会停止（可能需要撤销最后一行的填充（第 20-24 行））。 图 4 举例说明了分解算法的工作原理。左上方的图片显示的是一张未分割的地图，右边的图片中已经开始了洪水填充。第四行已经停止，因为该区域向上打开。在这种情况下继续前进是不明智的，因为这条线将直接穿过另一个潜在区域。这就是算法第 12 行的停止条件（(x + 1, y - 1) 6= f ree）。在左下方的图片中，算法已经完成了对区域的填充。在紧接着区域下方的一行中，算法有机会将区域向右扩展。但是，由于区域已经从右侧开始缩小，而且禁止再生长，因此区域填充停止。这就确保了区域具有相当规则的形状。在最后一张图片中，又有两个区域进行了类似的填充。 Empirical Evaluation我们在计算机游戏地图上运行了新的启发式方法，评估了这些方法的有效性，这些地图既有我们自己制作的，也有从流行的商业角色扮演游戏中提取的。所有实验均在 3.0 GHz CPU 个人电脑上运行。 表 1 显示了我们的寻路实验结果，其中对 octile 和两种新启发式方法进行了比较。在每张地图上，使用随机选择的起点和目标位置进行了 1000 次搜索。上半部分包括搜索我们的演示地图（图 1）所获得的实验数据，中半部分包括搜索热门游戏《光头之门 II》中九张不同地图所获得的数据（图 5）。在最后一部分，我们分别展示了同样来自《博德之门 2》的一个特别大的游戏地图的数据（图 6）。水平和垂直移动的成本为 100，而对角线移动的成本为 150。 在所有类型的地图中，新启发法在节点扩展数量和总运行时间方面都明显优于标准八进制启发法。总的来说，网关启发式是最好的。我们还可以看到，计算死胡同启发式的时间开销几乎可以忽略不计，因为节省的时间与节省的节点数大致相当。这是因为多图路径是预先计算好的。对于网关启发式而言，节点的减少尤为显著。然而，搜索时间并没有随着节点数量的增加而相对减少。这是由于新的启发式函数比计算八分距离复杂。尽管如此，所节省的时间还是相当可观的，而且在精心实施后还能进一步提高。 我们还有兴趣仔细研究启发式方法在较长的路径上的表现。前 10%部分给出了长于平均路径的结果（我们为每张地图随机生成了 10,000 条路径，其中包括最长的 10%）。现在，新启发式方法的性能提升更为显著。我们还想看看网关启发式估计值与真实路径长度的接近程度。 Conclusions我们提出了两个新的可接受启发式函数，用于指导大型游戏地图寻路中的启发式搜索。这些启发式方法的初步结果很有希望。这两种启发式方法确实优于大多数现代游戏中使用的标准技术。不过，在得出任何具体结论之前，我们希望在更多地图上进行更全面的实验评估。很明显，随着游戏地图的不断增加，像这里讨论的启发式方法将变得非常必要。 我们在实施方面仍有改进的余地，也许更重要的是，在改进启发式估计方面也有改进的余地。关于如何继续这项研究，我们有几个想法。其一是进一步研究区域分解算法，使其更好地适应各种不同类型的地形。","link":"/2024/01/23/Improved-Heuristics-for-Optimal-Pathfinding-on-Game-Maps/"},{"title":"Hierarchical and smoothed topographic path planning for large-scale virtual simulation environments","text":"Hierarchical and smoothed topographic path planning for large-scale virtual simulation environments作者：Caroline Chagas , Eliakim Zacarias , Luís Alvaro de Lima Silva , Edison Pignaton de Freitas Hierarchical pathfinding 、Path smoothing、 Terrain topography、 Agent-based simulations、 Simulation systems ABSTRACT虚拟仿真系统应充分利用智能体的逼真行为，让用户感觉沉浸在模拟真实世界环境的虚拟场景中。基于智能体的仿真通常用于培训和教学目的，在开发计算机游戏时经常探索的人工智能解决方案需要考虑更多的要求。为了提供模拟智能体如何在真实世界地形中导航的宝贵印象，关键要求之一是在路径规划任务中需要考虑地形特征。这意味着所使用的寻路算法必须正确处理智能体导航能力的重要方面。在最先进的仿真系统中考虑大规模地形场景时，这个问题更具挑战性，因为在处理搜索空间较大的地形表征时，路径规划可能过于耗时。为了应对为插入基于仿真的学习环境中的智能体计算安全且真实的路径解决方案这一挑战，本研究讨论了一种名为 HPA Theta* 的分层寻路算法，展示了在处理大规模真实世界虚拟地形中的路径规划时，如何在合理的计算时间内计算地形起伏感知的平滑路径。通过使用不同的模拟真实世界虚拟地形，利用大规模虚拟地形表示进行了广泛的实验活动，验证了该建议。实验结果表明，与其他类似的路径规划算法相比，所提出的方法能够有效地解决目标问题，并显示出更好的效果。 1. Introduction大规模真实虚拟地形中的寻路对于开发基于智能体的仿真系统至关重要（Abar, Theodoropoulos, Lemarinier, &amp; O’Hare, 2017; Abar et al.） 在虚拟地形场景中，仿真智能体应具备规划和执行不同类型导航任务的能力，以实现所需的基于仿真的训练目标。当涉及到智能体在真实世界地形环境的虚拟表征中进行路径规划计算时，不同的地形特征可能会阻碍模拟智能体的导航任务，或者干脆使这种自主运动完全不可能实现（Abd Algfoor, Sunar, &amp; Kolivand, 2015）。为了应对不同地形特征可能带来的智能体导航风险（如模拟车辆因丘陵地形特征而翻车和撞车），必须探索增强型路径规划算法，以保证智能体模拟的完整性和真实性（Brondani、de Lima Silva、Zacarias &amp; de Freitas，2019）。 通过对文献中发现的不平整地形寻路问题的分析，这项工作的贡献在于提出了 HPA Theta* 寻路算法。==该算法解决了与所代表的地形起伏倾斜特征相关的问题，在起点和目标位置之间寻找最直的可能路径和低成本路径。==在此过程中，它==考虑了智能体的移动限制，对分析路线中的微小偏差进行了平滑处理，避免了陡峭的地形倾斜阻碍模拟中智能体的安全移动==。此外，HPA Theta* 算法还能在一定的响应时间内提供路径结果，即使是在大规模虚拟地形中计算出的长距离路径也不例外。这对于保持模拟的逼真度以及用户沉浸于模拟培训活动中至关重要。HPA Theta* 算法采用分层方法进行路径规划，可以更好地探索仿真系统中不规则和分层地形的结构。 本工作是对 Brondani 等人（2019 年）所做工作的延伸，其动机是作为 SIS-ASTROS 项目（SIS-ASTROS，2014 年）的一部分，虚拟战术仿真系统在不同方面不断发展和改进的路径规划需求。结合不同的技术，提供更逼真的寻路方法，以支持增强型仿真系统的构建，从而带来诸多益处，这项工作的贡献如下： (1) 安全路径，尊重目标智能体的参数化运动限制。因此，所提出的 HPA Theta* 算法可以计算出平滑路径，避开陡峭的地形区域，而这种地形倾斜可能会给模拟智能体的导航带来风险； (2) 高质量路径，因为该算法在平滑路径的同时还处理了路径的地形成本。这意味着所提出的 HPATheta* 算法在最短路径和最低成本路径之间取得了平衡，从而降低了在不平坦地形区域导航的难度； (3) 即使在处理大规模虚拟地形时，也能优化执行时间。这是因为建议的解决方案将地形表示（即使用 QuadTree 结构）和路径规划的分层方法与前两项提到的优点结合起来。 为评估所提出的技术，在 SIS-ASTROS 模拟器使用的不同真实世界虚拟地形场景中进行了实验。需要强调的是，用于构建这些虚拟地形场景的地图都是真实世界的地图。实验使用寻路响应时间和路径成本值作为评估指标，将所提出的算法与文献中提出的其他分层寻路算法和基于平滑的寻路算法进行对比。此外，还对每种地形的实验结果进行了深入讨论，并对所有地形的实验结果进行了交叉分析。讨论还包括对 HPATheta* 算法分层特征相关性的分析。讨论最后分析了所建议技术的效率和准确性。 本文接下来的内容安排如下： 第 2 节介绍本文所要解决的问题。第 3 节回顾了寻路技术的背景概念和相关工作。第 4 节介绍了地形浮雕信息和大规模虚拟地形的表示结构。第 5 节解释了如何根据地形倾斜信息计算拟议寻路解决方案中使用的路径成本。第 6 节介绍了建议的 HPATheta* 算法。第 7 节介绍了实验并报告了获得的结果，第 8 节是本文的结论部分，为今后的工作指明了方向。 2. Problem statement计算机仿真系统和计算机游戏在为用户提供虚拟场景方面有某些相似之处，除此之外，前者还提出了更多地形表示方面的挑战，特别是与使用真实世界地形数据有关的挑战。在最先进的仿真系统中，大规模地形必须在虚拟场景中建模，这就要求地形表示结构更加优化（Brondani et al 2019). 这种大规模的真实世界地形最终需要对模拟目的的目标地形特征进行优化表示和处理，从而使图形三维可视化算法和人工智能（AI）算法的计算不会受到负面影响。 从人工智能的角度来看，在这些大型虚拟地形中运行的寻路算法（Abd Algfoor 等人，2015 年）往往需要处理极其庞大的搜索空间，这很可能会影响在所需响应时间限制内计算不同类型的路径。==在基于计算机的培训活动中，在一定的处理时间限制（建议响应时间低于 1 秒（Nielsen，1994 年））内获得路径规划结果至关重要。==这是因为这些有时间限制的反应不会对模拟训练的流畅性和真实度产生负面影响。此外，在处理大量沉浸在模拟中的智能体时，受时间限制的路径规划任务不仅对最先进模拟系统的开发，而且对许多其他应用的改进计算解决方案的开发提出了更艰巨的人工智能挑战。 在复杂的模拟环境中（如 Hawe、Coates、Wilson 和 Crouch，2012；Heinze 等人，2002；Murphy 和 Perera，2002），依赖于大规模虚拟地形的模拟器通常必须对具有不同运动能力的多个智能体进行建模，其中一些智能体能够在陡峭的地形缓解倾斜中导航，而另一些则不能（Brondani、de Freitas 和 Silva，2017）。为了向用户提供有效的模拟学习，模拟器应能尽可能真实地模拟智能体的导航行为。如果模拟不符合这一要求，就有可能因用户沉浸于真实世界的虚拟场景而降低预期的模拟培训效益（例如，Fletcher，2009；Frutos-Pascual &amp; Zapirain，2015）。例如，在 SIS-ASTROS 模拟器中，模拟目标之一是训练用户选择最佳地形位置来移动一组模拟车辆。如果模拟器不能让这些车辆沿着不同的地形特征进行真实的移动，用户就会从模拟中得到错误的反馈。由于在这种不真实的虚拟仿真中进行训练活动，当用户需要在实际情况中应用所获得的仿真知识时，他们很可能会做出不知情的、可能是错误的决定。无论仿真系统是否打算实现其仿真培训目标，都应避免这种情况。 特别是在模拟智能体探索路径的算法方面，模拟系统行业中使用的大多数算法都热衷于返回起点和目标地形位置之间距离较短的路径。虽然在许多电脑游戏场景中，这些结果足以达到预期的娱乐目的，但模拟问题在于，这些路径往往与模拟智能体在现实世界中选择的路线并不相似。除其他方面外，这些路径没有根据目标智能体的特定导航能力进行调整，这可能导致导航行为无法在虚拟仿真环境中捕捉到预期的真实世界中的智能体特征。在实践中，这可能会导致错误的智能体导航行为，如模拟车辆翻车（和撞车）、爬陡峭的山峰等。 有鉴于此，本文所要解决的问题==是如何在可接受的响应时间内，在大规模虚拟地形上计算出逼真的路径，以达到虚拟仿真的目的。==模拟智能体的路径规划算法需要根据地形起伏特征进行调整，即避开静态障碍物并尊重地形地貌，同时提供尽可能短的安全路径。==考虑到地形起伏，生成的路径应尽可能接近现实生活中的路径选择，避免不必要的路径曲线和/或 “之 “字形导航行为==，因为当路径规划算法在计算中严格避开所有其他地形起伏特征时，就会产生这样的结果。最后，生成的路径应为模拟智能体返回安全的导航路线，防止出现意料之外的智能体导航事故，而这些事故并不属于预期模拟的一部分。如何将这些特点结合起来是一个重要的研究课题，本作品将对其进行研究。根据所提出的建议，本工作范围之外的其他寻路问题也值得研究，如带有动态障碍物的寻路问题。 3. Background and related work本研究提出的寻路方法基于不同的技术，旨在将路径成本处理、路径平滑和优化寻路响应时间等优势结合起来。因此，本节将回顾这些技术的背景概念，同时讨论相关工作。 3.1. The exploration of the hierarchical approach for pathfinding在人工智能领域（Nilsson，1998 年），人们对 A* 寻路算法系列进行了大量研究（Abd Algfoor 等人，2015 年；Souissi 等人，2013 年）。A* 算法采用启发式方法来安排地形结构节点的处理顺序。考虑到评估地形节点（n）的优先级，该算法基于以下成本函数：f(n) = g(n) + h(n)，可描述如下： g(n)：它是评估当前节点（n）成本的函数； h(n)：这是一个估算从当前节点（n）到目标的成本的函数。该函数进行 “启发式”（h）评估，近似于精确的成本评估。 f(n)：它是 g 和 h的总和，是给定节点（n）的总体成本评估结果。 A* 算法的效率是最优的，没有其他最优算法能保证在地形表示图中展开更少的节点（Dooms，2013；Souissi，等人，2013）。虽然 A* 算法在实现计算机游戏中角色的路径规划功能方面得到了广泛的探索（Huang，2020；Kapi、Sunar 和 Zamri，2020），但随着搜索空间的大小和虚拟场景中智能体数量的扩大，其计算成本可能会变得过高。在这种情况下，分层地形表示技术通常与寻路方法相结合，以处理大规模和复杂的虚拟地形环境，主要用于开发现实生活中的模拟应用（Brondani 等人，2019）。 分层寻路技术旨在减少使用标准 A* 寻路算法确定路径所需的计算时间。这些技术通常使用地形表示的分层抽象。这些抽象为同一虚拟地形创建了不同的表示层次，其中低层次层次通常能更准确地表示地形特征。与此相反，使用较不详细的表征会导致搜索空间更简单，其中存在较大的地形表征单元。实际上，==与使用更详细的地形表示结构相比，更简单的搜索空间能让寻路算法执行得更快。==在分层寻路研究领域，Botea、Müller 和 Schaeffer（2004 年）提出了分层寻路 A* (HPA* )。==其目的之一是降低与由规则网格表示的地形结构相关的寻路复杂性。==具体做法是将地形图抽象为预先计算好的簇。然后将这些簇分组，形成更大的簇。HPA* 找到抽象路径后，会对该路径进行细化，并将其作为搜索过程的结果返回。==为了优化路径规划算法在大规模地形结构中执行时的响应时间，建议的工作采用了这种分层寻路方法。== 在另一项工作中，Sturtevant（2013a）介绍了部分重构 A* (PRA* )，旨在以路径质量的小幅下降为代价加快寻路过程。在 PRA* 中，虚拟环境被细分为若干小块。相邻的瓦片形成小块，小块被组合起来，形成更抽象的地形表示层次。这一过程一直持续到用一块地砖代表整个地形环境为止。PRA* 算法在抽象地形表示层上执行搜索，直到找到抽象解决方案。在向下投影到地形表示的较低层次后，该粗略路径解决方案将在这些较低层次上进行细化，返回到虚拟地形的原始离散化。 除了将分层方法应用于地形表示网格结构外，==Pelechano 和 Fuentes（2016 年）还提出了一种探索导航网格结构的分层寻路方法。==其中，预处理阶段从多边形导航网格开始。该网格代表了三维环境的一个抽象分区。第一个导航回路被视为层次树的最低层。层次结构中的其余层级是通过递归方式将较低层次的图形划分为特定数量的节点来创建的。分区一直执行到最高层图形无法再细分为止。这样，就从表示多边形网格的输入图形中创建了小图形。虽然寻路是基于 HPA* 算法（Botea 等人，2004 年），但它已被调整为在名为 “分层导航网格图 “的表示结构中工作。在寻路过程中，起点和终点被插入搜索层次的所需层次。然后将它们连接到最高层。搜索在最高层次进行，并在此提取最佳子路径。虽然 Botea 等人（2004 年）提出的算法也采用了分层方法，但其执行结构与本研究提出的方法相似。 在 HPA*中，地形图被抽象为若干个簇，通过抽象搜索在大簇中找到 “最粗 “的路径。然后，建立一条具体路径，它是在每个簇中搜索得出的细化路径。==正如 Botea 等人（2004 年）所描述的那样，这种技术降低了搜索的计算成本，生成的路径与理想路径的差距在 1%以内==。虽然这种分层方法可以与不同的地形表示拓扑相结合，但它需要预先计算地形簇。 预处理方法见图 1。如图 1a 所示，一旦确定了集群，就有必要对每个网格内的路径进行预处理。确定每个簇的内部值后，就可以检测连接这些簇的边界节点（图 1b）。 一旦执行了分层算法，就会根据起点和终点发现初始地形簇和最终地形簇，因为它们都包含在各自的簇中。然后，从集群到集群，发现所有应计算的路径连接（图 1c）。发现与路径相关的集群后，在每个集群内部执行标准寻路算法，从而形成路径（图 1d）。一旦使用了这些经过预处理并存储在内存中的地形表示信息（作为地形图离线预处理任务的一部分），路径搜索时间就会比运行时执行点对点寻路算法所需的时间减少。 正如 van Elswijk、Sprinkhuizen-Kuyper 和 Wiedijk（2013 年）所提出的那样，目前这项工作中提出的建议详细介绍了一种分层算法，该算法还依赖于路径平滑技术，为模拟智能体的导航任务提供更具真实性的路线。 3.2. Path smoothing寻路算法返回的路径将地形表示结构中的连续点（或节点）连接起来。一般情况下，这一过程会产生一段相对较短的路径。例如，A* 算法找到的路径是由连接相邻节点和相邻节点、从起点位置到终点位置的线段组成的。有时，这些连接会导致路径蜿蜒曲折，出现可以避免的小曲线。在许多模拟虚拟环境中执行的智能体运动中，与现实中的智能体形成的运动相比，遵循这种小曲线可能显得不切实际。在许多应用中，当智能体以最直接的方式向目的地移动时，就会出现逼真的移动行为。为了解决路径曲折和不真实的问题，可以在路径规划算法返回路径后执行平滑技术。 路径平滑算法可以消除生成路径上的多余点。只要没有需要避开的障碍物或不可导航的节点，这种情况就会发生，从而防止形成不需要的曲线的路径点被移除。图 2 展示了平滑的思路，只要路径上没有障碍物，就可以消除最终路径上的多余点。 Thorpe 和 Matthies（1984 年）采用了对 A* 算法返回的路径进行后处理平滑的方法。后处理平滑通常返回虚拟地形所使用的表示结构中可能的最短路径。虽然在执行这种平滑处理时路径长度可以减少，但寻路算法的总执行时间会增加。为便于比较，图 3 举例说明了最短路径、在搜索算法的每个步骤中使用网格的每个节点找到的路径，以及执行后处理平滑后找到的最短路径。 Botea 等人（2004 年）提出了一种平滑算法（算法 1）。该算法检查哪些属于路径的点或节点可以移除，用一条直线取代这些中间路径点之间的连接。该过程从解决方案的一侧开始。对于解中的每个节点，都要检查用直线到达后续路径节点的可能性。 如果是，两个节点之间的线性路径就会取代最初的次优路径节点序列。如算法 1 所示，后处理算法的输入是原始寻路算法返回的路径。一个名为𝑘的计数变量从 0 开始，作为参数接收的初始路径节点被分配为新平滑路径的输入节点。之后，会执行一个循环，以验证是否有可能直接追踪路径到下一个路径点，从而消除不必要的节点。这可以从算法 1 的第 5 至第 7 行观察到。如果看不到下一个路径节点，即路径受阻，无法直接到达循环中的下一个节点，则更新新路径的节点计数器。这种更新会使计数器增量，并在平滑路径中添加一个新节点。这样，计数器索引中的节点就接收到了输入路径的节点，即循环中正在验证的节点，在本例中就是𝑆𝑖。重复循环检查从输入路径起点到倒数第二个路径节点的节点。最后，平滑路径计数器递增，并将输入路径的最终节点分配给正在寻找的平滑路径的最终节点。这样，就能保证到达最终节点并返回后处理路径。与上述著作一样，本文提出的算法会从路径搜索算法返回的路径中删除可能不必要的点。在此过程中，该算法会检查路径障碍物和其他地形起伏特征，这些可能会阻碍沉浸在模拟场景中的智能体的自主导航模拟。 Theta* 算法（Nash、Daniel、Koenig 和 Felner，2007 年）使平滑成为可能。正如当前工作中所研究的那样，该算法还可以进行调整，以便在生成的路径中处理地形的倾斜度。Theta* 算法由 A* 算法发展而来，在将路径扩展到地形表示结构的下一个相邻节点时，Theta* 会检查是否有可能从当前节点的父节点追踪到算法打算扩展路径的相邻节点。Theta* 结合了在可见度图中搜索路径的 A* 思想和在网格结构中应用 A* 的思想。与 A* 算法不同的是，在更新成本 𝑔 和可见的未扩展邻节点的父节点时，Theta* 会考虑两种寻路可能性。其中一种是 A* 算法的路径，它考虑的是从初始节点到当前已验证节点的路径（𝑠），以及到其邻居节点的直线距离（𝑠′）[= dist(s, s’)]。第二种方案考虑的是从初始节点到当前节点的父节点的路径。在此基础上，算法会检查是否有可能形成一条从父节点到可见邻居的路径[= dist(parent(s), s’)]，考虑的是直线距离。重要的是，当当前节点的父节点与可见邻居节点之间有一条视线时，第二种选择是可行的。有这样的视线意味着在观察节点（当前节点的父节点）和被观察节点（可见的邻居节点）之间没有任何阻碍从父节点到邻居节点的路径搜索的节点。图 4 展示了视线的概念。如果没有路径障碍，则使用路径 2。否则，使用路径 1。 上述 Theta* 方法之间的区别也可以从算法 2 中详细说明的伪代码中得到验证。在第 2 行中，函数返回值用于检查是否存在视线。这是选择路径的一个条件。如果返回值为 “true”，则使用路径 2（使用平滑原则）；否则使用路径 1，从当前节点到直接相邻节点。 Theta* 算法在应用平滑理念时非常高效。这是因为它已经平滑地规划了路径，不需要进一步的后处理。不过，这种算法允许在处理路径限制的基础上搜索路径，扩展了只检查节点是否可航行的思路。这种想法有利于当前的工作，其目的是处理与地形起伏的某些陡峭倾斜有关的智能体移动限制。一般来说，拥有一条平滑的路径，其智能体的移动限制得到了考虑和规划，这些特征都可以作为路径质量的指标。 总之，Botea 等人（2004 年）提出的分层算法处理了与执行时间和内存使用相关的问题。在这个方向上，van Elswijk 等人（2013 年）提出了分层路径搜索 Theta* (HPT* ) 的想法，将 HPA* 分层技术与 Theta* 路径搜索算法相结合（这两种算法都曾在本文中重新讨论过）。通过这种方式，HPT* 成功地结合了两种算法的优点，即 (1) Theta* 提供的路径质量；(2) HPA* 的计算时间和内存要求。HPT* 的路径预处理和搜索程序与 HPA* 非常相似，但有两个例外： (1) 作为预处理任务的一部分，如果集群内部节点之间有 Theta* 算法返回的路径，则将这些节点连接起来；(2) 作为运行时搜索具体路径的一部分，这项任务使用 Theta* 算法执行。因此，目前的工作是以 HPT* 算法为基础，同时采用 Theta* 算法和 HPA* 分层技术，前者在路径规划过程中平滑路径，后者则优化路径搜索算法的性能。 3.3. Pathfinding with topographic terrain characteristics and agent movement constraints文献（Chen, Shi, &amp; Liu, 2009; Ganganath, Cheng, &amp; Chi, 2014, 2015; Marasinghe Arachchige, 2016; Pütz, Wiemann, Sprickerhof, &amp; Hertzberg, 2016）描述了在虚拟地形表示结构中表示地形特征的不同方法。其中，可以对地形表示节点的面（即法向量）进行定向，例如表示每个地形区域的最大和最小地形高度。此外，如 Ganganath 等人（2014、2015 年）、Marasinghe Arachchige（2016 年）和 Pütz 等人（2016 年）所述，依赖加权图的表示方法可以从地形高程模型中实现。路径规划算法还能考虑不同性质的地形地貌特征导致的智能体移动限制。正如 Kapadia、Ninomiya、Shoulson、Garcia 和 Badler（2013 年）、Sturtevant（2013 年 b）以及 Ninomiya、Kapadia、Shoulson、Garcia 和 Badler（2015 年）中介绍的那样，将成本应用于地形特征和路径规划计算，可以搜索到与智能体在现实中探索的路径更为相似的路径。归根结底，路径规划可以看作是一个约束处理问题，其中所代表的地形表面信息就是在路径搜索过程中正确计算的路径成本。不过，将地形高度和倾斜度数据表示（或转换）为成本信息的形式可以多种多样。有必要考虑寻路算法必须提供路径解决方案的应用问题：防止智能体出现非预期行为、实现较低的智能体能耗，以及处理燃料或维护成本等智能体后勤问题。 陈等人（2009 年）提出的导航网格是一种出色的表示结构。这种地形表示结构中使用的每个多边形都有一个法向量。所有法向量的集合构成一个梯度图，其变化表示在两个多边形之间移动的难度。因此，在执行寻路算法时会对梯度变化进行评估。生成成本的方法考虑到三个方面：路径长度（始终寻找最短路径）、根据法线矢量指示的地形倾斜度移动的难度以及与每种智能体相关的偏好/限制。因此，导航成本是根据穿越每个地形节点的难度的线性组合计算得出的。根据两个多边形之间的地形倾斜度，寻路算法返回的路线变化平滑，表明智能体移动的难度较低。虽然这种寻路方法中使用的路径成本计算与本文提出的解决方案不同，但这些工作也说明了如何在路径规划中表示和计算地形信息。在此过程中，会对穿越每个地形节点的成本进行局部分析，这与当前工作中的做法类似。虽然他们提出了防止为不同种类的模拟智能体确定风险路径的相关方法，但目前这项工作还研究了在大规模虚拟地形中使用分层和平滑路径规划技术进行寻路的问题。 在 Ganganath 等人（2014、2015 年）和 Marasinghe Arachchige（2016 年）的研究中，使用了加权图来支持地面智能体（机器人）的路径规划。该图由高分辨率数字高程模型（DEM）创建，可精确表示与地形表面相关的高程信息。在这里，每个图形节点都对应地形表面上的一个点。地形的倾斜角度会影响智能体（或机器人）的能量消耗，从而影响路径的选择。在这种情况下，除了智能体与地形之间的摩擦力信息外，还在建立地形表示的节点中加入了权重。考虑到智能体的特性（及其约束条件），计算出智能体在地形区域内航行所需的能量成本，并将该成本应用于路径搜索算法的启发式。这一过程会在最短路径和执行移动所需的能量消耗之间达成平衡。因此，智能体可以使用更多现实生活中可导航的路径。尽管对后勤问题的处理，例如对某些路线的能源成本的考虑（这是 SIS-ASTROS 项目未来工作的一个相关问题），例如，目前的这项工作不仅计算了地形缓解感知路线（避免了对预期模拟来说很奇怪的智能体事故），而且还计算了拉直的和尽可能真实的路线。考虑到技术方面的问题，这项工作依赖于启发式计算，这种计算根据智能体的一些运动属性进行调整，与机器人导航相关，但对于本文所要模拟的情况来说过于详细。这项工作没有考虑启发式计算，而是侧重于根据当前地形表示节点的地形起伏特征确定本地导航成本。在路径搜索过程中会对该节点进行分析，而这项工作仍然使用标准的启发式寻路计算。 Pütz 等人（2016 年）讨论了用于粗糙地形区域路径规划的三维导航网格。生成虚拟地形结构的主要输入是由表面重建程序构建的三角形网格。这一过程生成的导航网格可应用图优化算法。通过这种结构，可以对地形表面的若干特征进行编码。这些特征用所有图形边的地形导航成本层来表示，每个边的成本函数合并为一个成本函数。在这些层中，有一层是指与局部地形起伏不平有关的成本。由于导航网格结构允许将法线矢量关联到网格的每个三角形和顶点，因此该成本也可以基于法线矢量的计算。因此，所代表的信息表明了当地地形的倾斜度。在路径搜索计算中，可以通过检查某条路线的可通行程度来获得该信息。总之，这项工作探索了法向量，以捕捉导航网格结构中每个三角形的地形倾斜度。同样，本作品还探讨了在地形表示节点的每个方向（北、南、东、西）使用此类法向量表示地形起伏倾斜特征的问题。路径成本计算过程中的一个不同点是，他们的工作使用了不同的地形特征（在地形表示图的不同层中表示），这些特征在确定路径成本值时被结合在一起，而目前的工作关注的是仅考虑地形起伏倾斜度的寻路计算。不过，与这项工作类似，该工作中描述的路径搜索过程也是在本地计算地形起伏的路径成本。 Abd Algfoor、Sunar 和 Abdullah（2017 年）通过三种不同的技术提出了在寻路计算中使用权重信息的想法。第一种是基于与一组权重𝑤相关联的启发式搜索算法的迭代。第二种是基于起点节点和终点节点之间的长度，然后将其与𝑤 相关联。后者基于与一组权重𝛼相关的轨迹成本。一般来说，探索这些特征的目的是确定如何改进由此产生的寻路算法，使之与其他更传统的方法相比较。由于这项工作探索了在搜索过程中计算这些权重的不同方法，因此是本研究中需要考虑的相关方法。尽管地形信息可以作为路径搜索过程中需要考虑的一组权重值来获取，但他们的工作展示了如何将这些权重作为启发式路径搜索计算的一部分。这与目前的建议不同，因为它仍在探索寻路算法中的标准启发式函数。他们的工作与本文提出的工作之间的另一个对比是所开发实验中使用的算法。与他们不同的是，这项研究对比了使用和不使用路径成本值（可作为权重）的不同算法，并展示了如何从所代表的地形特征中得出这些值。 在 Perkins、Marais、Gain 和 Berman（2013 年）的研究中，提出了一种计算机器人最近路径的算法。一旦为这类智能体设计出这样的路径，它们就会在具有不同特征的地形中导航，该算法在路径搜索中还会考虑加权地形区域。该算法一般用于网格或 QuadTree 数据结构，需要高分辨率才能准确模拟不规则结构的边界。在这项工作中，所使用的成本函数已扩展到在二维三角形模型和三维四面体网格所代表的结构上运行，它们能更精确地模拟世界的多边形结构。与目前的建议类似，这项工作关注的是地形的详细分层表示，尽管在捕捉大规模地形时对网格结构的探索可能不利于计算有时间限制的寻路答案。与本文提出的工作一样，他们工作中使用的启发式方法优先确定最短路径，并在本地进行必要调整，以考虑相关地形区域的路径成本。虽然没有采用路径平滑技术，但他们的工作也研究了不规则地形表示结构中的路径计算。 在 Sturtevant、Sigurdson、Taylor 和 Gibson（2019、2020 年）中，动态成本被应用于代表地形的图形。成本是根据智能体要穿越的土地类型（草地、道路、水域等）的特征分配的。因此，我们提出了一种分层寻路方法，即根据成本信息定义的地形类型，在较大的地形区域内搜索路径。然后，在确定最终路径时进行路径细化。地形的成本由路径搜索算法计算，路径成本被用作算法质量的衡量标准。与当前的工作类似，他们的工作使用了与不同类型地形特征相关的路径成本计算，这种详细分析超出了当前建议的范围。他们的工作与本文介绍的工作的另一个共同点是使用了分层方法，这在处理大规模地形时具有相关性。不过，在他们的动态地形环境中没有研究平滑技术，而这项工作仅在处理静态地形表征时采用了这种寻路技术。 Uggelberg 和 Lundblom（2017）所做的工作研究了应用于 A* 算法的不同权重信息如何影响寻路执行时间。它还研究了这些权重对路径准确性的影响程度。将权重应用于代表虚拟地形环境的图节点，虽然得到的路径看起来更真实，但路径计算变得更加复杂。这种权重被应用于代表虚拟地形环境不同区域的结构；大权重被应用于智能体应避免的地形区域，而小权重则被应用于首选导航区域。此外，还存在不可导航的地形区域。通过这种方式，算法可以进行路径搜索，从而使最终路径的成本最小化。在这项工作中，所使用的启发式函数也是加权的，即根据待导航区域的面积对欧氏距离进行加权。与这项工作类似，这里提出的方法也呈现了不同的地形区域及其相应的地形特征。虽然这种类似吸引力和排斥力的方法似乎可以避免智能体路线的风险，但由此产生的路径可能会呈现不必要的曲线，与现实生活中的路径选择并不相似。这就是为什么不仅要根据地形起伏特征来指导路径确定，还要平滑所产生的路径，以便为目标智能体提供尽可能笔直的路线。 在 Basiri (2020)一书中，作者提出了一种寻路算法，用于处理开放地形区域，如空地和公园，传统的路线规划应用软件无法适当支持这些区域（例如，它们最常处理的是地图上的道路）。提议的算法根据轮椅移动应用进行了调整，这取决于不同的因素。这些因素考虑了轮椅使用者在规划路线时所受到的限制。这样，作为地形表示结构的增强可见度图的可见度点之间的链接就有了权重。该可见度图考虑到了障碍物、障碍等方面。链接的权重基于距离信息和地表条件、坡度等。这些因素是从轨迹挖掘算法和机器学习技术获得的运动模式中学习的。分配给每个可见度图链接的权重是所学因素的平均值。因此，在进行搜索时，应考虑地形结构的权重，寻找成本较低的路径。在根据目标智能体调整路径规划解决方案的同时，这项工作还考虑到了所提出的方法，其重点是处理智能体的导航要求，即在标准寻路解决方案通常无法接近的地形区域搜索路径。与本文介绍的方法不同，该方法利用机器学习来学习智能体的约束条件，并在确定智能体路线时对其进行计算。迄今为止，由于对机器学习方法的探索，这种改进寻路计算的方法尚未在本文介绍的研究项目中得到研究。 Li 和 Chou（2018）采用了基于约束的目标函数。在计算目标函数时，会权衡路径长度约束、平滑和碰撞风险，旨在最小化运动成本并平衡不同的约束条件。利用粒子群优化算法，计算出的函数可用于机器人在复杂环境中的运动规划。虽然通过基于约束条件的优化算法实现目标函数的最大化/最小化是解决现实路径确定问题的合理方法，但优化技术可能会带来寻路响应时间的延迟，不利于现实模拟的开发。虽然目前的工作只侧重于由于所表现的地形起伏而产生的导航约束，但它解决了路径规划的分层技术，以同时应对大规模虚拟地形和有限的响应时间要求。 要在虚拟地形图中表示倾角信息，就必须表示每个地形区域的地形特征，这些特征保存在相应的表示节点中。虽然采用了不同的技术来表示和使用有关地形不平整度的信息，但这些信息是由路径规划功能计算出来的，然后转换成导航成本。路径搜索算法会使用这些成本，还可以处理分配给智能体的其他运动限制。在当前的工作中，我们决定使用法向量来表示虚拟地形结构中的地形倾斜度信息。这一决定是基于这样一个事实，即 SIS-ASTROS 项目应用问题中涉及的智能体在通过包含陡峭倾斜度的地形区域时有移动限制（这些倾斜度是根据地形地面的法向量计算得出的）。 4. Overview of the proposed approach用于构建仿真系统的大规模地形的地形信息表示和计算是本研究提出的寻路方法的相关特点。正如 Brondani 等人（2019）所讨论的，QuadTree 数据结构的层次性是优化地形表示和路径搜索的基础。这是因为现实世界中不同层次的地形细节都可以在生成的虚拟地图的层次结构中表达出来。因此，QuadTree 表示结构的叶节点表达了虚拟地形的不规则网格和分层表示（其中地形特征多的地形区域要比地形特征少的其他区域精细得多）。这样，层次结构中的最高级别就代表了虚拟地形的总面积。在层次结构中，节点越深，表示的地形区域的详细程度越高。 在激励这项工作的模拟系统中，在构建地形导航地图时对 QuadTree 表示结构的细分考虑了不同的地形特征，如植被密度、地形景观的形状和地形区域的陡峭程度，以及河流或其他水体的存在。如果在所使用的真实世界地图上发现了这些地形特征（在 SIS-ASTROS 项目中，虚拟地形是根据基于地理信息系统的真实地形区域地图数据构建的），则会相应地在 QuadTree 层次结构中构建一个新的层次。这个过程一直重复进行，直到满足 QuadTree 层次结构的最终细分条件为止，该细分条件是根据所代表的现实世界地形特征和达到 QuadTree 层次结构的最高级别确定的。 在Brondani等人（2019）提出的QuadTree结构寻路执行中，分层搜索过程可以减少地形导航地图中访问节点的数量，从而降低整体搜索成本。此外，访问节点的数量与搜索的处理时间直接相关。这样，即使在处理大规模真实世界虚拟地形时，也能接近路径规划计算所需的处理时间限制。这种特性与当前的工作息息相关，因为所提出的寻路技术完全基于这种地形表示方法。 正如 Brondani 等人（2019）所描述的，QuadTree 结构是一种 “有根的树”，其中每个节点（n）正好有四个子节点或没有子节点。作为导航 QuadTree，它由一个分层结构组成，用于表示虚拟地形。由该结构生成的不规则网格由分层表示法的叶节点表示。在生成的不规则网格表示法中，每个节点都有以下信息： 代表虚拟地形信息的属性：n&lt;最小高度、最大高度、邻居、有河、有湖、有崖、可步行、正常北、正常南、正常东、正常西&gt;。 minHeight 和 maxHeight 属性提供了节点所代表的真实地形区域中的最小和最大地形高度信息； 可步行属性表示插入模拟中的智能体是否可以访问该节点。根据该节点所代表的地形特征，它是否允许地面智能体移动； 属性 normalNorth、normalSouth、normalEast 和 normalWest 是节点的四个法向量，分别指向每个节点的方向。它们提供了地形与向上矢量（平面的法向量，指向上方，在空间中的坐标为（0, 1, 0））相比的倾斜角度信息。 为了在寻路过程中探索分层表示法，我们使用 QuadTree 的较高层次来形成地形簇，第 3.1 节中解释了这一想法。这种层级的定义可能无法一概而论；这意味着应根据目标应用领域确定形成簇群的层级，以便优化抽象图中的搜索时间，并优化最终路径的搜索。为了在我们的项目中进行这样的分析，我们在模拟系统中进行了一系列测试，旨在了解什么是解决我们的应用问题最合适的聚类级别。这样，在执行寻路算法时，就有可能比只在叶子 QuadTree 节点上执行算法获得更高的性能。最后，如果叶节点比在层次结构中定义地形簇所选择的层次高一级，它就会成为一个簇，形成一个不规则的网格，也用于抽象路径计算（簇的层次）。 从已形成的地形簇出发，一旦底层模拟系统启动，就可以开始发现簇边界节点并对每个簇进行处理。集群处理的部分工作包括隔离边界节点（图 5.a）和搜索所有集群边界之间的路径距离（图 5.a）。为了找出这些距离，需要在每对边界节点中执行搜索算法，并将集群的输入和输出作为输入。在本文提出的方法中，除了处理集群边界节点对之间的距离外，还要计算每条路径的成本。在这种情况下，这些成本考虑了地形的倾斜度。之后，路径搜索算法将使用这些地形成本信息。例如，对于每个地形群节点，边界节点会被存储在一个列表中，以减少搜索时间。这一过程相当于在准备虚拟仿真场景时对地形表示结构进行预处理。 在执行搜索算法时，它首先通过集群边界连接规划集群之间的路径（图 6.a），搜索 “抽象路径”。然后，使用寻路算法在每个簇内部搜索路径，得到 “具体路径”。在每个集群中，在两个选定的边界节点之间搜索路径，同时考虑集群的路径入口和出口。每个集群返回的路径的联合构成结果路径。该路径由寻路算法的抽象和具体搜索步骤获得（图 6.b）。 在虚拟地形图的结构中插入了每个地形表示节点所代表的最大和最小地形高度值及其法向量（用于捕捉这些地形节点的起伏倾角）。之后，路径规划算法将使用这些节点属性来获取每个地形节点的起伏倾角。由于所开发的算法处理的是智能体在不平整地形图中的移动困难问题，因此决定使用倾斜度特征来表示地形的起伏特征，这一决定是基于第 3.3 节中的作品分析做出的。这种地形倾斜度被认为是智能体移动的障碍，因此，在模拟系统执行过程中，它们与为智能体计算更安全的路径有关。 在这项工作中，除了捕捉目标地形特征的属性外，与路径计算最相关的地形特征还包括节点是否受阻（可行走）。在这种情况下，与 Chen 等人（2009 年）提出的方法类似，浮雕倾斜信息由表示结构中每个节点的地形法向量表示。为了提高表示这种倾斜的准确性，使用了与组成地形表示节点的四个定向面（北、南、东、西）有关的法向量（normalNorth、normalSouth、normalEast 和 normalWest）。根据智能体的运动方向，这些有向法线向量有助于计算路径成本，路径规划算法会对路径成本进行分析。 法向量由组成每个三角形地形区域的向量的向量积构建而成。这些区域位于四叉树的叶节点内部（图 7）。这些法向量指的是各自节点的方向。这一过程使用节点四角的两个点（相对于正在建立的法线矢量方向（北、南、东、西））以及其中心点。根据这些点，可以得到构成三角形地形区域的矢量，从而计算出矢量乘积。因此，与这些三角形地形区域向量的正交向量就产生了。然后，这个法向量垂直于三角形地形区域的面。这样，就定义了法线北（NN）、法线南（NS）、法线东（NE）和法线西（NW）。有了它们，就可以在计算路径成本时只计算智能体将经过的浮雕倾斜值。根据智能体到达节点的方向，可以确定进入节点的成本；根据离开节点的成本，可以确定离开节点中心到与邻近节点交界处的成本。 法向量的计算方法如下： 有了关于四个节点方向的法向量表示法，就可以获得路径入口和出口的地形倾斜度。这使得地形信息的表示更加详细。同时，由于可以在计算路径时计算特定地形区域的成本，因此算法性能更加精确。 5. Using terrain relief inclinations in the computations of path costs目前这项工作中提出的成本计算方法可以处理路径搜索过程中的地形倾斜问题，并保证智能体的行车路径安全。为此，有必要在寻路计算中加入地形高程的成本值。正如第 3.3 节所述，可以探索不同的方法将可用的地形数据转换为成本值，而方法的选择往往基于要解决的应用问题。在这项工作中，采用了一种处理地形起伏倾斜度的方法，因为模拟智能体的移动会受到一定倾斜角度的影响。 地形起伏信息通过四叉树每个三角形节点的法向量获得。在此基础上，根据所代表的地形起伏倾斜角的余弦值计算出一个权重值。该权重值会影响选择或不选择给定路径的决定。权重值越高的地形区域，相关成本越低。实际上，地形倾斜角度（𝜃）越小，其余弦值就越大，权重值也就越大。因此，通过计算反余弦值，可以获得较低的成本。 由于 QuadTree 的每个叶节点都是由四个三角形区域（指节点方向）组成的，因此每个叶节点都有四个法向量。为了确定通过一个节点的成本，需要选择当前节点出口方向和相邻节点路径入口方向的地形起伏倾角。这些都是智能体在移动过程中要经过的节点部分。例如，如果智能体向东移动，它就会利用相应的法向量从东侧离开当前节点。这样，它就会根据自己的移动方向，使用节点一侧的法向量，从西侧边界进入邻近节点（见图 8）。尽管根据智能体经过的节点方向使用了地形倾斜信息，但仍有必要检查节点的其他法向量。这一点很重要，可以保证节点中是否存在急剧的地形倾斜，这种情况不允许智能体通过该地形区域。如果该节点所代表的地形倾斜度超过了智能体安全移动所允许的极限，则算法计算时将不考虑该节点。这样就可以跳过剩余的地形倾斜度验证过程，以及作为路径成本计算一部分的地形特征计算。 获得节点入口和出口的地形倾角后，检查这些倾角是否在 5 o 和 𝛼 之间。在这项工作中，根据联合国提供的资料（Blyth，2002 年），5◦ 以上的地形倾角被视为山脉。𝛼 代表允许智能体移动的最大地形倾角值，这种寻路/智能体移动约束可以在所提出的寻路方法中进行参数化。如果地形倾斜度在规定范围内，则根据上述计算方法确定路径成本。如果低于该范围，则成本为单位成本，因为建议的算法只处理被认为与智能体安全导航相关的浮雕倾角。这意味着，数值 1 只反映了路径距离的成本，而没有分配给地形起伏的成本值。因此，路径成本计算可概括为 图 9.a 和 9.b 可以直观地分析搜索过程的有效性。首先，将路径成本应用于标准 A* 算法，该算法不考虑地形起伏的高程。这意味着只考虑起点和终点之间的最短距离，而忽略了对智能体的交通可能有危险的地形区域。唯一考虑到地形高度的寻路处理方法是阻止地形倾斜值超过一定限制的节点，这是一种用于处理导航障碍的更简单的寻路处理方法。第二步，改进路径搜索算法，以考虑地形的不平整性，解决可能对智能体移动造成负面干扰的问题，返回成本较低的路径，绕过可能被视为移动轨迹障碍的特定地形区域。从图 9.a 和图 9.b 中可以看出，与标准 A* 算法的路线所包含的区域相比，寻路算法所搜索的路线穿过的地形区域具有轻微的地形起伏倾斜。在这里，底层法向量图显示了地形的倾斜度：区域颜色越深，地形的倾斜度越大。在本例中，35◦ 的倾斜值被定义为目标智能体流量的极限值。 由于将成本值应用于 A * 算法反映了路径搜索结果与急剧地形倾斜的偏差，这也是这项工作的目标之一，因此开发了一种旨在平滑所获路径的方法。平滑的想法基于 Theta* 算法，该算法在计算路径的同时，使其与模拟智能体在现实世界中可能选择的路线更加相似。 6. The proposed HPATheta* algorithm这项工作探讨了 Theta* 算法的路径成本计算。在此过程中，它允许根据选定的地形特征对计算出的路径进行平滑处理。除其他优点外，平滑还能改善路径规划算法得出的路径，通过避免蜿蜒曲折的路线使其更符合实际情况。因此，如果能返回智能体需要走过的最短距离，路径质量就会得到改善。如果路径偏离了非常陡峭的浮雕斜面，这些路径对智能体来说就会变得更加安全，这也是这些智能体沉浸在模拟环境中所需要的。因此，结合这两个优势的建议产生了一种高效的算法。 问题在于，当在路径规划计算中使用地形信息时，文献（Thorpe &amp; Matthies, 1984）中描述的标准平滑技术会忽略地形起伏的哪些部分可能有利于智能体导航行为的模拟。为了缩短距离和降低路径成本，有必要在 Theta* 中处理地形起伏，这也是当前工作的探索方向。在这种情况下，仅仅检查当前位置与其相邻位置的地形倾斜度是不够的。在使用视线平滑技术时，有必要解决地形起伏倾角问题。这样才能确定地形起伏倾角是否不会阻碍视线。因此，在 HPA Theta* 算法中探索的拟议路径平滑技术具有以下特点： (1) 当地形起伏倾斜度等于或大于𝛼（允许智能体安全移动的最大倾斜度）时，阻碍视线； (2) 将这些节点之间视线范围内遇到的进入和退出地形节点成本相加。这相当于在路径搜索计算中分配了一个视线成本； (3) 像执行标准 A* 算法一样，沿着一个节点到其邻居的路径，检查从当前节点到下一个节点的移动成本。当视线受阻，无法进行平滑时，就会这样做。 建议对 HPATheta* 算法使用的视线技术进行调整的目的是： (1) 只要没有给智能体移动带来风险从而导致无法导航的阻塞节点或地形起伏倾斜，就能避免路径障碍； (2) 计算沿视线的浮雕倾斜度总和，以确定其产生的路径是否会给智能体造成导航困难。 总之，视线方案的特点是 “近视视线”（算法 3）。与 Theta* 算法使用的标准视线方法不同，这种近视方法表明，只要地形起伏倾斜的总成本低于其他路径可能性，就有可能出现自由平滑视线。这意味着，与小曲线路径的成本相比，平滑会降低路径的成本。 HPA Theta* 算法通过处理地形起伏倾斜度和路径平滑技术，在起点和终点位置之间找到了成本较低的路线（见本文提供的实验结果）。实际上，较低的成本意味着可以避开陡峭的地形坡度。该算法完成从初始节点 Ns 到目标节点 Ng 的路径所需的成本定义如下： 其中，成本函数 g(Ns, N) 是𝑁𝑠 到查询节点 𝑁 的穿越成本。路径成本是通过累积组成路径的每个连续节点的穿越成本计算得出的。因此，它反映了从初始节点𝑁𝑠 到当前节点（即查询节点𝑁 的路径父节点）的路径成本，加上穿过当前节点 𝑝𝑎𝑟𝑒𝑛𝑡(𝑁) 到查询节点𝑁 的成本，如图所示： c(parent (N), N) 表示从当前父节点 (𝑁)到查询节点 𝑁 的旅行成本（考虑路径的缓解倾斜成本）。其定义如下 其中，d(父节点 (N)，N) 是父节点 (N) 到 N 的欧氏距离，再乘以第 5 节所述的 mScost 路径倾斜成本。综上所述，从 Ni 到 Nk 的路径成本是节点对之间的交叉成本之和，其值为 其中，𝜆 NiNk 描述了从 Ni 到 Nk 的路径，代表节点序列，即每 i ≤ j ≤ k 有一条路径（Nj，Nj + 1）。 最后，h(N, Ng) 是启发式函数，反映了从当前节点 𝑁 到目标节点 𝑁 的估计路径成本。在 HPATheta* 算法中，该启发式函数是通过这些节点之间的欧氏距离计算得出的，尽管所提议的算法在进行路径规划的同时还处理了地形起伏倾斜问题。 根据提议的算法，搜索过程从在开放节点列表中插入初始节点开始（算法 4，第 3 行）。因此，𝑔(𝑁𝑠) = 0。 在探索当前节点的邻居节点时，如果该邻居节点既不是目标节点，也不是代价无限大的节点，则会将不在开放节点列表中的邻居节点纳入其中。然后将当前节点从列表中删除。如果被探索的邻居是目标节点，则会使用𝑂𝑟 𝑔𝑎𝑛𝑖𝑧𝑒𝑃𝑎𝑡函数返回找到的路径，该函数会沿着 StartNode 和 TargetNode 之间的路径对节点进行排序。像往常一样，HPATheta* 算法会计算路径成本，并考虑列表中每个已探索的邻居。此时，算法会尝试应用平滑技术：使用 “近视视线”（算法 5，第 2 行）检查是否可以在当前节点的父节点和已访问的邻居之间找到一条直接路径。使用ε𝐵𝑜𝑢𝑛𝑑𝐼𝑛𝑡𝑒𝑟𝑠𝑒𝑐𝑡𝐿𝑖𝑛𝑒ε函数检查两个节点之间视线相交的扩展节点。如果视线畅通，则考虑平滑路径计算路径（算法 5，第 3 行）；如果视线受阻，则不平滑计算路径，使用当前节点的直邻节点组成路径（算法 5，第 5 行）。然后，算法会更新函数𝑚𝑜𝑣𝑒𝑚𝑒𝑛𝑡𝐶𝑜𝑠𝑡𝑂𝑛𝑈𝑒𝑣𝑒𝑛𝑒𝑠（计算穿越成本的函数、 算法 6，第 4 行）和（算法 7，第 5 行）。要更新该成本，需要使用 𝐶𝑎𝑙𝑚𝑝函数对所获得的穿越成本值的一致性进行检查。该函数将确保 𝑐𝑜𝑠𝑡 ∗ 𝑑𝑖𝑠𝑡𝑎𝑛𝑐𝑒 的值包含在距离和无穷大之间的区间内。如果得到的值小于𝑀𝑖𝑑𝑤𝑎𝑦和𝐶𝑎𝑛𝑑𝑖𝑎𝑡𝑒节点之间的距离，则返回它们之间的距离。探索完当前节点后，将其插入封闭节点列表。在下一次迭代中，将探索开放节点集中成本值最低的节点 𝑓 (𝑁)（算法 4，第 4 行）。 一般来说，HPATheta* 算法分析的路径方向可以根据检查每条视线时获得的成本而改变。这种处理方法指的是所谓的 “路径 2”（算法 6），其选择标准见第 3.2 节中描述 Theta* 搜索过程的伪代码中的算法 2。通过加权视线，如果 “近视 “视线没有受到阻碍，算法将返回一个路径成本，供路径决策时考虑（算法 5，第 2 行）、 其中的变量 𝑑𝑖𝑡𝑎𝑛𝑐𝑒 𝑖𝑡𝐶𝑜𝑠𝑡 返回 “𝐶𝑎𝑛𝑆𝑒𝑀𝑦𝑜𝑝𝑖𝑐’’函数计算的成本）。 但是，如果加权视线受阻或超重，要保持路线方向不变，则由 Theta* 执行所谓的 “路径 1”（算法 7），该算法也会在决策中使用地形倾斜成本。因此，在搜索过程中，地形地貌的处理是通过检查当前节点每个近邻节点的成本来完成的。 在算法中，路径成本是根据智能体的移动方向计算的。这意味着，该成本是根据出口节点方向的法向量（normalFrom）和邻近节点的入口法向量（normalTo）计算的，这两个法向量是智能体移动方向的一部分。𝑜𝑣𝑒𝑚𝑛𝑡𝐶𝑜𝑠𝑡𝑂𝑛𝑈 𝑛𝑒𝑣𝑒𝑛𝑒𝑠是计算穿越成本的函数，如第 5 节所述。对于视线来说，进入和离开地形表示节点的思路是相同的。经 ε𝐵𝑜𝑢𝑛𝑑𝐼𝑛𝑡𝑒𝑟𝑠𝑒𝑐𝑡𝐿𝑖𝑛𝑒ε 函数验证的视线穿过的所有节点都会计算其输入和输出成本，如图 10 所示。在图中，三角形输出区域用浅灰色虚线边界表示。三角形输入区域用深灰色表示。进入和离开每个节点的成本都会被计算出来，并与视线中包含的其他节点相加，形成近视视线的成本。如图所示，视线穿过的所有节点都会计算其成本。然后将它们加入视线的最终成本中。这条视线以一个节点的中心为起点，以另一个节点的中心为终点，尽可能平滑。 正如 HPA Theta* 方法所探讨的那样，Theta* 能提供更高质量的路径。但是，它需要更长的执行时间和更多的内存。在处理地形起伏倾斜时，这种类似于 Theta* 的计算时间会变得更长。为了解决这个问题，本研究提出了分层寻路方法，从而降低了搜索的复杂性，缩短了执行时间，如 Botea 等人（2004 年）的研究。此外，Theta结果与 HPA * 结果相结合，成功地结合了HPA Theta算法，因为两种算法的优点（van Elswijk等人，2013）都得到了保证。 总之，HPATheta* 算法依靠 Theta* 平滑技术来解决智能体因地形起伏不平而产生的移动困难。它还将 Theta* 算法集成到了分层寻路方法中。在实践中，QuadTree 所描述的地形表示结构被抽象为簇。然后，这些集群由更高 QuadTree 层级的节点来表示。预处理在每个簇中寻找内部的 QuadTree 路径，并使用旨在处理地形倾斜的 Theta* 算法找到路径。按照第 3.1 节中描述的 HPA* 提出的想法，在地形表示结构中与其他可行走节点有边界的所有可行走节点之间都会进行这种预处理。此外，集群之间相邻的边界节点也会相互连接，从而提供集群之间的连接。运行时，在经过起点和终点时，会确定感兴趣的簇。然后，执行经适当扩展以处理地形起伏倾斜的 Theta* 算法，搜索具体路径。总之，HPATheta* 算法除了通过一种新的视线计算形式考虑地形的不平整外，还利用了 Theta* 和 HPA* 的优点。 这项工作使用 QuadTree 来支持分层地形表示和寻路。De Berg、Van Kreveld、Overmars 和 Schwarzkopf（1997 年）指出，作为预处理模拟活动的一部分，对于细分为 n 个节点的地形，构建 QuadTree 的复杂度为 O((𝑑+1)𝑛)，其中 d 是树的深度。此外，在这种层次结构中插入、移除和搜索节点的复杂度为 O(𝑙𝑜𝑔(𝑛))。HPATheta* 首先会在更高层次的地形表示中搜索抽象路径。这是在 QuadTree 层次结构的某一中间层中进行的，地图簇就在这一层中表示。为了计算抽象路径，使用了类似 A* 的算法。实际上，A* 搜索需要构建一棵搜索树，其复杂度为 O(𝑏𝑑 )，其中 d 是成本最低的解的深度，b 是搜索树的分支因子。考虑到抽象路径所经过的地形群，HPATheta* 算法对具体路径进行细化搜索。再次使用类似 A* 的算法在每个簇中找到一条具体路径。在此过程中，只使用属于目标簇的四叉树分支的叶节点。考虑到每个簇只包含代表一小部分地形的节点数，每个簇搜索的复杂度也是 O(𝑏𝑑 )（搜索树缩小到簇的极限所代表的地形节点）。HPATheta* 算法基于 Theta* 算法（Nash 等人，2007 年）。它的时间复杂度是根据扩展节点的数量与搜索树的深度成指数关系来计算的，因此为 O(𝑏𝑑 )。然而，在 HPATheta* 的复杂度中还必须考虑另一个因素，即与用于验证视线的节点数量相关的线性成本，从而导致路径平滑（Daniel、Nash、Koenig 和 Felner，2010 年；Nash 等人，2007 年）。因此，HPATheta* 的渐近复杂度为 O（𝑏𝑑 + d）。 7. Experiments and results本实验旨在评估 HPATheta* 算法在根据目标智能体的移动限制在虚拟地图中搜索路径时处理地形特征的有效性。我们的假设是，在路径规划过程中对地形起伏倾斜进行处理可能会产生低成本路径。最重要的是，拟议的 HPATheta* 应该能找到不会对模拟智能体的导航行为造成风险的路线，允许它们偏离具有陡峭地形特征的地形区域。 实验使用了大型虚拟地形图。作为 SIS-ASTROS 项目（SIS-ASTROS，2014 年）的一部分，这些地图代表了三个真实世界的地形，Engel、Frasson 和 Pozzer（2016 年）、do Nascimento、Franzin 和 Pozzer（2018 年）、Frasson、Engel 和 Pozzer（2018 年）对这一计算机制图过程进行了描述。 虚拟地形’’B’’的主要地形特征是高山，可以更好地测试 HPATheta* 算法的地形起伏倾角计算。相比之下，虚拟地形’’A’’的地形起伏倾角较小。地形’’C’’虽然没有明显的地形起伏倾斜，但该区域有许多水体，导致表示结构中出现大量阻塞节点。每个地形的特征摘要见表 1。 针对每种地形，测试了六种不同的寻路算法，以便将拟议的 HPATheta* 算法与其他算法的结果进行比较。为便于比较，选定的算法包括：(i) 标准 Theta* （Nash 等人，2007 年）；(ii) 能够计算地形起伏倾斜度的改进 Theta* ；(iii) 基于标准 Theta* 的分层算法，称为 HPT* （van Elswijk 等人，2013 年）；(iv) Botea 等人（2004 年）提出的 HPA* ；以及 (v) 经过调整的 HPA*，以便在路径计算中处理地形起伏倾斜度。 值得一提的是，本研究对分层和非分层路径规划算法进行了比较。采用分层算法可以分析这种分层方法的影响，主要是在执行时间方面。此外，这些算法既可以使用与地形起伏倾斜度相关的路径计算，也可以不使用，从而可以根据这些地形特征比较寻路过程的成本。为了扩大围绕 HPATheta* 算法的分析和讨论，HPA* 算法（其在线版本称为 OHPA*）也被纳入实验中。这样，我们就可以比较是否使用路径平滑技术的算法。 对于每种算法，测试中都使用了以下指标：(i) 结果路径的长度（以米为单位的路径距离）；(ii) 路径搜索的执行时间（以毫秒为单位）；(iii) 结果路径的成本。成本是本研究中最相关的指标之一，因为它可以分析路径规划算法是否避免了可能损害目标智能体移动安全的救济倾斜。为了计算在路径规划中处理此类地形特征的成本，如第 5 节所述，我们定义了一系列相关的地形倾斜度。实际上，在路径规划计算中使用的地形起伏倾角在 5 o 度到 35 o 度之间。低于此范围的倾角值在路径计算中不予考虑。高于 35◦ 度的地形起伏倾角只被视为模拟智能体移动的障碍。 在我们的研究项目中，响应时间也是评估已测试路径规划算法的一个重要指标。根据 Nielsen（1994 年）的研究，人机交互研究中的响应时间有三个需要考虑的重要限制，主要是在仿真系统中，用户在其中扮演着与运行中的仿真互动的积极角色。这些时间分别为 0.1 秒、1.0 秒和 10 秒。在 0.1 秒内，用户认为系统会立即做出反应。从这个值开始到大约 1 秒的时间间隔被认为是 “用户的反应时间极限”，尽管他们可以处理一些系统延迟。当时间间隔在一秒到十秒之间时，用户会感觉与运行中的模拟越来越脱节。当等待系统响应的时间达到 10 秒左右时，只要系统不提供某种反馈信息来告知用户正在执行用户请求，用户就会开始觉得发生了错误。在这项工作中，这些系统响应时间限制与拟议的 HPATheta* 算法执行时间分析相关。 在测试中使用的每个虚拟地形的地图上都有 4,300 个起点和终点。这些点是在地形图的不同位置随机生成的。用于实验的计算机配置如下： CPU： 英特尔(R) 酷睿(TM) i5-8400 CPU @ 2.80 GHz 2.81 GHz；内存：16 GB（2 个 8 GB 插槽，频率 2400 MHz）；显卡：NVIDIA GeForce GTX 6000 显卡（2 个 8 GB 插槽，频率 2400 MHz）： NVIDIA GeForce GTX 1660 Ti；固态硬盘：240 GB；Windows 10 Pro（版本 10.0.19043.1052）。 为了分析实验结果，使用了广义线性回归模型（McCullagh 和 Nelder，1989 年）。根据实验结果的类型，在构建回归模型时使用了伽马分布。在这种情况下，该分布能更好地代表正的实际值，也就是实验中计算的路径搜索执行时间和结果路径的成本值。实际上，每种测试算法的结果都包含在回归模型中，以便对这些技术进行比较。 用于分析和比较测试算法的路径规划执行时间和由此产生的路径成本的回归模型定义为 g(mu) = 𝐵𝑒𝑡𝑎0 + 𝐵𝑒𝑡𝑎1 * X + 𝐵𝑒𝑡𝑎2 * D1 + 𝐵𝑒𝑡𝑎3 * D2 + 𝐵𝑒𝑡𝑎4 * D3 + 𝐵𝑒𝑡𝑎5 * D4 + 𝐵𝑒𝑡𝑎6 * D5、 其中，g 为对数函数。在实践中，该模型表示找到的路径的各自成本值和搜索算法的执行时间，两者都是虚拟地形上起点和终点位置之间距离的函数，这些距离值由模型中的变量 X 表示。为了将不同的技术与本研究提出的基本方法（HPATheta* ）进行比较，本统计模型中的所谓虚拟变量 D1-D5 用于表示每种算法。因此，回归模型描述了当 D1 = D2 = D3 = D4 = D5 = 0 时 HPATheta* 算法的执行时间或路径成本，并分别描述了当 D1 = 1 时的 HPT* 算法、当 D2 = 1 时带浮雕倾斜计算的 OHPA* 算法、当 D3 = 1 时的 OHPA* 算法、当 D4 = 1 时带浮雕倾斜计算的 Theta* 算法和当 D5 = 1 时的 Theta* 算法。也就是说，要获得上述每种算法的结果，必须给代表第 i 种算法的变量 Di 赋值 1，而其他变量 D 的值必须为 =0。 通过比较 HPATheta、HPT、OHPA* 和 Theta*，统计估算值代表了 (i) 执行时间和 (ii) 与 (iii) 不同路径距离值相关的路径成本的平均值。回归模型中使用的连接函数是对数函数，因为该函数在统计方法中的结果可以代表任何实际值。为了进行统计分析，确定显著性水平为 0.01（1%）。因此，在 i = 1、2、3、4、5 和 6 时，分别以 𝐵𝑡𝑎𝑖 = 0 或 𝐵𝑒𝑡𝑎𝑖 ≠ 0 定义了两个假设 H0 和 H1。然后，将 alpha 值与𝑝值进行比较。如果 alpha &lt; 𝑝-值，则拒绝 H0；否则，不拒绝 H0。𝐵𝑒𝑡𝑎1&gt;0意味着起点和终点位置之间的距离越远，算法返回这些距离的路径的执行时间就越长。对于𝐵𝑒𝑡𝑎𝑖来说，当 i 取值为 2、3、4、5 和 6 时，𝐵𝑒𝑡𝑎𝑖 = 0 意味着𝐷𝑖方法等同于基本方法。𝐵𝑒𝑡𝑎𝑖 &gt; 0 表示 Di 所指的方法比基本方法慢。𝐵𝑒𝑡𝑎𝑖 &lt; 0 意味着 𝐷𝑖 所代表的方法比基本方法快。 如图 12、图 14 和图 16 所示，在测试技术的寻路结果中，回归模型得到的 P 值均接近零，且低于 0.01 的α水平；因此，所有结果均具有统计学意义。因此，回归模型表明，对比技术之间存在显著差异。使用 HPT* 技术、OHPA* 技术以及有和无浮雕倾斜的 Theta* 技术，起点和目标位置之间路径距离的所有执行时间和成本值都与基准 HPATheta* 技术不同。以统计数据的分析为例，图 12A 中 D5 = Theta* 的路径成本值为 0.3224。由于 exp (0.3224) = 1.38（这里使用的是指数函数，因为链接函数使用的是对数），因此可以看出，在相同的路径距离下，Theta* 技术计算出的路径比 HPATheta* 技术多需要 1.38 个成本单位。图 12、图 14 和图 16 所示的其他结果也有类似的解释。由于上述图中的所有成本估计值均为正值，回归模型显示，使用 HPATheta* 算法进行路径搜索的成本低于 HPT* 、带浮雕倾斜的 OHPA、OHPA、带浮雕倾斜的 Theta* 和 Theta* 算法。 就两点之间的路径成本而言，我们最初的预期是，使用 HPATheta* 算法和带有浮雕倾斜度的 Theta* 算法所需的成本最低。在这种情况下，这些算法在进行路径规划时，会处理地形地貌的特殊性，并平滑所产生的路径。此外，OHPA* 算法很快就会出现，因为它考虑到了地形的起伏倾斜。不过，OHPA* 算法并没有对路径进行平滑处理，这也是影响最终路径成本的一个因素。从测试结果来看，最初的预期得到了部分证实。这是因为，每种地形的特殊性和是否使用分层搜索技术都会影响路径结果，进而影响路径成本。 7.1. Pathfinding results with terrain ‘‘A’’与其他地形的测试结果相比，虚拟地形 A 的计算路径成本（以计算出的路径长度以及沿该路径的浮雕倾斜成本来衡量）在所有测试算法中差异最大。即便如此，随着路径距离的增加，返回路径成本曲线的增量也略有不同。由于地形 A 的浮雕倾斜度大多在 0 o 到 10 o 之间（对目标智能体来说是微妙的地形特征），而算法考虑的浮雕倾斜度从 5 o 开始，因此成本结果大多反映了每种算法返回的路径长度。这个地形 A 也与其他地形不同：它代表了一个经过预处理的不规则群集级网格（图 11b）。也就是说，当一个节点的维度大于集群网格节点时（相对于集群定义的层级，该节点在层级上高一级），该节点就会成为一个集群，从而形成抽象层级路径搜索的不规则网格。与其他地形相比，地形 A 中的一些簇在 QuadTree 层次结构中处于较高的层次，从而扩大了这些簇的维度（鉴于 QuadTree 的性质，该簇将比系统中定义的传统簇大四倍）。 在地形 A 中，与其他算法相比，HPATheta* 算法的路径成本最低。除此基本算法外，还有 HPT* 算法获得的路径成本，该算法是基本方法的一个版本，不处理虚拟地形的地形特征。由于 HPATheta* 算法和 HPT* 算法的寻路结果相差无几，而且与其他算法相比，HPATheta* 算法的路径成本最低，因此很明显，在图 11（a）所示的阻塞节点较少、地形倾斜度较小（绝大多数在 0 o 至 10 o 范围内）的地形中，具有路径平滑功能的分层搜索算法可以获得更好的路径成本结果。这是因为 HPATheta* 方法很容易找到平滑路径。这种平滑也仅限于计算出的地形群的极限，避免了很长的平滑距离。 当 HPATheta* 算法与分层 A* 算法（如带浮雕倾斜的 OHPA* 算法和标准 OHPA* 算法）进行比较时，得出的路径成本差异较大。与基本方法相比，带浮雕倾斜的 OHPA* 算法的路径成本增加了 1.3462 个单位。另一方面，OHPA* 算法的路径成本增加了约 1.3554 个单位。这表明，尽管处理地形特征会导致路径成本增加，但所选算法对最终路径结果有很大影响。当处理的地形没有大的阻塞区域和地形起伏相当平缓时，这种影响更大，这也导致虚拟地形的分层表示结构（在我们的工作中为 QuadTree）的精细度降低（图 11a）。使用 OHPA* 方法时，在地形簇内部执行的 A* 算法考虑了从当前节点到其近邻节点的路径规划，有时会导致路径中出现不必要的曲线和偏差（例如之字形行为）。当采用带地形坡度的 OHPA* 时，对每个地形群执行带地形坡度的 A* 时，会偏离坡度在相关范围内的区域。因此，虽然由于地形起伏而降低了成本，但却增加了路径长度方面的成本。如果不考虑浮雕倾斜造成的成本计算，那么不带浮雕倾斜的 OHPA* 版本即使寻求尽可能短的路径，也会导致较高的地形成本。因此，使用促进路径平滑的算法是有意义的，因为它能使得到的路径更加真实，避免可能增加最终路径距离的微小而不必要的路径偏差。 比较 Theta* 算法的分层版本和非分层版本，分层版本在搜索过程的计算时间和所产生的路径成本方面都具有优势。带有浮雕倾斜度的 Theta* 算法比基本方法高出 1.29 个成本单位，这表明在地形群层面限制路径平滑可能有利于搜索。在不使用测试过的分层技术的情况下，该算法对地图进行整体探索，能够平滑长距离路径。不过，在某些情况下，这种较大的平滑可能会忽略与最终路径相关的偏差。反过来，与 HPATheta* 基本方法相比，不带浮雕倾斜的 Theta* 算法会使生成路径的成本增加 1.38 个单位。这是因为 Theta* 可以在不考虑地形特征的情况下平滑长距离路径。它只将路径障碍物视为一些障碍因素。它还能找到更直接的路径，即距离更短的路径，因为它寻求的是最短最平滑的路径。不过，与其他测试算法相比，不考虑地形倾斜度的 Theta* 算法得到的路径成本要高得多。在对考虑和不考虑地形信息的非层次算法版本进行观察时，与其他技术相比，比较其考虑和不考虑地形信息的版本，所获得的成本值之间的差异更大。从 HPATheta* 算法到 HPT* 算法的成本增加约为 1.4%（路径增加 1.0138 个成本单位），而从带浮雕倾斜的 Theta* 算法到标准 Theta* 算法的成本增加约为 7%（途中增加 1.0694 个成本单位）。 在执行时间方面，OHPA* 算法的表现优于其他测试算法，这一点可以从报告结果中观察到。如果将 A* 算法与分层算法一起研究，它们的表现会更加令人满意，因为它们能获得更好的性能。与基本方法相比，OHPA* 算法的执行时间非常接近，但比其他算法快约 80%。不过，OHPA* 算法并没有将平滑路径作为其优势之一，这也是本研究要解决的一个重要方面。考虑到所提出的 HPATheta* 算法能满足在 1 秒内给出路径结果的时间限制（如本节开头所述），虽然它不是所有测试算法中速度最快的，但在响应时间和返回路径质量方面都能满足要求。这表明，使用分层方法进行地形表示和寻路是缩短路径搜索执行时间的根本。在这种情况下，标准 Theta* 算法的执行速度是基础方法的 9.15 倍。在 Theta* 算法中加入对地形地貌的处理，执行时间比 HPATheta* 算法慢 14.39 倍。 7.2. Pathfinding results with terrain ‘‘B’’虚拟地形 B 在地形起伏不平方面非常复杂，约有 34.73% 的节点被遮挡，占虚拟地形总面积的 19.81%。由于地形起伏高度的变化，QuadTree 的细化程度更高，因此分层表示法的叶节点更小。在约 30 km × 30 km 的尺寸范围内，总共有 773 440 个法线矢量值来捕捉地形的倾斜度。其中，73.81% 属于与目标智能体相关的倾斜范围（介于 5° 和 35° 之间）。与地形 A 不同的是，该地形在群集层面上具有规则的网格结构（即节点代表具有相同尺寸的地形区域）。这是因为在构建 QuadTree 时使用了高度细化，因此节点较小。这意味着没有必要因为节点过大而扩展这种地形集群级别（如第 4 节所述）。 在地形 B 中，我们注意到测试算法得出的路径成本相对接近（图 14A）。这一结果与该地形结构中受阻节点的数量有关。该地形除了起伏高度变化大（导致地形表示节点受阻的一个因素）外，还有许多河流，这也是在表示结构中阻塞节点的一个因素。在某些地形群中，这些障碍物形成了有限的通航路径。例如，请看图 13 中以深色线段表示的河流之间的路径（在地形图的放大部分可以很容易地观察到）。虽然寻路结果彼此接近，但它们之间存在显著的统计差异。 在地形 B 的测试中，与其他算法相比，HPATheta* 算法的路径成本也是最低的。紧随其后的是 HPT* 算法，如统计模型所示，多出约 1.012 个成本单位。由于地形表示结构中的阻塞节点导致搜索空间有限，因此这些算法最终返回的路径彼此接近。尽管 HPATheta* 算法和 HPT* 算法得出的路径差别很小，但 HPATheta* 算法得出的路径成本更高。 由于使用分层 Theta* 算法得出的结果很相似，因此下一个得出较好路径成本的算法是带浮雕倾斜的 Theta。与建议的基本方法相比，带浮雕倾斜的 Theta 算法的路径成本增加了约 1.064 个单位。这是因为带浮雕倾斜的 Theta* 并没有将搜索空间限制在属于抽象路径的地形集群区域。因此，路径平滑可以通过不同的方式、不同的延伸、不同的路径点或延伸段进行，从而影响最终的路径结果。例如，在使用分层技术时，每个地形群的边界、入口和出口节点都必须是生成路径的一部分。这就限制了通过这些地图点进行路径平滑的可能性。这一事实也解释了为什么该算法没有获得比 HPT* 更优的路径成本（如最初预期的那样），因为 HPT* 也采用了分层策略，将搜索空间限制在由抽象路径扩展的地形簇内。反过来，标准 Theta* 算法在不考虑地形特征的情况下，与其他算法相比显示出更高的路径成本增加，大约增加了 1.117 个路径成本单位。当然，由于路径平滑中使用的视线技术只评估路径是否受阻，而不考虑平滑计算中的地形倾斜度，因此得出的路径成本要高于有地形倾斜度的 Theta* 算法。不过，分层 Theta* 版本，即 HPT* 与 Theta* 和带浮雕倾斜的 Theta* 版本相比，路径成本仍然相对较低。同样，从搜索空间的大小可以看出，尽管 HPT* 算法是一种分层算法，但它在搜索空间中也有局限性。总之，标准 Theta* 算法将地形图作为一个整体来探索，能够在不考虑地形信息的情况下平滑较大的地形区域，从而导致生成路径的路径成本较高。 与本文提出的基本方法相比，OHPA* 算法的路径成本也更高。虽然它们的搜索空间也仅限于地形集群节点，但这些算法并不进行路径平滑。因此，它们组成的节点-节点路径，其最终路径长度也会影响路径成本。在这种情况下，与拟议的 HPATheta* 相比，带有地形倾斜度的 OHPA* 所产生的路径成本增加了约 1.089 个单位。反过来，与基本方法相比，不带浮雕倾斜的 OHPA* 所产生的路径成本增加了约 1.104 个单位。如前所述，该算法寻求的是最短路径，但它没有考虑地形起伏信息。 在执行时间方面，拟议的 HPATheta* 算法落后于 OHPA* 算法（包含和不包含地形起伏倾斜度）和 HPT* 算法。这一结果在意料之中，因为 HPATheta* 算法不仅能计算由地形起伏产生的路径成本，还能在执行搜索时平滑路径。在地形 B 中，可以观察到长距离路径计算时间的增加远高于前面讨论过的地形 A 中类似路径计算时间的增加。增加的原因在于搜索过程中探索的节点数量，因为地形 B 的复杂性更高，因此分层表示结构的细化程度也更高。因此，响应时间与这些地形表示结构中已探索节点的数量成正比。不过，HPATheta* 算法即使在虚拟地形 B 中涉及较大距离的路径，也能在不到 1 秒的时间内返回路径结果。 与 HPT* 算法相比，HPATheta* 所需的计算时间延长了约 6.8%。至于两种版本的 OHPA* 算法（处理地形信息和不处理地形信息），基本算法的响应时间大约长 7 倍。需要强调的是，与标准的逐节点路径搜索相比，路径平滑执行过程需要额外的计算时间。如果考虑到浮雕倾斜信息，路径搜索过程就会变得相对耗时，从而导致响应时间比不执行平滑的有浮雕倾斜和无浮雕倾斜的 OHPA* 更长。不过，在计算寻路过程中考虑地形起伏信息进行平滑处理，比执行标准搜索，然后在平滑处理过程中执行考虑地形起伏倾角的后处理算法要好。考虑到所获得的计算时间值很低（路径距离为 20 千米时约为 50 毫秒），而且彼此非常接近，因此差异并不显著。 在地形 B 中，路径搜索中使用分层技术的重要性再次凸显。标准 Theta* 算法的执行时间比建议的基本方法多出约 3.61 毫秒。当使用带浮雕倾斜的 Theta* 算法时，执行时间比 HPATheta* 基本方法多出约 6.31 毫秒。 7.3. Pathfinding results with terrain ‘‘C’’ 与其他地形相比，虚拟地形 C 有更多的节点被阻塞（40% 的叶节点被阻塞，占地图总面积的 21.82%）。在使用的三个虚拟地形中，地形 C 的地形不平整度较低。总体而言，该地形的山脉较少，而且位于地图中心区域，高度也不高。这与地形 A 不同，地形 A 的不平整区域位于地形边缘。地形 C 还有大量的湖泊和河流，因此在其虚拟表示中会产生阻塞节点。地形 C 的尺寸约为 33 km × 62 km，其结构中共有 676 300 个法线矢量，反映了地形的起伏倾斜。其中，24.59%的地形处于与目标智能体相关的地形倾斜范围内（5◦至 35◦）。 由于许多节点被河流和湖泊阻挡，地形 C 的搜索空间也很有限，甚至比地形 B 更有限。图 15 中突出显示了地形 C 的一部分，以说明在因河流而受阻的节点之间狭窄的自由空间中寻找路径的情况。尽管在地形 C 中观察到的算法之间的差异很小，但 HPATheta* 方法显示出了最佳的路径成本。不考虑地形特征的 HPT* 算法的结果排在第二位，与基本方法相比，路径成本增加了 1.017 个单位。鉴于地形 C 有许多阻塞节点和轻微的地形倾斜，搜索结果有一定的就近路径倾向，特别是在使用类似性质的算法时。与基本方法相比，OHPA* 算法的路径成本增加了约 1.065 个单位。这再次表明，由于 HPATheta* 和 HPT* 对分层技术的探索，路径平滑对最终路径成本的影响。如前所述，在具有微妙地形倾角的虚拟地形中，返回路径之间的差异主要是由于路径搜索算法所使用的技术而非地形倾角信息本身造成的。在分析分层算法的结果时，路径搜索结果的这种相似性更加明显，因为这些算法将搜索空间限制在所产生的抽象路径所选择的地形群上。然而，对于在搜索过程中无限制地探索虚拟地形图（无集群限制）的算法，在寻路结果中观察到了更大的差异。与基本方法相比，带浮雕倾斜的 Theta* 算法增加了约 1.030 个路径成本单位，而标准 Theta* 算法则增加了约 1.100 个路径成本单位；与不带浮雕倾斜的Theta* 算法相比，带浮雕倾斜的 Theta* 算法的路径成本增加了约 6.7%，这是测试的性质相似的算法之间观察到的最大差异。如前所述，自由探索虚拟地形图，不局限于某些地形集群区域，可使最终寻路结果产生更大差异。然而，在大规模虚拟地形中，使用分层搜索技术对于提高寻路的执行时间是至关重要的。 正如在其他测试过的虚拟地形中已经看到的那样，OHPA* 算法在有地形特征处理和无地形特征处理的版本中，执行时间比其他算法短得多。在这种情况下，基本算法（HPATheta* ）比两个版本的 OHPA* 算法（带浮雕倾斜和不带浮雕倾斜）慢约 7 倍。与 HPT* 算法相比，HPATheta* 算法的执行时间更长，这在意料之中，也在情理之中，因为该算法计算的是与地形起伏倾斜度相关的路径成本。需要指出的是，在 HPT* 算法的路径规划中，并没有考虑计算地形起伏倾斜度成本的步骤。执行时间最长的算法是处理地形信息的 Theta* ，与基本方法相比，响应时间约为 5.155 毫秒。最后，与拟议的 HPATheta* 算法相比，标准 Theta* 算法的响应时间增加了约 3.346 毫秒。 7.4. Discussion为了扩大对本研究实验结果的评估范围，可以对以下几个方面进行分析：(i) 在所有地形中进行的测试结果，(ii) 本文所研究建议的分层寻路特性，(iii) 建议算法的效率和 (iv) 精度。 7.4.1. Cross analysis of the pathfinding results with the real-world terrain通过这三种不同的测试场景，我们可以发现每种地形的特殊性是如何影响每种测试算法的寻路结果的。地形 B 和地形 C 在地形细化程度和地形阻塞方面有相似之处，其结果在路径成本和执行时间方面也有一定的相似性（成本方面分别为图 14A 和图 16A，计算时间方面分别为图 14B 和图 16B）。这两种地形结构都有很大的细化，生成的节点越来越小，越来越大（其中许多节点被阻塞，根据所代表河流的走向形成 “小巷”）。此外，地形 B 和地形 C 的网格簇以规则布局的形式表示，与 QuadTree 处于同一级别（即第 5 级）。根据测试算法得出的最佳路径成本，B 地形和 C 地形的结果相当，但在执行时间方面存在差异。 地形 A 的路径成本与其他地形的结果不同（图 12A）。地形 A 的路径成本值与路径距离值一致。正如之前所讨论的，这是因为地形 A 与地形 B 和地形 C 不同，地形 A 有少量陡峭的浮雕倾斜（接近 35◦），并且由于地形特征，结构细化很少。这些结果还表明，分层平滑算法返回的路径成本较低。由于地形 A 的细化程度不高，也就是说，节点在表示结构中捕捉到的地形面积较大，此外还有细微的浮雕倾斜（绝大多数在 0 o 和 10 o 之间），因此路径平滑对结果路径的低成本起着根本性的作用。就每种算法在使用地形 A 时获得的最佳路径成本而言，它们的效率排序与使用其他地形进行测试时观察到的结果相同。这一寻路结果在所有测试场景中都是相同的。在性能方面，一般来说，与在其他地形下进行的测试相比，在地形 A 下执行的算法所需的处理时间要短得多（图 12B）。例如，对于 27 千米的距离，拟议的 HPATheta* 算法需要约 16 毫秒才能返回路径。在这种情况下，最耗时的算法是处理了地形特征的 Theta*。对于 27 公里的路程，该算法的执行时间约为 240 毫秒。在考虑这些长距离时，使用分层搜索方法的相关性再次凸显出来，从而提高了测试路径规划算法的性能。 如前所述，在地形 B 和 C 中，与测试算法返回的路径成本相关的效率顺序是相等的。不过，在使用不同算法时，路径计算时间的效率顺序存在差异（分别见图 14B 和图 16B）。在地形 C 中，与标准版本相比，带浮雕倾斜的 OHPA* 算法的执行时间更长。这是意料之中的，因为该算法采用了额外的成本计算步骤来计算地形起伏特征。在地形 B 中，观察到了相反的情况：基于地形的路径搜索算法与其标准版本相比，执行时间更短。不过，这一差异太小，小于 0.1 毫秒，因此不能视为相关。 与其他地形相比，在地形 C 中搜索相同距离路径所需的计算时间较长（图 16B）。在地形 C 中，拟议的 HPATheta* 算法搜索 27 千米距离的执行时间约为 200 毫秒，而在地形 B 中，相同距离的搜索时间约为 130 毫秒。 与地形 A 相比，地形 B 和地形 C 的搜索时间更长，这是意料之中的合理结果，因为这两个地形使用的表示结构更加精细。由于 B 和 C 地形更加复杂，搜索过程中需要探索的节点更多，这与路径规划算法的执行时间直接相关。在这些情况下，对地形特征进行处理的 Theta* 算法在所有情况下都获得了最长的计算时间，对 B 和 C 地形的响应时间分别达到约 820 毫秒和 1117 毫秒。 7.4.2. Analysis of the hierarchical pathfinding characteristics实验中使用的寻路算法的选择基于以下问题： (i) 平滑化，因此选择了标准版本的 Theta* 算法，并对其进行了调整，以处理地形路径成本和加权视线的计算；(ii) 层次化，这也是选择 HPA* 算法（在本研究中使用 OHPA* 在线版本）和 HPT* 算法的原因–比较它们在应用地形路径成本和不应用地形路径成本时的性能–因为导航结构被划分为群组，所以它们可以处理较大的搜索空间。这项工作是对 Brondani 等人（2019）所做工作的扩展，其动机是 SIS-ASTROS 项目（SISASTROS，2014 年）正在开发的虚拟战术模拟系统的相同路径规划需求。虽然其他算法也能探索分层和平滑的路径规划，例如 N 层子目标图（Uras &amp; Koenig, 2014）和跳点搜索（JPS）（Harabor &amp; Grastien, 2011），但我们实验中使用的算法能更好地探索 SIS-ASTROS 模拟系统中已经实现的分层和不规则地形表示结构。 实验结果表明，使用分层方法进行路径规划对于获得更好的搜索性能非常重要。正如本文前面所讨论的，搜索空间仅限于 “抽象路径 “所发现的簇的维度，从而引导搜索并减少搜索 “具体路径 “时所探索的节点数量。实际上，具体路径是通过对表征结构更高层次的细化分析得到的。从实验结果中可以看出，在地形 A（地形复杂度较低）中，建议的算法（HPATheta）计算出一条距离约为 27 千米的路径大约需要 16 毫秒，而不使用层次结构的算法（Theta，带浮雕倾斜度）计算出一条通往同一对来源点和目的地点的路径则需要 240 毫秒。而 HPT* 算法在相同地形上的相同距离则需要约 17 毫秒，而其不使用层次细化的版本，即不使用浮雕倾斜的 Theta* 算法则需要 150 毫秒。在地形 B 中，层次结构的相关性也很明显，这主要是因为该地形的浮雕复杂度更高。要找到一条距离为 27 千米的路径，HPATheta* 算法大约需要 137 毫秒，而有浮雕倾斜的 Theta* 算法只需 896 毫秒就能返回一条路径。HPT* 算法及其非层次化版本，即不带地形倾斜的 Theta* 算法的执行时间分别约为 129 毫秒和 505 毫秒。在地形更为复杂的地形 C 中，HPATheta* 算法在 27 千米距离内的执行时间约为 200 毫秒，而带浮雕倾斜的 Theta* 算法在相同距离内寻找路径的执行时间约为 1,117 毫秒。此外，在相同距离上，不带浮雕倾斜的 HPT* 算法和 Theta* 算法的执行时间分别约为 200 毫秒和 725 毫秒。 正如第 3.1 节所分析的，使用分层方法的寻路算法与非分层方法的寻路算法相比，性能提升是显而易见的，尤其是在应用于大规模搜索空间时。地形信息的预处理也是有助于实现上述结果的一个方面。正如在 HPA* （Botea 等人，2004 年）中介绍的那样，在不使用层次结构的情况下比较 HPA* 和 A* 算法，寻路性能的提高是显而易见的，尤其是在大型搜索空间和具有许多特征的地形中。不使用层次结构的寻路算法可能比使用该技术的算法稍好的情况是，搜索问题非常简单，通常涉及源点和目标点之间非常小的距离。然而，在模拟大型地形时，有必要处理较难处理的情况，包括在不超过进行模拟所需的时间限制的情况下穿越地图的长度。 7.4.3. Efficiency analysis为了证明寻路算法的效率，该算法必须达到预期目的，即以较低的成本获得结果路径，并在预定范围内提供执行时间。可以看出，所提出的算法在这些标准之间进行了相关的权衡：得到的路径成本和执行时间。在许多情况下，这两个方面是相互冲突的，因为要评估这些限制条件下的计算成本，就必须包含额外的路径搜索程序，这可能会增加执行时间。在所进行的实验中，根据第 7 节中介绍的实验方案，对所选算法的这些指标进行了收集和比较。低成本、平滑的路径可避免 “之 “字形行为，这对于开发算法的仿真系统以及许多需要进行此类地形计算的应用来说非常重要。此外，相对较短的执行时间也很重要，尤其是在仿真环境中，这一点将在第 7 节中说明。虽然实验结果并不表明所提出的算法（HPATheta* ）是所有测试算法中速度最快的算法，但就路径成本（这是实现本研究目标的关键因素）而言，该算法在所有测试地形中与其他算法相比取得了最好的结果。此外，即使是长距离路线，HPATheta* 算法的执行时间也低于规定的时间限制，从而保证了用户在模拟中的沉浸感（见第 7 节）。这表明 HPATheta* 算法即使在大规模地形中使用，也能在仿真时间限制内运行，从而实现了其目的。 7.4.4. Accuracy analysis为了评估寻路算法的准确性，我们需要评估返回路径的成本。我们的目标是最大限度地降低成本，因为成本越低，地形倾斜度越小。然而，一条能避开所有陡峭地形坡度的路径可能会变得非常曲折。为了在模拟上实现更真实的智能体运动（避免 “之 “字形的智能体行为），建议算法的目标是为平滑的路径获取更低的成本。这意味着 HPATheta* 算法获得的最终路径成本并不会导致浮雕倾斜成本之和的最小值。实际上，该算法返回的是避免这种不理想之字形的最小倾斜成本总和。 带浮雕倾斜的 A* 算法返回的路径成本最优。不过，这种算法往往会产生蜿蜒曲折的路径。通过比较 HPATheta* 算法与带浮雕倾斜度的 A* 算法的路径成本，可以发现 HPATheta* 算法的路径成本非常接近最优成本。根据寻路算法所适用的地形配置，平滑也能有效降低路径成本。比较在地形 A 中获得的成本值，所提出的算法比带有浮雕倾斜度的 A* 算法成本更低，这是与目标相关的结果。这一结果与在地形表示和搜索过程中使用分层和不规则结构的方式有关。尽管取得了这一积极成果，但在测试中考虑地形 B 和 C 时，结果却不尽相同。这是因为在模拟这些真实世界地形的各种特征时，所使用的表示结构略有细化。 当所使用的地形中只有很少的地形特征可供模拟使用时，就会在表示结构中使用较大的节点（有些节点甚至有一个集群的大小）。这些节点最终代表了智能体移动时需要覆盖的大片地形。从这个意义上说，在计算路径时访问这些节点中心的具有浮雕倾斜度的 A* 的行为会导致不必要的之字形路线，从而增加智能体路线的最终成本。实际上，与平滑后的路径相比，它们最终要走更长的距离。在使用地形 A 时，这种影响会更大，因为地形 A 在 0 o 和 10 o 之间有轻微的起伏倾斜。在这种倾斜情况下，平滑过程并不会给生成的路径增加多少成本，这意味着最终成本要低于忠实地偏离这些倾斜的路径的成本，尽管要走更长的距离。根据丹尼尔等人（2010 年）的研究，如果考虑到路径的长度，Theta* 算法在网格上找到的路径比 A* 算法更短。根据该研究中的实验，99% 的情况下 Theta* 算法比 A* 算法在网格上获得的路径最小。在具有微妙地形倾斜和大型表示节点的地形中，最终成本主要表示的是行进距离，而不是地形倾斜造成的成本。对于这种地形 A，拟议算法的最终成本比 A* 算法加上地形起伏处理后的路径成本低 16%。 对于地形 B 和 C，由于其复杂性更高，特别是与所考虑的智能体相关的大量河流和浮雕倾斜度，它们的分层和不规则表示结构表现出更高的精细度，带有浮雕倾斜度的 A* 算法通过彻底偏离倾斜度返回最佳成本。在这种情况下，这些地形表示结构的节点并不大。因此，路径上的浮雕倾斜度对路径成本的影响相对于行驶距离而言会变得更大（这与地形 A 不同）。尽管如此，HPATheta* 算法与带有浮雕倾斜度的 A* 算法相比，成本变化较小，后者能返回最优路径成本。对于地形 B，HPATheta* 算法产生的路径成本增加了 6%。对于地形 C，则增加了约 7.5%。总之，建议的算法提出的路径成本接近于返回最优成本的算法。这样，它还避免了 “之 “字形行为，此外，与带有浮雕倾斜度的 A* 算法相比，运行时间也短得多。根据第 7.1-7.3 节的分析，与实验中测试的其他算法相比，该算法得出的路径成本最低。这也是路径质量的相关指标。 8. Final remarks这项工作提出了一种寻路算法，用于处理基于真实世界地图构建的虚拟地形浮雕中的不平整问题，地形特征的处理反映在寻路的计算成本上。研究结果表明，在同一区域，相同的路径距离间隔，HPATheta* 算法的成本更低。 值得注意的是，这项研究解决了在不平坦的地形中搜索路径的问题，旨在促进插入大规模模拟虚拟环境中的不同类型智能体的安全移动。此外，该作品还介绍了如何使生成的路径更加逼真，这是以教育为目的的仿真系统的一个基本特征。这项研究通过对生成路径的平滑算法进行探索来实现。为此，路径计算使用了视线的概念，并对其进行了适当修改，以处理地形的浮雕倾斜。实际上，使用视线来处理涉及地形起伏倾斜的智能体移动限制信息，是一种在文献中仍未得到充分探讨的方法。尤其是在寻路过程中仅使用受阻节点信息时（通常在此过程中转换为路径权重），情况更是如此。此外，所提出的算法采用了分层搜索技术，将地形节点之间的路径预处理与虚拟地形表示结构的层次结构结合起来使用。这种技术优化了计算的执行时间。 针对提出的问题，通过与文献中的其他建议进行比较测试，对提出的路径规划解决方案进行了评估。通过这些测试，我们可以评估不同方案的优缺点，例如使用分层方法（OHPA* 和 HPT* ）所带来的性能提升，以及使用路径平滑技术（Theta* 和 HPT* ）的益处。通过所进行的实验，可以观察到 HPATheta* 算法成功地将不同寻路和地形表示技术的优势与使用和计算与目标智能体相关的地形特征信息结合在一起。研究还发现，无论模拟地形的复杂程度如何，提议的算法都能返回更高质量的路径。这意味着尽可能提供低成本的路径，包括浮雕倾斜度和覆盖距离，以及平滑路径。在性能方面，HPATheta* 算法也达到了 SIS-ASTROS 项目的研发预期。尽管在所有已执行的路径规划实验中，HPATheta* 算法的执行时间都不是最短的，但却接近最佳结果时间。在那些不是最佳时间的实验中，即使计算长路径距离（即大搜索空间），它也能满足所有实验中小于 1 秒的响应时间要求。 在未来的工作中，我们可以设想一种更加通用的方法，用于新型虚拟仿真的路径规划。这不仅是 SIS-ASTROS 项目的新发展，也是其他模拟培训和教学环境的新发展。由于这项工作仅限于有静态障碍物的场景，今后的工作可以扩展所提出的算法，以处理移动障碍物。尽管如此，仍有可能扩展本文讨论的分层和平滑技术，开发出一系列具有相似性的算法。这类算法将处理不同的现实智能体约束，更适合特定类型的大规模真实世界虚拟地形环境。","link":"/2024/01/23/Hierarchical-and-smoothed-topographic-path-planning-for-large-scale-virtual-simulation-environments/"},{"title":"Online Graph Pruning for Pathfinding on Grid Maps","text":"Online Graph Pruning for Pathfinding on Grid Maps作者：Daniel Harabor and Alban Grastien Abstract在均匀成本网格环境中寻路是机器人和视频游戏等应用领域中常见的问题。最先进的分层寻路算法速度快、内存开销小，但通常会返回次优路径。在本文中，我们提出了一种专门针对网格的新颖搜索策略，它速度快、最优且无需内存开销。我们的算法可以被描述为一个宏运算符，它只识别并有选择地扩展网格图中的某些节点，我们称之为跳跃点。连接两个跳转点的路径上的中间节点永远不会扩展。我们证明这种方法总能计算出最优解，然后进行了全面的实证分析，并将我们的方法与文献中的相关作品进行了比较。我们发现，使用跳跃点进行搜索可以将 A* 的速度提高一个数量级或更多，并报告了与当前技术水平相比的显著改进。 Introduction在机器人学（Lee 和 Yu，2009 年）、人工智能（Wang 和 Botea，2009 年）和视频游戏（Davis，2000 年；Sturtevant，2007 年）等领域，无处不在的无向匀成本网格图是一种非常流行的寻路环境表示方法。该领域具有规则性，通常具有高度的路径对称性（Harabor 和 Botea，2010 年；Pochter 等，2010 年）。在这种情况下，对称性表现为路径（或路径段）具有相同的起点和终点、相同的长度以及除移动顺序外的其他相同之处。除非处理得当，否则对称性会迫使搜索算法评估许多相等的状态，从而阻碍朝着目标取得真正的进展。 在本文中，我们通过开发一种宏运算符来处理这种路径对称性问题，这种宏运算符只选择性地从网格中扩展某些节点，我们称之为跳跃点。从一个跳转点移动到下一个跳转点，需要沿着一个固定的方向行进，同时反复应用一组简单的邻接剪枝规则，直到到达死胡同或跳转点。由于我们不会在跳转点之间扩展任何中间节点，因此我们的策略可以对搜索性能产生显著的积极影响。此外，计算出的解决方案保证是最优的。跳跃点剪枝速度快，无需预处理，也不会带来内存开销。它在很大程度上还与许多适用于网格图的现有加速技术是正交的。 我们的贡献如下：(i) 对跳跃点算法的详细描述；(ii) 一个理论结果，表明用跳跃点搜索能保持最优性；(iii) 一个经验分析，将我们的方法与两种最先进的搜索空间缩小算法进行比较。我们对文献中的一系列合成基准和实际基准进行了实验，发现跳点能将标准 A* 的搜索时间性能提高一个数量级或更多。我们还报告了与 Swamps（Pochter 等人，2010 年）（一种最新的优化剪枝技术）相比的显著改进，以及与 HPA*（Botea、M ̈ uller 和 Schaeffer，2004 年）（一种众所周知的次优寻路算法）相比具有竞争力的性能，而且在很多情况下占优势。 Related Work在规划（Fox 和 Long，1999 年）、约束编程（Gent 和 Smith，2000 年）和组合优化（Fukunaga，2008 年）等领域，已经提出了识别和消除搜索空间对称性的方法。然而，明确识别和处理寻路领域（如网格图）对称性的作品却寥寥无几。 Empty Rectangular Rooms（Harabor 和 Botea，2010 年）是一种离线对称破缺技术，它试图纠正这种疏忽。它将网格地图分解为一系列无障碍矩形，并用一组宏边取代每个矩形内部的所有节点，从而实现最佳旅行。这种方法只适用于 4 连地图，通用性不如跳跃点剪枝法。它还需要离线预处理，而我们的方法是在线预处理。 Empty Rectangular Rooms（Harabor 和 Botea，2010 年）是一种离线对称破缺技术，它试图纠正这种疏忽。它将网格地图分解为一系列无障碍矩形，并用一组宏边取代每个矩形内部的所有节点，从而实现最佳旅行。这种方法只适用于 4 连地图，通用性不如跳跃点剪枝法。它还需要离线预处理，而我们的方法是在线预处理。 死胡同启发式（Bj ̈ ornsson 和 Halld ́ orsson，2006 年）和沼泽（Pochter 等人，2010 年）是与我们的工作相关的两种类似修剪技术。两者都将网格地图分解为一系列相邻区域。之后，这种分解被用来识别与优化解决特定寻路实例无关的区域。这一目标与我们的工作类似，但又互为正交，我们的目标是减少探索搜索空间中任何给定区域所需的工作量。 修剪搜索空间的另一种方法是识别死单元和冗余单元（Sturtevant、Bulitko 和 Bj ̈ ornsson，2010 年）。这种方法是在基于学习的启发式搜索背景下开发的，只有在运行多次迭代深化算法后才能加快搜索速度。此外，识别冗余单元需要额外的内存开销，而跳跃点不需要。 快速扩展（Sun 等人，2009 年）是另一项加快最优 A* 搜索的相关工作。当它找到的后继节点与开放列表中的最佳节点一样好（或更好）时，就能避免不必要的开放列表操作。跳跃点是一个类似但本质上不同的想法：它允许我们识别出大量节点集，这些节点集通常会被扩展，但可以完全跳过。 在不要求最优化的情况下，分层寻路方法非常普遍。它们通过将搜索空间（通常是离线搜索）分解为更小的近似空间来提高性能。这类算法，如 HPA*（Botea、M ̈ uller 和 Schaeffer，2004 年），速度快、内存效率高，但也是次优的。 Notation and Terminology我们使用无向均匀成本网格图。每个节点都有≤ 8 个邻居，要么可穿越，要么不可穿越。从一个可穿越节点到它的一个相邻节点，每次直线（即水平或垂直）移动的成本为 1；对角移动的成本为√2。不允许涉及不可穿越（障碍）节点的移动。符号 d 指的是八个允许的移动方向之一（上、下、左、右等）。当 d 是一个对角移动时，我们将与 d 成 45 度角的两个直线移动记为 d1 和 d2。 路径 π = 〈n0,n1,…,nk〉是一条从节点 n0 开始到 nk 结束的无循环有序行走。我们有时会在路径的上下文中使用 setminus 运算符：例如 π \\ x。我们还将使用函数 len 来表示路径的长度（或成本），使用函数 dist 来表示网格上两个节点之间的距离：例如 len(π) 或 dist(n0,nk)。 Jump Points在本节中，我们将介绍一种搜索策略，通过有选择地只扩展网格图上的某些节点（我们称之为跳跃点）来加快最优搜索速度。我们在图 1(a) 中给出了基本思想的示例。 在这里，搜索正在扩展一个节点 x，它的父节点是 p(x)；从 p(x) 到 x 的移动方向是向右直线移动。在扩展 x 时，我们可能会注意到，评估任何突出显示为灰色的邻节点都没有什么意义，因为这种移动所引起的路径总是被提及 p(x) 而未提及 x 的另一条路径所支配（即不优于）。我们建议不要像经典的 A* 算法那样生成这个邻居并将其添加到开放列表中，而是简单地向右移动并继续朝这个方向移动，直到我们遇到一个节点，如 y；它至少还有一个非主邻节点（这里是 z）。如果我们找到了 y 这样的节点（跳转点），我们就将其作为 x 的后继节点，并赋予其 g 值（或成本值）：g(y)=g(x)+dist(x, y)。或者，如果我们遇到了障碍，我们就会得出结论：在这个方向上继续搜索是没有结果的，因此不会生成任何结果。 在本节的其余部分，我们将开发一个宏步算子，通过识别直线和对角线移动情况下的跳跃点后续节点来加速节点扩展。首先，我们有必要定义一系列剪枝规则，以确定是生成节点还是跳过节点。这将使我们能够精确地定义跳点的概念，并给出跳点算法的详细描述。然后，我们将证明 “跳转 “节点（如图 1(a) 中的 x）的过程不会影响搜索的最优性。 Neighbour Pruning Rules在本节中，我们将制定从网格中剪除与某个节点 x 紧邻的节点集的规则。我们的目标是从每一组邻接节点（即邻接节点(x)）中找出无需评估的节点 n，以便以最佳方式达到目标。我们通过比较两条路径的长度来实现这一目标：一条是以节点 p(x) 为起点、访问 x 并以 n 为终点的路径 π，另一条是同样以节点 p(x) 为起点、以 n 为终点但未提及 x 的路径 π′。此外，π 或 π′ 提到的每个节点都必须属于邻居（x）。 根据从父节点 p(x) 到 x 的过渡是直线移动还是斜线移动，有两种情况需要考虑。请注意，如果 x 是起始节点 p(x)，那么它就是空节点，不会被剪枝。 直线移动 我们会剪除任何满足以下优势约束条件的节点 n∈ 邻居（x）： 图 2(a) 显示了一个例子。在这里，p(x)=4，我们删除了除 n =5 以外的所有相邻数据。 对角移动 这种情况类似于我们为直线移动制定的剪枝规则；唯一的区别是排除 x 的路径必须是严格占优的： 假设邻域（x）不包含任何障碍，我们将把应用直线或对角线剪枝（视情况而定）后剩余的节点称为 x 的自然邻域，它们与图 2(a) 和图 2(c) 中的非灰色节点相对应。当邻域（x）包含障碍物时，我们可能无法剪除所有非自然邻域。如果出现这种情况，我们就会说对每个这样的邻居的评估都是被迫的。 定义 1. 在下列情况下，节点 n∈ neighbours(x) 是被迫的： n 不是 x 的自然邻接节点 len( 〈p(x),x,n〉 ) &lt;len( 〈p(x),…,n〉\\x ) 在图 2(b) 中，我们展示了一个直线移动的例子，其中 n =3 的求值是强制的。图 2(d) 显示了一个涉及对角线移动的类似示例；这里 n =1 的评估是被迫的。 Algorithmic Description我们首先要明确跳跃点的概念。 定义 2. 如果节点 y 的值 k 最小，使得 y = x+k d，且以下条件之一成立，那么节点 y 就是从节点 x 向 d 方向的跳跃点： 节点 y 是目标节点。 节点 y 至少有一个根据定义 1 被强制评估的邻居。 d 是对角移动，并且存在一个节点 z = y + ki di，它位于方向 di ∈{ d1, d2} 的 ki ∈ N 步，这样根据条件 1 或条件 2，z 是一个从 y 跳转的点。 图 1(b) 显示了通过条件 3 确定跳转点的一个示例。在这里，我们从 x 开始，沿对角线移动，直到遇到节点 y。因此 z 是 y 的跳转点后继节点（根据条件 2），这反过来又确定了 y 是 x 的跳转点后继节点。 确定单个跳转点后续节点的过程见算法 1。我们从紧邻当前节点 x 的邻居剪枝集开始（第 2 行）。然后，我们不是将每个相邻节点 n 添加到 x 的后继节点集合中，而是尝试 “跳转 “到距离 x 更远但与 n 处于相同相对方向的节点（第 3 行至第 5 行）。例如，如果边（x，n）是从 x 开始向右直线移动的，我们就在紧靠 x 右边的节点中寻找一个跳转点。这个过程一直持续到邻节点集合用完，并返回 x 的后继节点集合（第 6 行）。 为了识别单个跳跃点的后续节点，我们将采用算法 2。该算法需要一个初始节点 x、一个行进方向 d 以及起始节点 s 和目标节点 g 的身份信息。概括地说，该算法试图通过沿行进方向 d 行进（第 1 行）并检测该位置的节点 n 是否满足定义 2，来确定 x 是否有任何跳跃点后继节点。如果符合，n 将被指定为跳转点并返回（第 5、7 和 11 行）。当 n 不是跳跃点时，算法会递归并再次沿 d 方向前进，但这次 n 是新的初始节点（第 12 行）。当遇到障碍且无法继续前进时，递归结束（第 3 行）。请注意，在每个对角线步骤之前，算法必须首先检测不到任何直线跳跃点（第 9:11 行）。这一检查与定义 2 的第三个条件相对应，对于保持最优性至关重要。 Optimality在本节中，我们将证明对于网格图中的每一条最优长度路径，都存在一条等效长度路径，在搜索过程中只需扩展跳跃点节点即可找到（定理 1）。我们的结果是通过为每条最优路径确定一个对称的替代方案得出的，我们将该替代方案分割成连续的线段。然后，我们证明这条路径上的每个转折点也是一个跳跃点。 定义 3. 转折点是指路径上任何一个节点 ni，从上一个节点 ni-1 到 ni 的行进方向与从 ni 到下一个节点 ni+1 的行进方向不同。 图 3 描述了我们在最优路径上可能遇到的三种转折点。节点 nk 处的对角线到对角线转折点（图 3(a)）包括从其父节点 nk-1 开始的对角线步长，以及从 nk 到其后继节点 nk+1 的第二个对角线步长，这次的方向不同。同样，从直线到对角线（或从对角线到直线）的转折点包括从 nk-1 到 nk 的直线（对角线）步，然后是到达其后继 nk+1 的对角线（直线）步（分别如图 3(b) 和 3(c)）。其他类型的转折点，如直线到直线，都是微不足道的次优转折点，在此不予考虑（这些转折点已被我们之前制定的规则剪除；再看图 2）。 现在，我们准备在跳跃点和转折点之间建立等价关系，这些转折点出现在某些最佳长度的对称路径上，我们称之为对角先行路径。 定义 4. 如果一条路径 π 不包含可以被对角线到直线的转折点 〈nk-1,n′k,nk+1〉替代的对角线到直线的转折点，且 π 的长度保持不变，那么这条路径 π 是对角线优先的。 给定一条任意的最优长度路径 π，通过对 π 应用算法 3，我们总能推导出一条对称的对角线优先路径 π′。 请注意，这只是一种概念上的手段。 定理 1. 最优对角线优先路径 π′ 上的每个转折点也是一个跳跃点。 证明 假设 nk 是沿着 π′ 的任意转折点节点。我们将考虑三种情况，每种情况都与图 3 中所示的三种可能的最佳转折点之一相对应。 对角线到对角线 既然 π′ 是最佳值，那么 nk 和 nk-1 附近一定有障碍物，迫使我们绕道而行。我们之所以知道这一点，是因为如果没有障碍物，dist(nk-1,nk+1) &lt; dist(nk-1,nk)+ dist(nk,nk+1)，这与 π′ 是最优路径这一事实相矛盾。我们得出结论，nk+1 是 nk 的强邻。这足以满足定义 1 的第二个条件，使 nk 成为一个跳跃点 直线到对角线：在这种情况下，nk 附近一定有障碍物。如果不是这样，nk 可能会被对角线到直线的转折点所取代，这与π′对角线优先的事实相矛盾。由于 π′ 保证是对角线优先的，因此我们得出 nk+1 是 nk 的强制邻接点这一事实。这满足了定义 1 的第二个条件，因此我们得出 nk 是一个跳变点的结论。 对角线到直线： 在这种情况下有两种可能性，取决于从 nk 出发是否可以通过一系列直线步骤到达目标，或者 π′ 是否有额外的转折点。如果目标可以通过直走到达，那么 nk 有一个跳跃点后继点，它满足定义 1 的第三个条件，因此我们得出结论 nk 也是一个跳跃点。如果 nk 的后继点是另一个转折点 nl，那么该转折点一定是直线到对角线，并且根据这种情况的论证，也是一个跳跃点。我们再次得出结论，nk 有一个满足定义 1 中第三个条件的跳转点继承点。因此，nk 也是一个跳变点。 定理 1. 用跳跃点剪枝法搜索总能得到最优解。 证明 假设π是网格上两个节点之间任意选择的最优路径，π′是对π应用算法 3 得出的对角线优先对称等效路径。我们将证明，在使用跳跃点剪枝搜索时，π′提到的每个转折点都会得到最优扩展。我们的论证如下： 将 π′ 分成一系列相邻的线段 π′ = π′ 0 + π′ 1 + … + 每个 π′ i = 〈n0,n1,…,nk-1,nk〉都是一条子路径，沿这条路径的所有移动都沿同一方向进行（例如，仅 “上行 “或 “下行 “等）。请注意，除了起点和终点外，路段起点和终点的每个节点都是一个转折点。 由于每个 π′ i 只包含单一方向（直线或对角线）的移动，因此我们可以使用算法 2 从 n0∈ π′ i（每段开始的节点）跳转到 nk∈ π′ i（结束的节点），而不一定要停止扩展中间的每个节点。中间的扩展可能会发生，但我们从 n0 以最佳方式到达 nk 这一事实是有保证的。我们只需证明 n0 和 nk 都被确定为跳跃点，因此必然会扩展。根据定理 1，沿着 π′ 的每个转折点也是一个跳跃点，因此在搜索过程中每个转折点节点都必须扩展。只剩下起点和目标。起点节点必须在每次搜索开始时展开，而目标节点根据定义是一个跳转点。因此这两个节点都要展开。 Experimental Setup我们在免费提供的寻路库层次开放图（HOG，http://www. googlecode.com/p/hog2）中的四个基准上评估了跳跃点剪枝的性能： 自适应深度 是一组大小为 100×100 的 12 幅地图，其中每幅地图约有 1.3 的面积被划分为大小不一的矩形房间和一大片空地，空地上还穿插着随机放置的大型障碍物。在该基准测试中，我们为每张地图随机生成了 100 个有效问题，共计 1200 个实例。 《博德之门》 是一组 120 幅地图的集合，取自 BioWare 的热门角色扮演游戏《博德之门 II：阿蒙之影》；它经常作为标准基准出现在文献中（Bj ̈ ornsson and Halld ́ orsson 2006; Harabor and Botea 2010; Pochter et al.） 我们使用了由 Nathan Sturtevant 提供的变体，其中所有地图都已缩放至 512×512 大小，以更准确地反映现代寻路环境。地图和所有实例可从 http://movingai.com 获取。 《龙腾世纪》 是另一个现实主义的标杆；这一次取自 BioWare 最近推出的角色扮演游戏《龙腾世纪》： 起源》。它由 156 张地图组成，大小从 30 × 21 到 1104 × 1260 不等。在该基准测试中，我们使用了大量随机生成的实例集，这些实例集也是由 Nathan Sturtevant 提供的，可从 http:// movingai.com 获取。 房间 是一组 300 幅大小为 256×256 的地图，这些地图被分成对称的一排排小矩形区域（7×7），并由随机放置的入口连接。该基准曾出现在（Pochter 等人，2010 年）中。我们为每个地图随机生成了 100 个有效问题，共计 30000 个实例。 我们的测试机配备 2.93GHz 英特尔酷睿 2 双核处理器和 4GB 内存，运行 OSX 10.6.4。 Results为了评估跳跃点，我们使用了 A* 的通用实现，并对其进行了调整，以方便在线邻接剪枝和跳跃点识别。我们以加速度来讨论性能：即在网格中进行和不进行图修剪搜索时，解决给定问题所需的时间和扩展节点数量的相对改进。使用这一指标，搜索时间加快 2.0 表示速度快了一倍，而节点扩展速度加快 2.0 则表示节点扩展数量减少了一半。在每种情况下，都是越高越好。图 4 显示了四个基准测试的平均搜索速度。表 1 显示了平均节点扩展速度；每列的最佳结果以粗体显示。 与沼泽的比较 我们首先将跳跃点与 Swamps（Pochter 等人，2010 年）进行了比较：Swamps 是一种用于加速寻路的优化剪枝技术。我们使用了作者的源代码及其 A* 实现，并使用其推荐的运行参数进行了所有实验：沼泽种子半径为 6，”无变化限制 “为 2。 如图 4 所示，在所有基准测试中，跳跃点剪枝对平均搜索时间的改善令人信服。在《博德之门》和《龙腾世纪》中观察到的最大差异是，使用跳跃点搜索能提前 25-30 倍达到目标，而使用沼泽搜索只能加快 3-5 倍。在表 1 中也可以观察到类似的趋势，总扩展节点数的提升更为明显。 基于这些结果，我们得出结论：虽然沼泽能有效识别地图中与实现目标无关的区域，但仍需花费大量精力搜索这些区域。跳跃点使用了一种更强大但却正交的策略，证明可以忽略沼泽所扩展的许多节点。由于这两个想法似乎是互补的，因此我们认为可以很容易地将它们结合起来：首先，应用基于沼泽的分解来修剪与当前搜索无关的区域。然后，使用跳跃点搜索地图的剩余部分。 与 HPA 的比较： 接下来，我们将跳跃点剪枝与 HPA 算法（Botea、M ̈ uller 和 Schaeffer，2004 年）进行比较。HPA 算法虽然不是最佳算法，但速度非常快，被广泛应用于视频游戏中。为了评估 HPA* ，我们测量了插入和分层搜索的总成本。我们没有细化任何抽象路径，而是假设有一个预先计算好的簇内路径数据库。这种配置是 HPA* 最快的通用实现方式，但需要额外的内存开销。在搜索过程中，我们使用了单级抽象层次结构和固定的 10 个集群规模。这些设置是原作者推荐的，他们指出，更大的集群和更多的层次通常没有什么好处。 如图 4 所示，跳跃点剪枝与 HPA* 相比具有很强的竞争力。在 “自适应深度”、”博德之门 “和 “房间 “中，跳跃点具有明显的优势，在某些情况下比 HPA* 的搜索时间缩短了几倍。在《龙腾世纪》基准测试中，对于长度小于 500 的问题，跳跃点的优势很小，但对于更长的实例，两种算法之间的差距就很小了。表 1 提供了更多信息：虽然使用跳转点搜索所扩展的节点比 HPA* 少得多，但每次此类操作所需的时间却更长。 我们的结论是，跳点剪枝是 HPA* 的一个有竞争力的替代品，对于各种问题而言，它有助于更快地找到解决方案。HPA* 仍然具有优势，尤其是在内存开销可以接受且最优性并不重要的情况下，但前提是在抽象图中插入起点和目标节点的成本（如果没有路径数据库，还可能包括细化成本）可以在寻找抽象路径所需的时间内得到充分摊销。进一步工作的一个方向是使用跳点剪枝来加快 HPA*：例如在插入和细化过程中。 Conclusion我们介绍了一种新的在线节点剪枝策略，用于加快无向均匀成本网格图上的寻路速度。我们的算法只从网格图中识别并有选择地扩展某些节点，我们称之为跳跃点。在跳跃点之间移动只需沿着固定的方向（直线或对角线）行进。我们证明，两个跳转点之间路径上的中间节点永远不需要扩展，”跳过 “它们不会影响搜索的最优性。 我们的方法在寻路文献中是独一无二的，因为它几乎没有缺点：它简单，但非常有效；它保持最优性，但不需要额外内存；它速度极快，但不需要预处理。此外，它在很大程度上与文献中的竞争性提速技术是正交的，也很容易与之结合。我们还没有发现任何其他算法具备所有这些特点。 与文献中的相关研究相比，新算法具有很强的竞争力。与最近最先进的优化剪枝技术 Swamps（Pochter 等人，2010 年）相比，我们发现跳跃点的速度快了一个数量级。我们还表明，跳跃点剪枝与 HPA* 相比具有竞争力，而且在许多情况下明显快于 HPA；HPA 是一种常用的次优寻路技术，经常用于视频游戏等对性能敏感的应用中。 进一步工作的一个有趣方向是将跳转点扩展到其他类型的网格，如六边形或三维网格（Yap，2002 年）。我们建议通过制定一系列类似于方形网格的剪枝规则来实现这一目标。由于这些域上的分支因子低于方形网格，我们认为跳跃点可能比本文所观察到的更加有效。另一个有趣的方向是将跳跃点与其他加速技术相结合：如沼泽或 HPA*。","link":"/2024/01/24/Online-Graph-Pruning-for-Pathfinding-on-Grid-Maps/"},{"title":"Path Planning for Autonomous Mobile Robots: A Review","text":"Path Planning for Autonomous Mobile Robots: A Review Abstract摘要：为移动机器人提供自主能力是有好处的。它使人们可以免去人类操作员的干预，这可能会在经济和安全方面带来好处。在大多数情况下，自主性要求使用路径规划器，使机器人能够考虑如何从其所在位置在某一时刻移动到另一时刻。鉴于文献中存在大量的方法，根据用户的要求寻找最合适的路径规划算法可能具有挑战性。此外，本文所分析的过去的综述作品只涵盖了其中的一些方法，遗漏了一些重要的方法。因此，我们的论文旨在作为一个起点，对迄今为止的研究进行清晰而全面的概述。本文介绍了路径规划算法的总体分类，重点关注与自主地面车辆一起使用的方法，但也可扩展到在表面上移动的其他机器人，如自主船只。此外，还从路径规划的角度探讨了用于表示环境的模型以及机器人的移动性和动力学。对分类中提出的每个路径规划类别都进行了披露和分析，并在最后对其适用性进行了讨论。 1. Introduction自主导航是移动机器人的宝贵财富。它有助于减轻机器人对人工干预的依赖。然而，它也需要解决许多任务或问题，例如路径规划。这项任务在于找到最佳行动方案，使机器人从当前状态到达理想状态。例如，这两个状态可以分别是目标和初始位置。这一行动路线以路径的形式出现，在许多其他著作中也被称为路线。路径的作用是引导机器人到达所需的状态。然而，考虑到机器人可移动的自由空间，可能会有无数条可能的路径。路径规划算法通常试图获得最佳路径，或至少是其可接受的近似值。==这里的最佳路径指的是最优路径，即通过最小化一个或多个目标优化函数得到的路径。==例如，这条路径可能是耗时最少的路径。这在搜救等任务中至关重要[1]：灾难受害者可能会在生死关头请求帮助。另一个需要考虑的优化功能可能是机器人的能量。在行星探索中，这一点至关重要，因为漫游车可用的能源资源有限[2]。同时，规划器生成的路径必须遵循任何强加的限制。这些限制可能来自于机器人对某些地形的适应性限制。机器人的运动能力和现有地形的特点限制了可执行的操作类型。这就减少了路径规划器可生成的可行路径的数量。 在文献中，有大量的路径规划方法，而且这种方法的数量近年来还在不断增加。因此，根据特定要求（例如上述运动限制）选择最合适的方法是一项具有挑战性的任务。此外，如下文所述，有关路径规划的最新评论和调查并未对大多数现有路径规划解决方案进行全面概述。这就是撰写本综述论文的主要动机：它详细描述了不同的路径规划类别，并针对其中的每一类，介绍了文献中具有代表性的相关参考文献，重点关注那些针对在表面上（地面、水面等）移动的机器人的算法。本文的结构如下。第 2 节介绍本文提出的对现有路径规划算法进行分类的方法。根据该方法，本文还明确指出了之前的工作存在重要疏漏的事实。此外，本节还分析了用于处理环境和运动信息的方法。接下来的章节将分别讨论这一分类中的一个类别： 反应计算（第 3 节）、软计算（第 4 节）、C 空间搜索（第 5 节）和最优控制（第 6 节）。最后，第 7 节总结了本文的内容，并对上述类别中包含的路径规划算法进行了讨论。 2. Path Planning Algorithms图 1 描述了路径规划的四个类别，每个类别又分为两个子类别。这种分类基于构建和返回路径的原则和基本机制。下一小节将更详细地介绍这些类别以及为何如此分类。第二小节将介绍环境建模和机器人与地形交互建模的不同方法。我们认为有必要增加这一内容，因为对于许多算法，尤其是 C 空间搜索类算法，有必要事先构建这些模型。 图 1. 现有路径规划方法分类示意图。共有四个主要类别，每个类别包含两个子类别。不同类别中相邻的两个子类别具有共同特征。该示意图还显示了某些子类别更倾向于全局规划或局部规划。 2.1. General Classification建议的分类考虑了路径规划算法的功能。在过去的许多综述中，人们对路径规划算法进行了两种区分：一是根据环境是否动态来区分；二是根据在线和离线路径规划算法来区分[3]；三是根据环境的大小来区分，是局部环境还是全局环境。通常，”在线 “与 “本地 “相关，而 “离线 “与 “全局 “相关。这其中的主要问题是，有一些算法可以同时归为这两类。没有重新规划能力的算法由于计算速度快，可以在线使用。相反的情况也可能发生。例如，一种名为动态窗口法（DWA）的反应式计算算法通常用于局部规划[4]，但也可用于全局规划[5]。Vagale 等人[6]提出了一种有趣的算法划分方法，即需要初步地图表示的算法（经典算法）[7] 和不需要初步地图表示的算法（高级算法）。经典算法包括图搜索方法，而高级算法则包括软计算和基于采样的算法。Souissi 等人[7]提出了几种清晰合理的路径规划分类：根据机器人模型（整体动力学、非整体动力学、动力学）；根据地图模型要求（需要或不需要）；根据重新规划能力（离线或在线）；根据初步配置参数（确定性或概率性），根据算法是否总是计算出相同的解决方案。 本文提出的分类（如图 1 所示）有两个主要目的。首先，与以往的综述相比，本分类旨在涵盖更多种类的算法。过去的许多综述都提出或声称要对路径规划进行综述，但从表 1 中可以看出，大多数综述都存在重大遗漏。在本表中，”是 “表示对相关算法进行了重要讨论。仅提及表示出版物承认至少存在一种或多种该类算法。如果括号之间有一两个算法，则表示这些算法只被简单提及。其次，在某些情况下，路径规划类别的命名方式并不明确。例如，其他一些综述对经典方法和启发式方法进行了区分 [8,9]。Patle 等人[10] 将后者称为 “反应式”。然而，”经典 “一词可能是一个相当模糊的术语，因为大多数规划算法都是基于已有数十年历史的方法。这一类算法还包括许多运作方式完全不同的算法。==启发式这一术语不仅用于指进化算法和人工智能算法 [8]，也用于指基于图搜索的规划算法 [4]。==有鉴于此，我们==建议使用四个类别（见图 1）进行一般分类： 反应计算、软计算、C 空间搜索和最优控制==。此外，图 1 显示了这些类别中的每个类别在一般情况下是如何主要用于局部或全局规划的。此外，每个子类别与其他类别的子类别在功能上也会有一些共同点，例如使用数值方法、存在用于事先调整算法的参数、要求用图形对地图进行建模或使用随机迭代过程。 2.2. Path Planning Workspace Modeling路径规划器需要获得描述环境的信息。例如，这些信息可以描述是否存在障碍物或与规划相关的表面特征。此外，用于计算路径的标准还与机器人与环境的交互方式有关。例如，只需尽量缩短路径长度，或许还能获得哪些区域可以穿越、哪些区域不可以穿越的信息就足够了，而要尽量减少能量消耗，则应考虑到地形力学和机器人的转向方式。 2.2.1. Environment Modeling表面移动机器人是在空间的某个区域内从一个位置移动到另一个位置。因此，有必要考虑运动模型将如何与该表面交互，以及路径规划器将如何处理。例如，有些算法需要构建一个图形，以某种方式代表机器人移动的环境。==图搜索算法（属于 C 空间搜索范畴）大多属于这种情况==。蚁群优化算法（ACO）等进化算法也可以使用图形。这种资产可以表示影响机器人导航的地形特征在场景中的空间排列方式。特别是，本文假定有关图形是建立在度量图的基础上，同时也承认本文讨论范围之外存在其他类型的地图，如拓扑图和语义图[22]。根据 Souissi 等人的研究[7]，有多种构建图的方法，如图 2 所示。Nash 和 Koenig [11] 的研究也对这种分类方法有所启发。他们对单元分解和路线图进行了区分。第一种方法是将曲面分割成单元格。这些单元格可以使用规则网格[3,4,7,11]或不规则网格[7,11]进行排列。图 2a-c 展示了如何使用正方形、三角形和六边形三种多边形中的一种来构建规则网格。它的主要优点是每个节点的索引简单，可以快速访问其中任何一个节点，并以优化的方式将其存储在内存中[23]。==不规则网格（如图 2d 所示）可以使网格更好地适应不同分辨率值的地形特征，但代价是可能获得较差的路径[24]。==单元格分解的其他形式还有导航网格和基于圆的航点图，如 Nash 和 Koenig 所解释的那样[11]。如前所述，环境的另一种表示形式是使用路线图。路线图是由边连接的节点构成的图形。每个节点代表机器人的一种可能状态，而每条边则表示如何从另一种状态到达该状态。路线图的例子包括==沃罗诺图[25]==（见图 2e）、==可视图[26]==和==状态网格图（见图 2f）==。后者包括根据运动基元制作边，因此在机器人移动限制条件下，所产生的路径确保是可行的，尤其是在使用图搜索算法时，如 Likhachev 和 Ferguson [27] 以及 Bergman 等人 [28] 的研究。 图 2. 不同类型的环境单元分解图（a-d）和路线图（e-f）。(a) 正方形网格。(b) 使用三角形的棋格图。(c) 使用六边形的网格。(d) 不规则网格。(e) Voronoi 路线图。(f) 状态网格图。 这些图中的单元或节点可以静态或动态元素的形式存储其所在位置的地表信息[10]。例如，这可以是高程信息。数字高程图（DEM）是一个网格，其中每个节点都有一个相关的高程值。高程图也可以用多边形表示，==但常规网格图更受欢迎[29]==。与形状相关的特征，==如坡度或表面粗糙度，可通过卷积矩阵提取 [30]。==核的大小和 DEM 的分辨率将决定提取的特征类型。此外，这种分辨率还决定了地图中所包含要素的详细程度。如图 2d 所示，这种分辨率可以是非均匀的，也可以是多重的。网格的大小可以根据规划的规模来选择： 在覆盖机器人周围环境的情况下（或多或少是机载传感器可触及的距离），网格的大小为本地网格；而在覆盖范围大于本地网格的情况下，网格的大小为全球网格，通常使用卫星或无人机等外部来源的信息。 关于如何定义规划器工作区的成本，有不同的方法。首先，==我们将成本理解为机器人在移动过程中累积的度量。路径规划器的目标是通过生成最优路径，最大限度地减少这种累积。==有关成本可以是统一的，即机器人可以进入的区域始终具有相同的值。这种方法可用于避免碰撞的路径规划，在这种规划中，诸如二维平面上的路径长度等指标都会被最小化。==非均匀成本地图可用于为不同的可访问区域分配不同的成本值。例如，这对确定机器人在每个位置的能量性能非常有用。==此外，成本还可以根据方向向量来定义。这意味着，机器人将根据其航向具有不同的成本值。在这种情况下，==成本被归类为各向异性[31]==，而在相反的情况下，成本则是各向同性的。此外，机器人的转向动作也会根据其运动情况产生不同的成本值。最后，值得注意的是，环境可以是完全已知的，也可以是部分已知的，甚至是完全未知的。 2.2.2. Robot–Surface Interaction Modeling地面移动机器人与脚下的地表相互作用，推动自身前进。为了实现这一功能，有许多不同的运动执行器，例如轮子、履带、腿，甚至全向轮。图 3 展示了三个使用不同配置执行器的地面移动机器人的实际例子。这些致动器以及将它们连接到机器人本体的关节决定了机器人的运动结构和动态行为。换句话说，它们决定了机器人的运动配置。Zhang 等人[20]总结了一些众所周知的不同配置的运动学和动力学模型： 差动驱动[32]（见图 3a 中的 Koguma 机器人[33]为例和图 4a 中的模型描述）、阿克曼转向[34]（见图 4b、d）、滑行转向[35]（见图 4c）和全向[36]。其中一些模型包含与路径规划相关的约束条件，如前阿克曼转向机器人的最小转弯半径[37]（见图 4b）或滑行转向机器人在转弯动作中的高能耗[38]。此外，还有一种称为 “蟹行 “的模式（见图 4e）。由于所有车轮的顶部都有转向关节，这种模式允许机器人朝不同的方向行驶 [39]。此外，某些运动学配置还允许机器人进行点转向操作，使其在不平移的情况下旋转。值得一提的是，有一些铰接式机器人能够重新配置自己，以获得某种好处，并执行多种类型的运动（图 3c 中的 SherpaTT 就是一个例子）。例如，带有履带的铰接式机器人可以在崎岖地形上行驶时主动控制其稳定性[40,41]。还有一些机器人使用脚轮配置来执行一种名为 “轮行”（Wheelwalking）的运动模式 [42,43]。这种模式旨在克服机器人可能被卡住的松软地形。与此类似，推拉式运动模仿毛毛虫的运动方式，以增加在此类地形中的牵引力[44-46]。承认这种重构能力的路径规划算法是这类机器人必须具备的，因为这些算法可以找到利用其高度适应性的路径。在全局规划方面，Rohmer 等人[47] 使用了一种名为 Dijkstra 的图搜索算法，首先生成一条路径，然后通过仿真工具评估哪种运动模式更适合驱动每个部件。我们，这篇综述文章的作者，提出了使用 PDE 求解方法，在规划时使用各向同性成本函数考虑多种运动模式 [48,49]。据作者所知，目前还没有很多局部规划方法可以解决具有多种运动模式的机器人的动力学约束问题。Reid 等人[50]提出使用基于采样的算法–快速行进树（FMT*）–来解决带轮腿的可重构混合机器人的运动规划问题。 机器人的运动适应性好坏取决于地形特征，这在前面已经简要提到过。这些特征可能与地形的形态（形状）或构成有关。其中之一就是地形的倾斜度或坡度[51]。坡度会影响机器人的滚动角和俯仰角，这对于保持机器人的稳定性非常重要 [41,52,53]。此外，坡度还会根据方向影响机器人的能量表现。这种对方向的依赖性是由于重力的影响，使机器人在爬坡、下坡、横向或斜向穿越斜坡时消耗不同的能量[29,54-57]。另一个相关的地形特征是粗糙度。这是对法线矢量多样性的衡量 [58,59]，可能会影响机器人所经历的振动。根据机器人的底盘，它还可以克服其他地形。例如，机器人可以利用机身间隙（即机身下表面与地形表面之间的空间）克服岩石[60,61]。洞或沟等负面障碍物的存在可能会造成问题，因为它们很难被机器人的传感器捕捉到 [62]。至于地形的构成，它对机器人与地表交互的基本动态有影响。这种表面可能更坚硬，也可能更容易变形 [63]。这会影响机器人附着在表面上的方式，甚至限制其运动 [64]。一般来说，滑移是衡量机器人实际速度与指令速度之间差异的指标，通常通过计算两者之间的比率来实现 [65,66]。一些研究同时考虑了滑移和地形坡度，以便在穿越崎岖地形时对机器人进行更精确的估算 [67,68]。重力大小也会影响机器人与地形之间的动态交互 [30,69]。最后，路径规划器通常使用包含与形状和组成相关的多种地形特征的成本函数。例如，Ishigami 等人[2] 引入了动态移动指数，包括稳定性、滑移、经过时间和能耗。此外，与地形没有直接关系的其他因素也可能影响机器人的导航性能。其中之一就是太阳辐射 [66,70]，可将其建模为动态函数 [71]。Groves 等人[72]绘制了可能对机器人造成伤害的其他辐射类型，如在核拆除场景中。此外，风险概念对于防止机器人陷入危险境地也非常重要 [73]，例如，随着机器人靠近障碍物，成本也会增加 [74]。 图 4 轮式地面移动机器人的运动模型 轮式地面移动机器人使用的运动模型以及路径规划器： 差速驱动 (a)、前阿克曼 (b)、滑移转向 (c)、全阿克曼 (d)、抓取 (e) 和点转向 (f)。 3. Reactive-Computing-Based Path Planning Algorithms这类算法包括路径规划算法，在这类算法中，环境（通常是一张区分障碍物和非障碍物区域的地图）只显示现有障碍物的位置和形状。==反应式计算算法通常被用作局部路径规划算法==（覆盖机器人周围环境并进行动态重新规划），因为它们有能力快速处理新信息（例如，以新发现障碍物的形式），这些信息通常来自有限的机载传感器。作为局部规划算法，==这些算法通常会在遵循另一种算法制定的全局规划的同时，规划下一条直接路径或机动动作，以避开附近的障碍物。==不过，==这些算法可能会计算出局部最小路径，甚至导致机器人被卡住，因此必须特别小心。==反应式计算算法有两个子类别： 反应式机动方法，即由障碍物的存在决定机器人的下一步行动；局部优化方法，即根据障碍物的存在修改现有路径。 3.1. Reactive Manoeuvre本文介绍的算法依赖于定义机器人在每一时刻对障碍物的存在做出的反应。这种反应可以根据处理现有障碍物位置的公式来定义。不同表述方法的共同特点是产生反应所需的计算量较低，通常以转向或速度指令的形式出现。由于这种表述方式缺乏全局信息，因此这些技术通常被用作局部规划器。这种方法可以利用场来确定障碍物的位置，也可以通过检测障碍物边界来绕过障碍物，还可以在评估可用自由空间或移动障碍物的速度后发出速度指令。 ==势场法方法包括人工势场（APF）和矢量场直方图（VFH）算法。==在人工势场算法中，机器人的运动可以来自障碍物等外部元素产生的虚拟力的总和。这样，机器人会离这些障碍物越来越远，并避免与它们发生碰撞，因为来自它们的力是排斥性的 [75]。目标位置产生的吸引力会使机器人朝目标位置前进。从图 5a 中可以看出这一点。Ge 和 Cui [76] 提出了 APF 在包含动态障碍物环境中的应用。不过，这种策略的主要缺点是容易导致机器人陷入局部最小点。因此，进一步研究工作的方向是克服这一问题。这正是 Vadakkepat 等人[77]研究的主要目标。他们将 APF 与遗传方法（进化算法）相结合，以克服这种情况。这一组合还被用于规划模拟六轮漫游车的运动[78]。另一个混合版本包括使用 PSO 算法 [79]。Triharminto 等人[80] 提出了一种非混合解决方案，即在漫游车周围添加一个斥势场。不过，该方案尚未在 U 形障碍物上进行过测试。其他研究通过在检测到机器人处于局部最小点时创建自定义逃逸路径来解决这一问题 [81]。此外，Bayat 等人[82] 提出了一种受静电势场启发的解决方案，即用所谓的标量势场来引导机器人，而不是使用虚拟力的总和。Borenstein 等人[83]提出的 VFH 可创建极直方图来评估机器人周围的障碍物密度，从而选择障碍物密度最低的转向角。几年后，VFH 又有了一些改进 [84,85]。 ==Bug 算法，即 Bug1 和 Bug2，可使机器人绕过途中发现的任何障碍物，直至到达目标[86]。==它们的主要区别在于，Bug1 能让机器人绕过所有障碍物（见图 6a），而 Bug2 只能绕过部分障碍物 [19]。Bug1 和 Bug2 都不追求最优性，而是追求简单易用和计算量极少。它们可以用在只配备传感器的机器人上，这些传感器只能探测到机器人附近的障碍物。这样，这些机器人要么朝着目标行驶，要么沿着它们发现的障碍物的边界行驶。Buniyamin 等人[87] 和 Campbell 等人[19] 的研究提到了改进这种算法的一些变体，总体上减少了机器人的行驶距离。Xu 等人[88] 使用的 Bug 算法考虑了转弯半径限制，可生成平滑转弯的路径。 图 6. Bug 算法（a）和带气泡边界的弹性带（b）算法中使用的概念的图形表示。(a) 使用 Bug1 算法后的路径。(b) 经历拉伸后的路径。 以下方法主要是为机器人生成速度指令。速度障碍法考虑到智能体和任何其他移动障碍物的速度矢量，计算出一条安全轨迹[89,90]。这种计算方法会评估一个碰撞锥，如图 5b 所示。Chen 等人[91]将速度障碍与另一种称为快速行进方阵（FMS）的算法混合使用。Wilkie 等人[92]考虑了汽车的 Front-ackermann（见图 4b）运动模型。Chakravarthy 和 Ghose [93] 建议使用碰撞锥算法，该算法与速度障碍类似，但考虑到了任意形状的障碍。Qu 等人[94]介绍了该算法与汽车模型（如图 4b 所示，采用 Front-ackermann 配置）的结合使用。最后，动态窗口法（DWA）是一种在速度空间中搜索速度指令以遵循无碰撞圆形轨迹的算法，该轨迹由可接受速度值和时间窗口限定[95]。该方案可能不是全局最优方案，而是局部最优方案 [4]。DWA 甚至可用于高速航行的机器人 [96]。Feng 等人[97] 提出了一种改进版本，通过减少搜索速度空间来降低复杂性。其他方法将该算法用于能量最小化路径规划 [98,99]。虽然该算法通常被用作局部规划算法，但 Zhang 等人[5]提出将其作为全局路径规划算法在全球范围内使用。 3.2. Local Optimization==这些算法通常从预先存在的路径出发，根据现有障碍对其进行修改。==在这种情况下，优先考虑的是将计算量保持在最低水平，而不是牺牲最优性甚至完整性。修改路径有多种选择，从在速度空间内选择速度曲线，到在人造力作用下拉伸和拉长路径，不一而足。 在路径规划中使用弹性带是由 Quinlan 和 Khatib [100] 提出的。该方法根据障碍物的情况对现有的无碰撞路径进行变形，拉伸（见图 6b）或拉长。根据路径中的一组点，创建一组重叠的子区域，称为 “气泡”。这些 “气泡 “覆盖了无碰撞区域，其大小以与障碍物的距离为界。这就意味着，在路径中靠近障碍物的部分，气泡更小、数量更多。该方法可用于动态环境中，但较大的变化可能会导致方法失效 [100]。此外，该方法还通过遵守曲率约束 Khatib 等人[101]和使用贝塞尔曲线[102]适用于非自主车辆。弹力带的扩展包括时间约束，被命名为定时弹力带（TEB）。这一扩展版本解决了机器人的动力学约束 [103]。 4. Soft-Computing-Based Path Planning Algorithms==这类算法的目的不是找到精确的最优解，而是近似最优解，并能容忍一定范围内的不精确。==一般来说，这些算法需要用户调整某些参数，以便根据环境特征正常工作。这些算法甚至可以处理动态环境，适用于涉及大量变量和高自由度的问题[8]。不过，一般来说，它们需要大量的计算资源。本综述沿用 Mirjalili 和 Dong 提出的分类方法[104]，将其分为进化法、模糊控制法和机器学习法。第一种方法使用受生物学和自然界启发的技术：它们从一个由个体组成的系统开始，随着时间的推移而变化，即进化。模糊控制和机器学习方法属于人工智能的一个子类别。它们分别使用模糊规则和神经网络来生成控制器。这些控制器对于在最初的未知场景中导航非常有用，一般来说，它们会根据机器人探测到的障碍物生成路径。总之，软计算算法允许对一系列重复性元素（自然个体、模糊规则或人工神经元）进行调整，以生成路径。 4.1. Evolutionary Computation==进化算法也被称为元启发式或自然启发式 [105]==。这些算法通过种群的进化产生一条路径。种群由智能个体组成，其行动仿照自然界中的行为[104]。这些行为可能涉及修改自身和/或与其他个体交互。在某些情况下，这些操作意味着个体在环境的自由空间（即机器人可到达的空间）中进行运动。在执行一系列这些操作后，算法会逼近最优解。最终的路径和收敛所需的时间取决于分配给个体的行为策略、场景的性质以及用户分配给某些可配置参数的值。后者的一个例子就是填充路径规划问题的个体数量。进化算法包括遗传方法和蜂群优化器。第一种方法使用染色体模型，而第二种方法则以生物的行为为模型。 如前所述，遗传算法是以染色体为模型的个体[106]。这些个体包含基因，就像染色体一样，以二进制数字的形式存在。这些数字编码了一个解决方案，即在解决路径规划问题的特定情况下形成路径的一组航点。换句话说，群体中的每个染色体都代表一条路径。图 7a 展示了一个使用网格的例子。网格由单元格组成，每个单元格都标有一个数字。遗传算法从一组随机染色体开始。这组染色体通过三个过程进化： 繁殖、交叉和突变 [107]。复制通过复制最好的染色体来产生新的染色体。同时也会删除最差的染色体。交叉是染色体交换基因的过程。突变在基因中引入随机变化，以鼓励探索搜索空间并避免局部最小值。不断重复这些过程，算法就会收敛。Zhang 等人[4]提到，遗传算法在接近最优解时收敛速度会越来越慢。Han 等人[108] 使用遗传算法在有动态障碍物的环境中寻找最短路径。Tuncer 和 Yildirim [109] 对突变过程进行了修改。这包括检查即将发生突变的位置周围的空闲节点。这项工作将结果与之前的变异方法进行了比较。另一项研究工作使用了遗传算法以及高达 2000 × 2000 节点的大型网格[110]。用于路径规划的遗传算法也在一个实验平台上进行了测试[111]。更多的改进包括初始选择航点时，考虑那些位于障碍物附近的航点[112]。Elhoseny 等人[113]考虑到染色体的多样性，在突变过程中引入了更为规范的探索策略。此外，==这项研究不仅优化了路径长度，还利用贝塞尔曲线保持了平滑度。==最后，Lamini 等人的研究[114]还对交叉过程进行了改进，使解决方案收敛得更快，并减少了机器人转弯的次数。Patle 等人[10]的综述中介绍了许多基于遗传方法的路径规划应用。 图 7. 进化算法示例： 遗传算法 (a) 和蜂群优化算法 ACO (b)。(a) 用于执行路径规划的遗传算法的功能。图中的路径为染色体形式，基因为 21-08-03-06。(b) ACO 算法的功能。模拟蚂蚁在最短路径上沉积更多的信息素。最终，大多数蚂蚁会沿着这条路径前进。 与基于遗传方法的算法不同，蜂群优化器使用在自由空间中移动和行动的智能体。在大多数情况下，这些个体是以动物为模型的。经过一系列迭代后，这些个体朝向目标的运动会形成一种模式，最终收敛到产生的路径上。表 2 介绍了文献中使用的一些模型。粒子群优化（PSO）算法因其简单性而脱颖而出。它的灵感来源于某些动物群体的行为，如鱼群[115]。它创建了一系列粒子，这些粒子会随着时间的推移自行重新定位，直到算法收敛。这些算法寻找最佳位置，并根据以往经验相互交流 [116]。Mac 等人[117]提出了一种路径规划器，将 PSO 与 Dijkstra 算法（下文将讨论的一种图搜索规划器）相结合。另一种著名的算法是蚁群优化器（ACO），顾名思义，它是模拟蚂蚁的行为。这些昆虫在寻找食物的过程中会留下信息素的痕迹。其他蚂蚁可以追踪到这些痕迹。那些含有较多信息素的地方就是最佳发现路径的航点。图 7b 描述了在起点和目标位置之间有障碍物的情况下的这一概念。在这里，最佳路径就是最短的路径。按照同样的策略，虚拟蚂蚁可以在网格上移动，根据它们与目标之间的状态留下更多或更少的信息素 [118,119]。为了避免陷入局部最小值，一些研究将这种方法与启发式函数相结合 [120,121]。Che 等人[122]也通过采用灰狼方法中使用的规则解决了这一问题。Luo 等人[123]对 ACO 做了一些改进，不仅避免了死锁，还缩短了收敛所需的时间。还利用 DEM 对该算法进行了模拟，以最小化时间[124]和能量[125]。Sangeetha 等人的研究[126]也在避开动态障碍物的同时实现了后者。这项研究将 ACO 与模糊控制相结合。受自然启发的方法还有很多。为避免过多扩展，表 2 列出了其中一些。此外，还有将两种模型相结合的情况。Saraswathi 等人提出的方法就是这种情况[127]，其中对 Cuckoo 算法和 Bat 算法的混合进行了测试。 4.2. Artificial Intelligence软计算算法可使用其他可配置运算符集，如模糊规则或神经网络。Seraji 和 Howard [140] 演示了在一个实验性移动平台上使用模糊逻辑在非结构化地形中导航。Zavlangas 和 Tzafestas [141]提供了一个基于模糊逻辑的系统，旨在使移动机器人在动态环境中自主导航，避开途中的障碍物。Wang 等人[142]的研究重点是防止机器人陷入局部最小点，如 U 形障碍物产生的最小点。Pandey 等人[143] 还提供了模糊逻辑避障的模拟测试结果。关于神经网络的使用，==Yan 和 Li [144] 也在一个平台上使用了模糊逻辑，重点是尽量减少计算资源和穿越包含动态障碍物的环境。==Pandey 和 Parhi [145] 将模糊逻辑与一种名为 “风驱动优化 “的群体算法相结合，对模糊规则进行了调整。关于神经网络的使用，Zou 等人[146] 在 2000 年代初简要介绍了这类算法的应用。Engedy 和 Horváth [147] 为必须避开静态和动态障碍物的移动机器人介绍了一种使用神经网络的路径规划器。Zhang 等人[148] 使用这种技术在迷宫场景中寻找最短路径。这种方法还与遗传算法结合使用 [149,150]。 文献中的其他作品则将模糊逻辑与神经网络相结合 [151-154]。这方面有不同的方法。例如，Mohanty 和 Parhi [155] 将许多此类系统用于自主导航。Mac 等人[8]对相关混合方法进行了更深入的了解和更广泛的调查。此外，人们还研究了如何利用强化学习（RL）来控制机器人的运动 [156,157]。Faust 等人[158] 将强化学习与概率路线图法 (PRM) 相结合，这也是接下来详细介绍的算法之一。有关基于 RL 的规划算法的更多信息，请参阅 Sun 等人的研究 [21]。 5. C-Space-Search-Based Path Planning Algorithms这类算法将路径规划器的工作空间视为机器人可到达的所有状态或配置的空间。因此，这类算法中的大多数作品都将这一工作空间称为 C 空间。这些算法背后的主要思想是使用属于 C 空间一部分的离散样本集。换句话说，C 空间是离散的。这组样本包括初始状态和目标状态，或至少是相对接近这两个状态的样本。这样，这些算法就会执行搜索操作，访问这组样本。在某一点上，算法会找到并返回连接初始状态和目标状态的某个样本子集，该子集代表所产生的路径。换句话说，构成路径的每个航点都与 C 空间中的一个样本相对应。这意味着生成的路径在很大程度上取决于这些样本的分布、连接和访问方式。事实上，由于这种依赖性，有些方法需要进行后处理，以平滑生成路径的形状。 根据 C 空间离散化的方式，C 空间搜索类别又分为两类算法。图搜索算法是通过预先存在的图（如图 2 所示）来实现离散化的。该图中的每个节点都代表一个 C 空间样本，并与附近的其他节点（即其邻居）相连。基于采样的算法侧重于在 C 空间内以迭代方式创建和/或修改样本。即使在找到一条可行路径后，它们还能继续工作，找到更好的路径。 5.1. Graph Search==如前所述，C 空间可以以图的形式离散化。图搜索算法会全部或部分访问该图，直到找到连接初始状态和目标状态的路径。这类算法的第一种返回路径是将航点置于相邻样本之上。换句话说，路径上连续航点之间的连接与图边重合。==图 8a 是一个示意图，显示了在第一种情况下，路径的形状是如何由这些边决定的。因此，本综述将生成此类路径的图形搜索算法归类为边缘受限算法。因此，这些路径取决于图的结构。正如第 2.2.1 节所述，有多种单元分解和路线图形式的图结构。另一种图搜索算法 “任意角度”（Any-angle）就是为了解决这个问题而创建的，它对图的边进行了限制。之所以使用这个名称，是因为限制边缘规划器生成的路径只能使用特定的方向值。例如，在八邻规则网格中，如图 8a 所示，限制边缘的路径只能有 0、±45、±90、±135 和 180 度的方向。任意角度算法生成的路径不受限于这些方向，因为它们的航点不一定要放置在相邻节点上。图 8b 展示了这方面的一个例子。 图 8. 限边算法（a）和任意角度算法（b）生成的路径（红色）的主要区别：在第一种情况下，航点只能放置在连续（相邻）的节点上。 关于限边算法，图 9 展示了文献中==最具代表性的限边算法示意图==。最著名、最基本的限边路径规划算法是 Dijkstra 算法 [159]。该算法的第一步是选择一个节点，即起点或目标节点。此后，它开始向其邻居传播信息。这些信息可以是从起点出发所需的成本值，也可以是到达目标所需的成本值。算法会迭代访问已访问节点的邻居。关于成本的信息会不断传播，算法会为每个访问过的节点分配一个父节点。如果环境允许，即目标和起点之间没有障碍物，算法最终会同时访问这两个节点。此时，通过回溯父节点来检索路径。换句话说，路径从最后访问的节点开始，通过父节点返回。多年后，==哈特等人[160] 实现了启发式版本 A，== 以加快计算速度。后来，又有了进一步的改进。D 也被称为动态 A* ，是 A* 的增量版本，由 [161] 提出。增量版的意思是，每当分配给网格节点的成本发生变化时，该算法就会重复之前的计算。这就避免了算法从头开始执行全新的计算。例如，当机器人在行进过程中遇到新的障碍物时，这种计算量的减少允许快速重新规划。名为 Focussed D* 的改进版本进一步缩短了 D* 的计算时间[162]。Koenig 和 Likhachev [163] 提出使用终身规划 A* (LPA*) 作为 A* 的另一种直接增量扩展。他们以此为参考，开发出了更简单的 D* 版本，称为 D* -Lite [164,165]。Colas 等人[166] 在搜索和救援应用中的移动机器人上采用了这种算法。由于 A* 和 D* 算法，包括它们的版本，==都使用了启发式函数，因此得出的路径可能是次优的。==Likhachev 等人[167]提出了这些算法的随时版本，使用可配置的固定时间。在给定时间内找到的最佳路径由这些随时版本生成。多尔戈夫等人[168]提出了一种 A* 算法，即混合 A*，该算法在找到路径后通过重新排列节点，优先考虑所生成路径的可行性，以换取最优性和完整性的损失；从某种程度上说，该路径在运动学上是可行的。 关于任意角度算法，最早的算法之一是 Field-D* [169]。这是一种众所周知的算法，主要是因为美国国家航空航天局（NASA）的火星探测器自 Spirit 和 Opportunity 开始就采用了这种算法 [170]。与 D* 和 D* -lite 类似，它也是一种增量算法，因此会在后续执行中重复之前的计算。虽然 Field-D* 是克服路径受限于边的问题的杰出方法，但仍有改进的余地，可以找到更多最优路径。多年后，以 A* 为基础，更多的任意角算法被创造出来，它们都专注于在避开障碍物的同时寻找最短路径的问题。纳什等人[171]为此创造了 Theta* 。他们将其分为两个版本：一个是计算成本较低的 Base-Theta* ，另一个是成本较高但结果更接近全局最优最短路径的 Angle-Propagation Theta* 。Theta* 的主要前提是考虑障碍物拐角处的航向变化，与 Field-D* 相比，减少了路径上的航向变化 [172]。基础 Theta* 算法的增量版本后来被命名为增量 Phi* 算法 [173]。纳什等人[174]推出了更快的 Theta* 版本，即 Lazy-Theta。Theta 算法也得到了改进，能更好地处理非均匀代价图，即越接近障碍物，代价越高[175]。Šišlák 等人提出了加速 A* 算法[176]。它找到的路径比 Theta* 短，但速度较慢（尽管仍比 A* 快）。Yap 等人[177] 还引入了另一种名为 Block A* 的算法，并将其性能与 A* 和 Theta* 进行了比较。Nash 和 Koenig [11] 提供了另一项比较研究，其中包括加速 A、Block A、Field-D* 和 Theta* ，还包括后一种算法的变体。同一作者后来还将这种算法与可见性图的使用进行了比较[178]。Muñoz 和 R-Moreno [179] 建议使用 S-Theta* 算法生成平滑航向变化的路径。==3DANA 用于生成高程图上的路径[180,181]==。与 Theta* 和许多其他任意角算法相比，其他算法的结果有所改进，包括任意角子目标图 [182,183] 和 Anya [184,185]。 5.2. Sampling-Based基于采样的路径规划算法会按照不同的策略在 C 空间中创建一个又一个样本 [12,186]。之后，在满足特定条件或条件集（如达到时间限制）后，从创建的样本中检索路径。这种算法是渐进最优的。这意味着它们可以创建越来越多的样本，试图随着时间的推移找到更好的解决方案。一般来说，这些算法通常用于高维空间的搜索。然而，为了接近全局最优解，样本数量可能会相对较多 [14]，这就需要使用大量内存资源来存储所有样本。 如果只考虑两个点（起始位置或状态和目标），该算法就是单查询算法，而如果在同一环境下选择更多的点，该算法就被归类为多查询算法。关于单查询，最著名的算法之一是快速随机树（RRT）算法，它也是快速确定树（RDT）的一个特例[187]。该算法模拟了树的生长过程，即从一个起点开始，动态地创建样本，就像创建树枝一样。图 10a 描述了一个总结这一过程的方案。当其中一个样本与目标的距离超过一定距离时，就可以通过向后跟踪的方式找回路径，直至到达原点。如前所述，为了找到更好的路径，还可以执行更多的迭代。文献中可以找到对 RRT 的进一步修改。Kuffner 和 LaValle [188] 提出了一个双向版本，命名为 RRT-Connect。后来，Yershova 等人[189] 提出了 RRT 的改进版本，称为动态域 RRT，它能在树扩展过程中意识到环境中存在的障碍。Arslan 和 Tsiotras [190] 从图形搜索算法 LPA 中汲取灵感，提出了 RRT#，这是 RRT 的改进版本，收敛速度更快。Karaman 和 Frazzoli [186] 引入了一种名为启发式 RRT（RRT* ）的启发式 RRT 版本，以加快计算速度，同时仍能达到渐近最优。有关 RRT* 变体的广泛综述，请参阅 Noreen 等人的著作[14]。一种名为 “知情 RRT* “的改进版本在 RRT* 的基础上进行了改进，当找到一条可行路径时，将起点和目标位置围成一个椭圆[191]。接下来改进路径的迭代就在这个椭圆内进行，而不是让算法探索其他可能不会影响结果的选项。Gammell 等人[192]提出了另一种改进方法，称为批量有信息树（BIT），并进行了比较，证明其性能优于 RRT、有信息 RRT* 和 FMT。BIT 还借鉴了图搜索算法 LPA* 的一些步骤。区域加速批量有信息树（AIT）在 BIT 的基础上进行了改进，尤其是在存在狭窄走廊的情况下[193]。Adaptively Informed Trees (AIT* ) 和 Advanced Batch Informed Trees (ABIT* ) 算法在 BIT* 算法的基础上进行了改进，并被集成到 NASA 的一个实验性漫游车中 [194,195]。 关于基于采样的多重查询算法，最著名的是概率路线图法（Probabilistic Roadmap Method，PRM）[196]。这种算法从一系列已经分散在 C 空间中的样本开始。在此基础上，创建新样本，从每个初始样本创建一棵新树。图 10b 展示了这一过程背后的概念。之后，使用 A* 等图形搜索方法，利用 PRM 创建的图形检索路径。Karaman 和 Frazzoli [186] 提出了 PRM 的启发式版本。Park 等人[197]提出的改进方法采用了分层结构，减少了样本数量。Alenezi 等人[1]在模拟室内场景中对机器人进行了 PRM 测试。Ichter 等人[198] 提出了临界 PRM 算法，该算法将 PRM 与强化学习相结合，用于确定狭窄走廊等临界位置。 为了降低 RRT 和 PRM 的收敛速度，另一种基于采样的算法被命名为快速行进树（FMT* ）算法。它不仅借鉴了这两种算法的特点，还借鉴了一种名为 FMM 的优化控制算法，详情如下。FMT* 的主要目标是在涉及大量自由度的问题中找到避开障碍物的路径。Reid 等人[50]提出的铰接车辆运动规划就是一个例子。Ichter 等人[199]提出使用分组行进树（GMT），这是一种与 FMT 相似的算法，但其重点是通过 GPU 的并行化来加快计算速度。最后值得一提的是，有一些路径规划算法将动态采样方法与模型预测控制（MPC）技术相结合，以考虑动力学约束[57,200,201]。 6. Optimal-Control-Based Path Planning Algorithms基于控制方法的算法的基本原理是创建一个控制函数，将机器人从 C 空间的初始状态带向目的地。顾名思义，这里使用的是最优控制方法来解决路径规划问题[202]。与软计算方法的主要区别在于没有可配置的参数；这里的问题必须是完全封闭的。这里有两个不同的子类别。第一类是 PDE 求解，算法基于动态编程原理 (DPP)，在网格上求解偏微分方程 (PDE)[203]。第二个子类别，即数值优化，包括根据机器人的动力限制优化已有路径，使其可行的算法。 6.1. PDE-Solving-Based这里的优化控制方法基于动态编程原理，通过使用网格解决汉密尔顿-雅各比-贝尔曼方程 [204]。由于这是一个偏导数方程 (PDE)，这一子类被命名为 PDE 求解。它可以看作是计算波在网格上传播问题的数值解。波到达时间的值分配给每个网格节点。波的传播方式将取决于 HJB 方程的表达方式，包括代价函数。这种算法的主要缺点是通常无法处理不连续形式的约束。 HJB 方程的一个特殊情况是 Eikonal 方程。它不仅是静态的，而且还考虑了成本函数，只根据地图上的位置返回一个标量值。这意味着波在节点上的传播速度仅取决于分配的标量值。这样一来，特征方向就与总成本函数的梯度相吻合，因此只需使用梯度下降法就能检索出路径。多年来，人们提出了一整套方法，以较低的计算要求计算这一问题公式的解，因此这些方法被命名为快速方法 [18]。其中最著名的是由 Sethian [205] 提出的快速行进法 (FMM)。该算法采用与 Dijkstra 相同的策略访问网格节点。与 Dijkstra 不同的是，FMM 通过求解 Eikonal 算法为每个节点分配成本值。这样得到的路径是平滑、连续和最优的。Chiang 等人[206]将该算法与 A* 进行了比较，结果表明，由于路径不受网格限制，FMM 得到的路径更短。目前有许多使用 FMM 进行路径规划的研究 [207-210]。Gómez 等人[18]在综述中介绍了 FMM 的一些变体，其中大部分都降低了 FMM 的计算能力要求，同时还介绍了其他 Eikonal 求解器。它们是二进制 FMM、斐波纳契 FMM、简化 FMM 和不整齐 FMM。Eikonal 使用的成本值决定了计算波的传播速度。Petres 等人[24] 证明了这些成本值的梯度如何影响所产生路径的曲率半径。他们的研究还引入了启发式快速行进 (FM* ) 的理念，并将其与其他图搜索算法进行了比较。为了顺利避开障碍物，快速行进方阵（FMS）[74] 计算两次 FMM，首先在障碍物周围形成一个排斥场。图 11a 描述了由于障碍物附近的成本值较高（颜色较深），路径如何平稳地远离障碍物。Liu 和 Bucknall [211] 使用 FMS 以及对初始位置周围的成本进行修改，以考虑车辆的初始方向。研究人员还致力于提出 FMM 的增量版本，如 E* [212-214]。 要处理汉密尔顿-雅各比-0 贝尔曼（HJB）方程更一般的表达式，必须使用其他类型的方法。如果使用与方向相关（各向异性）的代价，FMM 会产生次优结果[215]。这种代价意味着，相对于节点的矢量代价而言，波的传播方向不同。在某些特殊情况下，FMM 可以在一定程度的各向异性条件下得出准确的结果，例如，成本函数的计算方式使其主要在与参考轴平行的方向上变化[24,216]。图 11b 描述的就是这种情况。Sethian 和 Vladimirsky [215] 建议使用一种名为有序上风法 (OUM) 的算法来处理静态 HJB 方程，Shum 等人[217] 证实了该算法的收敛速度。其主要缺点是计算成本的增加与场景中存在的各向异性成正比。Shum 等人[31]使用 HJB 进行各向异性路径规划，考虑了能量最小化和稳定性，并考虑了斜坡的方向和幅度。快速扫描法（FSM）也被证明适用于一般的静态 HJB 方程 [218]。它的工作原理是访问网格上的所有节点，沿着特定方向反复进行，这意味着它需要大量的迭代。Takei 和 Tsai [37] 使用 FSM 拟定 HJB 方程，以符合转弯半径约束条件。对于 Eikonal 情况，Bak 等人[219]对 FSM 进行了改进，以在成本变化过大时加快计算速度，Detrixhe 等人[220]则推出了并行版本。Jeong 和 Whitaker [221] 提出了一种名为快速迭代法 (FIM) 的算法，同样可以在并行架构上求解 Eikonal 方程。 6.2. Global Optimization该子类包含优化现有初步可行路径的路径规划算法。与第 3.1 节中介绍的局部优化方法不同，==全局优化方法是以投入更多计算负荷来换取路径的全局最优。==例如，Ratliff 等人[222]提出的方法首先使用基于采样的方法，如 RRT 或 PRM。第二步是使用梯度优化技术，从这条可行路径中逼近最优解。Van Den Berg 等人[223]也是从使用 RRT 计算出的轨迹开始，==随后将 jt 应用于基于差分动态编程（DP）的优化过程==。Plonski 等人[70]考虑到机器人会收获太阳能，因此使用 DP 计算了太阳地图中动态变化的路径。Ajanovi ́ c 等人 [224] 将 DP 与模型预测控制 (MPC) 相结合，计算出能量最小的路径。其他技术包括砰砰方法 [225] 和混合整数线性规划 (MILP) [226]。最后，Kogan 和 Murray[227]提出了一种独特的方法，他们使用非线性优化来规划长度在 20 米至 70 米之间的时间最优路径。 7. Summary and Conclusions根据本文提出的分类系统（见图 1），表 3 总结了每个路径规划类别的主要特征。表 3 分析了这些算法是否需要一个初步的环境模型、是否具有确定性（即在相同的初始条件下总能提供相同的解决方案）、是否能处理动态环境并重新规划、是否是最优的以及是否完整（即如果可行，总能返回一条路径）。考虑到最终路径规划应用的范围，有些算法会比其他算法更适合。此外，规划器的覆盖范围和重新规划能力（即处理环境信息更新的能力）将决定一种算法更适合局部规划还是全局规划。局部规划通常需要快速的在线计算，在环境数据发生变化时需要这种反应行为来规划新的路径。全局规划甚至可以离线计算，目的是在有静态初始环境的情况下，生成长距离穿越的路径。 基于反应式计算的算法似乎很适合局部避障路径规划，因为这些算法易于实现且成本低廉。此外，对于不确定性较高的场景或使用传感能力非常有限的机器人时，反应式机动方法也是一个不错的选择。局部优化甚至可以考虑使用 TEB 的动力学约束，尽管它们不能确保完整性。必须特别注意这两个子类别，以避免陷入局部最小值。软计算算法使用多个可配置的运算符生成路径，这些运算符的灵感可以来自自然界，也可以基于模糊规则和/或神经网络。它们适用于涉及大量变量的问题或难以建模的问题，例如高度动态的环境。在包含移动元素的情况下，在远距离（全局路径规划）情况下，使用进化法就足够了。最新的人工智能方法，包括 DL 和 RL 方法，还需要进一步研究才能得出可靠的结论，Sun 等人也指出了这一点[21]。基于模糊规则或神经网络的人工智能方法可用于快速局部规划，以替代反应式机动方法。C 空间搜索算法利用样本来表示机器人的不同配置。这些样本可以事先以图形的形式提供，也可以动态创建。图形搜索算法适用于全局路径规划，考虑到了高级图形（如可见度图或空间网格图），但需要投入时间来构建这些图形（这在离线规划中是允许的）。不过，这种算法在处理高维度问题时扩展性较差，因此需要使用基于采样的算法。事实证明，基于采样的算法也适用于此类操作和高维度问题。优化控制算法在获得全局最优结果方面表现突出。基于各向同性成本函数或各向异性成本函数的 PDE 求解算法在很大程度上依赖于所配制的 PDE，并且可以使用网格形式的地图模型。全局优化算法必须从已定义的路径开始，并根据机器人的运动限制进行调整。在不确定性较低的静态情况下，PDE 求解算法可提供最优路径，而无需重新规划，因此适合离线计算长距离穿越。最后，需要注意的是，所有这些规划算法都依赖于描述环境和机器人的可用信息。必须尽可能准确地模拟这些信息，才能改善路径规划器的结果。","link":"/2024/02/01/Path-Planning-for-Autonomous-Mobile-Robots-A-Review/"},{"title":"Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star","text":"Autonomous land vehicle path planning algorithm based on improved heuristic function of A-Star Abstract自主陆地车辆的路径规划已成为近年来的研究热点。本文提出了一种新型的自主陆地车辆路径规划算法。根据自主陆地车自主运动的特点，设计了一种改进的 A-Star 路径规划算法。使用 A-Star 算法进行路径规划的缺点是，A-Star 算法规划的路径包含许多不必要的转弯点，不够平滑。自主陆地车辆需要在每个转弯点调整姿态，这将大大浪费时间，也不利于自主陆地车辆的运动控制。针对这些不足，本文提出了一种新的启发式函数，结合人工势场方法，其中包含距离信息和障碍物信息。我们提出的算法在提高执行效率和减少转弯点数量方面表现出色。仿真结果表明，与传统的 A-Star 算法相比，所提出的算法能使路径更加平滑，使自主陆地车辆更易于控制。 Introduction近年来，陆地自动驾驶汽车（ALV）被广泛应用于应急救援、港口货运、物流配送等领域。1 路径规划在自动驾驶汽车领域占据核心地位，路径规划算法的效率直接影响自动驾驶汽车的寻路效率，而规划能力的实现决定了自动驾驶汽车能否高效、安全地完成任务。例如，在自动驾驶中不同车辆之间充分共享环境信息，不仅有利于实现更充分的路径规划，还能确保更高的安全等级。近几十年来，人们提出了许多路径规划算法，如 Floyd 算法、 Dijkstra 算法、 A-Star 算法、 蚁群算法、 粒子群算法 和人工势场等。 由于搜索速度快的特点，A-Star 算法已被广泛应用于解决静态路网的最短路径问题。A-Star 算法源于 Dijkstra 算法，引入了启发式函数以实现快速的节点搜索速度。然而，A-Star 算法的启发式函数只考虑了距离信息，导致寻路过程中出现多余的扩展节点。鉴于 A-Star 算法的不足，大量学者提出了相应的改进算法。洪斌等人提出了一种将改进的 A-Star 算法和动态窗口法相结合的混合算法，在复杂动态环境下具有良好的性能。Chen 等人将估值函数定义为指数衰减法，以减少冗余扩展。Wang 等人提出了一种基于网格映射的高效全区域覆盖路径规划算法。Zhang 等人考虑了无人艇的实际应用场景，通过增加角损耗项改进了评估函数，使最终路径具有最小的角，减少了路径上的损耗。Wu 等人通过建立禁忌表改进了 A-Star 的评价函数，从而快速有效地实现路径规划。Lin 等人通过引入父节点的影响来改进 A-Star 的实时性，但在对评价函数进行加权时没有考虑权重值的影响。 然而，上述算法在路径规划过程中只考虑了障碍物在全局地图中的位置，而没有考虑ALV周围的障碍物数量和距离，对地图信息的利用不够充分。针对 A-Star 算法路径不平滑的问题，我们提出了一种新的启发式函数，结合人工势场优化路径，提高搜索效率。在计算启发式项目时，我们的方法不仅考虑了当前位置到目标位置的距离，还考虑了当前位置周围的障碍物信息。仿真实验表明，我们的算法比 A-Star 算法性能更好。在网格地图环境下，比较 A-Star 算法和本文提出的算法，结果验证了我们的方法更有利于运动控制，规划的路径更平滑。 Establishment of environment model for ALV path planning对于路径规划而言，环境建模是至关重要的一步。根据建立的环境模型，真实的环境场景被转换成机器人可以处理的抽象场景，方便机器人进行路径规划。常见的地图表示方法包括拓扑建模法、轮廓地图法和网格地图法。 我们使用网格图法建立网格图，记录 ALV 的障碍物网格和路径信息。我们定义网格的属性，存储轨迹的父节点和网格是否为障碍物等信息，并使用矩阵将每个节点的信息映射到网格图中。然后对网格图进行二值化处理，将 0 定义为可通过的网格，1 定义为障碍物网格，从而得到二值化后的网格图。图 1 显示了网格图的一个示例。黑色网格代表障碍物，白色网格为可通过区域。在栅格化模型的环境地图中，地图被划分为多个紧密相连的小网格，每个网格代表地图的一个节点。地图中的每个节点只与相邻的八个节点构成一条路径。因此，在网格地图中，ALV 的移动方向一般只有 8 个，即网格地图中 8 个相邻节点的方向。 BackgroundA-Star algorithmA-Star 算法由 Hart 等人提出(Hart PE, Nilsson NJ, and Raphael B. A formal basis for the heuristic determination of minimum cost paths. IEEE Trans Syst Sci Cybern 1968; 4(2): 100–107.)，现已广泛应用于最短路径问题领域。作为一种典型的启发式搜索算法，A-Star 算法通过启发式搜索对节点进行评估，提高了节点搜索的效率，具有更好的性能和精度。启发式搜索使用估值函数，估值函数表示如下 其中，$f(n)$ 表示从起始位置经过当前位置 n 到目标位置的估计总成本, $g(n)$表示从起始位置到当前位置的实际路径成本，$h(n)$ 表示从位置 n 到目标位置的估计成本。 Artificial potential fieldKhatib 于 1986 年提出了人工势场法。人工势场法以目标位置为中心构建引力势场。引力势场的值随着自动驾驶汽车与目标之间距离的增加而增加，方向是从自动驾驶汽车到目标。吸引力势场函数的数学表达式如下 $f_a(x, y)$ 是吸引力势场函数，$\\epsilon$ 是比例因子。 以 ALV 的当前位置为中心，构建一个排斥力场，该力场随着障碍物与 ALV 之间距离的增加而减小，方向是从障碍物到 ALV。排斥力场函数的数学表达式如下： 其中，$\\rho(x, y) $为当前点$(x, y)$到障碍物的距离，$d_0$为距离阈值。当当前点到最近障碍物的距离大于 $d_0$ 时，不会产生排斥力。 这两个势场共同构成一个抽象的人工势场。人工势场法的势场力计算如图 3 所示 在人工势场中，对于空间中的某一点，ALV 将受到一个具有一定大小和方向的力的作用。人工势场法将 ALV 的运动抽象为受该虚拟力拖动的运动。 Method在应用场景中，ALV 首先在环境地图中规划路径，然后沿着路径前进。然而，在使用传统的 A-Star 算法进行路径规划时，规划的路径包含太多的转折点，路径不够平滑。因此，在路径跟踪过程中，ALV 需要进行许多不必要的姿态调整，以调整 ALV 的移动方向。当车辆沿着蜿蜒曲折的路径行驶时，会减慢 ALV 的速度，而且过多的姿态调整很容易破坏 ALV 的平衡。为了解决上述问题，本文结合人工势场方法的思想对 A-Star 算法进行了改进，并提出了一种新的启发式函数构造方法。在我们的方法中，周围障碍物和目标点对 ALV 的影响也包含在估算成本中。新的估值函数表达如下 其中，$f(n)$表示从起始位置到当前位置再到终点位置的总估计成本，$g(n)$ 表示从起始位置到当前位置的路径移动成本[22]，我们使用 $h(n)=h’(n)+v(n)$ 作为改进的启发式函数，$h’(n)$ 表示传统 A-Star 中的距离成本，$v(n)$ 表示潜在场地成本，包含周围障碍物的信息。 Improved distance heuristics $h’(n)$启发式函数的启发项 $h’(n)$ 对算法的计算效率有重要影响。它在总估计成本中的权重与 A-Star 的搜索速度呈正相关。启发式函数具有信息性。所谓启发式函数的信息量是指评估节点时的约束条件。信息量越大（即约束条件越多），被排除的节点就越多。 对于启发式项$h’(n)$的选择，有如下结论，其中$H(n)$为节点n到目标的实际路径长度。如果$h’(n)&lt;H(n)$，算法可以找到最优路径，但搜索节点较多，搜索效率很低；如果 $h’(n) = H(n)$，这是最理想的情况，算法可以以最高的效率搜索到最优路径；而如果 $h’(n)&gt; H(N)$，此时算法虽然搜索速度较快，但很难得到最优路径： 如果能找到更接近实际损失的启发式函数，就能提高搜索效率。A-Star 算法估计路径代价的函数一般取曼哈顿距离，此外还有欧氏距离和对角线距离。 假设矩形坐标中有两点 P 和 Q，P 点坐标为 $(X_{P}, Y_{P})$，Q 点坐标为 $(X_{Q}, Y_{Q})$，则 P 和 Q 之间的曼哈顿距离可表示为 考虑到正方形网格地图有八个移动方向，存在对角线移动，对角线距离更接近实际路径代价。为了简单验证这三种距离选择方法对 A-Star 算法的影响，我们通过实验仿真比较了不同距离选择方法下 A-Star 算法的搜索速度和搜索网格节点数。我们在大小为 40x40 的网格图上进行了验证实验，结果如图 4 和表 1 所示 实验结果表明，由于使用曼哈顿距离法计算出的估计成本大于实际路径中的成本，因此搜索时间最快，搜索网格数最少。但搜索范围最小，未能搜索到最短路径，这样规划的路径长度最长。用欧氏距离法计算的估计成本小于实际路径中的成本，所以网格节点数是三者中最大的；可以搜索到最短路径，但搜索时间是最长的。对角线距离更接近实际长度。因此，如实验所示，与曼哈顿距离和欧氏距离相比，使用对角线距离搜索的网格节点数量适中。 对角距离可以找到最短路径，而运行时间适中。因此，我们使用对角距离作为距离启发式 $h’(n)$。$h’(n)$的计算公式如下： 其中，$x_n$表示当前位置 n 的横座标，$y_n$ 表示当前位置 n 的纵座标，$x_e$ 表示目标的横座标，$y_e$ 表示目标的纵座标。 Obstacle heuristics $v(n)$根据人工势场法的原理，障碍物会产生排斥力，排斥力随障碍物与节点之间距离的增加而减小，而目标位置会产生吸引力，吸引力与节点到目标的距离成正比。本文将环境图构建为网格图，每个网格的位置用坐标表示。因此，势场力的计算方法与人工势场方法不同。 在栅格化地图环境中，斥力的计算公式如下，方向是从障碍物 i 到节点 k: 其中，k 表示当前位置，坐标为$(x_k, y_k)$；i 表示包含障碍物的第 i 个网格，坐标为$(x_i, y_i)$；n ~r 表示从障碍物 i 到节点 k 的矢量；e ~x 和 e ~y 分别表示 X 轴方向和 Y 轴方向的单位矢量。考虑到只有靠近 ALV 的障碍物才会影响 ALV 的工作，为了减少计算量，本文限制了障碍物的范围。其中，$\\rho(x_i, y_i)$是当前节点 k 到第 i 个障碍物的距离，$d_0$ 是距离阈值，本文中 $d_0 = 10$。 吸引力大小的计算公式如公式 (11) 所示，方向是从节点 k 到目标点 d 其中，k 表示当前位置，坐标为 $(x_k, y_k)$；d 表示目标点，坐标为 $(x_d, y_d)$；$\\vec{v_r}$表示从节点 k 到目标点 d 的矢量。 得出吸引力和排斥力后，可以计算吸引力和排斥力的合力，从而得出当前网格节点 k 所受的势场力。计算公式如下 这里的 $\\alpha$ 和 $\\beta$ 分别代表吸引力和排斥力的权重。在本文中，$\\alpha = 5$，$\\beta = 4$。 在人工势场法中，局部最小值问题是不可避免的。当计算出的 $\\vec{F}(k)$ 为 0 时，为了避免算法回到传统的 A-Star 算法，我们将在此时放弃斥力。此时 $\\vec{F}(k)$ 的计算公式如下 由于 A-Star 算法基于光栅化地图信息，因此在搜索节点时采用八邻搜索法，在搜索路径时只考虑八个方向的网格。上节计算的势场力是任意方向的。因此，在计算 $v(n)$ 时，我们将势场力投影到邻近节点的八个方向，即前、左前、左、左后、后、右后、右、前右。 计算过程如下： 首先计算从点 k 到相邻节点 n 的单位向量，如下式所示 图 5 显示了当前位置 k 在扩展其相邻节点 n 时的计算示意图。首先计算障碍物 S1~S3 的排斥力$\\vec{F}{r}(k, S_i)$; SiÞ和目标位置 d 的吸引力 $\\vec{F}{a}(k)$，然后计算所有排斥力和吸引力的结果力 $\\vec{F}(k)$。在计算当前位置 k 右侧节点 n 的 $\\vec{v}(n)$时，首先计算方向矢量 $\\vec{e_n}$，然后计算结果力在方向矢量上的投影，得到 $\\vec{v}(n)$。根据这种方法，计算节点 k 相邻八个扩展节点（不包括障碍物节点）的 $\\vec{v}(n_i)$。然后计算 $h’(n)$、$g(n)$ 和 $f(n)$，得到扩展节点的代价函数，并进行路径搜索。 算法步骤如下： 步骤 1：创建开放列表 O 和关闭列表 C，O 用于记录已生成但尚未访问的节点，C 用于记录已访问的节点；将起点添加到 O 中； 步骤 2：将 O 中代价 f 最小的节点 k 添加到 C 中，并检查该节点是否为目标节点，如果是目标节点，路径规划结束；否则，进入下一步； 步骤 3：扩展节点 k 的所有相邻节点。计算所有相邻节点 n 的 $v(n)$、$g(n)$、$h’(n)$ 和 $f(n)$。如果节点 $n$ 既不在 O 中，也不在 C 中，则将节点 n 添加到 O 中；如果节点 n 在 O 中，但计算出的 $f(n)$ 小于 O 中的旧值，则更新节点 n 在 O 中的 $f(n)$，然后根据 $f(n)$ 的值对 O 中的所有节点重新排序；如果节点 n 在 C 中，则跳过这一点。重复以上步骤，直到节点 k 的所有相邻节点都扩展完毕； 步骤 4：检查目标点是否在 C 中，O 是否为空。如果目标点在 C 中或 O 为空，则算法结束；否则，重复步骤 2~4。 Path smoothing要获得平滑的路径，常用的方法包括样条函数和贝塞尔函数。B 样条曲线是贝塞尔曲线的扩展。B 样条曲线的多项式阶数可以与控制点的数量无关，而贝塞尔曲线的阶数与控制点密切相关。因此，我们使用四元 B-样条曲线来平滑规划路径。给定 n þ 1 个控制点，四次 B 样条曲线的方程如下 Experiment本节设计了三组网格图进行实验验证，网格图中的每个网格代表 10 厘米 10 厘米的实际环境。仿真所用的计算机配置为 i7-6700HQ，16 GB 内存。 在第一张地图中，给定的起始位置坐标为(1, 1)，目标位置坐标为(20, 17)。原始规划路径如图 6（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 6(b) 显示的是平滑后的路径。表 2 列出了 A-Star 算法和我们提出的算法规划路径的比较。其中，算法消耗的时间是经过 30 次重复实验后得到的平均值。 如图 6 所示，A-Star 算法从靠近终点的一片障碍物之间穿过。改进后的 A-Star 算法避免穿越障碍物，而是选择从侧面绕行。计划路径中几乎没有不必要的转弯点。从表 2 中可以看出，路径长度都是 323.1 厘米，但 A-Star 算法规划的路径总共需要转弯 540 次，而我们提出的算法只需要转弯 315 次，大大降低了转弯成本。路径平滑后，A-Star 的路径缩短为 294.4 厘米，转弯角度减小到 219.09。我们的方法规划的路径缩短到 303.3 厘米，转弯角度减小到 140.86。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3.8 毫秒，而我们的算法耗时 5.2 毫秒。 在第二组实验中，我们选择了一个更为复杂的环境。ALV 需要多次绕过障碍物才能到达给定的目标点。给定的起始位置坐标为（24,17），目标位置坐标为（4,16）。 原计划路径如图 7(a) 所示。图 7(b) 显示了平滑后的路径。表 3 列出了 A-Star 与我们提出的算法规划路径的比较。 如图 7 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，两者规划的路径长度都是 906.7 厘米，但 A-Star 规划的路径总共需要转弯 1080 次，而我们提出的算法只需要转弯 540 次。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 99.6 毫秒，而我们的算法耗时 110.1 毫秒。 我们还对活性氧算法进行了实验。使用 Gmapping 方法创建网格地图，如图 8 所示，地图分辨率为 5 厘米=像素，膨化安全距离设置为 15 厘米。我们使用基于阿克曼模型的四轮驱动汽车，尺寸为 20 厘米 18 厘米 13 厘米。给定的起始位置坐标为（3.6 米，2.15 米），目标位置坐标为（4 米，15 米）。 原始规划路径如图 8（a）所示，其中红色为我们的算法规划的路径，蓝色为 A-Star 算法规划的路径。图 8(b) 显示的是平滑后的路径。表 4 列出了 A-Star 算法和我们提出的算法规划路径的比较。 如图 8 所示，改进后的 A-Star 规划的路径非常平直，几乎没有多余的拐点。表 4 显示，我们规划的路径长度为 1558.9 厘米，但 A-Star 规划的路径总共需要转弯 1755 °，而我们提出的算法只需要转弯 495 次。经过路径平滑处理后，A-Star 的路径缩短为 1516.5 厘米，转弯角度减小到 687.46。我们的方法规划的路径缩短到 1534.9 厘米，转弯角度减小到 237.84。从实验结果可以看出，我们的算法比 A-Star 算法性能更好。由于我们的算法更复杂，计算时间比 A-Star 算法长。A-Star 算法耗时 3332.7 毫秒，而我们的算法耗时 6657.4 毫秒。随着地图复杂度的增加，所消耗的计算时间也在增加。如图 8 所示，A-Star 算法规划的路径有许多锯齿状的转折点。这使得路径不够平滑，不利于 ALV 的运动控制。由于 ALV 在每个拐点都要调整角度，这势必会降低速度，影响运行效率。 实验仿真结果表明，与传统的 A-Star 算法相比，我们的改进算法转弯损耗更低、路径更直。我们的算法规划的路径长度与 A-Star 算法相似。但是，与 A-Star 算法相比，总转弯角度减少了 4060%。不过，我们的算法更为复杂，计算时间也比 A-Star 算法长。特别是在障碍物较多的环境中，计算时间会明显增加，算法效率仍有待进一步提高。我们的算法减少了拐点，让 ALV 更容易调整姿态，实现 ALV 的自主移动。当 ALV 在运行过程中遇到转弯时，它会降低速度并调整角度，以确保安全运行。在这个过程中，ALV 的效率会降低，控制难度会增加，而且会消耗大量时间。我们的方法虽然增加了规划时间成本，但提高了运行效率，减少了 ALV 的运行时间和控制难度。 Conclusion本文提出了一种新的启发式功能设计方法，以改进广泛使用的 A-Star 算法。考虑了周围障碍物对小车运行的影响。在启发式函数中加入了人工势场力，加强了算法的搜索方向信息，从而提高了 A-Star 算法的性能。与传统的只考虑距离的启发式函数相比，我们的方法考虑了周围的障碍物信息，更适用于障碍物较多的环境；改进后的算法规划的路径更直，有效减少了不必要的拐点，使小车能尽可能少地调整角度，减少了路径损耗，更有利于小车的运动控制。","link":"/2024/01/30/Autonomous-land-vehicle-path-planning-algorithm-based-on-improved-heuristic-function-of-A-Star/"},{"title":"A Novel Heuristic Emergency Path Planning Method Based on Vector Grid Map","text":"A Novel Heuristic Emergency Path Planning Method Based on Vector Grid Map Abstract摘要： 应急路径规划技术是智能交通系统的研究热点之一。由于城市路网的复杂性和道路拥堵状况，应急路径规划非常困难。城市突发事件造成的道路拥堵会直接影响原有的路网结构。这样，原有路网的静态权重就不再适合作为路径推荐的依据。为了处理动态的态势路网，将设计一种等距网格应急路径规划框架。基于态势信息，提出了一种新的态势网格路网模型，并将其应用于等距网格应急路径规划框架。基于该模型，将提出一种态势网格启发式搜索方法，可用于检测拥堵区域网格周围的车辆通过情况，并在最短时间内找到通往目的地的道路。在路径规划方法中，加入了基于四元数函数的网格启发式搜索策略，可以使算法快速收敛到目标网格。本文提出了三种图加速算法，以提高路径规划算法的搜索效率。最后，本文将设置三个实验来验证我们提出的方法。 1. Introduction近年来，随着城市路网越来越繁忙，应急绕行路径规划也变得越来越重要。在城市道路上经常会出现一些道路拥堵现象，尤其是在城市的早晚高峰时段，道路拥堵更为严重。针对这种情况，人们对如何成功地使汽车避开拥堵区域，以确保车辆能在最短时间内到达原定目的地进行了多项研究。因此，这种路径为车辆提供了一条绕行的紧急路径[1,2]。 目前，已有研究人员在此研究方向上提出了相关的疏散模型和疏散拥堵模型[3-7]。现有的路径规划研究主要集中在静态路网的动态路径规划上。Kim 等人[8]利用路网的空间结构提出了一种疏散路径规划（ERP）模型，以尽量减少计算时间。另一种是基于传统场景的紧急路径规划系统。Khalid 等人提出使用基于免疫的方法来解决动态路径规划问题[9]。该方法降低了元启发式方法的计算复杂度和最优解生成，启发式方法采用基于免疫的综合疏散规划（iEvaP+）方法，具有动态性。Zhang 等人[10]提出了一种人车协同情境模型。该模型是对大量混合流涉及绕行区域内的行人和车辆进行优化设计的综合线性模型。 其他研究侧重于道路交通的短期和长期预测[11]。Li 等人[12]研究了一种高效的时空神经结构搜索方法–自动搜索。该方法主要是更新各卷积层的时空相关性和层间条约学习的方法。Dai 等人[13]提出了一种混合时空图卷积网络（H-STGCN），它能够通过接收到的交通数据 “推断 “出未来的出行时间。例如，当信息受到干扰或缺失时，该方法可以参考上下文信息有效预测现有的道路交通流量。Lin 等人[14]提出了一种动态开关注意网络（DSAN），该网络具有新颖的多空间注意（MSA）机制，可明确测量输入和输出之间的相关性。该方法能有效过滤噪声，减少预测误差。该方法可有效预测短期和长期交通流量。 不过，上述方法都是对历史数据进行训练和计算。在应急场景下，通过历史数据无法有效预测现有交通流量。原因在于，应急场景中的随机性相对较大，因此无法通过概率计算出城市某一道路区域发生应急事件的概率。例如，从图 1 可以看出，当城市车辆遇到道路拥堵时，需要提前绕行。因此，本文的难点在于如何在路网图上给出具有态势动态的 top-k 绕行路径，使车辆能在最短时间内绕过紧急区域，驶向目的地。 为解决这些问题，本文将介绍等距网格应急路径规划（EGEPP）框架。该框架是对我们之前工作[15]中提出的网格地图应急路径规划（GMEPP）框架的改进。GEMPP 框架主要应用于紧急路径的疏散路径规划，并不考虑绕行路径的规划。因此，在 EGEPP 框架中，我们主要以路网速度和道路通行能力作为路径选择和网格选择的依据。这里需要注意的是动态路网的特点，因为紧急时间的开始是随机的，但其发展过程是附近的交通流量随着时间的推移逐渐减少，也就是说拥堵区域的车辆数量符合正态分布[16]。 根据这种情况，将设计一种新颖的情境网格路网模型（SGRN），该模型将具有时空特征的路网映射成随时间变化的动态路网图。然后，将引入==基于 SGRN 的情境网格启发式搜索算法（SGHS*）==。该方法将使用时间消耗函数和时间启发式函数来决定路径选择。它还包含一种基于动态路网的剪枝策略。最后，我们提出了一种基于情况网格的路网加速算法，以优化查询路径。总之，本研究的贡献总结如下： (1）本文介绍了一种紧急状况下的情景网格路网模型，称为 SGRN 模型； (2）一种名为动态网格 PageRank（DGPR）的新方法可根据当前路网的交通容量对所有网格进行排序，并为每个网格分配不同的等级值； (3) 引入时空动态地图的 SGHS* 算法，该方法根据排序后的网格规划绕行路径，并通过规划网格之间的两部分组成整体规划结果。根据 SGHS* 路径规划算法，提出了基于时间特征的剪枝策略，以确保在给定时间窗口内给出的路径结果使车辆行驶耗时最少； (4）最后，将提出基于情境网格的三种路网加速算法情境收缩层次结构（SCH）、情境网格收缩层次结构（SGCH）和情境网格多重反向收缩层次结构（SGMRCH）。有三种方法可以建立路网收缩哈希表，并改变路网顶点后添加的捷径与原始边之间的关系[17]。 本文接下来的内容安排如下。第 2 节介绍了主要的相关工作。第 3 节介绍了应急路径规划的新模型。第 4 节详细介绍了基于网格图的网格排序 DGPR 算法。第 5 节介绍基于网格图的迂回路径查询 SGHS*，并根据给定的时间窗口 Tq 进行剪枝。第 6 节将介绍基于态势网格图的三种动态路网加速算法。第 7 节介绍了验证 EGEPP 效率的实验。第 8 节是本文的结论。 2. The Related Worked启发式是在状态空间中进行搜索，对每个搜索位置进行评估，一次搜索即可获得最佳位置，并从给定的原点搜索到目标。这样可以省去很多不必要的搜索，提高效率。位置估值在启发式搜索中非常重要。使用不同的估值会产生不同的效果。==启发式搜索有以下几个优点：(1) 从当前位置向目标搜索，向下搜索确保在同一层次中获得的解是最优解。这样就省去了很多不必要的搜索路径。(2）在搜索目标顶点的过程中，如果启发式函数设计合理，算法可以快速收敛。(3) 在一定的搜索区域内，保证了搜索顶点的广度，即获得尽可能多的搜索节点信息。== A* 算法擅长解决静态路径中的最短距离问题，不同于 Dijkstra 算法和 Floyd 算法，该算法结合了广度优先搜索（BFS）和 Dijkstra 算法的优点[18]： 在启发式搜索的同时，提升了算法的效率，可以保证找到最优路径（基于评价函数，如曼哈顿距离、欧氏距离），Floyd 算法[19]在机器人路径规划、游戏编程、卫星路径搜索等领域使用场景较多。 Singh 等人[20] 研究了一种用于在线搜索和优化的实时 A* （RTA* ）算法。建立了最小能耗函数。该方法实现了移动机器人在静态障碍物中的导航，并通过约束机器人向最优方向移动来生成能耗最小的路径。Khalidi 等人[5,21,22] 提出了一种基于启发式时间动态监控的路径规划方法 T* 。T* 算法的重点不在于路径最优，而在于减少寻找路径的计算时间。例如，基于采样的线性时序逻辑（LTL）运动规划算法能有效计算连续状态空间中的轨迹，但不能保证最优。Bhatia 等人 [23] 提出了一种基于多层的路径规划技术。这种方法的优势在于通过构建离散轨迹，在路径规划中尽可能缩小搜索空间，从而反过来减少路径规划的时间，提高搜索效率。Mashayekhi 等人 [24]研究了一种基于快速探索随机树的无人车 A* （RRT* ）算法，该算法增加了启发式策略和贪婪思想，在原有快速探索随机树（RRT）算法[25]的基础上，改进了父顶点的选择方式，利用代价函数在扩展顶点到父顶点的地域内选择代价最小的顶点，同时，每次迭代后都会重新连接树中已有的顶点，从而降低了计算的复杂度，逐步实现最优解。 其他研究也提出了基于广度搜索图的策略。Guo 等人[26]提出了基于动态路网的 Dijkstra 算法路径规划策略，并通过仿真实验分析了该算法在时间最短、距离最短、油耗最少等条件下的效果，保证了在人口不断增长的城市中提供合理的车辆路径规划策略。Fink 等人[18]采用了基于地形数据的 Dijkstra 算法的多目标变体，以实现三维表面的整体最优遍历。所获得的结果被用于全球漫游车水平优化规划器（GRHOP）自动化系统中，以快速、准确地同时设置多个约束条件下的优化路线。Souza 等人[27] 将 Dijkstra 方法应用于树状图分析，将采矿块作为树状图的节点进行分析，用于计算将采矿块运输至目的地的最低成本路线。运输成本在图的弧中被剔除，它可以使用欧氏距离或运输时间来计算最小路径。 在城市道路上进行紧急路径规划有两点需要考虑。一是基于路网态势的动态路径规划。态势信息首先是一个随时间变化的动态变量。在不同时间，情况变量的值会根据当前的相关信息发生变化。第二个因素是路径规划中的阶跃搜索（从当前节点到其他节点的搜索过程），考虑加入广度搜索节点的策略，尽可能满足交通拥堵地区的条件需求，使车辆道路通行条件更好。表 1 列出了本文提到的主要参数。表 2 列出了本文提到的方法缩写和全称。 3. Two New Models Based on Emergency Path Planning本节将介绍两种模型：时空路网模型和情景网格路网模型。这两个模型都是在图结构模式的基础上进行改进的。其中，SGRN 模型将原有的图结构模型改进为使用区域道路特征表示道路权重的模型。 3.1. Spatial-Temporal Road Network Model基于时空图的交叉口可表示为有向图 G = &lt; V, E &gt;，其中 V 是交叉口集合，E =&lt; vi, vj &gt; 是有序顶点对集合，表示 vi 到 vj 之间有一条路径，vi 和 vj ∈ V。一条路径 &lt; vs, vd &gt; 表示车辆从源点 vs 出发，到达点 vd，权重 w:= &lt; vi, vj, Ta &gt; 定义为一对交叉点 i 到 j 的时间成本，w 为非负数，所有长度均为正数。 需要强调的是，时间 Ta 表示车辆通过两个交叉路口道路的平均时间，Ta 值是一个函数，表示为 Ta = Len/S，它不是固定不变的，Len 代表道路长度，S 是车辆的平均速度。路径规划方法考虑了查询时间窗口 Tq 处路网的速度 S。Tq 的目的是确保用户在这一时刻的最优路径，因为道路的 S 在不同的时间有不同的值。 3.2. A Situational Grid Road Network Model情景网格地图被建模为 Gn-map = &lt;Pr, gridid, (v1, v2, … , vi)&gt;，其中 Gn-map 是以 ng × ng 表示的整个城市地图，gridid 代表地图中的 ID（ng 值将在实验部分详细给出），Pr 表示网格中交叉口数量与其他网格中交叉口数量的比率。该比率的值将被视为网格的换向能力。排序算法将采用基于 PageRank 的网格排序算法 GPR（该算法的实现将在第 4 节中详细介绍）。vi 代表网格中的所有顶点，一个网格中的交叉点越多，该网格与其他网格的通信能力就越强；另一个是包含每个网格中所有顶点的出度集 Vout ∈ V。 网格地图将整个地图划分为多个子地图，即 Gs ∈ Gn-地图。每个网格中都会有若干交叉路口和道路，在为网格赋值时会考虑到这些因素。将地图划分为多个区域后，框架可根据参数设置为每个区域赋值。这些数值为疏散路径规划提供了重要依据。这些数值的变化恰恰反映了区域的权重变化，同时在理论上也提供了可靠的依据，保证了该方法在以后算法搜索路径时，将交叉口和道路量化为可计算的权重问题。这正是在网格地图上进行路径搜索的优势所在。值得注意的是，城市地图的不规则形状会导致一些网格在我们的网格之后不包含交叉口或道路，因此这些网格 ID 将在预处理时从数据中删除。 在本文中，情景指的是路网路况的实时变化，即通常所说的路况变化[28,29]。城市路网的拥堵程度一般会随着时间的变化而变化，同时，由于地区差异，同一时间的拥堵程度也不尽相同。这种受时间和地理位置影响而变化的路网状况被称为具有时空特征的状况路网。之所以要考虑路网的态势信息，是因为拥堵区域不是固定不变的，拥堵程度也是不同的（本文将通过路网速度来表示道路拥堵程度，因此与拥堵程度不再相关）。 4. Equidistant Dynamic Grid Map Based on Situational Road Network本节将介绍等间距网格路网的动态方法。等间距网格指的是将整个路网映射成二维平面坐标，并将路网作为一个整体进行分割。图 2 显示了路网网格图层，图 2 中的蓝线代表城市道路，原始路网显示了路网结构，切割路网显示了整个路网进行切割后的等间距路网，划分为网格交叉的路网将网格路网（红圈）划分为不同的网格。 4.1. Grid Sorting Algorithm GPR本文使用的排序算法是基于论文[15]中传统 PageRank 方法和 GPR 方法的改进 DGPR 算法。1999 年，Page 等人在论文[30]中提出了一种名为 PageRank 的算法。该算法的主要思想是，一个页面越 “有效”，该页面的链接质量就越高，也就越容易链接到其他 “有效 “的页面。因此，该算法充分利用网页之间的关系来计算网页的重要性。这种方法的独特之处在于它考虑到了所有实体之间的相关性。 网格图的目的是将整个城市绘制成不同的网格，并计算出交叉口的数量和网格的容量，作为网格的权重。图 3 显示，网格交叉口（蓝点）被划分为不同的网格。根据 GPR，有四个交叉口的网格 1 的排名高于有两个交叉口的网格 2，因为就交叉口数量而言，网格 1 的疏散能力优于网格 2。然而，实际情况还需要考虑道路的连通性，也就是每个交叉口和网格图中的入度和出度。为了解决这个问题，本文介绍了一种基于网格地图 GPR 的网格等级值算法。在该方法中，每个网格中的交叉口（网络中的顶点）和指定每个网格中顶点的数量定义为 ng，ng 的大小是整个道路网络中网格排序的一个因素。ng 的选择在网格排序中起着关键作用。考虑每对顶点的车道数。与车道数较少的道路相比，车道数越多的道路在某一时刻的汽车数量就越多。 网格的秩值是通过 GPR 方法迭代计算得出的。GPR 将网格中与其他网格顶点相连的所有顶点视为边的数量。网格外的边数定义为网格内度数（GIDN）。该值将作为网格等级参数加入公式 (4)。每个网格的等级值可通过公式 (1)-(3) 计算得出。 在公式 (1)-(3) 中，GPR(gridID) ∈ [0, 1) 的结果就是网格的秩值（GPR 的取值范围将在实验部分详细说明）。如果 GPR(grid1)&lt; GPR(grid2)，那么 GPR(grid2) 将被推荐，因为它的值更高。其中，k:= 顶点直接相连的网格数，表示网格中的顶点不一定与相邻网格相连。Ri 是第 i 个网格的 GPR 值，i 代表网格的 ID，com 定义为一个网格中指向同一网格的不同顶点的集合，其值为边的数量。L 是道路的车道数。阻尼系数 e = 0.85 是为了防止网格间的局部循环，提高收敛速度。Pi 为权重，Pi 越大，表示第 i 个网格中的交叉点数量越多，权重越大，gridi 代表第 i 个网格，V 为整个网络中的顶点总数。Vgridi 是第 i 个网格中的顶点总数，同时在导航时被选中的可能性越大。N 是网格数，所有网格都至少包含一个交叉点。 地图网格的数量决定了栅格化后算法的运行时间。算法 1 描述了网格的分布和排序，第 2-6 行将路网中的顶点依次划分到每个网格中，并计算每个网格的外度顶点。第 8-17 行计算每个网格的秩值，经过一定次数的迭代后，秩值趋于稳定，最后，第 18 行返回带有矢量值的城市网格道路网。在算法 1 的一次迭代中，算法需要依次计算每个网格的秩值，即 O(n)。在计算某个网格的秩值时，需要考虑相邻网格的秩值。以此类推，在计算每个网格的秩值时，必须再次计算其他网格的秩值，即 O(n - 1) 次，因此 GPR 算法的时间复杂度为 O(n(n - 1))，即 O(n2)，其中 n 为路网中的交叉口数量。 4.2. Dynamic Grid Sorting Algorithm DGPR Based on Situational Road Network4.2.1. Road Network SpeedA 小节首先介绍了 GPR 算法，然后将介绍一种新颖的动态网格 PageRank 算法（DGPR），即根据路网中各条道路的路网速度对区域交通容量进行排序。在介绍 DGPR 算法之前，先介绍本文使用的路网速度原理。 论文[31,32]介绍了路网速度的提取方法和计算方法。论文[31]研究了一种混合径向函数（RBF）神经网络算法来预测道路拥堵情况，以获得道路速度。然而，预测道路速度可能有助于正常交通条件下的路径规划，但已经不适用于紧急情况下的路径规划。论文[32]提出了一种机器学习机制，通过获取 OpenStreetMap 数据来估算路网速度。然而，估计出的路网速度仍然不是实时的，因此紧急路径规划需要对实时路网速度特别敏感。 本文中的道路网络速度将用 $RS= (\\sum \\limits_{n=1}^k \\frac{Distance(v_i, v_j)}{T_{ij}}) / k $ 表示，其中 $T_{ij} $是车辆通过（vi, vj）的时间，RSn 代表车辆速度，$Distance(v_{i}, v_{j})$ 代表相邻两个交叉点的欧氏距离。值得注意的是，这里的速度是查询时间窗口 T 内所有通过车辆的平均速度。因此，整条道路的网络速度如公式 (4) 所示，其中 K 为 T 时间内通过（vi，vj）的车辆数。 4.2.2. Dynamic Grid PageRank动态网格排序的目的是在城市道路发生交通拥堵或影响道路的区域发生紧急情况时，为受影响的车辆提供一些相对通畅的道路和区域，使其能够避开和绕过。 图 4 显示了不同时间戳下的情况。绿色实线表示道路畅通，黄色实线表示道路上车辆较多，红色实线表示道路拥堵。路网速度会随时间变化。例如，图中由路口 A 和路口 B 连接的道路（vA，vB）显示，在 t1 和 t2 时刻，道路状况良好。但随着时间的变化，当时间到达 t3 和 t4 时，道路（vA，vB）的路网交通流量较大，道路拥挤。然后，当时间戳为 t5 和 t6 时，路况变差，出现拥堵，换句话说，此时路网速度较低，车辆行驶缓慢。 基于路网的实时动态变化，提出了动态网格排序 DGPR。本文对 GPR 算法进行了调整，以适应路网的实时变化。根据实时交通容量（路网速度）和道路承载能力，对整个城市路网进行区域排序。文中[15]提到了不同网格条件下 GPR 算法的收敛时间。本文仍将路网划分为六个分布区。因此，在不同的时间窗口下，每条道路的路网速度是不同的。DGPR 根据每个区域从内向外连接的道路（从两个不同区域连接的道路）的路网速度和区域内道路的承载能力对每个区域进行排序并作为点值。算法 2 描述了 DGPR 的运行机制。 算法 2 中的 T 代表查询时间窗口。由于 DGPR 会不断迭代计算每个区域的容量值，因此当时间达到 T 时，算法会重新读取路网数据并对区域进行排序。第 4-7 行计算每条道路的平均路网速度（根据公式 (4)），并将计算出的路网速度分配给每条道路，作为每条道路排序计算的初始权重。值得注意的是，在计算网格间的排序值时，并非每条道路都会参与，这大大减少了计算开销。$R_i$ 代表非常网格的初始排序值并使用平均道路速度值，gridη 是一个网格中的边缘数。$DA_{matrix}$ 是实时动态变化的秩矩阵，每个网格的区域路网速度秩值都存储在矩阵中。$Ψi$为第 i 个网格的路网因子容量。第 9-19 行说明每个网格在每次迭代时都会计算自己的秩值，减去实际路网速度后得到的结果就是此时道路的最大松弛速度。$G_{n-map}$ 是一个 $n_g ∗ n_g$ 网格的道路网络。最后，将网格排序值存储在 HashMap(DGPR) 中，其中 $&lt; Grid_k, R_k &gt;$，$Grid_k$ 为第 k 个网格，$R_k$ 为第 k 个网格等级值。在实际道路网络中，如果道路越畅通，车流速度就会同时提高。相反，道路越不畅通，车流速度就越慢 本文指出，尽管从一个网格到另一个网格可能有不止一条路径，但传递的等级值仍会选择网格的整体网络速度值。由于拥堵往往是区域性的，当网格的网络速度较低时，附近网格的网络速度值会随着时间的推移而降低。因此，路网速度具有传递性。网格数量决定了算法的运行时间。在每次迭代中，算法仍需依次计算每个网格的秩值，即 $O(n)$。网格计算自己的秩值时，还需要计算相邻网格的秩值，即 O(n - 1) 次，所以 DGPR 算法的时间复杂度为 $O(n(n - 1))$ ，即 $O(n^2)$ 。 5. Emergency Path Planning Algorithm Based on Situational Road Network应急路径规划的关键在于路网条件的突变和实时性。然而，传统的路径规划方法显然无法满足当前路网状况的变化。因此，本节提出了一种新颖的情景网格启发式搜索算法。该方法通过考虑当前路网的变化因素来规划车辆的路径。在介绍该算法之前，先介绍了具有时空特征的路网。 5.1. The Characteristics of Road Network with Spatio-Temporal Characteristics图 5 显示，路网被划分为不同的网格（图中虚线圈出的矩形代表一个网格）。在示例图中，绿色实线代表路网中车速相对较高的道路，即路况相对通畅，车速接近道路的最高限速；黄色实线代表道路上车辆较多的情况；红色实线代表道路拥堵的情况。 在实际道路网络中，通常拥堵路段会导致附近区域的道路也跟着拥堵。随着时间 t 的变化，拥堵程度会通过道路交叉口相互传递。对于路网区域的划分，有利于紧急状态下车辆的实时动态路径规划。因此，本文通过对整个城市路网进行排序，比较各区域的通行能力。 根据图 4，路网随时间变化，拥堵状态具有持续性和随机性。因此，本文提出了一种新颖的 SGHS*，用于在紧急状况下对具有时空特征的路网进行路径规划。 5.2. Heuristic Search and Breadth Traversal Search Algorithm从图 6 中可以看出，绿色实线（source→h1→h2→h3→h4→h5→h6→h7→h8→destination）和蓝色实线（source→d1→d2→d3→d4→d5→d6→d7→destination）分别代表启发式搜索（代表算法为 A* 、RTA* 和 D*）[33,34]和广度优先遍历搜索（代表算法为 Dijkstra）[35,36]的结果。启发式搜索的优点是能快速有效地得到最优路径解（在静态有向正权重图的前提下），广度优先遍历搜索的搜索时间比启发式搜索长，但其优点是每次搜索都能得到相对全面的松弛边比较。 在启发式搜索中，启发式函数通常与目标顶点有关。一般来说，车辆会选择最短路径作为备选路径，因此启发式因子会选择搜索当前顶点与目标顶点之间的欧氏距离或曼哈顿距离（实际搜索结果对路径的搜索结果影响不大）。然而，在紧急路径规划中，需要考虑两个因素：路网的动态性和最短时效性。一方面，突发事件的发生必然会造成一个或多个区域的道路拥堵。另一方面，一旦拥堵区域发生紧急事件，区域内的车辆需要立即驶出该区域和附近车辆，并以最短的时间成本驶向目的地。 但根据实际路网情况，两种搜索模式提供的路径都要驶向拥堵区域（通常车辆会选择路网等级较高的道路），因此避开拥堵区域有利于车辆以最短的时间驶向目的地。 5.3. Situational Grid Heuristic Search to Path Planning Based on DGPR本节将介绍称为 SGHS* 的情境网格启发式搜索。在第 4 节中，我们提到了动态网格路网的原理，SGHS* 算法将根据这一原理为城市车辆进行紧急路径规划。 图 7 描述了 SGHS* 算法的路径规划结果。从图 7 中可以看出，SGHS* 算法在初始选择路径时，首先会确定当前顶点的网格 ID，然后根据网格 ID 对整个城市道路进行排序。DGPR 算法得到的整个城市路网区域的排序结果是基于路网速度的。网格的优势在于可以对城市路网进行区域管理。 源顶点的网格为 grid32。在第一次搜索中，SGHS* 将访问相邻的网格。值得一提的是，在最初的 GEMPP 框架中，网格搜索每次会搜索 8 个相邻网格。但在实际网格划分中，虽然有些网格相邻，但并没有实际的路网连接。我们称这些网格为虚拟网格（Virtual-Grid），而如果有部分路网与实际路网相连则称为实体网格（Entity-Grid）。不过，在 EGEPP 框架中只能访问实体网格。 如图 5 和图 7 所示，绿色实线代表路网速度较高的道路，与 Grid32 直接相连的网格为 Grid22、Grid31、Grid33 和 Grid42。当 DGPR 算法为这四个网格赋值时，其顺序可以是（从轻度拥堵到严重拥堵）Grid42 &gt; Grid22 &gt; Grid31 &gt; Grid33。当 SGHS* 获得要搜索的网格 ID 时，会建议优先规划路径，即搜索通往 Grid42 的路径，因为 Grid42 的排名更高。但在实际定位时，会发现车辆的行驶方向与想法相反。此时，就会形成一种掉头的情况。在实际场景中，不建议这样做。如果车辆不及时改变方向，很可能会出现一种绕圈现象。 为了避免这种情况，设计了四元数函数 ∂{μ，φ，θ，υ}。μ 是激活函数，只有当 μ 为 TRUE 时，SGHS* 算法才会比较后三个函数值。φ 是网格间的最小步长。其结果等于当前搜索网格与目标网格之间的网格数。θ是当前顶点网格中心坐标与下一个搜索网格中心坐标之间的连线，也是下一个搜索网格中心坐标与目标顶点网格中心坐标之间的夹角。υ 的值是 DGPR 的结果。等式 (5) 描述了阶跃函数。 其中，ξ 是搜索次数，Gridd 代表目标顶点的网格 ID，CountGridid 是源网格到目标网格的计数。公式 (6) 表示角度公式。 公式 (6) 是两条直线的夹角公式。其中 ι1 是当前顶点的网格中心坐标和下一个搜索网格的网格中心坐标的斜率函数，ι2 是下一个搜索网格的网格中心坐标和目标顶点的网格中心坐标的斜率函数（两个顶点构成一条直线）。 定义 1. 给定两个 φ1 和 φ2，且两个网格排序值相近，φ1 的步长值 &gt; φ2，φ2 所在的网格将优先作为网格候选集。 如图 8 所示，Grid22 和 Grid42 的通行能力都较好，但 Grid42 的步长比 Grid22 加了 2，即 G1 &lt; G2，因此在实际路径规划中，相当于车辆要绕远路，这在实际推荐路径中是不被接受的。 定理 1. 给定两个 ∂1 和 ∂2，当激活函数 μ1 和 μ2 都为真时，步长的优先级高于角度值，角度值高于 DGPR 值。 证明 假设 G5 是当前的起始网格，当只剩下 G2 和 G7 作为候选网格时，从图 8 中可以看出，θG2-1 &gt; θG7，但根据欧氏公式，φG2 &gt; φG7，G7 更接近 D。此时，无法确定哪个网格是最佳搜索网格。此时，需要根据 DGPR 的排序结果进行判断。DGPR 的值越高，网格中的道路通行能力就越好。DGPR 优先级较低的原因是，当 G1 和 G2 为候选网格时，假设只考虑两个网格的 DGPR 值，当 υ1 &lt; υ2 时，车辆将行驶到 G2 网格，从而导致返回或重复道路（例如，车辆之前从 G2 网格行驶到 S 网格）。 定义 2. 给定两个 θ1 和 θ2，当 (θ1 &gt; θ2) ∧ (θ2 6= 0) 时，则 θ1 的网格比 θ2 的网格更接近目标网格。 从图 8 可以看出，θG1 &gt; θG5 &gt; θG6 &gt; θG2，Grid22 与目标网格相邻，Grid33 与目标网格相差一个网格。然后比较网格 31 和网格 42。假设网格矩形的边长为 2，~ DG6 的长度为 4√2，~ DG2 的长度为 2√10，显然 4√2&lt;2√10。因此，网格 31 在空间上更接近网格 13。正方形网格的优点是便于进行几何计算。不过，本文不使用三角形的面积作为参考函数。 定理 2. 给定两个 υ1 和 υ2 分别是两个三角形的面积值，如果 υ1 小于 υ2，候选网格不一定更接近目标网格。 证明 根据图 8 可以看出，三角形 ∆ DSG2、∆ DSG6 和 ∆ DSG1 的面积相比较时等于 ∆ DSG1 的面积，因为三角形的面积可以通过底边的长和高来计算，如图 8 所示。线段 ~ G1S 和 ~ G2S 的长度相等，三角形 ∆ DSG1 和 ∆ DSG2 的高为线段 ~ DG3。因此，根据三角形的面积公式， ∆ DSG1 的面积等于 ∆ DSG2 的面积。然而，就物理距离而言，G1 网格比 G2 网格更靠近 D 网格。接下来，我们将比较三角形 ∆ DSG2 和 ∆ DSG6 的面积。根据定义 2，G6 网格更接近 D 网格。然而，∆ DSG6 的面积大于 ∆DSG1 的面积，而 ∆ DSG1 的面积等于 ∆ DSG2 的面积，所以 ∆ DSG6 大于 ∆ DSG6。 定义 3. 给定两个候选网格 G1 和 G2，当 G1 中函数 ∂ 的步长和角度值为 φ1 &lt; φ2，θ1 &gt; θ2，则 G1 更接近目标网格。 根据图 8 所示的候选网格，φ1 &lt; φ6，θ1 &gt; θ6。然而，情况并不一定相反。例如，对于网格 G1 和 G4，假设 G1 和 D 之间没有实体-网格，θ1 = θ4（根据平行四边形，对角线相等），但 φ4 &lt; φ1。同样，φ1 = φ5，但θ1 &gt; θ5。根据矩形的对角线和边长，G1 更接近目标网格 G5。因此，φ1＜φ2，θ1＞θ2 是 G1 比 G2 更接近目标网格的必要条件和不充分条件，即（φ1＜φ2）∧（θ1＞θ2）-→G1＞G2（G1＞G2 表示推荐的 G1 高于 G2）。 下面将介绍网格内的路径规划。根据路网速度计算预计行驶时间的启发式函数。为此，搜索图需要根据不同的时间查询路径。情景路网的特点是随时间变化的路径权重不同。因此，我们的方法需要根据给定的时间窗口 Tq 查询当前路网，并返回 T′ qs 的最优路径。因此，为了满足要求，将设计一个搜索函数 F(n)，即公式（7）。 其中，G(n) 表示从源顶点到第 n 个顶点的实际时间，即公式 (8)。 vi 和 j 构成当前查询的道路，d 是目的地顶点。 其中，TR(vi,vj) 表示车辆通过两个交叉口 vi 和 vj 的实际时间，即公式 (9)。ε是道路的最大通行能力，取值范围为（0，1）（详见第 7 节），Len(vi,vj) 是 vi 到 vj 的距离，RS(vi,vj) 代表 vi 到 vj 之间道路的平均速度，该值从轨迹数据集中提取。 其中 λ = H(n) 是启发式因子，即等式 (10)。公式 (11) 使用曼哈顿距离除以车辆的平均速度 VSavg，即行驶距离除以总时间（VSavg 的值代表 G(n) 探索的所有候选路径加上车辆已行驶路径的总平均速度）。因此，使用这种估算方法可以更好地判断下一步要探索的路径。 SGHS* 方法根据道路的实际时间加上估计时间之和来选择道路。G(n) 的取值保证了车辆的经过时间是所有候选路径使用时间中最小的，这也是 BFS 搜索原理所保证的，即 G(n) ≤ G(n)*。启发式函数 H(n) 是单调递减的。 定理 3. 给定查询时间窗口 Tq，采用启发式路径规划方法在 G 中找到时间窗口 Tq 内的最短路径子集，当 H(n)≤H(n)* 时，离目标顶点越近，扩展的顶点越少。 证明 因此，必须在给定的查询时间 Tq 内找到最多路径的子集。根据启发式原理，搜索顶点离目标顶点越近，H(n) 的值就越小。当 H(n) ≤ H(n)* 时，它满足单调递减特性，因此在搜索顶点的过程中，可以避免重复搜索顶点。因此，H(n) 越小，需要搜索的顶点就越少。 其中，MD 是两点 tn 到 d 之间的曼哈顿距离，$\\vec {x}$和 $\\vec{y}$ 分别代表纬度和经度，即公式 (11)。我们将使用估计时间作为启发式，因为车辆总是希望在最短时间内到达目的地。 BFS 搜索过程将执行 G(n) 函数 [36]。如果每次只向下搜索一个顶点，该方法就会变成 A* 搜索模式，搜索效率也不会提高。在 SGHS* 搜索过程中，唯一的限制是一个时间窗 Tq。根据公式 (12) 确定 G(n) 的停止条件。 其中，Tmps、Tmpd 是一个网格内的临时源顶点和临时目标顶点。值得注意的是，当 G(n) 中的 TRq &lt; Tq 时，搜索将继续进行。当 TR ≥ Tq 时，搜索将停止。在这种情况下，SGHS* 必须返回上一个顶点，因为当车辆行驶在两个交叉路口之间时，GPS 可能无法准确收集车辆的当前位置[35]，例如车辆进入隧道或在桥下行驶。算法 3 第 7-12 行描述了公式 (12) 的计算过程： 算法 3 演示了 SGHS* 的路径规划过程。第 4 行和第 29 行用于确定源顶点和目标顶点是否在同一网格中。第 5-27 行描述了 SGHS* 的启发式搜索，其中包括剪枝策略，将在第 5.4 节中详细介绍。在优先队列存储中，每个顶点都需要搜索一次。第 20-23 行由公式 (7)-(10) 计算得出。第 30-41 行描述网格间的搜索。设置四元数函数 ∂ 的目的是在区域道路畅通时，尽可能选择离目标网格最近的网格作为候选网格。 算法 3 的时间复杂度分析如下。当从一个顶点开始搜索时，搜索开始，未访问的顶点被访问。在最坏的情况下，每个顶点至少被访问一次，每条边至少被访问一次。最坏的情况是，在搜索过程中，如果一个顶点被向下搜索，它的所有子顶点都被访问过，那么它就会回退。两点间 SGHS* 规划的时间复杂度为 O(n) = n ∗ (v1 + n) + v2，其中 n 为顶点数，v1 为当前顶点，v2 为搜索顶点。因此，时间复杂度渐近为 O(n)，源顶点和目的顶点之间 SGHS* 的时间复杂度为 O(n2)。O(ng) = ng ∗ ng 是搜索网格的时间复杂度，ng 是网格数。最后，SGHS* 的时间复杂度为 O(n2) + O(ng) = O(n2)。 5.4. Pruning Strategy将详细介绍基于 SGHS* 的修剪策略。路况权重是不断变化的。图 9 显示了 SGHS* 算法的剪枝策略结果。假设车辆从顶点 S 出发，则可搜索的边分别为 ~ SV1、 ~ SV0 和 ~ SV3。根据 SGHS* 的搜索策略，车速最高的道路将优先被搜索到。但是，目前路网的情况正在发生变化，在紧急情况下，SGHS* 希望搜索更多的路径作为车辆的备选路径。因此，根据查询时间窗口 Tq，确定车辆可以到达的交叉点顶点集作为候选路径。换句话说，根据已知的道路长度和路网速度，可以获得实际的行驶时间，并将获得的时间与查询时间窗口 Tq 进行比较。如果不超过 Tq，算法继续向下搜索。如果 Tq 等于或超过时间 Tq，则停止搜索并返回候选顶点。此时，我们会从优先队列中删除未搜索到的顶点，这就是 SGHS* 的剪枝策略。 例如，图 9 中无向图的 $S\\vec{V}1$ 边速度较快，SGHS* 在搜索 V1vertex 时如果不超过查询时间窗口 Tq，就会继续向下搜索到 V2顶点。而 $S\\vec{V}0$ 和 $S\\vec{V}3$ 的速度较低，因此 SGHS* 判断这些路径的行驶时间超过了 Tq，所以不会搜索顶点 V0 的三条相邻边和顶点 V3 的一条边。这样，EGEPP 框架不仅能在紧急情况下搜索更多交叉路口，还能从候选路径中删除拥堵路段。公式 (12) 描述了 SGHS* 计算车辆行驶候选路径所需的时间是否超过给定的时间窗口 Tq。值得注意的是，SGHS* 会给每个搜索到的顶点分配一个标签，表明该顶点当时是放松的，这大大降低了搜索的时间成本。例如，如果图 9 中的顶点 V0 在搜索过程中被 SGHS* 访问，那么当 V2 被放松时，V0 将不会被搜索。 图 10 描述了 SGHS* 算法（紫色实线）、Dijkstra 广度优先遍历算法（蓝色实线）和 RTA* 算法（绿色实线）的路径规划结果。紫色实线（source→s1→s2→s3→s4→s5→s6→s7→s8→s9→s10→s11→s12→s13→destination）表示 SGHS* 算法的顶点通过数结果。虽然 SGHS* 通过的交叉点较多，这意味着行驶时间会比交叉点较少的路径长，但路径的选择性却优于其他两种算法。也就是说，车辆可以选择向其他方向行驶，绕过交叉路口的拥堵区域。因此，Dijkstra breath first 和 RTA* 规划的路径大于 SGHS* 规划的路径。 6. Graph Acceleration Algorithm Based on Situational Grid Road Network本节将介绍基于路网速度的 SCH、SGCH 和 SGMRCH 三种顶点搜索算法。在 [15] 中，提出了两种基于交叉口类型的顶点收缩算法 RCH 和 MRCH。在全局路网顶点收缩的情况下，MRCH 优于 RCH。但在某种情况下，路网结构会随时间发生变化，因此并非所有顶点都需要计算收缩算法。因为在静态路网中，收缩顶点越多，搜索算法在路径规划时就会搜索尽可能少的顶点，从而提高搜索效率，减少路径规划时间。当然，增加的捷径越多，恢复边所需的时间可能就越长。 6.1. Situational Contraction Hierarchies Algorithm传统的 CH 算法会将顶点从高一级收缩到低一级 [17,37]。例如，假设图 G = &lt; V, E &gt; 的顶点按重要性升序命名为 (1, 2, … , n)。只有当 &lt; u, v, w &gt; 是唯一一条从 u 到 w 的最短路径时，才需要 &lt; u, w &gt;。顶点的容量越大，收缩级别就越高。反之，顶点容量越小，收缩水平越低。因此，用传统方法收缩路网中的顶点是不需要的，所以需要改变收缩的顺序。虽然其他研究相对关注时间和转弯 [38,39]。 图 11 显示了分层收缩算法对路网结构的影响。从图 11a 中可以看出，没有相位图，也没有右图。假设只考虑经过节点的数量，V1 到 V5 和 V3 到 V6 将经过 V4，这表明 V4 的重要性很高。V2 也比 V1 和 V3 重要。因此，V2 和 V4 将在一次收缩中缩小。结果就是图 11b 的情况。删除了边 E1、E7、E2、E6、E3 和 E5。在图 11b 中添加了三条捷径，在还原道路网络时将转换为之前删除的边缘。 算法 4 演示了 SCH 的计算过程，第 3 行读取所有道路网络的速度，并根据顶点所连接的一侧道路网络的速度赋值。第 4 行在全局路网中搜索双向最短路径。第 5-9 行用于判断顶点是否收缩以及收缩后的处理。值得注意的是，第 5 行中的 “小于良好 “表示 vi 的水平较低，因此将对其进行收缩。SCH 的时间复杂度主要是搜索每个顶点时的最短路径搜索时间等于 O(2logn)，其中 n 是顶点的个数。 6.2. Situational Grid Contraction Hierarchies Algorithm and Situational Grid Multiple Reverse Contraction Hierarchies Algorithm下面将介绍基于网格图的顶点收缩加速方法的两种算法。网格图加速的思路是首先将网格作为顶点。如果网格之间有边相连，则会形成一条连接两个网格的边，这条边不加权。在 GDPR 算法中，会得到每个网格的网络容量排名值，该值的大小由网格内部的路网速度决定。如果一个网格内部出现拥堵，该网格就会连同其他网格的边一起从网格图中删除。捷径不会被保留或添加。这样，剩余的网格将形成一个新的网格网络图，并在此基础上执行 SCH 收缩。 与算法 4 相比，算法 5 增加了网格收缩过程，目的是收缩更多的顶点。由于不会推荐拥挤区域 SGHS* ，所以网格图收缩处理在 SGHS* 算法之前进行。第 3-9 行是网格图的广度优先遍历，即在搜索每个网格的拥堵情况后，将拥堵网格从图中删除，并断开与其他网格的连接边。第 10-18 行是对图中剩余的每个顶点进行分层排序，将符合收缩要求的顶点从图中删除，以减少图中顶点的数量。图搜索的时间复杂度为 $O(ng) = n_g ∗ v1$，其中 ng 为网格数，顶点搜索的时间复杂度为 $2logn$，其中 n 为顶点数，因此 SGMRCH 的时间复杂度为 $O(ng) + 2logn = O(n)$​。 同样的原理，SGMCH 算法在原有 RCH 算法的基础上增加了栅格图收缩策略。这种方法的优点是可以收缩图中大量的 L - 交点交集，从而使路径规划算法在顶点搜索时可以最小化松弛边。需要注意的是，CH 算法和 MRCH 算法都是在图初始化时进行的，因此不会影响路径规划的计算时间。但是，在本文提出的 SGRN 模型中，路网速度会随着时间的变化而变化，因此情况路网收缩算法必须在每次路网变化时执行图预处理程序。这就要求图收缩算法必须在可接受的时间内完成。 算法 6 的第 3-9 行仍然是网格地图搜索。它首先删除拥堵区域的网格，然后断开连接的网格。这一步与 SGCH 流程相同。第 10-28 行是对整个道路网络的遍历查询。它收缩了所有阶数为 2 的顶点，并为删除顶点时相连的两个顶点添加了快捷连接。它将删除的边的权重相加，从而得到捷径。图搜索的时间复杂度为 O(ng) = ng ∗ v1，其中 ng 是网格数，顶点搜索的时间复杂度为 n ∗ (v1 + m) + v2 = O(n2)，其中 n 是顶点数，m 是边数，因此 SGMRCH 的时间复杂度为 O(ng) + O(n2) = O(n2)。 其中突出的一个问题是 SCH、SGCH 和 SGRMCH 的权重加权。在以往的研究中，道路权重通常选择道路的长度，这样在收缩顶点时就可以加上相连边的权重。然而，本文的权重设计为道路网络速度，速度值不能相加，否则就意味着将错误的道路网络速度反馈给车辆。因此，以路网速度的平均值作为加权结果，将两条边的路网速度分配给一条边更为合理[40]。图 12 是 EGEPP 框架示意图。 从图 12 中可以看出，在数据处理阶段，将现有路网数据和车辆轨迹数据进行融合，通过 DGPR 算法对整个城市路网进行网格动态划分，并对网格路网进行图收缩处理，在此过程中，本文共提出了三种图收缩策略。最后，利用收缩后的路网，通过 SGHS* 规划应急路径，最终返回一条最短的绕行路径。 7. Experiment and Verification本节将详细介绍实验过程和参数设置。实验将尝试使用网格大小为 ng = 288 [15]、网格顶点数和道路密度作为不同参数来测试路径查询效率的影响。我们将比较 GMEPP 框架和新提出的 EGEPP 框架下城市交通紧急情况下车辆的绕行路径和行驶时间，以及两种框架下应急路径规划算法的运行时间比较。同时，比较了 SGHS* 算法、GBD 算法、RTA* 算法、RRT* 算法、T* 算法、A* 算法和广度优先遍历算法。最后，本文还需要加入本文提出的图加速算法与其他图加速算法进行比较，从而验证加入图加速算法后对原图进行路径规划的效率，以及加入其他图加速算法对本文提出的 EGEPP 框架的影响。 7.1. Experimental Settings本文的重点是基于北京路网的应急路径规划，因此不包括其他城市的网格划分。在实验验证阶段，会加入实验对比算法中不同上下尺寸、不同道路密度的行能量，而不同城市间的网格划分结果不会影响算法的效率。 在紧急场景下，车辆需要快速绕过紧急区域并驶向最终目的地，因此以最小的成本和时间绕过紧急区域非常重要。因此，本文的实验主要关注路径规划时间和车辆行驶时间，以验证 EGEPP 框架的可行性。EGEPP 将主要集中于快速将秩值较高的车辆导入网格，并获得最优路径，即车辆从源顶点到目的顶点所需的时间最短。本文接下来将进行三种实验。 讨论了网格数对 DGPR 算法的影响。由于路网的不断变化，适当的查询窗口可以使车辆的行驶路径获得更高的速度。因此，根据轨迹数据的采样频率，选择合适的时间查询窗口 Tq 来测试和验证所提出的 SGHS* 算法； 设置不同长度的起点和终点，通过仿真实验比较不同算法的路径规划，得到不同算法下车辆行驶的规划路径时间； 设置不同的图大小来验证所提出的三种图加速算法和CH的效率，然后将图加速算法导入路径规划算法中比较算法效果，并设置单车工况和多车工况算法对比。 实验环境为 16G 内存、64 位 Windows 10 操作系统、Intel i5 @3.30GHz CPU。算法编译语言为 Java 和 MATLAB，可视化工具为 QGIS。数据集是来自 OpenStreetMap（https://www.openstreetmap.org，访问日期：2020 年 12 月 5 日）的北京城市路网，经过处理细化后包含 83 884 个顶点和 222 778 条有向边，不包含悬浮点和悬浮线（悬浮点和悬浮线是指图中孤立的点和边，这类点和线通常出现在村庄的边上）。北京还有约 500 G 的车辆轨迹数据和微波数据，并使用网格大小为 ng = 288 的 G288 地图（网格大小对路径规划算法的影响已在论文[15]中讨论）。本文将不再详细讨论）。 7.2. 不同网格数下的查询时间窗口 Tq 和 DGPR 有效性讨论在演示实验之前，先介绍一下城市路网的容量。首先，可以提取和处理 OpenStreetMap 数据集。可供车辆通行的道路可分为五类： 未分类道路、三级道路、一级道路和高速公路。其次，表 3 显示了城市道路的容量划分，指的是道路的交通状况。这些都是国家标准。CRG 是城市道路等级，其值与 SL 相对应。SL 代表道路限速，TC 代表道路通行能力。为便于计算，将其归一化并称为最大通过系数 ε，最后将 ε 值导入公式 (9)。 网格的秩计算可根据算法 2 的第 14 行进行。由于 OpenStreetMap 存储的是方向性道路结构，因此每个顶点都会有一条出站边和一条入站边。交叉点 ID 已经过预处理。由于轨迹数据的采集频率为 2 分钟，我们提出的 DGPR 算法应确保在这段时间内完成计算，并获得每个网格的排序值。由表 3 可以得出表 4。 对表 3 中的路网速度中值取平均值后，可得到所有路网速度内的车辆容量，然后进行归一化处理，得到最终的 φ 值。DGPR 算法计算每个网格的 PR 排列值，与表 4 比较并赋值，得到每个网格的最终通行能力系数 φ。根据通行能力系数，本文规定当网格的通行能力系数为 0.02 时，为拥堵；0.09、0.12 和 0.14 为轻微-拥堵（即图 1 中颜色不断变化的道路）、 图 1 中颜色不断变化的道路，当网格得到这个值时，μ 的标志为 TRUE）；0.17、0.22 和 0.24 代表畅通无阻的道路，SHGS 算法在比较网格时，如果遇到相同标签的网格，就会比较二次函数，如果μ 为 TRUE，就会比较数值。 图 13 显示了 DGPR 算法和 GPR 算法的收敛性比较结果。图 13 的纵坐标表示每种算法的上一次迭代结果与当前迭代结果的插值，横坐标表示算法的迭代次数。随着迭代次数的增加，可以看出算法在逐渐收敛。从图 13 中可以看出，当迭代次数达到 15 次时，两种算法都接近收敛，但 DGPR 算法的收敛速度高于 GPR 算法，DGPR 在 15 至 20 次迭代之间趋于平稳。 图 14 显示了 DGPR 和 GPR 的运行时间，两种算法在迭代次数达到 50 次时出现了明显的变化，DGPR 的增长趋势较为平缓，但 GPR 的加速度出现了明显变化。由于图 13 显示两种算法在迭代次数为 30 后都收敛为 0，因此与图 14 所示的运行时间结果相比，DGPR 算法的运行时间为 570 ms &lt; 120,000,000 ms，满足轨迹数据的刷新频率条件。 由于本文中轨迹数据集的采集频率为 2 分钟，但根据情景刷新率指定时间窗口可能并不合适。例如，短时间内路网的变化并不明显，不会对路网造成影响。因此，我们使用 Tq = [2, 5, 15, 30, 45, 60] [41] 作为时间窗口，并使用 500、1000、2000、3000 个起始端顶点对，缩写（SEVP）如表 5 所示。RV(avg)表示 SGHS* 中不同起止顶点对的平均松弛顶点数，RT(avg)表示 SGHS* 一次迭代的运行时间，IT(avg)表示 SGHS* 每次运行的平均迭代时间。 表 5 显示了不同查询时间窗口 Tq 对不同起点-终点顶点对的 SGHS* 算法的影响。根据不同的起点和终点对，当查询时间 Tq 一定时，放松顶点的数量没有太大差别，然后随着查询时间的增加，放松顶点的数量逐渐变多。但是，当查询时间小于 15 时，因为每次搜索的顶点都是根据路网的速度进行查询的，所以在迭代计算中有很多顶点在一次搜索中因为给定的行驶时间太短而没有访问到，最终导致算法无法搜索到这些顶点。 然而，当查询时间窗口 Tq &lt; 15 时，松弛顶点的数量也逐渐减少，但变化值不大。比较不同查询时间窗口下的算法运行时间结果，可以得出结论：当查询时间窗口 Tq = 60 时，算法的一次迭代时间过长，这是因为算法在一次探索中放松了大量顶点，几乎是在对静态图进行全局搜索。此外，45 分钟和 30 分钟也显示了相同的结果，都是由于放松了大量顶点。当查询时间窗 Tq = 5 和 Tq = 2 时，运行时间有所减少，但变化并不明显，主要原因是到达的顶点离目标点太远，而 SGHS* 在计算启发式函数时必须计算候选顶点到目标顶点的曼哈顿距离，因此 SGHS* 算法花费了大量时间开销。 7.3. 算法运行效率验证本小节将设置不同长度的路径来比较每种算法的运行效率。本文提出的 SGHS* 基于动态态势栅格地图，因此在本节的实验设置中加入了路网速度的概念。首先，根据提出的四元数函数∂ { μ、φ、θ、υ }，验证四元数函数与各参数∂ { μ } 的组合、 ∂ { φ }, ∂ { θ }, ∂ { υ }, ∂ { φ, θ }, ∂ { φ, υ }, ∂ { θ, υ }, ∂ { φ, θ, υ }, 和欧氏距离 (ED) 分别进行验证。 我们模拟了一个 ng × ng = 34 × 54 的网格图，测试的目的是验证所提出的二次函数 ∂ 在更新网格搜索时的效率。为了防止算法在同一网格中搜索，会给经过的网格设置一个标签，当标签为 False 时，表示该栅格已被选为候选路径网格；当标签为 True 时，表示算法可以继续访问该网格。如果栅格在搜索过程中进入了无法通过的栅格（如图 15 中的红色栅格），算法可以将搜索逆转到前一个栅格并重新搜索。 图 15. 针对构成四元数函数的参数，测试了不同参数对路径规划算法的影响。(a) ∂{φ} 对路径规划的影响。(b) ∂{θ} 对路径规划的影响。(c) ∂{υ} 对路径规划的影响。(d) ∂{φ，θ} 对路径规划的影响。(e) ∂{φ，υ} 对路径规划的影响。(f) ∂{θ, υ} 对路径规划的影响。(g) ∂{φ，θ，υ} 对路径规划的影响。(h) 仅根据欧氏距离进行路径规划。 在本实验中，设置了163个红色网格代表拥堵网格，即禁止车辆行驶的网格，以验证参数对路径规划和车辆的影响程度，只要是相邻的网格都可以行驶，包括对角相邻的网格。蓝色网格是从源点 s 到目的地 d 的路径，灰色网格为非拥堵网格，实验设置随机分配灰色网格的容量值，2 分钟改变一次，所有灰色网格均为车辆可通行的网格，且 μ 始终为 TRUE。这里需要注意的是，当算法在重复网格中不断搜索时，会增加搜索网格与目标网格之间的曼哈顿距离，以便算法能够搜索到其他已经搜索过的网格。 不同参数对搜索栅格的影响结果如图 15 所示。图 15a 仅以∂{φ} 的步长作为从源网格到目的网格的路径规划时搜索网格的条件。从图 15a 可以得出结论，算法在开始时对网格的搜索是有效的，当遇到 L 型障碍区时，算法在绕过拥堵区之前会进入死胡同，在后面的规划中，同样遇到 T 型障碍区和 L 型障碍区时，算法需要回溯。从图 15b 可以看出，通过角度∂{θ}时，选择最多的依据仍然是需要绕过大量的障碍区。 图 15c 显示，只有以 GDPR 值作为路径规划的条件，算法规划的结果是车辆走过许多重复区域，甚至在同一区域内循环搜索不同的网格，这种现象被称为绕行，在紧急场景下是不允许的。图 15d-f 显示了明显的改进，算法规划的路径可以让车辆通过更少的网格，但仍有少量迂回。图 15g 增加了三个元素∂{φ, θ, υ}，算法规划的路径明显优于其他路径。虽然在网格周围也有少量迂回，但整体规划路径的结果是进入障碍区的路径没有迂回，而且路径向目标网格的整体方向性较好。图 15h 显示的是只考虑欧氏距离的路径规划结果，搜索路径在 L 形拥堵区域出现了大量光栅迂回，这是因为算法只考虑了整体方向性，而没有考虑会遇到的拥堵区域。 其次，实验测试的自行车在不同路径长度下的算法对比，有说明路网密度问题，因为测试选择的路径长度不同，所以路径跨度的路网密度也不同，所以这点保证了算法在不同路网密度条件下的测试。因此，表 6 将涉及四种不同的道路长度 P1 = 5.3 公里、P2 = 17.5 公里、P3 = 30.4 公里和 P4 = 49.8 公里（曼哈顿距离）。 表 6 中，NGS 表示搜索到的网格数，NVS 表示搜索到的顶点数，runtime（RT）表示算法的有效性，∗ 为空。Dijkstra 算法作为路径规划中的广度优先遍历算法，随着路径长度的增加，搜索顶点的数量呈指数增长，当搜索路径为 49.8 km 时，访问顶点的数量高达 19 311 个。 A* 算法在搜索路径中访问的顶点数量要少得多，这是因为我们将启发式函数设为搜索顶点到目标顶点的欧氏距离，以此作为判断访问候选顶点的依据。T* 算法访问的顶点数量会比 A* 算法少一些。RTA* 是实时 A* 算法的一个变种，它增加了实时搜索路径的功能，但其搜索顶点的数量与 A* 算法基本相同。不过，RRT* 算法在搜索顶点时增加了路径剪枝策略，目的是在规划路径时增加尽可能剪枝路径的捷径，但与 A* 相比，其访问的顶点数量相近 GBD 算法和 SGHS* 算法都加入了栅格判断，因此两种算法比较的是栅格数。开始时，规划路径 P1 搜索的栅格数相同，因为路径长度不大，且路径长度跨越两个栅格。但是，随着规划路径距离的增加，算法搜索网格的差异就会显现出来。由于 SGHS* 算法增加了一个二次函数来决定网格的选择，这使得算法在搜索网格之前，只能选择容量相近的网格进行比较。因此，随着路径长度的变化，SGHS* 算法在减少网格数量方面有显著变化。GBD 算法和 SGHS* 算法由于受到网格的限制，所以在搜索距离为 49.8 km 时，搜索顶点数分别为 3482 个和 3369 个，因此与其他算法相比明显减少。不过，这种趋势在短距离路径规划中并不明显，因为在短距离路径规划中，相当于所有算法都在网格上搜索，所以搜索顶点数几乎相同。除了 Dijkstra 算法的运行时间稍长之外，其他六种算法的运行时间相近。虽然 GBD 算法和 SGHS* 算法搜索的顶点数基本相同，但增加了搜索网格的时间，而且 GBD 每次都需要比较相邻网格，SGHS* 比较的网格数比 GBD 少，但由于要计算二次函数∂{μ，φ，θ，υ}，SGHS* 和 GBD 算法的运行时间相近（347.5 ms 和 340.9 ms）。 第三，我们将验证算法在不同道路情况下的模拟实验使用情况。表 7 显示了不同算法在非拥堵（道路速度范围为 45 km/h 至 120 km/h）和拥堵（道路速度范围为 10 km/h 至 80 km/h）情况下进行的对比实验，并通过车辆的行驶时间进行验证（在不超过速度范围的情况下，为每条道路分配一个随机值）。实验路径选择 p1（5.3 公里）、p2（17.5 公里）、p3（30.4 公里）和 p4（49.8 公里）作为查询路径。根据路径的长度，可以对郊区和城区的路径规划进行比较。由于城市的道路密度大，郊区的道路密度小，因此算法的运行结果可以在不同道路密度的情况下进行验证，并根据车辆行驶时间（时间单位，分钟）进行比较。 从表 7 的模拟实验结果可以看出，当车辆以较高的速度在道路网络上行驶时，所需的时间并不因路径的长短而有太大的变化。当路况不拥堵时，Dijkstra 算法通过搜索两顶点之间的最短距离作为路径规划的基础，所提供的道路往往是两点之间的最短路径。不过，其他算法也是一样，A、T、RTA* 和 RRT* 也是以两点间的最短路径为基础进行规划的。对于 A* 和 T* 只是简单地加入了启发式函数，所以在规划路径时搜索时间较快，RTA* 是实时动态规划，但在路网速度较大时规划结果与 A* 相同。RRT* 只是在搜索时增加了剪枝策略，剪枝策略并不影响路径的规划结果。GBD算法虽然有网格，但其最终规划路径仍是基于两点间的最短路径，SGHS*算法是基于路网速度进行道路规划，由于城市路网整体速度相近，所以车辆行驶算法提供的路径耗时相差不大。 在拥堵条件下，对不同算法规划的路径结果进行了比较。结果发现，与非拥堵情况相比，Dijkstra 算法规划的路径随着路径长度的增加而变长，这是因为该算法只能规划最短路径，无法绕过拥堵地区的道路。A* 算法和 T* 算法的结果相同。虽然 RTA* 和 RRT* 都是实时的，但算法的实时刷新频率大于路网的实时刷新频率，只能在下一步搜索路径，不能有效判断区域内的整体交通状况。GBD 算法和 SGHS* 算法规划的路径可以减少车辆的行驶时间。GBD 根据区域的最大容量为车辆规划路径，但由于不能保证车辆能有效避开区域内的拥堵区域，因此路径规划仍以区域内的最短路径为基础。但是，SGHS*算法选择路网速度较高的网格为区域间的车辆提供服务，并选择路网速度较高的道路供车辆在网格内行驶，因此这种策略在一定程度上避免了车辆驶入拥堵路段。 7.4. Impact of Graph Acceleration Algorithms on Path Planning本节将比较几种图加速算法对路径规划的影响。首先比较了不同顶点大小的不同图收缩方法。实验使用六种图大小进行验证，顶点数分别为 500、1000、3000、5000、10000、20000 和 83884。根据算法的运行时间和收缩顶点的数量对算法进行评估。顶点代表顶点数；边代表边数；网格代表网格数；CV 和 CG 分别是收缩顶点数和收缩网格数；快捷方式代表连接两个新顶点的边；RT 代表算法运行时间。 从表 8 中可以得出图加速算法的结果。从表 8 中可以看出，CH 算法随着图的大小变大，搜索的顶点数也在不断增加，运行时间也呈指数增长，∗为空。SCH算法是根据路网速度来收缩顶点的，可以看出SCH收缩算法的数量没有CH算法多，但这是可以接受的，因为在实际路径规划中搜索算法不需要搜索整个图，只需要根据路网速度大小搜索顶点即可。 SGCH 算法和 SGMRCH 算法都对网格进行了收缩，因此增加了对网格的比较。由于这两种算法都是根据路网的速度进行收缩的，因此根据 DGPR 结果首先进行网格收缩，然后再进行顶点收缩，这使得算法的计算开销大于 CH 和 SCH。不过，从收缩结果可以看出，SGCH 以及 SGCH 和 SGMRCH 算法都收缩了大量网格和顶点。由于 SGMRCH 是基于网格收缩的 MRCH 算法，因此在 SGMRCH 算法多次迭代后，收缩的顶点数量比 SGCH 算法多。SGCH 和 SGMRCH 都根据网格容量值收缩网格，因此这两种算法的收缩网格数差别不大。值得注意的是，SCH、SGCH 和 SGMRCH 的运行时间均小于路网刷新频率的 2 分钟（120,000,000 ms）。 图 16a 比较了每种算法在不同路径长度下的运行效率，随着路径长度的增加，运行效率呈指数增长。图 16b 采用了传统的收缩分层算法，该算法根据交叉点的访问度对图进行收缩。从图中可以明显看出，该算法的运行效率有所下降，但随着长度的增加，算法的运行时间仍呈指数增长。图 16c 为 SCH 图搜索算法，与图 16b 相比，可以看出该算法的运行效率有所提高，因为 SCH 算法主要根据路网速度收缩交叉口，所以当路网速度变化不明显时收缩的顶点很少。 图 17 显示了在查询量的基础上添加不同图形加速算法的效率，旨在提高多车辆情况下路径规划算法的运行效率。图 17a 显示，算法的运行时间随着文本量的增加而增加。当查询文本量达到 70 KB 时，SGHS* 算法的运行时间比其他算法稍慢。图 17b,c 分别添加了 CH 和 SCH 图收缩算法，但路径规划算法的运行时间指标仍随着查询量的增加而快速上升。图 17d,e 中分别加入了 SGCH 和 SGMRCH 算法。可以看出，GBD 和 SGHS* 算法的增长趋势明显减弱。 最后，图加速算法明显提高了路径规划算法的搜索效率。 7.5. Discussion首先，DGPR 算法是对原有 GPR 算法的改进，它需要搜索网格中的每个顶点。DGPR 改进了权重的计算方法，使其更符合实时路网情况。顶点所在的网格会被分配和排序，每个顶点仍然需要被遍历。DGPR 的收敛速度比 GPR 快约 5 次迭代，这主要是由于简化了网格排序的计算过程，且相同迭代次数下 DGPR 的运行时间更短。 其次，与 GBD 算法相比，SGHS* 算法的空间复杂度更高，因为 GBD 算法是双向搜索顶点，而 SGHS* 算法是单向搜索顶点，主要原因是为了避免搜索拥挤的顶点。SGHS* 算法尽可能排除了不必要搜索的道路和交叉口。这样的处理提高了算法的计算效率，缩短了算法的运行时间。剪枝策略是减少一次迭代中对顶点的搜索，因此 SGHS* 的计算时间比 GBD 少，当测试路径距离为 49.8km 时，在拥堵情况下，使用 SGHS* 的车辆所用时间比 GBD 快 6.6 分钟。同样的原理也适用于 T、RTA 和 RRT* 算法。T、RTA和RRT的目的是为了快速收敛路径规划算法，并考虑路网的实时动态变化，但这三种算法并没有考虑探索尽可能多的可能性，而SGHS加入了剪枝策略，有效排除了冗余路径的可能性。此外，当搜索路径长度为 5 km 左右时，SGHS* 算法的搜索时间高于 RTA、RRT 和 GBD 算法，但随着计划长度的增加，SGHS* 算法的运行时间小于它们。因此，主要原因是随着路径长度的增加，SGHS* 算法搜索的顶点数远远少于其他算法。 第三，本文提出的三种图加速算法的时间复杂度不同。与基线算法 CH 相比，SGCH 和 SGMRCH 收缩网络的结果显示路径规划有明显改善。不过，从收缩结果来看，SCH 和 CH 的差异并不明显，这主要是因为 SCH 考虑的交点情况与 CH 考虑的交点重要性情况相似，因此两种算法收缩的顶点数量也相似。由于在图搜索中使用了双向策略，SCH 算法的时间复杂度较小，因此为 O(2logn)。SGCH 增加了单向图遍历，所以它的时间复杂度为 O(n)，SGMRCH 算法需要遍历一次路网中的所有顶点，然后根据情况信息进行网格收缩和顶点收缩，所以 SGMRCH 的时间复杂度为 O(n2)。但与其他图加速算法相比，SGMRCH 由于进行了多次路网收缩处理，收缩顶点数量最多，计算时间小于网络采样频率的 2 min，是整体路径规划时间和计算成本的最佳选择。CH 只单一考虑了顶点的通达度情况，没有结合实际路网交通流量，因此收缩了一些不重要的交叉口，影响了计算效率。而 SGCH 和 SGMRCH 加入了网格的收缩，在一定程度上增加了搜索顶点的数量（一个网格包含多个顶点），使得路径规划时不再搜索拥堵区域。这样就提高了路径规划的效率。 8. Conclusions总之，通过对比实验可以得出，当道路行驶条件发生变化时，SGHS* 算法提供的路径使车辆行驶到目的地的时间更短，当路径小于4 km时，SGHS*+SGCH算法的效率更高，当查询路径大于4 km时，SGHS* +SGMRCH的运行效率更高。而且，SGCH 和 SGMRCH 算法的运行时间小于态势信息的刷新时间，因此满足了 DGPR 对网格进行排序后的图加速处理。此外，SGHS* 算法在加入四元数函数∂{μ，φ，θ，υ} 作为网格判断后，加快了搜索目标网格的收敛时间。 在这项工作中，我们利用对北京路网数据和车辆轨迹数据的分析，并在路网网格为 ng = 288 的情况下，对提出的 EGEPP 框架进行了验证。在紧急情况下，我们在态势图 SGRN 模型的基础上，增加了 SGHS* + SGCH 和 SGHS* + SGMRCH 算法来规划路径，并为车辆提供容量较大的道路，使车辆绕行到达目的地。仿真结果表明，路径规划的最佳查询时间窗为 Tq = 15 min。当查询时间窗口小于 Tq = 15 分钟时，需要重复路径规划搜索。当查询时间窗口大于 Tq = 15 分钟时，算法规划的路径往往会进入拥堵区域。最后，通过大量实验发现，在城市道路上发生紧急情况时，EGEPP 框架比 GMEPP 框架能提供更好的绕行路径。 在今后的工作中，我们仍将重点关注路网权重（如道路坡度或最大车辆承载能力）等态势信息的影响，以及城市路网通行之间的相关因素对路径规划的影响。","link":"/2024/02/02/A-Novel-Heuristic-Emergency-Path-Planning-Method-Based-on-Vector-Grid-Map/"},{"title":"The 2^k Neighborhoods for Grid Path Planning","text":"The 2k Neighborhoods for Grid Path Planning Abstract网格路径规划是人工智能领域的一个重要问题。对它的理解是开发自主导航系统的关键。在有关这一问题的大量文献中，一个有趣而又令人惊讶的事实是，在评估这些算法时，只使用了少数几个邻域。事实上，通常只考虑 4 邻域和 8 邻域，很少考虑 16 邻域。本文介绍了三方面的贡献，这些贡献使得我们能够为扩展的 2k 邻域（即每个状态有 $2^k$ 个邻域，其中 k 是一个参数）构建有效的网格路径规划器。首先，我们根据 2k-1 邻域为 2k 邻域提供了一个简单的递归定义。==其次，我们推导出任意 k ≥ 2 的距离函数，从而提出了完美适用于无障碍网格的可接受启发式方法，这些方法概括了著名的曼哈顿距离和奥克蒂尔距离==。第三，==我们定义了 2k 邻域的典型路径概念；这使我们能够将邻域纳入两个版本的 A* 中，即典型 A* 和跳点搜索（JPS）。==与 $2^k$ 邻域一起使用时，Canonical A* 和 JPS 在许多配置下，无论在解决方案质量还是运行时间方面，都优于任意角度路径规划器 Theta∗。在某些配置下，我们的规划器与任意角度路径规划器 ANYA 的一种实现具有竞争性。我们的主要实践结论是，标准的、广为人知的网格路径规划技术可以为任意角度网格路径规划提供有效的方法。 1. Introduction网格路径规划是人工智能领域最著名的问题之一。当把二维空间中的目标导航问题建模为网格上的图搜索问题时，它就自然而然地产生了。 网格路径规划在机器人（Lee &amp; Yu，2009 年）和视频游戏（Bj ̈ornsson, Enzenberger, Holte, &amp; Schaeffer，2005 年）等领域都有大量应用。此外，它仍然吸引着人工智能界的大量关注。值得注意的是，最近已经举办了三届网格路径规划竞赛（GPPC）（Sturtevant 等人，2015 年），对该领域的最新进展进行了检验（Botea 和 Harabor，2013 年；Harabor 和 Grastien，2011 年；Uras、Koenig 和 Hern ́andez，2013 年）。 有关网格路径规划的研究主要集中在简单的 4 邻网格（其中允许进行心形移动）和 8 邻网格（通过对角线移动扩展 4 邻移动）。造成这种情况的主要原因可能是这些邻域易于实现，而且人们对它们有很好的启发式方法。事实上，曼哈顿距离和 Octile 距离 (Sturtevant &amp; Buro, 2005) 分别是 4 邻域和 8 邻域无障碍网格的完美启发式方法。虽然计算机视觉领域的研究人员已经发现并研究了 16 邻域的距离函数（Marchand-Maillet &amp; Sharaiha, 1997），但据我们所知，对 16 邻域网格路径规划的评估（如 Nash, 2012; Aine &amp; Likhachev, 2016）从未考虑过这些启发式方法，而是使用了欧氏距离 (ED)。 针对无障碍网格的完美启发式方法可以让 A* 等规划者更快地找到解决方案。它们经常是其他网格路径规划技术的关键推动因素。其中一个例子是 Uras 等人（2013 年 GPPC 最佳轨迹奖得主）的方法，该方法主要依靠 Octile 距离计算子目标图，然后利用子目标图进行快速路径规划。另一个例子是 FRIT（Rivera, Illanes, Baier, &amp; Hern ́andez，2014 年），这是一种最先进的实时启发式搜索路径规划算法，其性能依赖于构建所谓的理想树，并使用 Octile/Manhattan 启发式。 在使用 4 个和 8 个相邻网格寻找路径时，一个重要的问题是任意角度路径的次优性。这个问题也被称为数字化偏差（Tsitsiklis，1995；Hew，2017）。直观地说，由于只允许少数棋步产生后继棋子，因此路径无法弯曲到实现最优所需的角度。事实上，Bailey、Tovey、Uras、Koenig 和 Nash（2011 年）对 4 邻角和 8 邻角路径规划的次优化问题进行了详细研究，并确定 4 邻角和 8 邻角最优解的成本与任意角度最优解的成本最多分别相差 $\\sqrt{2} \\approx 1.414$倍和$ \\sqrt{4 - 4 \\sqrt{2}} \\approx 1.08$ 倍(These results are obtained by Bailey et al. (2011) when the vertices of the search graph are placed at the corners of the grid cells.)。 为了在应用图搜索算法的同时找到质量更好的解决方案，研究人员对 A* 进行了扩展，使其能够找到具有更大角度多样性的移动（如 Daniel、Nash、Koenig 和 Felner，2010 年），并提出了可以直接考虑利用任意角度的路径的算法（如 Harabor、Grastien、Oz 和 Aksakalli，2016 年）。另一个文献中尚未深入考虑的方案是增加邻域的大小。 在本文中，我们将研究 2k 邻域上的网格路径规划，即在给定参数 k 的情况下，定义 2k 次移动的邻域。我们的第一个贡献是定义了这种邻域。我们证明的一个显著特性是，包含移动的最小正方形的半径由斐波那契数列给出。此外，我们还推导并证明了一种算法的正确性，该算法可以返回 2k 邻域上无障碍网格中任意两点之间的距离。我们的证明和构造适用于任意 k，从而推广了曼哈顿距离、Octile 距离以及 Marchand-Maillet 和 Sharaiha 的距离函数。不过，我们的证明似乎比 Marchand-Maillet 和 Sharaiha 对 16 邻域的证明要短得多，也简单得多。最后，我们定义了 2k 邻域的规范排序（Harabor &amp; Grastien, 2011; Sturtevant &amp; Rabin, 2016）。典型排序是跳点搜索（JPS）（Harabor &amp; Grastien，2011 年）的核心技术，是 8 连接网格路径规划最快的搜索算法之一。 我们实现了三种 2k 路径规划器：常规 A、带有我们的规范排序的 A，以及 2k 版本的 JPS。我们通过标准基准对它们进行了评估。我们测试了不同的 k 值，并将我们的 2k-tile 启发式与 ED 进行了比较。Canonical A* 和 JPS 的运行时间随 k 值变化，而常规 A* 则不然。与 ED 相比，我们的启发式搜索在常规 A* 的每个邻域以及 Canonical A* 的 8 邻域中都更快。我们还比较了任意角度路径规划器 Theta* （丹尼尔等人，2010 年）和 ANYA 的两个实现（Harabor 和 Grastien，2013 年；Harabor 等人，2016 年）：Uras 和 Koenig（2015 年）的版本以及 Harabor 等人报告的版本（2016 年）。ANYA 的优化版本（Harabor 等人，2016 年）在运行时优于我们的实现，而我们在许多配置中优于 Theta*。 我们在本文中报告的研究包括并扩展了之前发表的 AAAI17 论文（Rivera, Hern ́andez, &amp; Baier, 2017）。以下项目描述了 AAAI 出版物中未包含的材料。 我们提出了一个新的迭代启发式函数，并证明了其正确性。该函数之前已在另一份会议出版物中发表（Hormaz ́abal, Dı ́az, Hern ́andez, &amp; Baier, 2017）。 我们讨论并评估了 2k 版本的 JPS。 我们考虑的是智能体站在单元格四角而非中间时的路径规划问题。我们之所以采用这种不同的观点，是因为在 4 联接和 8 联接的网格中，这样会产生成本更低（最优）的解决方案（Bailey 等人，2011 年）。 我们扩展了实验结果，展示了不同类型基准（游戏地图、房间和随机）的性能。 我们用一个关于我们提出的启发式 h2k 的一致性的附加定理（定理 10）扩展了理论结果。此外，我们还提供了所有定理的完整证明。 在所有基准测试中，我们将任意角度路径规划器 Theta* 和 ANYA 进行了比较。 接下来，我们介绍背景信息，然后定义 $2^k$ 邻域。然后，我们推导出 2k-tile 启发式。我们将继续提出我们的典型排序，最后给出我们的经验评估和结论。 2. Background在本节中，我们将回顾网格路径规划的基础知识，并介绍最常用的邻域。 2.1 Grid Path PlanningN × M 网格是一个元组（C, O），其中 C = {(i, j) ∈ N × N | 0 ≤ i &lt; N, 0 ≤ j &lt; M } 是单元格集合，O ⊆ C 是障碍单元格集合。单元格 (i, j) 的四个角分别是 (i, j) （左下角）、 (i + 1, j) （右下角）、 (i, j + 1) （左上角）、 (i + 1, j + 1) （右上角）。 在网格路径规划文献中，对于智能体在网格中移动时可能位于的位置有两种假设。第一种是更传统的假设，即智能体位于单元的中心。第二种假设是，智能体位于某个单元的某个角落。在本文的其余部分，我们采用第二种观点，因为（1）在考虑扩展邻域时，这种观点简化了表述；（2）在 4 连网格和 8 连网格中，使用这种假设找到的路径更短，更接近真正的最优路径（Bailey 等，2011 年）。持这种观点的另一个重要原因是，Kramm、Rivera、Hern ́andez 和 Baier（2018）最近的研究表明，当 k 增大且顶点位于单元的角落时，最优路径的代价可以证明更接近于任意角度最优路径，而顶点位于单元中心时则不是这种情况。当然，这种观点的一个后果是，智能体的移动非常接近障碍物单元格；事实上，它 “触及 “了障碍物。虽然这可能被视为一个缺点，但它与传统的任意角度文献是一致的（参见图 2；Harabor 等人，2016 年）。 与网格（C，O）相关联的搜索图中，C 中每个单元的每个角都有一个顶点。搜索图的边由智能体可以执行的移动决定。每个移动都是一对有序整数。移动的集合称为邻域。 在本文的其余部分，我们使用有序对来表示二维中的移动和点。我们将这些对解释为二维向量。因此，我们假设以下等式成立：$(x, y) + (x′′, y′) = (x + x′, y + y′)$，以及 c(x, y) = (cx, cy)。我们用黑体表示有序对。我们用符号 [a, b] 来表示实数区间 ${x∈R | a ≤ x ≤ b}$，用 ]a, b[ 来表示 ${x∈R | a &lt; x &lt; b}$ 。单元格 c 的内部是点 ${c + μ(0, 1) + ν(1, 0) | μ, ν ∈ ]0, 1[}$ 的集合。单元 c 的边界是 ${c + μ(0, 1) + ν(1, 0) | μ, ν ∈ [0, 1]}$ 中不在 c 内部的点。最后，如果存在两个非负数 α 和 β，使得 $(x, y) = αm + βm′$，那么我们说 (x, y) 被两个移动 m 和 m′ 所包含。 在 p 中应用移动 m 所访问的点的集合是 {p + λm | λ∈ ]0, 1[}。在以下情况下，移动 m 适用于顶点 u： $u + m$ 是图形的一个顶点，并且 m 在 u 中应用时访问的点不包含： (a) 障碍单元内部的点 (b) 两个单元格边界的交点(2. Note that the intersection of the borders of two cells can be nonempty only if those cells are adjacent.) 一个 3 × 3 的网格，显示了适用的棋步（蓝色）和不适用的棋步（红色）。移动（1，3）不适用于顶点（0，0），因为它访问了单元格（0，1）内部的点。此外，移动（0，1）也不适用于顶点（1，1），因为它访问的点位于单元格（0，1）和（1，1）边界的交叉点上。 关于适用和不适用移动的说明，请参见图 1。顶点 u 的后继集定义为 N 上从 u 到 v 的路径是顶点 v1v2 - - vn 的序列，其中 v1 = u，vn = v，并且对于每个 i∈ {1, . , n - 1}，vi+1∈SuccN (vi)成立。请注意，这个定义意味着路径可以挤过对角线上的障碍物；在图 1 中，路径 (1, 0)(2, 1)(2, 2) 是合法的。对于每个 i∈ {1, . . . , n - 1}. 如果在 N 上存在一条以 v1 为起点、以 v2 为终点的路径，那么两个顶点 v1 和 v2 在 N 上是可到达的。 路径 σ = v1 - - vn 的成本为 c(σ) = ∑n-1 i=1 ‖vi+1 - vi‖。如果 N 上从 u 到 v 的每条路径 σ′ 都满足 c(σ) ≤ c(σ′)，那么 N 上从 u 到 v 的路径 σ 就是最优路径。 网格路径规划问题是一个元组 P = (C, O, N , ustart , ugoal )，其中 (C, O) 是一个网格，N 是一个邻域，ustart ∈ G 和 ugoal ∈ G 分别是邻域 N 中与 (C, O) 相关的搜索图的起始顶点和目标顶点。P 的解（或最优解）是 N 上从 ustart 到 ugoal 的路径（或最优路径），其中只包含 N 中的移动。 下面一个有用的概念是障碍物的凸角。一对（x，y）在以下任一条件下是障碍物的凸角： 1.（x，y）是某个障碍单元的左下角或右上角，且移动（1，-1）和（-1，1）适用于（x，y），或 2.（x，y）是某个障碍单元的左上角或右下角，移动（1，1）和（-1，-1）适用于（x，y）。 上述定义并不假定对角线上的移动，如（1，-1），是邻域的一部分。因此，这一定义也适用于 4 连网格。 2.2 The 4- and 8-Connected Neighborhoods and Their Heuristics传统上，4 连接邻域和 8 连接邻域被用于评估网格路径规划算法。4 连接邻域的定义如下 实际上只允许垂直和水平移动。此外，8 连邻域通过对角移动扩展了 4 连邻域。其定义如下 两个网格单元 u 和 v 之间的曼哈顿距离是 u 和 v′之间 N4 最佳路径的成本，假设网格中没有障碍物。它的定义是 |∆x| + |∆y|，其中 ∆x 和 ∆y 满足 (∆x, ∆y) = v - u。同样，给定两对单元格 u 和 v 的 Octile 距离返回的是假设障碍物集为空的 N8 上最优路径的成本。其定义为 其中 ∆x 和 ∆y 的定义同上。我们将 u 和 v 之间的曼哈顿距离和 Octile 距离分别记为 h4（u，v）和 h8（u，v）。 2.3 The Any-Angle Neighborhood任意角度网格路径规划允许智能体移动到网格中任何视线可及的点。因此，任意角度邻域包含了到达搜索图中每个顶点的移动。 3. The 2k Neighborhoods下面，我们将定义 2k 邻域，使其概括网格路径规划领域传统上使用的 4、8 和 16 连接邻域。对于每 k ≥ 2，我们定义 N2k 为一个序列 Q0、Q1、…，其中 Qi 是一个包含 N2i+2 第一象限移动的序列。它的第一个元素 Q0 包含第一象限（即正象限）上的 4 邻域移动；因此，Q0 = 〈（1，0），（0，1）〉。现在，如果 Qi = 〈 a0, . , an〉，Qi+1 是由 Qi 构建的，方法是在每个连续元素 aj 和 aj+1 之间插入总和 aj + aj+1。形式上，Qi+1 = 〈b0，b1，. ， b2n〉，其中 该系列的前三个要素是: Q0、Q1、. , Q5 也如图 2 中的第一象限元素所示。 请注意，Qi 中的元素是成对线性独立的。这是一个重要的性质，因为它说明移动是唯一的，即无法通过重复邻域中的其他移动来模拟。我们可以通过归纳法证明这一事实。事实上，Q0 的两个元素是线性独立的。此外，加入 Qi+1 的每个新元素都与 Qi 中的每个元素线性独立，因为它是 Qi 中两个（线性独立）元素之和。我们将其形式化为 命题 1 如果 u，v∈Qi，并且存在一个 k，使得 u = kv，那么 u = v。 为了定义第一象限移动的邻域，我们只需将每个移动映射到所有四个象限。因此，对于正交移动（（0，1）和（1，0）），我们会产生两个新的移动（（0，-1）和（-1，0）），而每个非正交移动（x，y）会产生 3 个额外的移动，对应于改变 x 和 y 的符号： 因此，我们可以滥用符号，将 N2k 解释为一系列棋步 〈v0，v1，. . , v|N2k |-1〉。当我们这样做时，我们假设序列的第一个元素是（0，1），并且 vi 和 vi+1 是这样的，即对于每 i∈ {0, . , |N2k | - 2}；也就是说，N2k 中的移动是顺时针排序的。此外，如果对于某个 j，m = vj，那么 m + 1 和 m - 1 分别表示紧接 m 的顺时针移动（即 v(j+1) mod 2k）和紧接 m 的逆时针移动（即 v(j-1) mod 2k）。最后，如果对于某个奇数 j，m = vj，我们说 m 是奇数移动，而当 j 为偶数时，我们说 m 是偶数移动。 命题 2 对于每 k ≥ 2，N2k 的万有性为 2k。 证明： 注意 |Q0| = 2 和 |Qi+1| = 2|Qi| - 1，这是一个递推方程，其解是 |Qi| = 2i + 1。对于 Qi 中的每一步非正交棋（其中有 |Qi| - 2），N22+i 中就有四步棋。此外，N22+i 包含 4 步正交棋步，总共有 4(|Qi| - 2) + 4 步棋。这就产生了 |N22+i| = 2i+2，对于每 i ≥ 0。 我们定义的一个特性是，Qi 中所有移动都可以被包围的最小正方形的大小–下文定义为邻域半径–呈指数增长（见图 2）；更确切地说，它随着斐波那契数字的增长而增长。在确定结果之前，让我们先正式定义邻域的半径。 定义 3 邻域 N 的半径定义为 现在，我们使用 Fib 函数定义斐波那契数列： 定理 4 radius(N2k ) = Fib(k - 2)。 为了简化符号，下面我们用 Qk 表示序列 Q 中 k 位置上的元素，其中 k 的取值范围为 0 到 |Q| -1。要证明定理 4，首先要注意，当 k 为奇数时，Qik = Q(k-1)/2 i-1 + Q(k+1)/2 i-1 成立。此外，观察 (k + 1)/2 和 (k - 1)/2 是连续的，因此其中一个是偶数。因此，如果 (k + 1)/2 是偶数，那么通过等式 (1)： 根据下面两个定理，定理 4 的证明非常简单。 定理 5 Qi 中任意一对的每个坐标都小于或等于 Fib(i)。 证明： 通过对 i 的归纳，我们可以检验出在基本情况下（i = 0）这是真的。假设每 i ∈ {1, . , n - 1}. 下面我们稍微滥用一下符号，当 x ≤ k 和 y ≤ k 都成立时，我们说 (x, y) ≤ k。现在，我们证明对于每一个 k，Qkn ≤ Fib(n)。我们区分两种情况：k 为偶数和 k 为奇数。如果 k 是偶数，那么 Qkn = Qk/2 n-1。根据归纳假设，Qkn ≤ Fib(n-1)，因此我们得出结论 Qkn ≤ Fib(n)，因为 Fib 是非递减的。 现在假设 k 为奇数。那么就有两种情况（公式 (5) 和 (6)）可以类比证明。这两种情况的证明方法相同，因此我们只需假设： 证明结束。 定理 6 假设 Fi 是由 F0 = 0 定义的数列，并且 Fi = 2Fi-1 + (-1)i-1, 对于 i &gt; 0，则 QFi i 的第一个坐标等于 Fib(i)，对于每个 i。 证明 首先要注意的是，对于每一个 i &gt; 0，Fi 都是由偶数加减 1 形成的 (2Fi-1)，因此是奇数。假设每 i ∈ {1, . , n - 1}. 现在我们证明 n 也成立。 现在有两种情况：n 为偶数和 n 为奇数。我们只关注前一种情况，因为后一种情况的证明与前一种情况类似。因为 n 是偶数、 进一步观察，根据公式 (8) 我们可以得到 另外，请注意这意味着 (Fn + 1)/2 是奇数，因此 (Fn - 1)/2 是偶数。现在，根据公式 (8)， 那么我们利用 Fi 的定义来写、 将等式 9 和 10 代入等式 (6) 可以写出 最后，通过归纳假设，我们得到了想要的结果。 我们对 N2k 的定义与法雷数列有关（Hardy &amp; Wright, 2008），其中，阶数为 n 的法雷数列 Fn 是分母不超过 n 的 0 到 1 之间的不可约分数序列，例如，F3 等于 0 1、1 3、1 2、2 3、1 1。这个数列的一个性质是，如果 a/b、a′/b′和 a′/b′′ 是三个连续的法里分数，则 a′ = a + a′′，b′ = b + b′′（定理 29；Hardy &amp; Wright，2008 年）。 4. A Distance for the 2k-Neighborhood在网格路径规划中，使用信息丰富的启发式方法至关重要。在 4 邻网格和 8 邻网格中，曼哈顿距离和八分距离在节点扩展数量上分别优于欧氏距离。曼哈顿距离和八分距离都对应于任意位置与目标位置之间最短路径的成本，忽略任何障碍物。 在本节中，我们将为更一般的 2k 邻域建立曼哈顿距离和 Octile 距离的类似模型。我们将重点回答这样一个问题：给定任意 i 和两个非负数 x、y，当只能在 Qi 中移动时，（0，0）和（x，y）之间最短路径的成本是多少？ 这个问题可以形式化为一个整数程序（IP）。事实上，如果 Qi = 〈v0, . . . , vn〉，我们要解决下面的 IP，即 Pi： 服从于： 对于每个 i∈ {0, . , n}，其中每个 αi 是一个整数变量，直观地表示移动 vi 的应用次数。 下面我们将证明 Pi 的线性规划（LP）松弛总是有一个整数解。在证明这一结果之前，我们将注意力转向 Pi 的 LP 松弛（我们将其命名为 Pi LP），研究它的性质和解。 4.1 A Solution to $P^{i} _{LP}$我们的第一个结果证明，我们可以专注于一个更简单的双变量问题，而不是原来的 n 变量问题。 定理 7 假设 Qi = 〈v0，…。, vn〉，且设 j 为 vj 和 vj+1 所包含的 (x, y)。那么 Pi LP 等价于 ˆ Pi LP，其定义为 证明 在剩下的证明中，给定 Pi LP 中每个变量 αi 的赋值 σ，我们用 D(σ) 表示 ∑n i=0 αi‖vi‖ 的值。假设 $P^{i} _{LP}$ 的最优解是对所有变量 $α_i$ 的赋值 σ，使得 σ(αk) &gt; 0，对于某个 k，k &lt; j（下面的证明可以稍作修改，以适应 k &gt; j + 1 的情况，但为了简单起见，我们省略了这一点）。现在考虑将所有向量 vi 一个接一个，先放 vk 形成的曲线。因为这条曲线的终点是（x，y），起点是（0，0），所以它必须与向量 vj 产生的射线相交。这条曲线可以 “分割 “成两部分：相交前的部分和相交后的部分。 现在我们正式确定一个事实，即总和可以分为两部分，一部分包含相交前的向量，另一部分包含相交后的向量。这意味着 (x, y) 可以表示为两个不相交集合中的矢量之和： A- 和 A+，分别包含相交前后向量的索引。此外，索引 T 用于表示与射线实际相交的向量。T 不属于 A- 或 A+。注意 A- 是非空的，因为它包含 k。最后，对于某个正值 m 和某个非负值 β ≤ αT 我们有如下结论： 图 3：定理 7 的证明示意图。在该图例中，我们假设 vj 和 vj+1 在 Q 中是连续的，且 (x, y) 包含在 vj 和 vj+1 中。(a) 我们假设最优解使用向量 vk1, . , vk4。在证明中，这意味着 A- = {k1, k2}，T = k3，A+ = {k4}。我们注意到，对于某个 α，可以用 αvj 来 “替换”(a) 中 vj 左边的最优解曲线部分，从而得到更好的解 (b)。 前两个等式的示意图见图 3。 请注意，等式 19 会产生一个不同的赋值，即 σ′′，它满足 Pi LP 的所有约束条件，并将 i∈A- 的每个 αi 赋值为 0。此外，D(σ′) &lt; D(σ)。事实上，这个新赋值用一条直线取代了原解中的一条曲线。 上述论证适用于任何使用索引小于 j 或大于 j + 1 的向量的赋值。因此，我们得出结论，对于 0≤ i &lt; j 或 j + 1 &lt; i ≤ n 的每一个 i，最优解必须是 αi = 0。 最后，请注意 ˆ Pi LP 只有一个可行的分配，即方程 (17) 的解，它必须使 αj 和 αj+1 都为正值。 根据定理 7，Pi LP 的解很容易计算，因为 ˆ Pi LP 只有一个可行点。具体来说，这就是求解方程 (17) 的两个线性方程组的 αj 和 αj+1 的赋值。因此，Pi LP 的解可以在恒定时间内计算出来。 下面的结果最终证明，对于每个 i ≥ 0，ˆ Pi LP 的解都有一个整数解，因此它就是 Pi 的解。 定理 8 对于每个 i ≥ 0，Pi LP 都有唯一的整数最优解。 证明 对于基本情况，观察 i = 0 时的解是 αj = x 和 αj+1 = y，因此是整数。 现在，我们假设 ˆ Pk LP 的解是整数。假设 ˆ P k+1 LP 的方程（17）为: 因为 vj 和 vj+1 在 Qk+1 中是连续的一对，所以其中一个在 Qk 中，而另一个是 Qk 中两个元素的和。在不失一般性的前提下，我们假设前者是 vj+1，后者是 vj。那么，我们可以将方程（20）重写为 αjvj-1 + αjvj+1 + αj+1vj+1 = (x, y)，或者等价地重写为： 其中 vj-1, vj+1 ∈ Qk。现在我们利用归纳假设得出结论：等式（21）给出的方程组有一个整数解；因此 αj 和 αj + αj+1 都是整数，这最终意味着 αj+1 也是整数。 下面的结果是定理 8 的直接结果，主要是说，要找到通往（x，y）的最优路径，我们只需在邻域中选择 “最近 “的移动，并将两者结合起来。我们由此推断出启发式方法和规范排序。 推论 9 假设 Qk-2 = 〈 v0, . , vm〉，且单元格 (x, y) 位于正象限。此外，设 j 使得（x，y）被 vj 和 vj+1 所包含。那么，在 N2k 上，使用 vj 和 vj+1 的整数组合，可以从（0，0）最优地到达（x，y）。 4.2 A Heuristic for N2k根据定理 7 和 8，我们可以得到以下算法，计算 N2k 上从（0，0）到点（x，y）的最优路径长度，假设 N2k = 〈v0，. . . , vm〉： 确定一个 j，使得 vj 和 vj+1 包含（x，y）。要搜索这样的 j，我们可以进行顺序搜索或二进制搜索。 求解方程（20）给出的两个线性方程组，并返回 αj‖vj‖+αj+1‖vj+1‖ 。 如果 P 是一个有目标顶点 g 的路径规划问题，而 c 是 P 的搜索图中的一个顶点，我们用 h2k (c) 表示上述过程在 g - c 上返回的值。 定理 10 h2k 是 N2k 的一致启发式。 证明 假设 s′ 是 s 的后继，那么 h2k (s) ≤ c(s, s′) + h2k (s′)。 在给定 k 的情况下，不难生成完成第 1 步和第 2 步所需计算的伪代码。算法 1 显示了不同 k 值下的启发式算法。在这些算法中，第 1 步是通过顺序搜索解决的，因此在最坏情况下需要执行 O(2k-2) 次检查。 4.2.1 A 2k Iterative Heuristic使用二进制搜索解决步骤 1 也是可行的。这意味着，对于特定的 k，我们可以编写一个伪代码，在最坏的情况下，该代码在执行过程中需要进行 O(k) 次 “if “检查。有趣的是，我们还可以构造一个以 k 为参数的函数，它的执行时间与 k 成线性关系，并且大小不变。 关键的一点是，计算启发式不需要执行上文第 4.2 节所述的两步方法。在抽象层面上，该算法可视为同时进行二进制搜索和方程组求解。伪代码如算法 2 所示。 算法的每个循环可以理解为一个 “因式分解回合”。每轮因式分解使用 N2k 的两次连续移动。为了说明这一点，假设我们想计算从（0，0）到（10，8）的 2k 距离。最初，我们从 4 连邻域开始，由于 (10, 8) = 10(1, 0) + 8(0, 1)，10 是与移动 l = (1, 0) 相关的因子，而 8 是与移动 r = (0, 1) 相关的因子。对于第一轮因式分解（即主循环的第一次迭代），我们希望用 l + r = (1, 1) 来表示 (10, 8)，因为我们知道这样的移动会出现在下一个邻域中。为此，我们取两个因数之间的最小值（本例中为 8），并将其作为 (1, 1) 的因数。为了使因式分解正确，我们观察到我们仍然需要使用棋步（1，0），而它的因数是 10 - 8 = 2。因此，在第一轮因式分解结束时，我们将（10，8）表示为 2（1，0）+ 8（1，1）。在下一轮中，要引入的棋步是 (1, 0) + (1, 1) = (2，1)，它的因数是 min{2, 8} = 2，我们仍然需要使用因数为 8-2 = 6 的棋步 (1，1)；因此，我们将 (10, 8) 表示为 2(2，1)+6(1，1)。随着我们不断迭代，我们会发现在 k 值不断增大的情况下，N2k 的棋步会有新的因式分解。 定理 11 函数 distance(a, b, k) 返回从（0，0）到达（a，b）的 N2k 邻域上最优路径的成本。 为了证明该定理，我们首先证明以下两个定理。 定理 12 在算法 2 的循环迭代 p 次之后，l 和 r 是 Qp 的连续移动。 证明 我们通过对第 4 行循环迭代次数的归纳来证明这一点。基本情况是微不足道的，因为（0，1）和（1，0）是 Q0 的连续移动。现在我们假设经过 n 次迭代后，l 和 r 是 Qn 的两个连续移动。那么有两种情况。首先，第 5 行 if 语句的条件为真，那么在迭代 n+1 中，根据 Q 的定义，r 和 l 是 Qn+1 中的连续移动。 定理 13 (a, b) = xl + yr, x ≥ 0, y ≥ 0 是调用 distance(a, b, k) 循环的不变量。 证明： 我们也可以用归纳法来证明。在零次迭代后，三个关系式成立（回想一下，输入使得 (x, y) 位于第一象限）。现在我们假设经过 n 次迭代后 (a, b) = xl + yr。那么 对于任意 z，该算法的行为就好像 z = min{x, y}。事实上，如果 x &gt; y，那么 x 将被重新定义为 x - min{x，y}，而 y 不会改变。否则，y 被重新定义为 y - min{x，y}。这保证了 x ≥ 0 和 y ≥ 0。此外，等式 (22) 加上 l 和 r 的更新方式保证了 (a, b) = xl + yr 在迭代 n + 1 中成立。 现在，我们可以对定理 11 进行完整的证明了。 定理 11 的证明 此外，在执行结束时，(a, b) = xl + yr，而根据定理 12，r 和 l 是 Qk-2 的连续移动。因此，我们观察到 x 和 y 是定理 8 中方程组的解，这反过来意味着 x‖l‖+ y‖r‖ 是 N2k 上（0，0）到（x，y）的距离，这意味着算法 2 是正确的。 5. Practical Grid Path Planning with $N_{2^k}$==以上我们正式描述了 N2k 的特征，并给出了一个一致的（可接受的）启发式，它非常适合无障碍网格。==然而，如果我们计划使用 A* 进行路径规划，N2k 的一个重要问题就是分支因子的增加，它与 k 呈指数关系。事实上，每一次 A* 扩展，我们都需要生成 2k 个后继路径，其中许多路径都有可能被添加到打开列表中，这将产生大量的开销。 然而，一个相反的现象是，在无障碍的 2k 网格中，两个顶点之间的最优路径数量可能会随着 k 的增加而大幅减少。这是因为，在无障碍网格中，最优路径的任何重新排序移动也是最优路径。在有 2k 个邻域的情况下，最优路径可能会使用更长的移动，从而导致移动次数更少的路径。举例来说，我们可以考虑（0，0）和（4，2）之间的路径数。当 k = 2（4 邻域）时，我们到达（4，2）的任意移动序列为 4 次垂直移动和 2 次水平移动，结果为 6！4!2! = 15 条路径。当 k = 3（8 邻域）时，我们需要 2 个对角线 (1,1) 移动加上 2 个垂直移动，得到 4.2! 2!2! = 6 条最优路径。最后，当 k ≥ 4 时，只有一条最佳路径需要两次 (2, 1) 移动。 因此，即使分支因子随 k 的增加而呈指数增长，两点之间的最优路径数量也可能随 k 的增加而大幅减少。因此，至少在理论上，增加 k 并不会明显降低网格路径规划的性能。 在本节中，我们将展示如何在 2k 邻域中利用 8 邻域网格路径规划的最新进展。具体来说，我们将展示跳跃点搜索（JPS）和典型 A* 如何适用于 N2k 邻域。事实证明，JPS 和 Canonical A* 在 8 邻域和 4 邻域网格上都能提高普通 A* 的性能，因此，了解如何将其融入 2k 邻域非常重要，因为与普通 A* 相比，我们也希望看到性能的提高。 我们遵循 Sturtevant 和 Rabin（2016 年）对 JPS 的看法，他们指出，JPS 可以理解为两个概念的组合：网格路径的规范排序和特定的后继函数。 图 4：左：16 邻域上的典型路径示意图。右图 S 和 G 之间的典型路径（灰色）和两条非典型路径（黑色）。 根据 Sturtevant 和 Rabin（2016）的定义，8 连网格上的典型路径是指通过使用 dncm 形式的棋步序列生成的路径，其中 d 是对角线棋步，c 是与 d 相邻的红心棋步： (i) 每对顶点之间最多只有一条典型路径，以及 (ii) 每条典型路径都是最优路径。性质（ii）源于我们的推论 9，性质（i）源于对两次移动顺序的限制。(关于 8 连接网格上的典型路径，请参见图 5a）。 如果我们能保证上述两个性质，将此定义应用于 N2k 并不困难。根据推论 9，我们知道对于任意 k，只需在 N2k 中连续移动两次，就能以最佳方式到达无障碍网格中的每个顶点。因此，要满足条件 (ii)，我们只需关注连续移动两次的路径。最后，为了满足条件 (i)，我们可以像 8 连网格一样，优先选择其中一个移动发生在另一个移动之前。在下面的定义中，我们首先选择奇数移动，因为这概括了 Sturtevant 和 Rabin（2016 年）针对 8 连网格给出的典型路径定义： 定义 14 如果 N2k 上的一条路径是由棋步 vnum 序列生成的，其中 v 是 N2k 中的奇数棋步，v 是 v - 1 或 v + 1，且 n，m ≥ 0，那么这条路径就是一条典型路径。 作为说明，图 4 显示了从 16 个连接网格中的一个顶点出发的典型路径。请注意，（2，1）及其变体（1，2）、（1，-2）等是唯一的奇数移动。 5.2 Canonical A* for $N_{2^k}$Canonical A* 是 A* 的一个版本，它直观上侧重于建立通往目标的典型路径。它在实践中的优势在于，搜索空间中的单个顶点无法通过另一条（同样好的）路径重新发现。为此，Canonical A* 使用 Harabor 和 Grastien（2011 年）提出的自然后继者和强制后继者概念来剪裁节点的后继者集合。直观地说，由于只考虑自然后继者，A* 自然只能建立规范路径。然而，由于并非所有可到达的节点对都可以通过典型路径到达，因此有必要定义强制后继者的概念，当搜索扩展的顶点是一个障碍物的凸角时，就可能需要强制后继者。 现在我们为这两类后继者提供正式定义。由于这些定义是在执行 Canonical A* 时使用的，因此我们在定义中提及扩展的概念。 定义 15 给定搜索节点 u 是通过移动 m 从父节点扩展而来的。如果符合以下条件，则 u 的后继节点 v 在 N2k 上是自然的： 如果 m 为奇数，则 v 位于 {u + (m - 1)，u + m，u + (m + 1)} 中。 否则，则 v = u + m。 u 的自然后继符用 natural (u) 表示。 此外，如果 v 是搜索的根节点（因此没有从任何节点扩展过），那么 SuccN2k (v) 就是 v 的自然后继节点。 如上所述，当关注自然后继时，搜索只会生成规范路径。示例见图 5(a)。现在，我们按照 Harabor 和 Grastien（2011）的方法定义强迫后继者的概念： 定义 16 给定一个搜索节点 u 通过邻域 N2k 上的移动 m 从父节点 t 扩展而来，如果符合以下条件，则 u 的后继节点 v 是强制的： v 不是 u 在 N2k 上的自然后继，并且 路径 tuv 是 t 和 v 之间唯一的最优路径。 u 的强制后继符用强制 (u) 表示。 只有在扩展作为障碍单元凸角的顶点时，才会出现强制后继。 现在我们要描述的是 N2k 的 Canonical A* ，它概括了 Sturtevant 和 Rabin（2016 年）针对 8 连接网格提出的 Canonical A。Canonical A 可以看作是一种算法，它在扩展节点时，会剪除所有不在其自然后继或强制后继之列的节点。更具体地说，当扩展根节点 r 时，SuccN2k (r) 中的所有节点都会被添加到开放列表中。 具有强制后继的节点只能对应于障碍物凸角的顶点。枚举这类强制后继节点非常简单。当通过移动 m 扩展到一个障碍物 v 的凸角时，直观的第一步是决定搜索应该 “转向 “哪里。为了确定这一点，我们可以观察到 v 有两个位于 o 边界上的后继棋子，一个是由应用于 o 的水平移动产生的，另一个是由应用于 o 的垂直移动产生的；让我们用 mh 和 mv 表示这两个移动。现在只有 mh 和 mv 中的一个与 m 形成最小角。强制后继是指 v 的所有非自然后继，它们是由 m 与 m′ 之间的移动产生的。mh 和 mv 分别是（-1，0）和（0，-1）。mv 是与 m 形成最小角度的移动，因此（4，2）的强制后继是包含在 mv 和（4，2）的自然后继中的所有后继。 定理 17 如上所述，Canonical A* 可以为 $N_{2^k}$ 上的任何路径规划问题 P 找到最优解，且对每一个 k 都是如此。 定理 17 的证明直接来自lemmata 19 和 20，我们将在下文中解释。第一个结果是，总是存在一条由典型路径串联而成的最优路径。因此，我们假设，如果 σ1 是一条以顶点 v 为终点的路径，而 σ2 是一条以顶点 v 为起点的路径，那么 σ1 ◦ σ2 表示不重复 v 的 σ1 和 σ2 的连接。 定义 18 给定路径规划问题 P，P 上典型路径的连接，σ1 ◦ σ2 ◦ . 对于每个 i∈ {1, … , n - 1}，如果 σi ◦ σi+1 不是一条典型路径，则 ◦ σn （n ≥ 1）是不可还原的。, n - 1}. 定理 19 对于 N2k 上任何可解的路径规划问题 P，都存在一个最优解，它要么是一条典型路径，要么是两条或两条以上典型路径的不可还原连接。 定理 20 假设 P 是一个路径规划问题，其最优解是典型路径 σ1 ◦ σ2 ◦ … 的不可还原串联。◦ σn. 那么，对于每个 i∈{1, … , n - 1}，σi 的最后一个顶点（以及 σi+1 的第一个顶点）都是一个椭圆。, n - 1}，都是一个障碍单元的凸角。 证明： 为了证明矛盾，让我们假设 σJ 和 σJ+1 违反了两难的条件。我们用 a 表示 σJ 的第一个顶点，用 b 表示 σJ+1 的最后一个顶点。 图 6 展示了在一个特定网格中，两点之间的两条典型路径的所有可能连接，而这两点之间不能用一条典型路径连接。以 a 为起点的典型路径用绿色表示，以 b 为终点的典型路径用红色表示。请注意，由 “未被障碍物’切割’的最后一条典型路径 “定义的多边形（灰色阴影）3 是由 a 和 b 之间的所有典型路径连接而成的，即通过一条典型路径将 a 连接到阴影区域中的一个顶点，然后再将该顶点连接到 b。 我们希望证明，当连接两条典型路径的顶点恰好是多边形的角（实际上也是阻碍直接连接的障碍区域的角）时，a 和 b 之间就形成了最短路径。 为了说明为什么会出现这种情况，我们将任意角邻域的证明–它更容易理解–调整为 2k 邻域的证明。在任意角邻域中，最短路径也是紧绷的。非正式地讲，当 “把路径当作一根弦，拉其两端就无法使其’绷紧’”（Oh &amp; Leong，2017）时，路径就是绷紧的；换句话说，最优路径只在障碍物的拐角处 “弯曲”。利用三角形不等式很容易证明，绷紧的路径总是比不绷紧的路径短。图 7 显示了 a 和 b 之间的绷紧路径、绷紧路径 acb 和非绷紧路径 adb。为了证明绷紧路径更短，让 e 成为线段 ad 和 cb 向左延伸的交点。现在我们写出与三角形 ebd 相关的一个三角形不等式、 请注意，由于两条路径并不完全重合，因此 (25) 实际上是一个严格的不等式。 现在我们来证明在 2k 邻域中也存在同样的关系，这次我们比较的是一条绷紧的典型路径和一条非绷紧的典型路径。在继续分析之前，我们先用 πxyz 来表示图中从 x 到 z 并访问 y 的路径。此外，我们用 πec 表示连接 e 和 c 的线段，其中 e 是 πadb 与路径 πcfb 向左延伸的交点。请注意，e 是一个可能是也可能不是顶点的点（在图 8 中，它实际上不是顶点）。 我们假设 πacb 和 πadb 都是典型路径的连接；但是前者是紧绷的，而后者不是。证明其余部分的关键在于我们可以写出与任意角情况类似的三角形不等式。事实上，根据定理 7，πecb 是用 16 邻域移动连接 e 和 b 的最短线段，因为它是用 16 邻域的连续移动生成的。因此我们可以写成 请注意，这是一个严格的不等式，因为我们假设 $d \\not = c$。 最后，请注意，由于路径 πagc 是最优的，我们可以写成 将 (26) 和 (27) 相加，我们得到 c(πacb) &lt; c(πadb)。虽然我们以 16 邻域为例进行了证明，但同样的论证也可用于任何 2k 邻域。 为了完成证明，我们可以使用矛盾论证： 如果 σJ 和 σJ+1 使得 σJ 的最后一个元素不是角，那么一定有另一条路径 σ′ J ◦ σ′ J+1 确实在角上弯曲，而且 σ′ i ◦ σ′ i+1 应该比 σi ◦ σi+1 短（这一点可以用上面的论证来证明），这与原始路径是最优路径的事实相矛盾。 定理 17 的证明：从上面的分析中，我们可以看出，如果问题有解，那么就存在一条最优到达目标的典型路径的连接。此外，根据定理 20，我们知道在这些典型路径之间访问的顶点也是障碍物的一个角。由于 Canonical A* 完全扩展了障碍物的每个凸角，因此可以通过 Canonical A* 找到分区的每条典型路径。我们的结论是，Canonical A* 是完整和最优的。 5.3 Jump Point Search跳点搜索（JPS）（Harabor &amp; Grastien，2011 年）是一种搜索策略，与 Canonical A* 一样，在扩展节点时，我们只计算自然后继和强制后继。不过，我们不会立即将这些后继节点直接添加到 “打开 “列表中，而是为每个节点计算一个所谓的跳转点，然后再将其添加到 “打开 “列表中。更准确地说，我们计算将后继者添加到开放列表的方法，借鉴了 Harabor 和 Grastien（2011 年）在算法 4 中描述的后继者生成器。在伪代码中，调用 jump(v, direction(v, n), g) 会计算从 v 向 direction(v, n) 方向的跳转点。最后，direction(v, n) 表示从 v 生成 n 的移动。 节点 v 在 d 方向上的跳跃点直观上对应于沿着 d 方向前进所找到的节点，当我们到达目标或有强制后继的节点时就会停止。此外，如果 d 是奇数棋步，我们也会在找到一个节点后停止，而该节点在与 d 紧邻的两个方向中的任何一个方向上都有一个跳跃点。 定义 21（2k 跳转点）如果 j = v + kd，且 k 是大于 0 的最小自然数，则节点 j 是 v 在 N2k 中向 d 方向的跳转点： j 是目标，或 j 有强制继承人，或 ==如果 d 是奇数棋步，那么在方向 d + 1 或 d - 1 上存在一个 j 的跳跃点。== 计算跳跃点非常简单，只需改编 Harabor 和 Grastien（2011 年）的函数，并按算法 5 进行修改即可。 6. Empirical Findings 我们的评估有两个目的。首先，我们想研究将 N2k 与最标准的启发式搜索算法 A* 结合使用对解决方案质量的影响，并将获得的解决方案与任意角度路径规划器 ANYA 和 Theta* 生成的解决方案进行比较。其次，我们想利用 h2k 启发式和欧氏距离研究 k 的增加对 A、Canonical A 和 JPS 运行性能的影响。此外，我们还将运行时间性能与 ANYA 和 Theta* 进行了比较。 我们在 Uras 和 Koenig 的 Subgoal graphs 实现（2015 年）之上实现了我们的算法，该实现使用标准二进制堆进行 Open。该实现包括 Theta* 以及 Harabor 和 Grastien（2013 年）描述的任意角度规划器版本，下文我们称之为 ANYA。我们还包括 Harabor 等人（2016 年）描述的同一任意角规划器优化版本的结果，除随机地图外，我们在下文中称之为 iANYA。所有实验均在主频为 2.20GHz 的 Intel(R) Xeon(R) CPU Linux 机器上运行，内存为 128GB。 ==我们对 JPS 的实现对最初的提议做了两处修改，这使得实现更加容易，同时保留了最初 JPS 的所有特性。首先，跳转点要么是目标，要么是障碍物的凸角；其次，跳转点在扩展时是完全扩展的，即其所有后继点都被添加到开放列表中。== 在比较中，我们使用了来自 MovingAI 资源库（Sturtevant，2012 年）的三组游戏地图。第一组游戏地图来自《博德之门 II》（包含大小为 512 × 512 的地图）、《龙腾世纪：大小的起源》（包含大小为 512 × 512 的地图）和《龙腾世纪：大小的起源》（包含大小为 512 × 512 的地图）： 起源》中的地图，大小从 22 × 28 到 1260 × 1104 不等，以及《星际争霸》中的地图，大小从 384 × 384 到 1024 × 1024 不等。第二组是大小为 512 × 512 的随机地图，其中受阻单元的比例从 10% 到 40% 不等。最后，第三组是大小为 512 × 512 的房间地图，房间大小从 8 × 8 到 64 × 64 不等。 图 9-11 显示了不同邻域、ANYA、iANYA 和 Theta* 的常规 A* 的平均求解成本。这些图还显示了次优化的平均百分比，省略了 A*（k = 8）以获得更好的绘图缩放效果。我们评估了 2k 的七个值：8、16、32、64、128、256 和 512。我们得出以下结论。 在所有三个基准中，当 k 增加时，求解成本都会提高。当 k 增加到 6（64 邻域）以上时，改善幅度微乎其微。 与最优任意角规划器 ANYA（和 iANYA）相比，我们发现当 k 超过 6（64 邻域）时，A* 几乎能获得最优任意角路径。具体来说，在 64 邻域中，游戏图、房间图和随机图的次优率分别只有 0.19%、0.19% 和 0.10%。 与 Theta* 相比，我们发现在游戏地图和房间地图中，k 大于 4（16 个邻域）的 A* 能找到更好的解决方案。在随机地图中，当 k 大于 3（8 个邻域）时，A* 能获得更好的平均解成本。 现在，我们将注意力转向运行时评估。在我们的实现中，Canonical A* 和 JPS 没有使用任何预计算或其他优化方法，如 Rabin 和 Sturtevant（2016 年）或 Harabor 和 Grastien（2014 年）所述的优化方法。我们认为优化方法的实施是未来工作的一部分。 为了了解不同算法对运行时间的影响，我们展示了图 12，图中显示了不同邻域下常规 A、典型 A 和 JPS 的平均运行时间。我们评估了每种算法的 h2k 启发式和欧氏距离 (ED)。我们评估了相同的七个 k 值。 在常规 A 上。* 在游戏地图和房间地图上，运行时间随 k 的增加而增加。这是因为分支因子较大，而分支因子随 k 的增加呈指数增长。在 k 值较小的情况下，使用 h2k 启发式的 A* 比使用欧氏距离的 A* 运行速度更快。在 k 值中等和较高的情况下，使用 ED 的 A* 运行速度稍快，这是因为计算我们的启发式需要开销，而且当 k 值较大时，h2k 与欧氏距离更接近。在随机地图中，对于每个 k，使用 h2k 的 A* 都比使用欧氏距离的 A* 快。 关于 Canonical A 。* ==主要观察结果是，在游戏地图和房间地图中，对于大多数 k 值，使用欧氏距离的 Canonical A* 性能更好。在随机地图中，对于大多数 k 值，h2k 是最佳选择。== 关于跳点搜索。 在游戏地图中，对于大多数 k 值（k = 3 除外），使用欧氏距离的 JPS 是最佳选择，但在 k &gt; 6 时，它的性能被 ANYA 和 iANYA 所超越，随机地图除外。在房间地图中，欧氏距离在 k = 3 和 k = 4 时性能最佳，在其他值时，使用 ED 的 JPS 略快。在随机地图中，h2k 启发式是最佳选择。 在所有算法中。 JPS 在 “游戏地图 “和 “房间地图 “中表现最佳（”游戏地图 “中 k = 9 除外）。另一方面，JPS 在随机地图中的性能最差。这可以解释为，JPS 在扩展一个状态时，会生成从该状态出发的典型路径上的所有状态 Sturtevant 和 Rabin（2016）。 即使在基本配置（k = 2）中，优化后的 iANYA 规划器也优于我们的算法，但随机地图除外。在游戏、房间和随机地图中，Theta* 的运行时间分别为 14.49 毫秒、17.39 毫秒和 2.77 毫秒。在游戏地图和房间地图中，使用 2k 邻域的 Canonical A* 和 JPS 比 Theta* 更快，在每个 k 中都是如此。此外，如图 9-11 所示，还能获得更好的求解成本。在随机地图中，使用 ED 启发式（k = 4）的 Canonical A* 比 Theta* 更快，并能获得更好的成本。在游戏图、房间图和随机图中，ANYA 的运行时间分别为 4.16 毫秒、7.20 毫秒和 35.03 毫秒。在 Game 和 Room 地图中，在 k 等于 6（64 邻域）之前，JPS 比 ANYA 快。当 k = 7（128 邻域）时，运行时间相似。当 k &gt; 7 时，JPS（未进行优化）比 ANYA 更快，在解质量上也更有竞争力。==在随机地图中，对于我们评估的所有 k 值，使用 2k 邻域的 Regular A、Canonical A 和 JPS 都比 ANYA 快。== 此外，我们还列出了四个表格，显示了扩展次数、堆渗流和每次扩展的时间。表 1 显示了常规 A* 的结果。我们发现，当邻域大小增加时，每次扩展的搜索时间也会增加。此外，如表 2 所示，当使用 Canonical A* 时，我们观察到每次扩展的搜索时间会平稳增加。表 3 显示了 JPS 的结果。扩展次数对应的是以广度优先搜索方式进行的规范扩展次数，目的是识别插入到开放列表中的跳转点。这就解释了为什么扩展次数多，而渗滤次数少。在这里，每次扩展所需的搜索时间很少，但当邻域增大时，搜索时间就会增加。 表 4 显示了 Theta* 和 ANYA 的结果。关于 Theta* 和 ANYA 中什么是扩展的解释，可以在解释我们使用的 Uras 和 Koenig 实现方法的论文中找到。由于算法的工作方式，在 k 值较小的情况下，Theta* 和 ANYA 与普通 A* 相比，每次扩展的开销较小。另一方面，如果考虑每次搜索扩展的时间和总搜索时间，Canonical A* 和 JPS 似乎是更好的选择。从表 1、表 2 和表 3 中的结果可以看出，在 k 值较小的情况下，h2k 启发式比欧氏启发式能获得更好的结果。 7. Summary and Conclusions我们提出了在 2k 邻域上构建有效网格路径规划器的三个关键贡献。首先，我们正式==定义了 2k 邻域==；其次，我们定义了==2k 距离函数==，该函数可在 k 的多项式时间内计算，并可用作可接受的启发式。第三，我们定义了==规范排序，最终使我们能够提出 2k 邻域的跳点搜索实现方法。==我们的规划器能生成更好的解决方案，但运行时间的增加在使用跳点搜索或规范 A* 时较小。对于 32 邻域及更高邻域，我们的规划器比 Theta* 能生成更好的解，而对于 64 邻域及更高邻域，我们的规划器能获得低于 0.2% 的次优化。我们的规划器并没有进行特别优化，但在多达 64 次移动的邻域中，它的平均速度比任意角度规划器 ANYA 的实现要快，但并不比优化算法 iANYA 快。因此，我们的方法似乎值得推荐给那些寻求高质量解决方案，同时又希望使用标准或简单实现方法的实践者。 这项研究为未来的工作打开了一扇门，未来的工作可能会研究 2kneighborhoods 在任意角度增量搜索中的应用，这是一个与机器人相关的问题。与机器人应用相关的还有三维网格的 2k 邻域版本。这也是我们目前的研究课题之一。","link":"/2024/02/05/The-2-k-Neighborhoods-for-Grid-Path-Planning/"},{"title":"A review: On path planning strategies for navigation of mobile robot","text":"A review: On path planning strategies for navigation of mobile robot Abstract本文对迄今为止使用的移动机器人导航技术进行了深入研究。本文对经典方法和反应式方法进行了逐步研究，以了解各种环境条件下路径规划策略的发展，并找出研究差距。经典方法包括单元分解法（CD）、路线图法（RA）和人工势场法（APF）； 研究考虑了遗传算法 (GA)、模糊逻辑 (FL)、神经网络 (NN)、萤火虫算法 (FA)、粒子群优化 (PSO)、蚁群优化 (ACO)、细菌觅食优化 (BFO)、人工蜂群 (ABC)、布谷鸟搜索 (CS)、洗牌蛙跳算法 (SFLA) 和其他杂项算法 (OMA) 等反应式方法。对静态和动态条件下的导航进行了分析（针对单个和多个机器人系统），结果表明，与传统方法相比，反应式方法更加稳健，在所有地形下均表现良好。同时还发现，作为一种混合算法，反应式方法可用于提高经典方法的性能。因此，反应式方法在移动机器人的路径规划中更为流行和广泛。本文最后以表格数据和图表的形式比较了各种导航策略的使用频率，这些策略可用于机器人技术中的特定应用。 Introduction最初，移动机器人的应用仅限于制造业。但如今，它已普遍应用于娱乐、医疗、采矿、救援、教育、军事、太空、农业等领域。在执行导航任务时，机器人配备了许多智能设备，这些设备需要对环境进行建模、定位、控制运动、检测障碍物，并利用导航技术避开障碍物。从初始位置到目标位置的安全路径规划（通过检测和避开障碍物）是任何导航技术最重要的功能。因此，在简单和复杂的环境中工作时，正确选择导航技术是机器人路径规划中最重要的一步。目前，不同研究人员在移动机器人导航领域开发了许多技术，是当今研究最多的课题。移动机器人导航分为三类：全局导航、局部导航和个人导航。全局导航能够确定环境中各元素相对于参考轴的位置，并朝着预先确定的目标前进。局部导航涉及环境动态条件的识别和各种元素之间位置关系的建立。通过考虑环境中各种元素的位置，处理它们之间的相对关系，这就是个人导航。机器人运行的基本步骤[1]如图 1 所示。 本文根据路径规划所需的先验环境信息对导航策略进行了分类。大致可分为全局导航和局部导航。在全局导航中，移动机器人必须先获得环境、障碍物位置和目标位置的信息，而在局部导航中，移动机器人不需要先获得环境信息。全局导航策略处理的是完全已知的环境。局部导航策略处理的是未知和部分已知的环境。已知环境下的路径规划算法基于传统方法，如 CD、RA 和 APF。这些算法都很传统，智能性有限。本地导航方法被称为反应式方法，因为它们更加智能，能够自主控制和执行计划。 许多研究人员都提交了有关移动机器人导航的调查论文[2-3]，但这些调查不足以对单项导航技术进行深入分析。这篇关于移动机器人导航的调查论文旨在找出特定领域的研究空白和创新范围。它深入分析了静态环境、存在移动障碍物和目标的动态环境、仿真分析、实验分析、多移动机器人导航、与其他智能技术的混合、在三维（3D）环境中的应用以及在军事或国防设备中的应用等方面的单项算法。调查还强调了经典方法和反应方法之间的差异，这些差异基于它们在特定环境（如空中、陆地、水下、工业和危险环境）中的有效性和应用。参考文献[2]的重点是 “在特定的环境中”。2]主要关注基于本地传感器信息的反应式方法、滑动模式控制和基于分散式 MPC 的方法，而参考文献[3]则仅限于三维环境。[3] 则仅限于三维路径规划。 第 2 节将导航策略分为传统方法和被动方法。第 3 节讨论文献调查，第 4 节为结论。 2. Navigational techniques used for mobile robot navigation几十年来，各类研究人员和科学家提供了大量导航方法。用于移动机器人导航的各种方法大致分为两类，即经典方法和反应方法（图 2）。 2.1. Classical approaches最初，经典方法在解决机器人导航问题方面非常流行，因为当时还没有开发出人工智能技术。使用经典方法执行任务时，要么会得到结果，要么会确认结果不存在。这种方法的主要缺点是计算成本高，无法对环境中存在的不确定性做出反应，因此不太适合实时执行。本文将对 CD、RA 和 APF 等经典方法进行综述。 2.1.1. Cell decomposition (CD) approach这种方法将区域划分为不重叠的网格（单元），并使用连接图从一个单元穿越到另一个单元，以实现目标。在遍历过程中，考虑纯单元（无障碍单元），以实现从初始位置到目标位置的路径规划。在确定从初始位置到目标位置的最佳路径时，路径中存在的损坏单元格（包含障碍物的单元格）会被进一步分割成两个新单元格，从而得到一个纯单元格，这个纯单元格会被添加到序列中。在 CD 方法中，初始位置和目标位置分别由起点和终点单元表示。连接这两个位置的纯单元序列表示所需的路径 [4-5]。CD 方法分为自适应、近似和精确三种。 在图 3 所示的精确单元分解法[6-7]中，单元没有特定的形状和大小，但可以根据环境地图、形状和其中障碍物的位置来确定。这种方法以多种方式使用规则网格。首先，将环境中可用的自由空间分解成小元素（梯形和三角形），然后为每个元素编号。环境中的每个元素都是连接图的一个节点。相邻的节点可以在配置空间中连接起来，该图中的一条路径相当于自由空间中的一条分道线，由连续的条纹单元勾勒出来。该图中的一条路径与自由空间中的一个网络相连，该网络由连续的条纹单元格勾勒而成。然后，通过通道中相邻单元格交叉点的中点，将底层布置与目标设计连接起来，从而将该通道转换为自由通道。 在近似单元分解法[8-9]中，规划空间被用来定义具有特定形状和大小的规则网格，因此很容易实现。在空间中，物体的边界不应与之前确定的单元边界相匹配，因此被称为近似。在这种导航方法中，如果物体占据了网格空间，就会被视为障碍物，否则就会被视为空白空间。在搜索区域的寻路过程中，每个单元格的中心被假定为一个节点。图 4 显示了 4 节点和 8 节点连接系统，机器人必须在它们之间以对角线方式行进。自适应单元分解可以理解自由空间中存在的信息，并遵循常规单元分解中避开自由空间的基本概念。Samet [10] 和 Noborio [11] 提出了一种四重自适应分解法。它将环境划分为大尺寸的单元格，但当网格单元被部分占用时，它会将单元格划分为四个相等的子部分，直到单元格变空为止。图 5 显示了在不同大小的网格单元触及障碍物边界时产生的工作空间地图。该系统有一个缺点，即在获得新数据（障碍物的新位置）时无法更新程序，因此在动态环境中会失效。Lingelbach [12] 对高维静态配置空间中的路径规划问题进行了论证。他解决了链状机器人平台和迷宫环境的路径规划问题。Rosell 等人[13] 将谐函数应用于 C 形障碍物环境中的单元分解，而 Sleumer 等人[14] 则提出了基于 CAD 信息的移动机器人路径规划策略。Cai 等人[15] 提出了一种基于传感器的近似单元分解策略，用于对复杂环境中的多个固定目标进行分类。该方法在静态环境中的表现优于最短路径，并能完全覆盖环境。Dugarjav 等人[16] 提出了同样的基于传感器的单元分解模型，用于处理移动机器人任务中的未知直线工作空间。他们将 CD 方法与激光扫描机制结合使用，以避开未知环境中的物体。Glavaski 等人[17] 提出了一种混合方法，以填补路径规划问题中理论成果与实际考虑之间的差距。他们开发了一种基于 APF 的精确单元分解路径规划器，以降低计算成本。为了在不确定的环境中执行，Tunggal 等人[18]提出了实时运行的 FL 和 CD。为了在三维环境中同时处理多个活动，Mark 等人[19] 提出了一种贪婪深度优先搜索算法和基于 GA 的单元分解方法，用于机械手的路径规划。Gonzalez 等人[20]通过改变所涉及的单元分解、图权重和计算航点的程序，对轨迹进行了定量研究。Wahyunggoro 等人[21]将单元分解方法应用于探索三维环境的空中导航问题。在这种方法中，模糊逻辑与单元分解方法相结合，用于引导和控制航空飞行器。 2.1.2. Roadmap approach (RA) RA 也被称为高速公路方式。它是从一个地方到达另一个地方的方法，自由空间之间的连接用一组一维曲线来表示[22]。当路线图绘制完成后，规划者就可以将其作为同质道路的排列方式，从而发现理想的排列方式。在这里，节点在为机器人找到理想路径中扮演着重要角色。RA用于寻找从机器人初始位置到目标位置的最短路径；Voronoi图和可见性图用于绘制路线图。可见度图法将初始位置和目标位置与地图上的节点连接起来。图 6 表示可见度图，其中暗区表示障碍物，虚线表示从初始位置到最终位置的相应路径 [23]。这种方法也可用于多边形障碍物环境，其中多边形的顶点由节点表示，边则是节点之间的连接[24]。Voronoi 图 [2527] 是另一种用于机器人路径规划的路线图算法。这种方法将区域划分为若干子区域，图中的所有边都是利用障碍物边界上相邻两点的等距点来构建的。 图 7 显示了 Voronoi 图的工作原理。文献[28-30]介绍了 Voronoi 图在移动机器人绕障碍物导航领域的应用。为了提高性能，消除 Voronoi 图中的急转弯和长循环等缺点，对有效路径规划进行了一些改进[31]。混合方法是通过结合可见度图、沃罗诺图和势场方法 [32] 来实现路径优化。据观察，该方法无法获得最佳路径，且执行过程复杂。为了成功利用 Voronoi 图进行路径规划，Yang 等人[33]采用了骨架图等多种策略。Wein 等人[34]提出了一种结合使用可见性图和 Voronoi 图的方法，以获得最佳路径。Kavraki 等人[35]提出将概率应用于 RA，以理解和生成路径规划的解决方案。然而，这种方法在获得最佳路径长度方面效率较低。为了改进寻找最短路径的过程，Sanchez 等人[36] 对概率路线图方法（PRM）进行了细微的改进。在他们的方法中，将懒碰撞检查策略与 PRM 结合起来，以解决真实环境中的路径规划问题。Yan 等人[37]成功测试了无人飞行器在三维环境中的导航。在该方法中，路线图方法采用概率公式来控制飞行路线。 2.1.3. Artificial potential field (APF) approachKhatib [38] 于 1986 年提出了用于移动机器人导航的 APF 方法。他认为，目标和障碍物就像带电表面，总电势会对机器人产生假想力。如图 8 所示，这种假想力会吸引机器人朝目标前进，并使其远离障碍物。在这里，机器人沿着负梯度避开障碍物，到达目标点。Garibotto 等人[39]介绍了这种方法在移动机器人导航中的应用。Kim 等人[40] 利用 APF 讨论了在未知环境中的一种新的避障策略。他们使用谐函数来避免局部最小值问题。Borenstein 等人[41] 也提出了局部最小值条件问题的解决方案。在这项研究中，他们考虑了机器人导航的动态特性。文献[42-43]对动态环境中的避障 APF 进行了分析。利用静电定律对 APF 方法进行了一些改进 [44]。静电法的实施有助于产生势函数和实时确定无碰撞路径。在实时环境中移动避障并非易事，因此 Huang [45] 开发了一种速度控制机制，以便在实现目标的同时了解障碍物的位置和速度。为了避免局部最小值并实现全局最优，Shi 等人[46] 引入了上位势函数和上位斥势函数。Sfeir 等人[47] 通过振荡和冲突等 APF 方法解决了移动机器人导航中的观测问题。他们提出了一种改进版的 APF，当目标靠近障碍物时，可将振荡和冲突最小化。为了测试 APF 的适用性，Pradhan 等人 [48] 使用了 ROBOPATH 仿真工具。他们考虑了各种环境条件下的多个移动机器人，观察到在无碰撞的情况下，协调策略的效果更好。为了提高 APF 路径规划器的性能，它与许多技术结合使用，如 BFO [49]（如图 9 所示）、GA[50]、PSO [51] 和 FL [52]。在三维空中和水下条件下导航是一项具有挑战性的任务，但 Cetin 等人[53]和 Li 等人[54]分别使用 APF 方法取得了成功。","link":"/2024/02/16/A-review-On-path-planning-strategies-for-navigation-of-mobile-robot/"},{"title":"Optimal path planning of mobile robots: A review","text":"Optimal path planning of mobile robots: A review Abstract移动机器人越来越多地应用于自动化工业环境。此外，还有其他一些应用，如行星探测、监控、地雷探测等。在所有这些应用中，为了让移动机器人完成任务，无碰撞路径规划是一个先决条件。本文概述了离线和在线环境下移动机器人路径规划的研究进展。文章讨论了移动机器人路径规划中常用的经典方法和进化方法。综述显示，进化优化算法的计算效率很高，因此在处理非确定性多项式时间困难（NP-hard）问题时，越来越多地与传统方法结合使用。此外，还讨论了开发计算效率高的路径规划算法所面临的挑战。 Key words: Path planning, mobile robot, off-line environment, on-line environment, classic, evolutionary algorithms. Introduction移动机器人越来越多地应用于许多自动化环境中。移动机器人的潜在应用范围很广，如老年人服务机器人、工厂中用于转移货物的自动导引车、无人拆弹机器人和行星探测机器人。在所有这些应用中，移动机器人都使用图 1 所示的构件（Siegwart 和 Nourbakhsh，2004 年）执行导航任务。 移动机器人的导航包括环境感知、定位和地图构建、认知和路径规划以及运动控制。感知指的是理解其感官数据，而在周围环境中找到其姿势或配置则是定位和地图构建。在通过运动控制实际完成首选轨迹之前，利用认知决策根据任务规划路径是一个重要阶段。由于每个组成部分本身都是一个广阔的研究领域，本文将对路径规划方法进行综述。 除机器人应用外，路径规划还可用于规划电路板上的路径、获取无线移动通信中网络的分层路径（Manousakis 等人，2005 年）、规划计算机图形学中数字艺术家的路径以及计算生物学中了解蛋白质折叠的可能路径（Choset 等人，2005 年）。 本文旨在概述移动机器人中使用的路径规划算法。本文概述了离线和在线环境下移动机器人路径规划的研究进展。文章讨论了移动机器人路径规划中常用的经典方法和进化方法。此外，还确定了开发计算效率高的路径规划算法所涉及的进一步范围和挑战。 CATEGORIES OF PATH PLANNING ALGORITHMS移动机器人的路径规划是确定从起点到目标点的无碰撞路径，优化性能标准，如距离、时间或能量，其中距离是最常用的标准。==根据环境信息的可用性，路径规划算法分为离线和在线两类。在预先知道静止障碍物和移动障碍物轨迹的完整信息的环境中，机器人的离线路径规划也被称为全局路径规划。==当事先无法获得完整的环境信息时，移动机器人在环境中移动时通过传感器获取信息。这就是所谓的在线或局部路径规划。从本质上讲，在线路径规划是从离线模式开始其初始路径的，但当它发现障碍物情况有新的变化时，就会切换到在线模式。 OFF-LINE PATH PLANNING ALGORITHMS离线环境下的路径规划实例包括核电站维护期间运行的服务机器人、工厂中的自动导引车等，在这些环境中，捕捉到的环境地图可能不会发生任何变化。 Classic approaches制定和解决路径规划问题的基本方法是配置空间（Cspace）方法（Lozano-Perez 和 Wesley，1979 年）。虽然 Udupa（1977 年）在其博士论文中也提出了这一观点，但将其广泛应用于路径规划的却是 Lozano-Perez。这种方法的核心思想是将机器人表示为一个点。因此，移动机器人路径规划问题的 C 空间被简化为二维问题。当机器人被简化为一个点时，每个障碍物都会按机器人的大小放大，以进行补偿。Latombe 的著作（1991 年）将路径规划文献围绕这一方法进行了整合。以 C 空间为基本概念，有许多经典的路径规划方法，如路线图方法、单元分解方法等。在路线图方法中，我们构建了连接起点和目标点的无碰撞路径网络。众所周知的路线图方法有可见度图和沃罗诺伊图。 可见度图（Lozano-Perez 和 Wesley，1979 年）是通过连接起点和目标点之间相互可见的多边形障碍物的两个顶点绘制的。然后通过从可见度图中获得的道路确定最短路径。由于道路的数量取决于多边形障碍物及其边缘的数量，因此该方法在稀疏环境中非常有效（Li 等人，2002 年；Siegwart 和 Nourbakhsh，2004 年）。另一种路线图方法，即 Voronoi 图（Dunlaing 和 Yap，1985 年），是通过与两个或两个以上障碍物等距离的点来构建的。因此，获得的路径更安全，但通常不会更短（Masehian 和 Amin-Naseri，2007 年；Garrido 等人，2011 年）。 单元分解法（Lozano-Perez，1983 年）计算移动机器人的 C 空间，将所得空间分解为单元，然后在自由空间单元图中搜索路径。网格法（Brooks 和 Lozano-Perez，1983 年；Zhu 和 Latombe，1989 年；Payton 等人，1993 年；Likhachev 等人，2005 年；Hachour，2008a，b）是一种流行的单元分解法，使用网格生成环境地图。主要的困难在于如何确定网格的大小，网格越小，环境的表示就越准确。然而，使用较小的网格会导致内存空间和搜索范围呈指数上升（Zheng 等人，2007 年）。 Evolutionary approaches传统方法虽然有效，但在确定可行的无碰撞路径时需要花费更多时间。而且，经典方法往往会锁定局部最优解，而局部最优解可能远不如全局最优解。此外，在存在多个障碍物的情况下，移动机器人的路径规划被认为是非确定性多项式时间困难（NP-hard）问题（Canny 和 Reif，1987 年）。如果环境是动态的，这个问题就会变得更加复杂。这些缺点使得传统方法在复杂环境中显得无能为力（Sugihara 和 Smith，1997 年）。因此，诸如遗传算法（GA）、粒子群优化（PSO）等进化方法应运而生。同样，蚁群优化（ACO）和模拟退火（SA）也被用来快速解决路径规划问题。 GA 是一种基于自然遗传学和选择力学的优化工具（Holland，1975；Goldberg，2000）。使用 GA 进行路径规划的第一步是随机生成包含备选路径的种群。美国国家航空航天局的 Dozier 等人（1997 年）提出了一种混合规划器，它利用了基于可见度的修复方法和进化技术。基于可见度的修复方法用于将干扰障碍物的路径（无效路径）快速转化为有效路径，然后再由二进制编码的 GA 进行处理。使用二进制字符串的遗传算法计算成本很高，因为在每次评估函数之前，染色体都要转化为表型（Ripon 等人，2007 年）。Xiao 等人（1997 年）提出了一种用于路径规划的进化规划器。该规划器的基因型结构相对简单，可代表有效路径，但需要复杂的解码器和适应度函数才能获得最佳路径。此外，在转换为二进制模式时可能会损失精度。 此外，Sugihara 和 Smith（1997 年）、Gallardo 等人（1998 年）、Nagib 和 Gharieb（2004 年）以及 Al-Taharwa 等人（2008 年）都使用了由二进制字符串组成的固定长度路径。对于障碍物较少的环境，固定长度路径能快速给出解决方案，而对于复杂环境，则需要数小时才能演化出解决方案。为了在复杂环境中到达目标，需要可变长度的染色体。Tu 和 Yang（2003 年）提出了长度可变的二进制编码遗传算法，其中基因表示随后的移动方向和距离。这种算法的主要局限性在于会产生一些无效的结果，如可能根本无法到达目标点的路径（Shahidi 等人，2004 年）。 Wang 等人（2006 年）提出了一种基于遗传的路径规划算法，该算法生成的种群包括与障碍物相互干扰的种群（无效路径）。随后，这些无效路径序列将接受惩罚函数评估。这增加了计算负荷，导致执行时间增加（Raja 和 Pugazhenthi，2008、2009a、b、2011）。 PSO 是另一种广泛应用于路径规划的进化算法。它是一种进化计算技术，灵感来自鸟群或鱼群的社会行为。通过多年对鸟类和鱼类动态的研究，人们发现了利用这种行为作为优化工具的可能性。与 GA 相比，PSO 的优点是更容易实现，需要调整的参数也更少（Kennedy 和 Eberhart，1995 年）。Qin 等人（2004 年）提出了一种利用基于图的方法和 PSO 找出最短路径的算法。他们使用基于图的方法获取静态环境中的无碰撞路径，然后使用 PSO 和突变算子得出最短路径。 Zhang 和 Gu（2008 年）使用了取决于多边形障碍物顶点数量的可变路径长度。二元 PSO 与类似基因突变的算子一起用于优化路径。Nasrollahy 和 Javadi（2009 年）提出了一种基于 PSO 的动态环境规划器，其中生成的种群包含无效路径，然后对其进行惩罚函数评估。最近，Gong 等人（2011 年）提出了一种使用多目标 PSO 和类似基因突变算子的模型。多目标是路径与障碍物的最短距离和危险性。突变算子用于修复无效路径。 蚁群优化（ACO）和模拟退火（SA）算法（Masehian 和 Sedighizadeh，2007 年）在路径规划中的应用比例较小。蚁群优化算法的灵感来源于蚂蚁的觅食行为，即寻找通往食物源的最短路径。Guan-zheng 等人（2006 年）提出了一种基于改进 Dijkstra 算法和 ACO 的最优路径规划方法。改进的 Dijkstra 算法包括标准 Dijkstra 算法和去除不必要路径节点算法，以获得次优路径。ACO 用于从次优路径中获得全局最优路径。Garcia 等人（2009 年）提出了简单的 ACO - 距离记忆（SACO-dm）算法，用于静态和移动障碍物之间的全局路径规划。在 SACOdm 算法中，最佳路径受机器人与目标节点之间的当前距离以及蚂蚁对已访问节点的记忆能力的影响。结果表明，与 SACO 相比，最佳路径的计算时间更短。 SA 是一种启发式随机搜索方法，类似于通过退火冷却熔融金属的过程。Martinez-Alfaro 和 Gomez-Garcia（1998 年）提出了一种在 C 空间设置的静态多边形障碍中采用 SA 实现无碰撞路径的方法。该方法采用二进制设置，当希望缩短计算时间时，可能会产生非最佳路径。Miao 和 Tian（2008 年）为动态环境开发了基于 SA 算法的方法。他们的方法使用静态和动态障碍物的顶点作为搜索空间。然后使用 SA 算法找到最优路径。 ON-LINE PATH PLANNING ALGORITHMS近来，由于自主移动机器人必须能够在动态环境中工作，在线路径规划受到了研究人员更多的关注（Masehian 和 Katebi, 2007）。在线环境下的路径规划应用包括行星探测、采矿业、侦察机器人等（Hachour，2008a）。传统的在线路径规划方法包括势场方法和碰撞锥方法。如今，进化方法与传统方法一起被越来越多地使用。 Classic approachesKhatib （1986 年）率先提出了人工势场 (APF) 方法，该方法在移动机器人领域非常流行。通过这种方法，C 空间中的点机器人在 APF 的影响下移动，在 APF 中，假定障碍物产生排斥力，目标产生吸引力。机器人根据这些力的结果移动。这种方法以其数学上的优雅和简单著称，因为只需很少的计算就能找到路径。然而，这种算法的缺点是，当吸引力和排斥力的大小相等时，机器人可能会停滞或被困住。克服这一问题的方法之一是辅以有影响力的算法来逃离陷阱（Latombe，1991 年），迄今为止，已经提出了许多势场方法的变体，如逃逸力算法（Vadakkepat 等人，2000 年，2001 年）、Lv 和 Feng（2006 年）使用的陷阱恢复模型、自适应虚拟目标算法（Luh 和 Liu，2007 年，2008 年）等。 路径规划问题也可以通过向量场直方图方法来解决（Borenstein 和 Koren，1991 年）。每一瞬间，都会生成一个极值直方图来表示机器人周围障碍物的极值密度。机器人的转向方向是根据最小的极点密度和与目标的接近程度来选择的。在给定的环境中，极坐标直方图必须在每个瞬间有规律地重新生成，因此该方法适用于障碍物稀疏的环境。 另一种常用的在线方法基于碰撞锥概念（Chakravarthy 和 Ghose，1998 年；Qu 等人，2004 年）。如果机器人与特定障碍物的相对速度落在碰撞锥的外部，就可以避免机器人的碰撞。Fiorini 和 Shiller（1998 年）提出了与碰撞锥方法相似的速度障碍物方法。该方法包括选择规避动作，以避开速度空间中的静态和移动障碍物。他们使用了基本的启发式策略来确定目标的优先次序，如避免碰撞、实现目标或完成具有首选拓扑结构的轨迹。 另一种在线避障方法是动态窗口法（Fox 等人，1997 年；Brock 和 Khatib，1999 年）。动态窗口包含可行的线速度和角速度，同时考虑到机器人的加速能力。然后，根据车辆动态优化下一瞬间的速度，以避开障碍物。 Evolutionary approaches尽管传统方法被认为是有效的，但计算时间对于任何在线路径规划算法的成功都至关重要。但是，由于环境信息不完整，传统方法很难在快速计算时间内获得最佳结果。此外，由于路径规划问题的复杂性达到了 NP-hard，传统方法通常与 GA、PSO 等进化方法相结合，以克服其缺点。 Vadakkepat 等人（2000 年，2001 年）提出了进化 APF（EAPF）算法，利用 GA 得出最优势场函数。当机器人被困住时，引入了一种名为 escape-force 的单独算法来从陷阱中恢复。Luh 和 Liu（2008 年）提出的势场免疫网络使用速度障碍法来识别最可能发生碰撞的障碍物。势场方法与受生物启发的免疫网络相结合，用于避开最紧迫的障碍物。免疫网络的整体响应是通过 GA 计算得出的。提出了自适应虚拟目标算法来引导机器人离开陷阱。假定机器人在偏离目标 90° 以上的情况下会被困住。 Min 等人（2005 年）使用碰撞锥方法和 PSO 建立了一个数学模型，用于在线路径规划。为了减轻计算负担，他们在运动模型中忽略了障碍物速度的瞬时变化。因此，他们的算法适用于障碍物速度较慢的稀疏环境。此外，PSO 与二进制编码遗传算子相结合用作优化工具，并不考虑动态约束。然而，最近的研究表明，真实编码的进化算法比二进制编码的进化算法执行得更好。 Hu 等人（2007 年）基于 PSO 和流函数（或势流）提出了一种在静态或动态环境中引导移动机器人的方法。流函数源于流体力学，用于引导自主机器人避开障碍物。不过，他们的模型也没有考虑障碍物速度的瞬时变化。Park 和 Kim（2008 年）提出了一种基于势场方法的 PSO 算法。势场通过粒子的适应度值进行数学建模。PSO 粒子被设计为以牛顿动力学运动。Lu 和 Gong（2008 年）针对未知环境提出了一种使用 PSO 技术的在线路径规划算法。他们的算法完全基于环境的距离信息，没有任何以接近障碍物的速度为特征的数学模型。最近，Hong 等人（2011 年）提出了一种使用经典 APF 的模型，该模型考虑了速度势场的动态模型，由一种名为量子 PSO 的 PSO 变体获得。受微观粒子运动性质（量子力学）的启发，量子 PSO 通过波函数更新粒子的状态，而不是位置和速度。 Mei 等人（2006 年）提出了一种针对动态环境的混合算法，它结合了 APF 和 ACO。ACO 用于规划全局路径，然后 APF 用于引导机器人选择局部路径。Lv 和 Feng（2006 年）提出了数值势场来模拟环境，并应用 ACO 来搜索最佳路径。他们还讨论了陷阱恢复解决方案。ACO 的主要问题是难以获得快速收敛解。Lee 等人（2008 年）提出了使用势场方法的改进型 ACO，通过调整 ACO 的控制参数来获得快速收敛解。改进后的 ACO 利用改变的信息素（蚂蚁分泌的一种物质）来更新位置向量。 Zhang 等人（2004 年）提出了一种与 SA 相结合的 APF 方法，该方法考虑了足球机器人在附近有障碍物的情况下无法到达目标（GNRON）和局部最小值的问题。考虑到 GNRON 问题中起点和目标点的距离信息，推导出了新的势函数。Miao（2010）提出了一种基于多算子的路径规划 SA 方法。除了 SA 之外，还引入了切换、删除、突变和修复算子。此外，还针对移动障碍物对 SA 的参数进行了微调。 SCOPE AND CHALLENGES在路径规划领域，进化方法已被证明比纯粹的经典方法产生更好的结果（Garcia MAP 等人，2009 年）。由于更好的路径质量会影响移动机器人的高效运行，因此已经提出了几种算法来克服 NP 难路径规划问题的复杂性。文献综述表明，通过解决以下一些问题，开发更高效的离线路径规划算法，以获得更高质量的路径，仍有很大的发展空间： 在初始生成群体时，应只考虑不与障碍物发生干扰的有效路径，而无需使用惩罚函数评估。 使用实数字符串的优化技术计算成本较低，因为在评估目标函数之前，无需用二进制代码表示备选路径的细节。 考虑到环境的复杂性（顶点数量），可在生成种群时使用包含不同数量段落的路径。 可以使用简单的解码器和拟合函数来减少算法的计算时间。 与离线算法相比，开发计算效率高的在线算法更具挑战性。在环境信息不完整的情况下工作的困难之一是无法预先规划路径，因此很难实现全局最优解。不过，通过应对以下挑战，可以获得更高质量的路径： 可以建立更精确的数学模型，这些模型可以显示机器人的瞬时速度以及接近障碍物的速度，甚至可以处理杂乱的移动障碍物。 在处理最紧迫的障碍物时，考虑其他限制性障碍物的影响可以取得更好的整体效果。因此，数学模型应同时考虑限制性障碍物的影响，这些障碍物可能比避开迫在眉睫的威胁更容易导致进一步的偏离。 避开存在路径的机器人陷阱是避障中的另一个重要问题。可以省去恢复陷阱的麻烦。 如果机器人的下一个瞬间是在移动机器人的运动学和动力学约束的范围内规划的，那么任何在线路径规划算法都会取得真正的成功。因此，数学模型应包含在艰难的时间变化环境中动态约束的上限。 此外，多重优化目标、多机器人协调、传感、预测、运动控制等方面的不确定性也给移动机器人技术带来了许多其他挑战。 CONCLUSION目前，路径规划的发展逐渐受到电路板设计、网络路由、计算机动画、药物设计、计算生物学等新应用的启发。研究界提出了许多解决路径规划问题的方法。本文反映了移动机器人路径规划（包括在线规划）方面的研究进展。尽管已经开发出许多高效算法，但路径规划问题的多样性仍在不断增加。直到上世纪 90 年代，确定无碰撞路径仍是主要目标。目前，虽然无碰撞路径是一个必要条件，但还需要解决其他重要问题，如动态环境建模、多重最优函数、动态约束等。这些制约因素使得路径规划问题更具挑战性，因此需要更稳健、更高效的算法。","link":"/2024/02/21/Optimal-path-planning-of-mobile-robots-A-review/"},{"title":"An Algorithm for Planning Collision-Free Pahts Among Polyhedral Obstacles","text":"An Algorithm for Planning Collision-Free Paths Among Polyhedral Obstacles Abstract本文介绍了一种避免碰撞的算法，用于规划多面体物体在已知多面体物体间移动的安全路径。该算法对障碍物进行转换，使其代表移动物体上任意参考点的禁区位置。该参考点的轨迹若能避开所有禁区，则不会发生碰撞。轨迹是通过搜索一个网络来找到的，该网络可以为变换后的障碍物中的每个顶点指出可以安全到达的其他顶点。 Introduction在物理对象的计算机模型上进行操作时，避免碰撞是基于模型的操纵系统的核心问题。本文介绍了一种在类似描述的障碍物中为多面体物体规划安全（即无碰撞）路径的算法。1 算法需要 (1) 找到可能会靠近障碍物的安全路径，以及 (2) 保证这些路径相对于预先指定的距离度量较短。 最简单的避免碰撞算法属于生成和测试范例。首先假设一条从起点到目标的简单路径，通常是一条直线，然后测试路径是否存在潜在碰撞。如果检测到碰撞，就会提出一条新路径，可能会使用检测到的碰撞信息来帮助假设新路径。如此反复，直到检测到路径上没有碰撞为止。这种算法的三个步骤大致如下 (1) 计算移动物体沿建议路径扫过的体积、 (2) 确定扫过的体积与障碍物之间的重叠，以及 (3) 提出新路径。 第二步是确定扫过的体积与障碍物之间的重叠，也称为交叉或干涉计算 [2，3]。目前的计算机建模技术采用了大量的简单曲面，即使是最常见的物体也能精确建模。要确定两个这样的模型是否重叠是相当困难的。我们将这种一般方法称为 “扫掠体积法”，它有一个更根本的缺点。问题在于第二步和第三步之间的关系。每条建议路径只提供了潜在碰撞的局部信息，例如相关体积交点的形状，或导致碰撞的障碍物的特征。这些信息会建议改变局部路径，但不足以确定何时采用完全不同的路径会更好。这种全局观念的缺乏会导致在可能的路径空间中进行昂贵的搜索，而路径的最坏长度上限又非常大。 扫掠体积法的一个根本替代方法是明确计算移动物体相对于障碍物的位置约束。所需的轨迹是满足所有位置约束条件的最短路径。如果将物体建模为凸多面体集合，则位置约束条件可以用移动物体顶点相对于障碍物表面平面的位置来表示。这样，轨迹问题就可以像 Ignat’yev [5] 那样被视为一个优化问题。这种表述方式的难点在于，这些位置约束条件虽然是线性的，但并非同时适用。移动物体上的每个点不一定要在所有障碍物的平面之外；每个点至少在每个障碍物的一个平面之外就足够了。这一特性使得传统的线性优化方法不再适用。 本文介绍的算法与优化方法密切相关。计算移动物体上任意参考点位置的约束条件。二维或三维的多面体障碍物会产生多面体禁区集，即与会发生碰撞的参考点位置相对应的区域。这种转换将为多面体寻找安全路径的问题简化为为点寻找安全路径的问题。要完成最后一项任务，就必须找到一条路径，穿过连接禁区顶点的图形。 将物体的位置约束条件作为参考点的约束条件进行计算的技术非常强大，已被独立应用于不同的问题。Udupa [9] 将其用于规划计算机控制机械手的安全路径，Lozano-Perez [6] 将其用于识别物体上可行的抓取点，Adamowicz 和 Albano [1] 将其用于二维模板布局。 Udupa 利用对障碍物的简单 “增长 “变换来计算操纵器三自由度子集的三维参考点的禁区近似值。该系统对参考点的合法位置（the ]ree space）进行可变分辨率描述。子集操纵器的安全路径是通过递归方式将中间目标引入直线路径，直到完整路径位于自由空间中。这种方法有两个缺点： (1) 由于完整的机械手有三个以上的自由度，三维禁区无法模拟机械手的所有约束条件。当轨迹失效时，Udupa 系统会使用与操纵器相关的启发式方法进行修正。启发式方法的使用往往会限制算法在杂乱空间中的性能。 (2)递归路径搜索器仅使用局部信息来确定安全路径，因此存在一些与体积扫频法相同的缺点。 本文提出的算法使用更精确的增长操作来计算二维和三维的禁区。它引入了一种图搜索技术来寻找路径，当只涉及平移时，这种技术能产生最佳的二维路径。然后，该技术被推广到处理三维障碍物，并扩展到统一处理三个以上的自由度。由此产生的算法不再保证最优路径。这种算法已被用于规划一个七自由度机械手的安全轨迹。这些轨迹已成功执行。 Udupa [9]详细介绍了以前在避免碰撞方面所做的工作，特别是与计算机控制的机械手有关的工作。 障碍物模型的性质会影响任何避免碰撞算法的细节。为具体起见，本文的详细讨论和示例假定所有物体都被建模为一组可能重叠的凸多面体。任何物体都可以按照这种方式进行建模，达到所需的任何精确度。在凸多面体集合中为单个凸多面体寻找无碰撞路径的方法可以简单地扩展为在复杂障碍物中为复杂运动物体规划安全路径。扩展方法包括找到移动物体的每个凸分量相对于所有障碍物的每个分量的约束条件。综合移动物体的约束条件是其各部分约束条件的总和。 避免碰撞算法是为三维空间定义的。不过，二维的表述更容易理解；为了清晰起见，接下来的章节首先介绍二维情况下的完整算法，然后考虑扩展到三维。第 2 节介绍了多边形物体在平面内多边形障碍物间平移的简单算法。第 3 节考虑了允许移动物体旋转和平移的效果。第 4 节讨论具有更多自由度的更复杂移动物体。第 5 节讨论了向三维空间的推广。算法的两个步骤直接受到建模方法选择的影响，对这两个步骤的讨论将在附录中进行。这些步骤将在本文正文中进行功能描述。 2. Collision Avoidance on the Plane 考虑图 1 所示的问题：将一个点物体 A 从位置 S 移动到位置 G，同时避开障碍物（如阴影所示）；图中还显示了从 S 到 G 的最短无碰撞路径。这条路径的重要特性是，它由直线组成，通过可能为空的障碍物顶点序列连接起点和终点。在任意多边形物体的平面运动中，连接任意两个可达点的最短无碰撞路径总是具有这一特性。 定义了无向图 VG（N，L）： 节点集 N 为 V u (S, G}，其中 V 是所有障碍物顶点的集合，链接集 L 是所有链接（n~, nj）的集合，使得连接 N 第 i 个元素和第 j 个元素的直线不会与任何障碍物重叠。图 VG(N, L) 称为 N 的可见性图 (VGRAPH)，因为图中相连的顶点可以相互看到。VGRAPH 如图 1 所示。平面上从 S 到 G 的最短无碰撞路径是 VGRAPH 中从与 S 对应的节点到与 G 对应的节点的最短路径，此时链路上使用的是欧几里得度量。我们将这种通过寻找可见度图中的最短路径来为一个点寻找无碰撞路径的方法称为 VGRAPH 算法。这种方法曾用于早期的机器人车辆 SHAKEY [8]的导航，Ignat’yev [5]中也有详细描述。 VGRAPH 算法之所以简单，是因为移动物体 A 是一个点。对于相对于障碍物较小的移动物体来说，这是一个很好的近似值，但在其他情况下就会出现问题，lgnat’yev [5, 第 241 页] 是这样说的： 机器人从 y0 点（本例中为 S 点）开始沿 xla（顶点）方向移动。在这里，它必须考虑自己的尺寸，以免撞上障碍物和墙壁。 本文展示了如何将更一般形式的避免碰撞问题简化为 VGRAPH 问题。换句话说，它涉及机器人如何 “必须考虑自己的尺寸”。 图 1 中问题的一个简单概括是将移动物体 A 变为半径为 rA 不可忽略的圆。VGRAPH 算法可以适应这种情况，方法是将顶点移开障碍物，使它们至少与所有边相距 ra（图 2）。移动 A，使其中心点穿过新移出的顶点，仍然可以得到一条距离最小、无碰撞的路径。不过请注意，找到的路径与图 1 中的不同。SHAKEY [8] 中也使用了这种顶点位移技术。 VGRAPH 算法要求移动物体是一个点；然后，障碍物代表该点位置的禁区。如果移动物体不是点，则必须计算一组新的障碍物，它们是移动物体上某个参考点的禁区。这些新的障碍物必须描述会导致与任何原始障碍物发生碰撞的参考点的位置。当参考点为 A 的中心时，图 2 中被移动的顶点实际上就是这些新障碍物顶点的近似值。 由原始障碍物 O 和移动物体 A 计算出一个新障碍物 O’ 的操作称为 “A 生长 0”。由 A 生成一组障碍物的结果将用 GOS(A) 表示，即 4 的 “生成障碍物集”。请注意，生长操作与推导机床切割零件的路径密切相关。 请看图 3(a)。图 1 和图 2 中的障碍物相同，但移动物体A现在是一个矩形实体。图 3(b) 显示的是A长大后的障碍物。该图还显示了A的参考点从 S 到 G 的最短无碰撞路径。请注意，障碍物空间的边界也被视为障碍物并进行了生长，从而避免了在空间外移动的路径。 增长操作的定义是计算移动物体的参考点位置中会与给定障碍物发生碰撞的位置。移动物体的位置被解释为其 (x, y) 位置，即生长出来的障碍物是 (x, y) 空间中的多边形。这是一个任意但自然的选择。不同类型的移动物体需要不同的选择。图 4(a) 显示了 (x, y) 坐标系中的一种情况。移动物体A可以围绕一个固定点旋转并改变长度。图 4(b) 显示了 $(r, \\alpha)$ 空间中由于图 4(a) 中障碍物的存在而禁止A尖端进入的区域；图 4(c) 显示了以 (x, y) 坐标系表示该区域的另一种方法。选择哪种表示方法取决于 (1) 计算禁区（即增加障碍物）的难易程度，与 (2) 从生长出来的障碍物建立 VGRAPH 的难易程度。 将多面体作为形状描述的基本单位会影响我们对障碍物表示方法的选择。多面体（平面上的多边形）的边界是坐标变量的线性方程。这一特性使它们在计算上更具吸引力。在本节中，我们将物体表示为平面直角坐标系中的多边形。自然的选择是在同一空间中表示生长的障碍物，从而使生长操作成为从多面体到多面体的映射。请注意，在图 4（b）中，物体 O 被解释为（x，y）空间中的多边形，而由此产生的$（r，\\alpha）$ 空间中的生长障碍物 O’ 并不是该空间中的多边形。 选择障碍物表示法的另一个因素是 VGRAPH 中两个节点之间路径的形状。VGRAPH 中连接两个节点的链接意味着相应位置之间的路径不会与任何障碍物重叠。到目前为止，路径都是以直角坐标空间中的直线来表示的；由于生长出来的障碍物都在这个坐标空间中，因此使用直线简化了重叠检测。当然，路径可以是更复杂的曲线，最好用不同的坐标系来表示。例如，图 4 中的物体可能在 $ (r, \\alpha) $ 坐标系中以直线运动。在这种情况下，使用生长障碍物的极坐标形式来检测重叠可能会更有效。 生长障碍物的表示方法取决于应用领域的几何细节。选择时应尽量简化整体计算。为简单起见，下一节将继续假设生长的障碍物是 (x, y) 空间中的多边形。 3. The Effect of Rotation值得注意的是，如图 2 和图 3 所示，生长操作对 A 的方向非常敏感。与方向有关的原因是，生长的障碍物被定义为参考点的禁区。平面上一个点的位置只能编码两个自由度，而区分 A 的两个不同方向位置的合法性至少需要三个自由度。图 5 显示，A 的方向与图 3 中的不同，会产生不同的生长障碍和不同的路径。为了明确方向，我们将用移动物体 A（其方向参数为角度 $\\alpha$）表示所有障碍物的生长结果，即 $GOS(A_{\\alpha})$ 。这些生长出来的障碍物的顶点集合称为 $V_{\\alpha}$。 概括地说，A 的参考点位于生长障碍物集所有元素之外的 A 在方位 ,$\\alpha$ 的任何位置都不会发生碰撞。GOS(A,)中每个障碍物的边都是在保持 A 与障碍物接触的情况下，通过追踪 A 的参考点在每个原始物体周围的路径计算出来的。在两个物体发生碰撞之前，它们必须首先接触；因此，任何会导致碰撞的参考点位置都必须在障碍物内部，而在障碍物外部的任何位置都必须是安全的。显然，这个条件的前提是 A 的方向不会改变。 考虑将物体 A 从方位为 o~ 的位置 S 移到方位为 ft 的位置 G 的问题。简单地计算一条在 GOS(A,) 和 GOS(A~) 中没有碰撞的路径是找不到安全轨迹的，因为在改变方向从 a 到/3 的过程中，A 必须经过整个中间方向范围。寻找路径的一种方法是了解平面上哪些位置可以实现所需的旋转。然后，算法就可以规划出一条从起点到这些位置之一的路径，旋转到所需的方向，然后沿该方向移动到目标。 要使一个位置允许改变方向，旋转物体在其任何中间方向上都不能与任何障碍物重叠。图 6 显示了 A 从方位 a 到方位 fl 所经过的区域；这个区域可以用另一个多边形 A t,, 来近似表示。为简单起见，Ca 显示为矩形。这个新对象被称为包络线，可以用来生长一个新的障碍物集 GOS(A t~, m)，也如图 6 所示，它表示 A 的参考点在区间 [a,/3] 内任何一个方向上的禁止区域。我们将把它称为过渡障碍集。类比顶点集 V，，集合 Vt,, ~ 代表过渡障碍集中的障碍顶点集。一般来说，我们可以为顶点集的所有元素关联一个方向区间（可能是奇异的）以及一个位置。 要使一个位置允许改变方向，旋转物体在其任何中间方向上都不能与任何障碍物重叠。图 6 显示了 A 从方位 a 到方位 fl 所经过的区域；这个区域可以用另一个多边形 A t,, 来近似表示。为简单起见，Ca 显示为矩形。这个新对象被称为包络线，可以用来生长一个新的障碍物集 GOS(A t~, m)，也如图 6 所示，它表示 A 的参考点在区间 [a,/3] 内任何一个方向上的禁止区域。我们将把它称为过渡障碍集。类比顶点集 V，，集合 Vt,, ~ 代表过渡障碍集中的障碍顶点集。一般来说，我们可以为顶点集的所有元素关联一个方向区间（可能是奇异的）以及一个位置。 图 6 中的问题现在可以通过以下方法解决： (1) 在 S 处找到一条以方位 a 为起点的路径，该路径要避开 $GOS(A_{\\alpha})$ 中的障碍物，并以 $GOS(A_{[\\alpha, \\beta]})$ 中没有障碍物的点为终点、 (2) 旋转到方向 $\\beta$，并 (3) 找到一条通往 G 的路径，避开 $GOS(A_{\\alpha})$ 中的障碍物。 这可以说是一个 VGRAPH 问题，即在如下定义的可见度图中找到从 S 到 G 的最短路径： 使以下可见性条件在链路上成立： (1) 方向区间 [a, b] 和 [c, d] 必须不相交、 (2) $n_i$ 位于 $GOS(A_{[a, b]})$ 的所有障碍物之外、 (3) $n_j$ 位于 $GOS(A_{[c, d]})$ 的所有障碍之外、 (4) 从 $n_i$ 到 $n_j$ 的路径要么： (a) 不与 $GOS(A_{[a,b]})$ 中的任何障碍物重叠，或 (b) 不与 $GOS(A_{[c, d]})$ 中的任何障碍物重叠。 $VG_{\\alpha, \\beta}$ 中的求解路径是以 S 为起点、以 G 为终点的节点序列： $S, n_1, n_2, …, n_k, G$ 其中相邻节点通过 L, ~ 中的链接相连。每个 n e Vt, ~,1 的定义是：如果 n 位于 GOS(A E.bl) 的所有障碍物之外，则移动物体 A 的参考点可以位于区间 [a, b] 内任意方向的 nj 位置，而不会有碰撞危险。从 ni 到 nj+ 的链接意味着 A 的参考点必须进行相应的平移。此外，如果 nj 和 ni +1 分别属于不同的顶点集 Via, 1 和 Vtc, ~1，那么也可能需要改变方向。L,, ~ 的条件要求链路端点对应的方向区间必须不相交。这意味着存在某个方向 x，如果 a _&lt; b 和 c _&lt; d，那么 max(a, c) &lt; x &lt; min(b，d)，A 可以安全地位于链接的任一节点。沿着链接移动需要首先旋转到 x 方向，然后从第一个节点平移到第二个节点。由于平移的方向与链接的两个节点都兼容，因此链接的可见性条件只需检查是否与任一节点的障碍集中的障碍物重叠即可。或者，如果从 n 到 nj+l 的路径在 GOS(A t, ~l) 和 GOS(A t..d~) 的所有障碍物之外，那么旋转可以与沿链接的平移同时进行。 使用过渡集（如 GOS(A t-, ]）有两个重要缺点。VG&lt; ~ 中的最短解路径不再保证是原始问题的最优解，而在 VGRAPH 中找不到解路径并不一定意味着不存在安全轨迹。原因有两个方面。首先，也是最基本的原因是，在 VGRAPH 中找到的路径只会在可以进行完全旋转的位置改变运动物体的方向。如果最佳路径涉及穿越一条狭窄的通道，其中 A 的方向必须在 , 和/3之间的一个小范围内，那么这条路径就不可能是这一版本 VGRAPH 算法的求解路径。其次，即使避免了第一个问题，目前的算法也只考虑[~, /3]范围内的方向，因此无法计算移动物体只能在指定范围外的方向上移动的通道。后一个问题可以简单地通过扩大方向区间来解决，但代价是前一个问题变得更加严重。 4. More Degrees of Freedom只要移动物体的自由度大于障碍物坐标空间中的一个点，就可以使用过渡障碍物集。唯一的要求是可以计算出一个包络 At, ‘ 1 ，它是一个与 A 相同类型的对象，例如一个多边形，使得 A=, x &lt; z _&lt; y 内的任何一点也在 A tx, ~J] 内。然后，这个对象就可以用于生长操作，生成一个过渡障碍集。参数范围 Ix, y] 的性质没有其他限制；特别是，它不必是一个方向范围，x 和 y 也可以是矢量。在 GOS(A tx, yl) 中所有障碍之外的点表示 A 的配置参数 z~ 可以安全取值的位置，即 x~ &lt; z~ _&lt; yi。 图 7 重复了图 4 的示例，只是现在移动物体可以进行 x 和 y 方向的平移、旋转并改变长度。选择生长障碍物的坐标系还将决定配置参数使用哪个坐标变量。例如，如果生长出来的障碍物在 (x, y) 坐标系中表示为多边形，那么 (r, a) 就是配置参数，反之亦然。 配置参数还可用于处理移动物体，该物体的形状会因各组成部分相对位置的变化而改变。图 8 所示的物体由两个矩形组成，这两个矩形可以围绕一个共同点自由旋转。该物体相对于静止障碍物的形状可以用以下公式描述： (1) 部件的形状、 (2) 它们的相对位移、 (3) 图 8 所示的两个角度 0 和 O。 在本例中，运动过程中只有角度会发生变化；因此，该运动物体的障碍物集必须通过 0 和 p 的值进行参数化。 一般来说，对象不需要在全维配置空间中生长；相反，重复使用对低维、分区配置空间的操作，可以使生长操作在全配置空间的子空间中方便地进行。第 2 节和第 3 节所述的 VGRAPH 算法保持不变，只是将标量参数和区间替换为矢量参数和区间。 5. Collision Avoidance in Three Dimensions迄今为止，VGRAPH 算法一直是作为平面防撞算法来介绍的。本节将探讨三维障碍物对算法的影响。这种概括并不影响算法的陈述，但会影响障碍物生长和图形搜索的细节。这些主题将在附录中讨论。 泛化到三维空间有一个不幸的副作用。绕过多面体障碍物的最短路径一般不会只穿过多面体的顶点（图 9）。也就是说，VGRAPH 中的最短路径（其节点集仅包含生长出来的障碍物顶点）并不能保证是最短的无碰撞路径。一般来说，最短路径需要经过障碍物边上的点。我们的方法是沿着已生长障碍物的边缘引入额外的顶点，使任何边缘的长度都不超过预先规定的最大长度。这种方法通常能很好地逼近最优路径。 使用三维障碍物对算法的执行时间也有很大影响。三维生长操作比二维生长操作耗时更多。三维生长的障碍物通常比底层对象复杂得多（附录 1）。较大的顶点集也增加了搜索可见度图所需的时间。这些影响使得在实际应用中必须使用近似值。 少用细节生长操作可以大大节省成本。许多应用领域的特性是，移动物体只需在路径上的少数几个点靠近障碍物即可。这些关注点通常包括路径的起点和终点。在其他情况下，对路径的要求并不那么严格；事实上，当移动物体远离障碍物时，靠近障碍物往往是不可取的。VGRAPH 算法可以很容易地利用这一特性；无需对每个已知障碍物执行详细的生长操作，只需对靠近照料点的障碍物执行生长操作即可。而在远离观测点的地方，则可以安全地使用大幅度的近似值。由多个多面体构成的复杂物体可以用一个外围多面体来近似。移动物体也可以采用类似的近似方法，从而进一步简化过程。此外，还可以使用一种非常简单的生长运算（附录 1），这种运算虽然牺牲了精确度，但速度更快，得到的物体也更简单。 使用这种近似技术的关键在于如何有效地确定哪些物体靠近观测点。显然，如果一个观察点位于一个物体的内部或靠近由其产生的长大障碍物的一个侧面，那么该观察点就靠近该物体。这意味着，移动物体位于观察点时，要么在该物体的内部，要么靠近该物体的一侧。对运动物体和静止物体进行近似处理，会使照料点位于增大的障碍物内部。这一条件可作为谨慎生长的标准。当移动物体相对于障碍物较大时，将其近似为单个物体会导致过多障碍物的详细生长。移动物体越大，简单近似的效果可能就越差。特别是移动物体的某些部分，如果距离照应点相对较远，就会导致生长出来的障碍物包括照应点。解决方法是对移动物体进行分层分解；也就是说，如果最粗糙的描述测试失败，则使用稍好的近似值。这样就能更好地隔离潜在的碰撞源。而不涉及的运动物体的其他部分则无需仔细考虑。Udupa [9] 提出了类似的可变细节近似方案。 提高算法效率的另一种方法是在图搜索操作中使用启发式方法。附录 2 对 VGRAPH 的搜索进行了简要讨论。 6. Summary and Discussion本文展示了如何将 SHAKEY [8] 用于导航的简单可见度图算法扩展到更一般的避免碰撞问题。实现这一目标所需的机制包括增加障碍物和将移动物体缩小到一个点。这种方法有一个理想特性，即提供了两个子问题，即增加障碍物和搜索可见性图，这两个问题可以独立解决。附录中介绍了我们目前解决这些问题的方法。 VGRAPH 算法尚存在的最重要问题是将配置参数量化为区间。需要几乎连续改变方向和位置的路径需要较小的量化区间，从而产生许多过渡障碍集，因此计算成本很高。 本文所述的 VGRAPH 算法是在 IBM 370/168 型计算机上用 PL/1 实现的。它已被用于为一个七自由度计算机控制的机械手规划无碰撞轨迹[10]；这些轨迹已在实验室中成功执行。","link":"/2024/02/21/An-Algorithm-for-Planning-Collision-Free-Pahts-Among-Polyhedral-Obstacles/"},{"title":"Path Planning: A 2013 Survey","text":"Path Planning: A 2013 Survey Abstract近几十年来，自动化和机器人领域取得了令人瞩目的进展。具有 “感知和避让 “能力的谷歌无人驾驶汽车或智能无人驾驶飞行器（UAV）等项目，都是以高度自主为目标的有趣研究工作的范例。在这种情况下，我们强调改进路径规划算法是不可避免的要求。事实上，路径规划是系统自动化过程中的重要任务之一，系统在环境中移动时要避开障碍物并遵守各种约束条件。在本文中，我们介绍了自动化、机器人和视频游戏领域中路径规划的最新进展。此外，我们还重点介绍了能够满足实时约束和动态重新规划的广泛算法。 I. Introduction在过去的二十年里，机器人技术和视频游戏的不断进步造就了非凡的智能系统。在这些领域取得进步的关键要求无疑是路径规划。事实上，如何在实时条件下生成一条从给定初始点到最终目的地的高效路径，仍然是最大的挑战之一。 一个完整的、确定的、能够实时生成可接受路径的算法程序，将允许实现高度的自主性。例如，当汽车自动驾驶你去上班时，你就可以阅读报纸了。 本文的其余部分安排如下。第 2 节介绍了路径规划问题以及过去几十年来研究的各种算法的最新进展。第 3 节介绍不同的环境建模方法。第 4 节重点介绍与实时环境相适应的解决方案，以实现高度自主。最后，第 5 节总结了本文介绍的最新技术，并阐述了我们未来研究的前景。 II. Path Planning特别是在上世纪 60 年代，关于路径规划的研究成果层出不穷。其中一些研究解决了不同领域的难题，如机器人从一点移动到另一点的轨迹计算、人形机器人学中结合运动学和动力学约束条件的行走运动和操纵计算、生物信息学中的分子运动研究等。 如图 1 所示，我们可以将==最高级别的路径规划问题==分为 3 类： 整体工程学问题 在机器人学中，如果一个平台的所有自由度都是可控的，那么这个平台就被称为全局问题。由于所有运动都是可能的，因此这种能力可以轻松控制机器人，从而简化了路径规划问题。例如，如果机器人在平面上移动，两个平移和一个旋转就是三个自由度。从给定的位置出发，一个整体平台可以向前、向侧和自转。运动学约束规定了系统配置与其速度之间的关系。因此，这些约束条件在数学上只能用位置参数的函数来表示。事实上，整体动力学约束并不涉及运动物体的速度。 非整体问题 非整体性一词来自机械领域，指的是无法通过完全积分来消除状态变量时间导数的微分约束。许多简单的平台都不符合整体力学。例如汽车，我们在执行某些轨迹（如停车操作）时不得不进行机动操作。对于非整体性车辆的运动规划，一种常用的局部规划策略是杜宾斯最优路径。 动力学问题 运动学一词最早出现在 [1] 中，用于指定两种类型的约束条件： 运动学约束和动力学约束。避开障碍物和速度边界分别是动力学问题中运动约束和动态约束的例子。 ==路径规划问题分类的第二个层次是区分用于执行路径规划的两种策略。==事实上，对于某些算法，如 Dijkstra 和 A star（A*）[2]，在搜索最优或可行路径之前，第一步必须是建立环境模型，而对于其他一些算法，如潜在场[3]和 RRTs（快速探索随机树）[4]，则不需要建立环境模型。 在第三层，我们将高效的在线算法与只能离线使用的第二类算法区分开来。一般来说，==在线算法是那些没有环境建模步骤的算法。事实上，如果我们能在预处理步骤中建立环境模型，第二类算法中的某些算法就有可能成为在线优化的候选算法。== ==在第四层，我们将路径规划分为两类：确定性和概率性。==在确定性方法中，我们引用了数学编程法、Dijkstra 算法和 A* 算法，这些算法应用于网格和可见度图。这些确定性方法允许在初始条件相同的情况下，每次执行都获得相同的结果。鉴于上述算法的复杂性，当这些方法用于实时环境时，在大多数情况下并不奏效。因此，在[5]和[6]等几项研究中，作者考虑了后退地平线，以减少计算时间。此外，其他研究工作只考虑了可行/最优路径的搜索，而环境建模则是在预处理步骤中实现的。但克服实时环境问题的最常用解决方案是概率方法，如粒子群优化法[7]、蚁群法[8]、概率道路映射法[9]、随机探索随机树[4]和多智能体路径规划[10]。 III. Environment modeling正如前文所述，要执行某些类型的路径规划算法，环境建模是不可避免的步骤。在本节中，我们将介绍最先进的环境建模方法。这些方法主要分为两类： 第一类是单元格分解法，可以以规则和不规则网格或导航网格等不同方式进行分解。单元格可以代表自由空间的拓扑结构。第二类方法使用可见度图[11]或图表[12]预先计算分布在建模环境中的点之间的路径。下文将详细介绍上述方法： 常规网格 它们在环境建模中使用最多，尤其是在机器人和视频游戏中。事实上，规则网格有几个优点，如易于实现和更新简单。因为无论存在多少障碍物，规则网格的节点和边的数量总是相同的。图 2-a、b 和 c 分别描述了正方形网格、三角形网格和六角形网格。此外，如图 2-e 所示，移动单元格有时也可用于逃离某些可能被困在障碍物之间的情况，见图 2d。尽管规则网格仍然是最常用的环境建模技术，但它有两个主要缺点，一是障碍物建模的精确度可能较低，二是在提高分辨率时内存开销较大。 不规则网格 1974 年，Finkel 和 Bentley 在文献 [13] 中介绍了一种名为 Quadtree 的网格实现新技术。这种网格是不规则的，因为单元格的尺寸并不相同。H. Samet 在文献[14]中大力推动了对四叉树的研究。四叉树在图像处理、GIS（地理信息系统）或二维碰撞检测等多个领域得到了广泛应用。如图 3-d 所示，四叉树的主要思想是将地图细分为 4 个方格，并对包含障碍物的每个方格重复这一过程。因此，对于不规则网格，我们必须获得一个节点代表大片无障碍区域的路线图，反之，我们将获得靠近障碍物的更薄的单元格。与规则网格相比，这种方法的第一个优点是减少了内存消耗。此外，这种方法还能加速路径规划算法对图形的探索。四叉树的主要缺点是在某些情况下可能会降低路径质量。另一个缺点与高密度的障碍物有关，在这种情况下，使用四叉树就失去了意义。将四叉树扩展到三维的八叉树在图像处理中也很常见，参见 [15] 和 [16]。 可见度图： 如图 3-a 所示，可见度图法的原理是通过将障碍物顶点之间以及与初始节点和最终节点之间建立联系来模拟环境的所有拓扑结构。因此，在探索可见度图时，我们可以获得尽可能短的路径。事实上，两个节点之间的最短路径要么是直线，要么与障碍物相切。因此，当在二维空间中使用 Dijkstra 或 A* 算法时，可见度图能提供最优解，这也使其成为路径规划中使用最广泛的环境建模方法之一。 能见度图技术最早由 Hart 和 Nilson [2] 于 1969 年提出，Lozano-Prez 和 Wesley [17] 于 1979 年将其应用于 Shakey 机器人。一些研究成果降低了可见度图算法的复杂性。事实上，第一个算法的运行时间为 O(n3)。此后，为了降低可见性图的复杂度，Lee [18] 和 M. Sharir 和 A. Schorr [19] 分别提出了 O(n2 log(n)) 时间的算法。其他著作提出了更快的算法，如 [20]、[21] 和 [22]。尽管为改进可见度图做出了种种努力，但它仍然只能在二维空间建模环境中以离线分辨率实现。事实上，正如 Canny [23] 所证明的，三维空间的路径规划问题是 NP 难的。 维诺图 有关路线图的首批重要著作都是基于 Vorono ̈ı 图。有关 Vorono ̈ı 图的综合书目见 [24]。沃罗诺̈ı图的首次非正式使用是在 1644 年由笛卡尔提出的，1850 年迪里希特也对二维和三维情况进行了研究。数学家 Georgy Fedosievych Vorono ̈ı将其推广到多个维度，这也是该方法名称的由来。文献中包含了 Vorono ̈ı 图的几种实际应用，如旨在优化碰撞检测的文献 [25]。在二维多边形环境中，Vorono ̈ı 图给出了与多边形障碍物距离相等的线条。图 3-b 演示了这一过程。从理论上讲，障碍物之间的连线允许安全导航。当最优性不是关键要求时，为了减少碰撞几率，有时更倾向于使用 Vorono ̈ı 图。需要注意的是，对于导航网格、可见度图和 Vorono ̈ı 图来说，复杂度显然取决于障碍物的数量和形式，一般也取决于所研究空间的限制条件。 IV. Search The Optimal/Feasible Path一些应用和实时系统（如自主机器人和视频游戏）对路径规划的性能提出了越来越高的要求。此外，路径规划仍面临许多挑战，如处理高度自主的能力。在路径规划领域，E. W. Dijkstra [26] 于 1959 年提出的 “Dijkstra 路径规划 “揭示了如何在图上找到两个节点之间长度最小的路径。如今，”Dijkstra 算法 “仍然是最著名的图遍历算法之一。 在本节中，我们将简要介绍路径规划中使用的不同类型的算法。然后，我们将详细介绍三种算法：A* 及其变体、RRT 及其变体，以及潜在场算法。 在 Dijkstra 算法问世 10 年后，Hart 和 Nilson 于 1969 年发表了一个伟大的贡献。这就是著名的 A* 算法，在当时被广泛应用，至今仍是最常用的算法之一。 基本 A* 算法的主要缺点是执行时间长。相反，1986 年提出的势场算法 [3] 被认为是最快的路径规划方法之一。 上世纪 80 年代，已发布的路径规划算法的种类和数量大幅增加。这是因为机器人自动化和视频游戏领域的新挑战提出了并行需求。在过去的二十年中，大部分研究工作的共同目标都是尽量缩短执行时间。尤其是在 1987 年 Canny 发表了关于路径规划复杂性问题的文章[23]之后。 文献中提出了几种元启发式算法，如蚁群算法 [8]、模拟退火算法（见 [27] 和 [28]）、遗传算法（见 [29]、[30] 和 [31]）。这些算法的主要优点是求解效率高。元启发式算法的主要缺点是难以复制相同的解，因为它们是随机的。此外，在许多情况下，应用于路径规划的元启发式算法无法满足实时约束条件。 1998 年，史蒂文-拉瓦勒（Steven Lavalle）发表了有史以来最有效的元启发式和最快的路径规划方法之一，名为 “RRTs”： 快速探索随机树”。RRTs 方法在概率上是完全的，因为它能保证找到可行的解决方案，但不一定是最优的。 在实时环境的某些领域，RRTs 算法等元启发式算法被认为是无与伦比的。的确，它们在性能和可接受的解决方案质量之间做出了很好的权衡。但对于某些工业领域（如直升机和无人机）来说，它们仍然不切实际，因为这些领域的解决方案即使不是确定性的，也至少在时间和内存方面是有限制的，这样才能获得认证。 在本文的其余部分，我们将分别详细介绍 A*、RRT 和势场及其变体，因为它们是最常用的三种路径规划方法。 A. A star and its variantsA* ，发音为 “A star”，是最著名的寻路算法。它由彼得-哈特（Peter E. Hart）、尼尔斯-尼尔森（Nils Nilsson）和伯特伦-拉斐尔（Bertram Raphael）于 1968 年提出[2]。作者对著名的 “Dijkstra 算法 “进行了扩展。A* 算法的主要原理是通过使用通往目标节点的启发式方法来减少探索图节点的数量。因此，A* 算法的运行速度通常比 Dijkstra 算法快得多，而且在最坏的情况下它会退化。如图 5 所示，当使用可见度图时，A* 算法可以达到最佳效果，而当使用网格时，它可以提供一个可接受的解决方案，见图 6。对于某些领域，如航空工业，确定性和完整性可能是某些算法不可或缺的两个特性。A* 算法在使用可见性图或网格时，都能独立验证这两个特性。 鉴于这种算法的重要性，一些研究人员试图改进原始版本，尤其是在过去的二十年里。下面，我们将介绍在文献综述中最为突出的一些 A* 变体。如图 4 所示，我们可以将 A* 变体分为四类。 1) Dynamic variants: D* (1994): 之所以选择 D* 作为算法的名称，是因为该算法的基本结构与 A* 算法相同，而且具有动态的特点。事实上，作者[32]提出的想法是，当所研究的地图发生变化时，例如出现新的障碍物时，迅速做出反应。D* 算法的主要缺点是所需内存成本较高。此外，D* 算法在理解和实现上也非常复杂。 聚焦 D* （1995 年）： 这是对 D* 算法的改进，事实上，它保持了相同的算法，但降低了计算成本。正如 D* 算法的作者 Antony Stentz [33] 所说，Focussed D* 算法的运行时间缩短了 2 到 3 倍。 LPA* (2002 年)： LPA* （终身规划 A* ）是 A* 的增量版本。在第一次运行时，它与 A* 完全相同。但所有后续搜索都要快得多，因为它重复使用了之前的搜索，以减少需要检查的节点数量。[34] 中的实验结果证明了 LPA* 的优势。LPA* 与 D* 的不同之处在于，它总是能找到一条从初始起点到初始目标的路径。因此，当起点坐标可能发生变化时，就不能使用这种方法。 D* Lite（2002 年）：如 [35] 所述，它采用与 D* 相同的导航策略，但在算法上有所不同。作者应用自己的算法 LPA* 开发了 D* Lite 算法，该算法能够动态规划从当前节点到目标的最短路径。与 D* 相比，D*-Lite 算法更易于理解和实现。此外，[35] 中还证明了 D* Lite 的运行速度至少与 D* 一样快。 2) 任意角度运动请注意，亚历克斯-纳什（Alex Nash）2012 年发表的博士论文[36]对任意角度路径规划方法进行了出色的概述。 Field D* （2007 年）： D*-Lite 的一种变体，它并不将移动限制在网格内；最佳路径可以让装置沿任何角度移动，而不仅仅是网格点之间的 45（或 90）度角。美国国家航空航天局曾用这种方法为火星探测器寻路。 Theta* （2007 年）： Theta* 是 A* 的一种变体，与 A* 和 Field D* 相比，它能提供更短的路径。不过，θ* 并不具备快速重新规划的能力，因为它是基于 A* 的，而 Field D* 则是基于 D*-Lite 的。 递增 Phi* （2009 年）： 结合了 Theta* 和 D* Lite 的优点。事实上，我们可以将该算法视为 Theta* 的增量版本，见 [38]。 3) Moving Target Points移动目标搜索是许多机器人应用中的一个重要问题。近十年来，针对这一问题发表了许多作品，如广义自适应 A* (GAA* 2008)、移动目标 D* Lite (MTD* Lite 2010)、广义边缘检索 A* (GRFA* 2010) 和树自适应 A* (Tree-AA* 2011)，分别见 [39]、[40]、[41] 和 [42]。 4) Anytime path planning在一些案例研究中，做出决定的时间非常有限。例如，要让直升机从 “禁飞区 “起飞，我们只需要一个极快的解决方案来避免事故，而不需要专门生成一条新的路径来飞行到最终目标。为了解决类似的问题，我们探索了一种新的 A* 变体，我们称之为 “次优解的随时路径规划”，也称为 “分层路径规划”。 分层寻路 A（HPA 2004）：为了满足实时约束条件，HPA* [43]的作者灵机一动，将一般问题分解为分层子问题。他们证明，这种方法能有效降低网格地图寻路问题的复杂性。 随时 D*（2005 年）：如 [44] 所述，这种方法结合了随时方法和增量方法的优点，为复杂的动态搜索问题提供了高效的解决方案。 Partial Refinement A* (PRA* 2005)：该算法在实时战略（RTS）游戏领域的有效性已在 [45] 中得到证实。 分层注释 A（HAA 2008）：是分层路径规划类中最先进的算法之一。它具有处理异构多地形环境的特性，见 [46]。 B. RRTs and its variantsRRTs 启发式由 Steven M. LaValle [4] 于 1998 年提出。但它很快成为最广泛使用的方法之一，事实上，与现有方法相比，它被证明是非常创新和有效的。RRTs 方法不需要上游环境建模，与需要环境建模的 A* 及其变体相比，在计算时间上具有相当大的优势。如图 7 所示，在带有障碍物 Xobs 的给定空间 X 中，RRTs 的策略是通过对空间进行随机取样来扩展一棵树，并从起点 Xinit 开始生长，直到这棵树足够接近已知目标 Xgoal。在每次迭代中，树都会增加一个新的顶点。被选择扩展的顶点是与生成的随机顶点最近的顶点，见图 7。一旦选择了最近的顶点，我们就会沿着随机顶点的方向以某种预定义的度量推进。图 7 给出了一个 RRTs 算法的应用实例。 因此，基于 RRTs 的算法将环境构建阶段与寻路阶段结合起来。RRTs 方法可以快速探索状态空间，是目前最快的方法之一。此外，RRTs 还具有概率完备性。这意味着，当一个解决方案存在时，产生它的概率趋于 “1”。 RRTs 算法的主要缺点是在没有可能的解决方案时，无法停止执行和报告。在过去十年中，有几项研究旨在改进 RRTs 方法的基本版本。 下面，我们将介绍主要提出的 RRT 变体： 双向 RRT：作者在 [47] 中提出的巧妙想法是启动两棵树，一棵在起始节点初始化，另一棵在目标节点初始化。在使用多处理器架构执行时，这种方法可能会非常有趣。 RRT* ：是一种基于增量采样的算法，它能像基本 RRT 一样找到初始路径，然后利用三角形不等式进行优化。事实上，它优化了两个非连续节点之间的连接。RRT* 的作者声称他们的解决方案是渐进最优的，见 [48]。 RRT* 智能网格：其原理与可见度图类似。事实上，它不是生成纯随机的探索树，而是对搜索空间进行知情探索，并在障碍区域生成随机节点。如文献[49]所述，RRT*-Smart 是 RRT* 算法的扩展，旨在加快其收敛速度，从而在更短的执行时间内获得最优或接近最优的解决方案。 C. Potential FieldsO. Khatib 在文献[3]中首次提出了 “势场 “方法（也称为 “人工势场”）。作者有一个巧妙的想法，即把机器人比作沿着根据目标和机器人感知到的环境障碍物所形成的势场的当前线移动的粒子。移动机器人浸泡在电势场中（见公式 1），该电势场由与目标相关的吸引力电势（见公式 2）和与障碍物相关的排斥力电势（见公式 3）叠加而成。 势函数 U 的梯度（见公式 4）为每个点提供了机器人的移动方向，并使其根据势函数梯度的递减进行演化。然后，算法不断迭代，直到 q 所代表的机器人与 q 0 所代表的目标之间的距离小于等式 5 中的某个预定常数δ。 势场法为路径规划提供了一种简单的技术，易于实施，适用于有实时要求的导航。然而，势场法的简单性并不能掩盖其主要缺点，即局部最小风险。事实上，影响移动机器人的总势能是符号相反的吸引势能和排斥势能之和。因此，对于研究环境中的某些障碍物，该函数可能会出现一些局部最小值，机器人会被困在其中，如图 9 所示。因此，在拥挤的环境中，势场方法可能会受到很大限制。 早在上世纪 80 年代末，为了消除由于局部最小值造成的潜在场限制，已经开展了多项研究工作。其中最重要的一项研究是由 Barraquand 和 Latombe 于 1989 年提出的，他们提出并比较了四种摆脱局部最小值问题的技术：”最佳优先运动”、”随机运动”、”山谷引导运动 “和 “约束运动”。 正如 2012 年发表的路径规划文献综述[50]中所述，势场方法仍然受到研究人员的关注。事实上，它仍被认为是在线路径规划的最佳方法之一，参见[51]、[52]和[53]，其中一些势场方法的变体是在过去十年中发表的。 V. C onclusion在本文中，我们对路径规划方法进行了文献综述。我们介绍了几种方法，并揭示了它们的优缺点。因此，我们根据所考虑的案例研究，说明了每种方法的使用价值。 我们将路径规划方法分为两大类。第一类是需要进行环境建模的方法。这些方法最有可能给出最优或接近最优的解决方案。而第二类方法可以在不对上游环境建模的情况下进行路径搜索。这些方法更适合处理实时需求。在我们的研究中，我们特别关注三个算法系列，即 A*、RRTs、势场及其变体。 三维路径规划问题已被证明具有 NP 难度[23]，但在过去十年中，一些旨在生成三维路径的优秀近似算法已经问世[54]、[55]和[56]。但这些算法会导致性能或效率下降，并消耗大量内存。因此它们不能用于实时问题。 在未来的工作中，我们将从 A* 系列变体中汲取灵感，开发一种新的三维算法，以满足实时约束和动态路径重新规划的要求。","link":"/2024/02/22/Path-Planning-A-2013-Survey/"},{"title":"Hierachical Path Planning for Multi-Size Agents in Heterogeneous Environments","text":"Hierarchical Path Planning for Multi-Size Agents in Heterogeneous Environments 异构环境中多规模智能体的分层路径规划 摘要– 路径规划是游戏和其他研究领域（如机器人学）的核心课题。尽管如此，很少有研究涉及具有多种尺寸和地形穿越能力的智能体问题。==在本文中，我们介绍了一种新的规划器 Hierarchical Annotated A* (HAA* )，并演示了如何使用单个抽象图为具有不同大小和地形穿越能力的智能体进行规划==。通过理论分析和实验评估，我们证明 HAA* 能够为各种问题生成接近最优的解决方案，同时比低级搜索的工作量保持指数级下降。HAA* 所需的存储空间也仅为原始网格地图的一小部分。 I. INTRODUCTION单智能体路径规划是计算机科学中一个众所周知、研究广泛的问题。它有很多应用领域，如物流、机器人和最近的计算机游戏。尽管在这一领域已经取得了大量进展，但迄今为止，专门针对异构地形环境中不同规模智能体规划问题的研究还很少。 这个问题非常有趣，因为在解决路径规划问题时，这种多样性会带来更多的复杂性。现代即时战略或角色扮演游戏（例如 EA 广受欢迎的《红色警戒 3》或 Relic Entertainment 的《英雄连》）中经常会出现各种形状和能力各异的单位，它们必须在具有复杂地形特征的环境中进行导航，这些地形特征包括多种地形、不同的海拔高度等。因此，对步兵突击队来说可能有效的路线，对重型装甲坦克来说可能无效。同样，汽车和越野车的大小和形状可能相似，但各自选择的路径可能大不相同。 遗憾的是，目前大多数路径规划器，包括最近出现的分层规划器（[1]、[2]、[3]、[4]），只在某些理想条件下表现良好。例如，它们假定所有智能体都有同等能力到达给定地图上的大部分区域，而且一个智能体无法穿越的任何地形，任何智能体都无法穿越。此外，还经常对每个智能体的大小做出假设；由于所有智能体通常大小一致，因此为其中一个智能体计算的路径对其他任何智能体都同样有效。这些假设限制了这些技术的适用性，使其只能解决非常狭窄的问题：同质环境中的同质智能体。我们将讨论相反的情况，并展示如何在智能体的大小和地形穿越能力都可变的情况下计算出高效的解决方案。 首先，我们扩展了最近基于清除的寻路[4]工作，以便测量环境中关键位置的障碍物距离（第四节），并展示这些信息如何帮助智能体规划适当的路径（第五节）。接下来，我们将借鉴一种成功的基于集群的抽象技术[1]，以生成结构紧凑但信息丰富的搜索抽象（第六节）。最后，我们将介绍一种新的==基于清除（clearance-based）的分层路径规划器 HAA*==（第八节），并对其在异构多地形环境中涉及多规模智能体的各种问题上的性能进行详细的实证分析（第十节）。 II. RELATED WORK高效计算路径规划解决方案的一个非常有效的方法是，通过创建一个较小的近似抽象空间并在其中进行搜索，使原始问题变得更加容易解决。抽象空间将一个搜索问题分解成许多更小的问题，从而使智能体能够根据宏观操作来推理路径规划策略。这就是所谓的分层路径规划。 [1]和[2]、[5]中介绍了两个与我们的工作相关的最新分层路径规划器。其中第一个分层路径规划器 HPA* 通过将环境划分为由入口连接的方形簇来构建抽象搜索图。规划工作包括在抽象图中插入低层次的起点和目标节点，并找出它们之间的最短路径。==第二种算法 PRA* 通过抽象节点群来构建多层次搜索空间；其结果是将原始问题中的搜索空间缩小到沿最优最短路径的节点 “窗口”。==HPA* 和 PRA* 都专注于解决同质智能体在同质地形环境中的规划问题，因此当其中任何一个变量发生变化时，它们都是不完整的。我们的技术与 HPA* 类似，但我们对其进行了扩展，以解决更广泛的问题。 在机器人学中，力势可以帮助自主机器人在环境中找到无碰撞的路径。其基本原理是，当机器人接近障碍物时，会被远处的目标吸引，并被障碍物排斥。基于势能的路径规划的一种著名方法是 “刷火 “算法[6]，该算法通过在网格图上的每块瓷砖上标注与最近障碍物的距离来进行规划。这种嵌入式信息可让机器人计算斥势，从而使用梯度下降策略进行规划。Brushfire与HAA* 类似，它所产生的注释能让智能体了解自己与附近障碍物的距离。HAA* 的不同之处在于它能明确计算地图上每个位置的最大可穿越空间。此外，与 “刷火 “不同的是，HAA* 不会受到不完整性的影响，因为当排斥力相互抵消并导致机器人进入局部最小值时，就会出现不完整性。 走廊地图法（CMM）[4] 是最近推出的一种路径规划器，它能通过使用概率路线图来表示地图的连通性，从而回答多规模智能体的查询。路线图（或主干路径）由节点组成，节点上标注有间隙信息，表明在遇到障碍之前最大边界球的半径。通过创建 Voronoi 区域将节点放置在路线图上，以分割地图并确定与固定障碍物保持最大局部距离的位置。与 CMM 类似，HAA* 也是计算给定位置的可穿越空间大小，但我们的方法适用于网格环境，因为网格环境比路线图更容易创建，在各种应用中也更常见。另一个关键区别在于，我们允许对抽象图的大小进行细粒度控制；而 CMM 抽象图的大小是固定的。最后，我们处理的是多rain 情况，这使得我们的方法具有更丰富的信息。 在文献中，使用导航矩阵来表示环境越来越流行。在这一类别中，最近的两个规划器是三角剖分 A* 和三角剖分还原 A* [3]。TA* 利用一种被称为 Delaunay 三角剖分的技术来构建环境的多边形表示。其结果是一个由受限边和非受限边连接的无向图；前者可遍历，后者不可遍历。TRA* 是这种方法的延伸，它将三角形网格抽象为类似路线图的结构。与我们的方法一样，TA* 和 TRA* 都能回答多规模智能体的路径查询。不过，TA* 和 TRA* 所使用的抽象方法与我们的工作截然不同。我们使用的是将环境简单划分为正方形群组的方法，而他们的方法则旨在最大化三角形大小。我们还处理额外的地形要求，而 TA* 和 TRA* 都假定环境是均质的。 III. PROBLEM DEFINITION网格图是由原子正方形单元组成的结构。每个网格单元称为一个八面体，与 k 个相邻单元相连，其中 0 ≤ k ≤ 8。每个八面体要么被阻挡，要么可以穿越。被阻挡的八边形称为硬障碍物，因为没有智能体可以占据它们。==每个可穿越的八边形 t 都与特定的地形类型相关联，即 terrain(t) ∈ T，其中 T 是所有可能地形的集合，有 r = |T | ≥ 1 种可能的地形==。网格图可以表示为一个图 G = (V，E)，其中每个可穿越的八边形生成一个节点 v∈ V，每个八边形的邻接关系用边 e∈ E 表示。==（八边形 octile 可以指一个栅格，因为一个小栅格与八个其他的小栅格邻接， 更泛泛地，八边形指一个能够与八个同构图形临界地一个图形）== 智能体是试图在网格图上移动的任何实体。每个智能体都是正方形，大小为 s ≥ 1 : s ∈ S，其中 S 是为问题定义的所有智能体大小的有限集合。一个智能体占据 s × s 个栅格，这些栅格对应着它当前的位置。每个智能体都有地形穿越能力 c ⊆ T，它由一个或多个地形组合而成。让 C ⊂ 2T 成为所有智能体能力 c 的集合。如果一个智能体的能力中不包含其地形类型，则该智能体永远无法占据一个八分区。一个智能体可以在两个 s×s 的地点 l1 和 l2 之间沿正中方向移动，条件是：（1）智能体可以穿越 l1 和 l2；（2）l1 和 l2 之间的总位移量仅限于一个栅格的长度或宽度。对角线移动只有在存在等效（但更长）的两步移动时才允许。 问题实例（或查询）被定义为与智能体相关联的一对位置，即起点和目标。如果在这两个地点之间至少存在一条路径，且该路径仅由智能体可穿越的栅格组成，那么问题就是有效的。 IV. COMPUTING CLEARANCE VALUE ANNOTATIONS间隙值（clearance）是与八分区 t 和能力 c 相关联的障碍距离度量。它表示一个正方形的最大长度（或宽度），该正方形的左上方八分区为 t，且只包含地形类型包含在 c 中的八分区。 一个八分位点可以有多个与之相关的间隙值，每个能力点一个。 为了使我们的想法更容易理解，我们将以一个简单的环境为例，该环境有两种地形类型： 地面（用白色地砖表示）和树木（用灰色地砖表示）。为了区分可穿越地砖和不可穿越地砖（硬障碍），我们将后者涂成黑色。因此，穿越这种地图所需的能力集 C 定义为 $C = { { Ground }, {Trees }, {Ground ∨ Trees} }$。我们将使用两种大小的智能体穿越这个环境，因此让 S = {1, 2}。 ==(g)描述了，当tree障碍物可以被穿越时，地图的clearance== 图 1(a)至(d)说明了在上述环境中如何通过迭代程序计算间隙。在图 1(a)中，突出显示的可穿越目标瓦片的间隙方格初始化为 1。随后的迭代（图 1(b)-(c)）扩展了方格并增加了间隙。该过程一直持续到该方格包含障碍物（图 1(d)）或超出地图边界为止，此时我们终止迭代，不再增加间隙。 图 1(e) 显示了玩具地图示例中单一地形 {Ground} 能力的clearance（请注意，我们省略了零值clearance）。同样，图 1(f) 和图 1(g) 分别显示了与 {Trees} 和 {Ground ∨ Trees} 功能相关的净空值。 得出清除值后，我们将其存储在内存中，并对每个能力 c∈C 重复整个过程。因此，以这种方式计算清除值的最坏情况空间复杂度为： 定理 1：设 CV 是用 r 个地形标注八分网格图所需的所有间隙值的集合。此外，让 G = (V, E) 表示网格图，其中 $VHO \\subseteq V$ 是硬障碍物集。那么$$|CV| = (|V|-|V_{HO}|) \\times 2^{r-1}$$ 证明 ==要使某个节点可被某种能力穿越，该能力必须包含该节点的地形类型。==地形（以及能力）有 $2^r$ 种组合，但一种固定的地形类型最多只能出现在 $2^{r-1}$ 种能力中。表示环境的节点共有 V 个，我们避免在 $V_{HO}$ 中为所有节点存储任何间隙值。（举个例子：对于20x20大小的栅格图，只有0， 1，表示可通行和不可通行，其中障碍物栅格约有20个，CV是所有间隙值的集合，则$|CV| = (|400|-|20|) \\times 2^{2-1}$） 从 Lemma 1 得出的结果是一个上限；如果没有智能体具有给定的能力 c，就没有必要存储相应的清除值。尽管如此，相关的指数增长函数表明，由于每个节点都有 $Θ(2^r)$ 个清除值，因此存储每个清除值是不切实际的。幸运的是，清除值可以按需计算，不费吹灰之力。特别是，计算大小为 $s \\in S$ 的任何智能体 a 的清除值，只需构建一个最大面积为 $s^2$ octile 的清除方阵。我们在算法 1 中介绍了这种方法。 计算间隙的主要优势在于，我们能够将扩展问题映射为一个经典问题，即 “典型问题”，其中只有两种瓦片类型（可穿越瓦片和受阻瓦片），且只有原子大小的智能体。我们将其形式化为: 定理 2：给定一个注释网格图和一个具有任意大小和能力的智能体，任何路径规划问题都可以简化为经典路径规划问题，其中智能体的大小为一个八分位点，智能体的能力为一个地形。 证明 考虑一个规模为 $s_a$、能力为 $c_a$ 的智能体 a。进一步考虑大小为 $s_a × s_a$ 的位置 l、其左上方的八分位点 ul，以及与八分位点 ul 和能力 ca 相关的间隙值 cv（ul，ca）。很容易观察到，当且仅当 cv（ul，ca）≥ sa 时，智能体 a 可以穿越位置 l。这样，我们就可以将原始问题映射为一个经典的路径规划问题，如下所示： 将当前占据 sa × sa 位置 l 的智能体 a 映射为一个原子大小的智能体，其位置为 ul。在搜索路径时，只有当 cv(t, ca) ≥ sa 时，原子大小的智能体才能穿越任何八分区 t。所有其他八分区都被视为阻塞区。 这是一个有用的结果，因为它表明我们可以应用经典路径规划中的抽象技术来回答涉及多种地形类型和智能体大小变量的更为复杂的查询。特别是，如果将把网格图划分为互不相连的簇的拓扑抽象直接应用于具有任意大小智能体的问题，那么一个大型智能体可能同时处于多个簇中。这就提出了一系列我们认为难以处理的难题。上述定理巧妙地消除了这一问题，因为一个原子大小的智能体一次只能处于一个簇中。 V. ANNOTATED A*使用清除值对我们的扩展问题进行低层次规划，是迄今为止各种想法的直接应用。为了计算起点和目标节点之间的最优最短路径，我们使用了经典 A* 算法的一种变体 [7]，我们称之为注释 A* （简称 AA* ）。我们的方法与标准 A* 算法不同，每个查询都需要两个额外参数：智能体的大小和能力。回想一下，可以按需计算每个访问地点的清除率。因此，算法所考虑的每个原子八面体都可以动态地评估为阻塞或可穿越。这样，我们就可以将任何查询映射为一个典型问题，如前所述。 VI. CLUSTER-BASED MAP ABSTRACTIONAA* 对于原始网格图上的低层次规划来说已经足够，但对于大型问题来说效率不高；我们更倾向于使用宏运算符来表达更好的策略。现有的分层路径规划方法，尤其是那些专注于网格图的方法，如 [1] 和 [2]，通过将网格图分解为离散的相邻区域来实现这一目标。每对相邻区域都由一条最短路径连接，每个典型问题都被映射到这个更小的分层表示中。然而，当我们引入任意大小和能力的智能体时，以前的抽象技术就会崩溃，因为它们产生的分层抽象是不完整的。特别是，每对相邻区域之间可能存在多条最短路径，智能体大小和能力的每种组合都可能有一条最短路径。为了解决这个问题，我们以定理 2 中的结果为基础，该定理是本节所述空间抽象的关键。 我们的技术扩展了 [1] 中的流程，即把网格地图分成固定大小的正方形部分，称为簇。图 2(a) 显示了这种分解方法的结果；我们使用大小为 5 的簇，将玩具地图分成 4 个相邻的簇。 在最初的工作中，==入口被定义为沿两个相邻集群边界存在的最大无障碍过渡区域。==每个入口都有一个或两个过渡点（取决于其大小），在抽象搜索图中，这些过渡点由一对节点表示，节点之间用权重为 1.0 的无向边连接。我们使用类似的方法，但需要将所有能力的集合 C 作为参数，从而尝试识别每个 c∈C 的入口。 给定一个能力 c，我们从沿相邻边界区域的第一对可穿越地砖（即地形类型在 c 中的地砖）开始，扩展每个入口，直到出现以下三个终止条件之一：到达边界区域的尽头、检测到障碍物（即硬障碍物或地形类型不在 c 中的可穿越地砖）或任一集群中沿边界区域的节点间隙值开始增加。最后一个条件对于大型智能体来说非常重要，因为在这种情况下，一个集群会被边界附近的障碍物（如墙壁）部分分割开来。通过利用间隙，我们能够推理出此类障碍物的存在，并在每次检测到任一集群内部的可穿越空间量增加时，建立一个新的入口。 一旦找到入口，我们就会在每个群组中选择第一对相邻节点作为转换点，这对节点能最大限度地提高 c 的clearance（清除值、间隙值）。 给定能力 c 的一对相邻节点 (n1, n2) 的间隙定义为 cv(n1, n2, c) = min(cv(n1, c), cv(n2, c))。因此，我们在抽象图中添加了两个节点之间的新边 $e_{inter}$，并标注了相应的能力和清除值。该算法对每个 c∈C 重复进行，当所有相邻群组都被考虑后，算法结束。这样可以确保我们为每种可用能力识别出所有可能的入口。 在图 2(b) 中，我们展示了通过扫描集群 C1 和 C3 之间的边界发现的三个入口。入口 E1 和 E2 分别使用 {Ground} 和 {Trees} 功能发现，每个入口只跨越部分边界区域。入口 E3 横跨整个边界区域，使用 {Ground ∨Trees} 功能发现。连接的瓦片代表后续转换点的位置； 最终结果如图 2(c) 所示。请注意，E1 和 E3 在抽象图中的同一对节点上。这是由于我们尝试重新使用抽象图中任何现有节点的策略所致。 分解的最后一步是尝试为集群内的每对抽象节点在抽象图中添加一组内边。我们通过运行多个 AA* 搜索∀(c, s) : c∈C, s∈S 来实现这一目标、 注释为 AA* 使用的能力和通关参数，并将其权重设置为等于成本和通关参数。并将其权重设置为等于路径成本。当所有集群都已考虑完毕时，算法结束。 因此，我们构建了一个抽象多图，其中每条边 e 都标注了能力值 ce 和清除值 cv(e,ce)。如果 ce ⊆ ca ∧cv(e,ce)≥sa，则每个 e∈Eabs 都可被大小为 sa、能力为 ca 的智能体 a 遍历。我们将由此产生的抽象称为初始抽象，并给出以下定理来描述其空间复杂性： 定理 3：让 $V_{abs}$ 表示网格图抽象图中的节点集，网格图完全可以划分为 c×c 个簇、 每个簇的大小为 n × n。那么，在最坏情况下，节点总数为$$|V_{abs}| = 4(2n-1)+(4c-8)(3n-2) + (c-2)^{2}(4n-4)$$证明 每个过渡点都会在抽象图中产生两个节点。如果没有坚硬的障碍物，并且两个集群之间相邻边界上的每对节点都具有不同的地形类型，那么过渡点的数量将是最多的。在这种情况下，地图中间的集群有 $(c - 2)^2 $ 个，每个集群有 4 个相邻集群，每个集群包含 $4n - 4$ 个节点。地图周边（不包括角落）的集群有 4c - 8 个，其中有 3 个相邻集群和 3n - 2 个节点。边角集群共有 4 个，有 2 个相邻集群，每个集群包含 2n - 1 个节点。 定理 4：让 Eabs(L) ⊂ Eabs 表示包含 x 个抽象节点的群集 L 的内边集合。此外，假设 r 是地图中发现的地形总数，k 是 L 中发现的不同地形类型的数量。那么，在最坏情况下，连接 L 中所有节点所需的内边数量为$$|E_{abs}(L)|=|S| \\times 2^{k-1} \\times \\frac{x(x-1)}{2}$$ 证明 对于集群中的每对抽象节点和每种大小/能力组合，我们最多能计算出一条最佳长度的路径。根据阶式 1，我们知道每个节点最多可由 $2^{r-1}$ 种能力穿越，因此覆盖 2 个节点的路径最多为 $|S| × 2^{r-1}$ 种。然而，集群内的地形数量受集群大小的制约；只能找到 $k ≤ r$ 个地形。由此可见，覆盖每对节点的边集的大小上限实际上是 $|S| × 2^{k-1}$。在最坏的情况下，每对节点之间的边的数量将达到最大值，每个集群中总共有 $\\frac{x(x-1)}{2}$ 对这样的节点。 定理 5：设 $E_{inter} ⊂ E_{abs}$ 表示网格图抽象图中的内边集合。在最坏的情况下，网格图完全可以划分为 c × c 个簇，每个簇的大小为 n × n，簇间边的数量由以下公式给出：$$|E_{inter}| = (2c^{2} - 2c) \\times \\frac{n(n-1)}{2}$$证明 我们从定理 3 的证明中得知，在最坏的情况下，两个相邻集群之间边界上的每块瓷砖都由抽象图中的一个节点表示。如果我们计算邻接数，避免重复，我们会发现总共有 $2c^2 - 2c$。 每个过渡都会产生一条互边，每个邻接有 n 个间隙为 1 的单地形过渡，还有一定数量的互边代表间隙较大的多地形过渡。通过观察我们可以发现，每个邻接会产生 [n 个单地形转换]…[1 个 n 地形转换]。这一递推关系适用于一般序列计数公式 $\\frac {n(n-1)}{2}$ 上述结果之所以有趣，有几个原因。首先，==定理 3 表明图中节点的数量是簇大小的函数。==这表明，通过改变簇的大小，==我们可以用一点性能（遍历一个簇所需的时间）来换取内存（更少的抽象开销）==。定理 4 和 5 中的结果似乎支持这一假设。我们看到，图中节点之间的边数主要取决于节点所在集群的复杂度，而不是能力数的指数。这一点非常重要，因为它意味着，尽管有一个指数型的抽象边缘增长函数，但我们可以直接控制指数的大小。基于簇的分解技术允许我们根据需要在每个簇中包含或多或少的复杂性。 VII. OPTIMISING ABSTRACT GRAPH SIZE 优化抽象图大小正如我们在定理 4 和 5 中观察到的，初始抽象算法试图表示簇之间和簇内部的每一条最优路径。然而，大多数图的拓扑结构远比最坏情况简单；在我们的实验场景中，我们经常观察到在发现内部边缘时，不同的（c, s）参数对会返回相同的路径。这就为我们提供了一个机会，通过删除抽象边集中不必要的重复来压缩图。 请看图 3(a) 中的初始抽象，并与图 3(b) 中的预期结果进行对比。{E3、E5} 表示节点 w 和 y 之间的相同路径，但标注了不同的间隙值。在这种情况下，我们认为 E3 和 E4 具有强支配性，即 E3 ≻ E5 和 E4 ≻ E6。这是边与边之间的非对称且不可反反复复的关系，我们将其形式化为 定理 6：假设{ea, eb}∈ Eabs 是两条不同的边，它们连接同一对抽象节点，并标注了能力 ca ⊆ cb，这样就可以了：$$cv(e_{a}, c_{a}) \\ge cv(e_{b}, c_{b}) \\and weight(e_{a}) = weight(e_b)$$那么 ea ≻ eb，我们可以从 Eabs 中移除 eb，而不失一般性或最优性。 证明 由于 ca ⊆ cb，因此任何有能力穿越 eb 的智能体也一定有能力穿越 ea。此外，如果 cv（ea，ca）≥ cv（eb，cb）成立，那么任何足以穿越 eb 的智能体也一定足以穿越 ea。这些条件足以保持一般性。最后，由于 ea 与 eb 的权重相等，我们不能因为删除 eb 而失去最优性。 我们将去掉所有强主导边后的结果图称为高质量抽象图。 我们在分析这一问题时还发现，在许多情况下，存在多条到达目标位置的备选路线。最短路径往往需要穿越最佳长度的多地形边。然而，使用稍长的单地形边往往也能到达相同的目的地。这表明抽象图可以进一步压缩，而不会影响表示的完整性。 图 4(a)和 4(b)显示了典型的高质量抽象，而图 4(c)和 4(d)则突出显示了进一步压缩图形后的理想结果。在这个例子中，我们可以看到，虽然边 E1 和 E2 有不同的遍历要求，但任何大小为 s∈{1, 2} 的智能体都能遍历 E2，而且不失一般性。在这种情况下，我们称 E1 为弱支配，并将其标记为 $E1 \\succsim E2$。我们还注意到 $E3 \\succsim E4$、$E6 \\succsim E7$、$E10 \\succsim E8 $和 $E10 \\succsim E9$。 与强支配性的情况不同，它只保留了表征完整性（而非最优性）。我们将其形式化为 定理 7：假设 La 和 Lb 是两个相邻的簇，{wa, xb}, {ya, zb}∈ Vabs 是两对抽象节点，每对节点连接 La 和 Lb。将与这些节点对相关的边表示为 {ewx, eyz} ∈ 在这种情况下，如果满足以下条件，$ewx \\succsim eyz$： 那么，任何可以通过遍历 eyz 到达的地点也可以通过 $e_{wx}$ 到达。 证明 如果在边集 ${ewx、eyz、ewy、exz}$ 之间存在一条回路，其中每条边都可被 cyz 穿越，且清除值至少等于 $cv(eyz、cyz)$，那么就可以得出，La 或 Lb 中任何可从 ya 或 zb 到达的节点都必须可从 wa 或 xb 到达。因此，智能体可以通过 $e_{yz}$ 到达的任何目的地也可以通过 $e_{wx}$ 到达。 推论 8：如果 $ewx \\succsim eyz$，那么 ya 和 zb 也是主边，可以移除，除非另一条（非主边）中间的边需要移除。 证明 如果 ya 和 zb 是非支配内部边所需要的，我们就不能在不违反清除支配条件的情况下删除它们，而清除支配条件是保持表征完整性所必需的。然而，如果情况并非如此，根据回路条件，我们知道任何节点都可以通过 $y_a$ 或 $z_b$ 从内部边到达，也可以通过 $e_{wx}$ 的端点到达。因此，这两个节点和任何依赖于它们的相关内边都可以安全地删除。 在许多情况下，多地形间边缘往往与非常大的间隙相关联；比我们最大的智能体的大小要大得多。这不必要地限制了定理 7 中间隙优势条件的适用性。利用已知的 $s_M = max_{s \\in S} s$ 这一事实，我们可以通过对定理 7 中的 $E_{abs}$ 应用以下截断条件，最大化弱支配边的数量：$$\\forall E_{abs}(cv(e, c_e)) \\gt S_{M} \\Rightarrow cv(e, c_e) \\leftarrow s_{M}$$当然，以这种方式选择低质量抽象确实会影响计算解的质量。在最糟糕的情况下，高质量图中代价为 1.0 的一步转换可能长达 f (n) = 4n + f (n - 2) : f (2) = 3, f (3) = 13，其中 n ≥ 2 是 n × n 簇的长度。然而，这只是一种病态情况；我们将证明，实际情况中的差异要小得多，而且仍然接近最优。选择采用哪种质量抽象技术取决于具体应用的要求；这是运行时性能与空间之间的典型权衡。 VIII. HIERARCHICAL PLANNING有了合适的图抽象，我们就可以再次将注意力转回到智能体规划上。为了计算一个典型问题的层次解，我们采用了与 [1] 中描述的类似方法。我们在此简要介绍一下他们的方法；如需更详细的说明，请读者参阅原著。 首先，我们使用起点和目标节点的 x、y 坐标来确定每个节点所在的本地集群。接下来，我们在抽象图中插入两个临时节点（完成后删除），分别代表起点和目标。要将节点连接到图的其他部分，需要尝试使用 AA* 找到从每个节点到群组中其他抽象节点的内边。这一阶段总共需要 i + j 次搜索，与起点和目标簇中的合并抽象节点数相对应。 为了计算高级计划，我们再次使用 A* 的变体–这次是在将节点添加到开放列表之前评估抽象边的注释。一旦搜索结束，我们就可以获取结果，如果不需要立即执行，我们就完成了。否则，我们会沿着抽象最优路径在原始网格图中的每对节点之间进行多次小规模搜索，从而完善计划。我们将这种算法称为分层注释 A* （简称 HAA* ）。 IX. EXPERIMENTAL SETUP我们从一款流行的角色扮演游戏中借用了一组 120 张八角形地图，大小从 50x50 到 320x320 不等，对 AA* 和 HAA* 的性能进行了评估。以前的游戏相关研究（如 [1]）也使用过相同的地图。在默认配置下，这些地图只有一种类型的可穿越地形，其间夹杂着坚硬的障碍物。因此，我们创建了五个衍生集（共 720 张地图），每张地图上的每块可穿越地砖都有{10%、20%、30%、40%、50%}的概率被转换成第二种可穿越地形。具有这种地形类型的地块被称为软障碍，因为它们不是所有智能体都能穿越的。这样，我们就可以在同时存在软障碍和硬障碍的环境中对算法进行评估。 对于每张地图，我们通过在任意选择的地点对和一些随机能力之间随机创建有效问题，生成了 100 个实验。我们在每个实验中使用了两种智能体大小：小型（占用一块地砖）和大型（占用四块地砖），结果总共产生了 144,000 个问题实例（720x200）。所有实验均在运行 OSX 10.5.2 的 2.4GHz 英特尔酷睿 2 双核处理器和 2GB 内存上进行。为了实现这两个规划器，我们使用了阿尔伯塔大学免费提供的寻路库 HOG (www.cs.ualberta.ca/ ̃nathanst/hog.html)。 X. RESULTS在表 I 中，我们列出了抽象图相对于原始图的大小，原始图平均有 4469 个节点和 16420 条边。我们研究了将软障碍（SO）的数量从 0%（原始测试地图只有一个可穿越地形）增加到 50%的效果。我们还对比了群集大小{10、15、20}范围内的高质量和低质量抽象（表示为 HQ 和 LQ）（表示为 CS10、CS15 和 CS20）。 首先要注意的是，在所有情况下，抽象图的大小都只是原始图的一小部分。不出所料，较大的集群生成的图较小；在使用 CS20 的 SO 0% 问题集上观察到的抽象图最小。在这种情况下，使用 HQ 抽象后，原始图形中的节点数减少了 4.0%，边数减少了 5.0%。LQ 抽象效果更好，节点数量仅为原始图的 2.0%，边缘数量仅为原始图的 0.9%。 与存储图表相关的总空间复杂度由存储节点和边所需的总空间给出。如果我们假设每个非抽象节点和边都需要一个字节的内存来存储，那么我们最小的抽象图（每条边包含 2 个注释（能力和许可，共需要 1 个额外字节））的空间复杂度是使用 HQ 抽象时原始图大小的 8.7%，而使用 LQ 抽象时仅为 1.8%。同样，最大的 HQ 图形（出现在 SO 20% 的 CS10 中）的空间复杂度是原始图形的 63.8%。相比之下，最大的 LQ 图形出现在 SO 50% 的 CS10 中，其空间复杂度为原始网格图的 40.4%。从 CS10 到 CS20，HQ 图形的最坏情况空间复杂度降低到 47.0%，LQ 图形降低到 26.4%。 有趣的是，如果我们用节点数来表示图形中的内边数量，就可以推断出大多数 HQ 图形主要是由内边组成的。具体数量取决于集群中软障碍物的密度；密度较低的集群（如 SO 20%）会导致更多的内边，因为在每对抽象节点之间会发现更多的独特路径（大小和能力各不相同）。这与推理 4 一致，有助于理解 HQ 抽象的最坏情况行为。 LQ 图大小的线性增加是由于随着软障碍物数量的增加，发现了更多的单地形入口（这一观察结果与定理 3 一致）。增加集群中软障碍物的密度会降低定理 7 中电路条件的满足率，从而导致 SO 50% 的最坏情况。 接下来，我们考虑 HAA* 在路径质量方面的性能。我们的衡量标准是$$% error = \\frac{apl - opl}{opl} \\times 100$$其中，oppl 是 AA* 计算出的最优路径长度，apl 是 HAA* 使用的抽象路径长度。 图 5(a) 显示了 HAA* 在群集大小和软障碍物方面的平均性能。请注意，HQ 图形产生的误差非常小；在大多数情况下，误差在 3-6% 之间。然而，最令人鼓舞的也许是 LQ 抽象的结果，在大多数情况下，HAA* 的性能都在最佳值的 610% 以内。在这两种情况下，观察到的最大误差出现在 SO 0%，这是由于我们的边间放置策略造成的。在所有情况下，我们选择入口处间隙最大的一对节点作为过渡点，这对节点往往位于入口区域的起点，而这并不是最佳位置。在以单一地形为主的低复杂度地图集群中，这种情况会导致入口过长，而单条边际线又无法很好地体现这种情况。增加软障碍物的数量可以缩短入口并产生更多的过渡点，从而显著减少误差。HAA* 似乎针对复杂情况进行了优化，因此在较简单的问题上性能略有下降。 有趣的是，与 HQ 和 LQ 抽象相关的误差在 SO 20% 时达到最小，然后逐渐增加到 SO 50%。为了更好地理解这一现象，我们在图 5(b) 中展示了使用 15 个固定群集大小的 HQ 和 LQ 图上小型和大型智能体的性能。请注意，小型智能体的性能在 SO 20% 之后继续提高，而大型智能体的性能则开始下降。所观察到的误差上升源于在具有更密集集群的问题集上入口尺寸的减小。如表 I 所示，软障碍物较多的地图会产生更多较小的单地形入口。这种情况对小型智能体来说是有利的（有更多的过渡点可供选择），但对大型智能体来说却是不利的，因为它们必须越来越频繁地通过单一过渡点从一个集群穿越到另一个集群：这一过渡点是由横跨两个集群之间边界区域长度的长长的多地形入口产生的。每一次这样的穿越通常都是次优的，会降低路径的质量。最糟糕的情况出现在 SO 50% 数据集上，HAA* 的性能开始接近 SO 0% 数据集上的性能。 最后，我们将目光转向图 6，在图 6 中，我们使用搜索工作量指标对 HAA* 进行了评估。在这里，我们将 HAA（在插入、分层搜索和细化阶段）与 AA 在 HQ 和 LQ 图上扩展的节点总数进行了对比。我们将重点放在 SO 20% 问题集上，以分析随着路径长度的增加对搜索工作量的影响，但也注意到其他问题集也有类似的趋势。 通过观察图 6(a)，我们可以发现使用大集群规模 HQ 图的智能体在这项测试中处于劣势。将起点和目标连接到其本地簇中的每个抽象节点所需的插入工作在总工作中占了很大比重，导致 HAA* CS20 在处理长度不超过 250 的问题时落后于 AA* 。我们可以看到，随着问题长度的增加，CS20 与较小集群规模之间的差距也在缩小。相比之下，在图 6(b) 中，我们可以看到使用 LQ 图时，差距并不明显（每个簇的抽象节点较少）。不过，对于最大长度为 450 的问题，CS10 或 CS15 似乎更适合。计算解决方案所需的平均时间与图 6 中显示的趋势非常相似；在此特定数据集上，使用 HQ 图和 LQ 图，HAA* 每次查询的平均时间分别为 6.3ms 和 3.7ms。这进一步重申了我们的技术在游戏等现实世界应用中的适用性，因为在这些应用中，用于路径规划的计算资源非常有限。 XI. CONCLUSION路径规划中的异质性是许多现实世界问题的特征，但迄今为止却很少受到关注。在本文中，我们通过展示如何计算和利用基于间隙的障碍物距离来改进异构地形网格世界环境中多智能体的路径规划，从而解决了这一问题。我们的方法将涉及不同大小智能体和多地形穿越能力的复杂问题简化为简单得多的单大小、单地形搜索问题。在这些新见解的基础上，我们引入了一种新的规划器–分层注释 A* ，并通过比较分析表明，HAA* 能够在各种环境中找到接近最优的问题解决方案，而且搜索工作量仍然比标准 A* 低得多。我们的分层抽象技术应用简单，但非常有效；我们已经证明，在大多数情况下，存储抽象图的开销仅是非抽象图开销的一小部分。 未来的工作可能涉及计算注释，以处理海拔高度和其他常见地形特征。我们还希望找到一种更好的边间放置方法，并减少在抽象图中插入起点和目标的工作量。最后，我们相信 HAA* 可以有效地应用于解决异构多代理问题。","link":"/2024/02/28/Hierachical-Path-Planning-for-Multi-Size-Agents-in-Heterogeneous-Environments/"},{"title":"Near Optimal Hierarchical Path-Finding","text":"Near Optimal Hierarchical Path-Finding近似最优的分层路径搜索 Abstract商业计算机游戏中的路径搜索问题必须实时解决，而且往往受到内存和 CPU 资源的限制。使用 A* 等搜索算法确定路径所需的计算量会随着搜索空间的增大而增加。因此，在大型地图上寻路会导致严重的性能瓶颈。 本文介绍了 HPA* （Hierarchical Path-Finding A*），一种在网格地图上降低寻路问题复杂性的分层方法。该技术将地图抽象为相互关联的局部群组。在局部层面，预先计算并缓存穿越每个簇的最佳距离。在全局层面上，簇的穿越只需一大步。层次结构可以扩展到两级以上。小的聚类被组合在一起，形成较大的聚类。计算所有聚类的交叉距离时，会使用为包含的较小聚类计算的距离。 我们的方法是自动的，不依赖于特定的拓扑结构。在不使用特定领域知识的情况下，我们成功地处理了随机地图和真实游戏地图。我们的问题分解方法在环境不断变化的领域中效果非常好。该技术还具有简单和易于实现的优点。如果需要，还可以插入更复杂的领域专用算法，以提高性能。 实验结果表明，搜索工作量大大减少。与高度优化的 A* 相比，HPA* 的搜索速度最多可提高 10 倍，同时搜索到的路径与最优路径的差距不超过 1%。 1 Introduction商业计算机游戏中的路径选择问题必须实时解决，而且往往受到内存和 CPU 资源的限制。分层搜索被认为是降低这一问题复杂性的有效方法。然而，目前还没有关于商业游戏中分层路径搜索的详细研究报告。部分原因是游戏公司通常不会公开他们的想法和源代码。 行业标准是使用 A* [10]或迭代深化 A* ，即 IDA* [3]。A* 通常速度更快，但 IDA* 使用的内存更少。这些算法有许多增强功能，可使其运行更快或探索更小的搜索树。对于许多应用，特别是那些有多个移动 NPC 的应用（如在实时战略游戏中），这些时间和/或空间要求是限制因素。 本文介绍了在网格地图上进行分层路径搜索的新方法 HPA*，并进行了性能测试。我们的技术将地图抽象为相互关联的局部集群。==在局部层面上，我们预先计算并缓存了穿越簇的最佳距离。==在全局层面上，==我们的行动是一步跨越一个簇，而不是移动到相邻的原子位置。== 我们的方法简单、易于实现，而且通用，因为我们不使用任何应用特殊知识，应用该技术时也不受地图属性的影响。我们可以处理成本可变的地形和各种拓扑类型，如森林、带有任何形状障碍物的开阔区域或建筑物内部，而无需对实施进行任何更改。 对于许多实时路径搜索应用来说，并不需要完整的路径。通常只要知道有效路径的前几段就足够了，这样移动装置就能开始朝正确方向移动。随后发生的事件可能会导致移动装置不得不改变计划，从而不再需要路径的其余部分。A* 返回完整的路径。相比之下，HPA* 返回的是由子问题组成的完整路径。第一个子问题可以求解，让单位沿着路径走几步。根据需要，可以解决后续子问题，提供更多的移动。这样做的好处是，如果单位不得不改变计划，那么就不用浪费精力去计算通往前一个节点的路径，而这是根本不需要的。 分层框架适用于静态和动态变化的环境。在后一种情况下，==首先假设不动的拓扑元素会发生局部变化（例如，a bomb 破坏了 a bridge）。==我们在本地计算从被修改的集群中提取的信息，并保持框架的其他部分不变。其次，假设地图上有多个移动单元，计算出的路径可能会被另一个单元阻塞。我们将以较小的代价计算出一条抽象路径，而无需花费额外的精力将其还原为底层表示。我们会迅速让角色朝好的方向移动，并在角色需要时重新指定抽象路径的部分内容。如果路径受阻，我们会从角色的当前位置重新规划另一条抽象路径。 我们方法的层次结构可以有很多层，因此可以扩展到大型问题空间。当问题地图比较大时，可以通过增加层级数来减少搜索工作量，但代价是需要更多的存储空间和预处理时间。 我们的技术会产生次优解，以最优性换取更高的执行性能。在应用 apath-smoothing 程序后，我们的解决方案与最优方案的差距在 1%以内。 1.1 Motivation考虑从加利福尼亚州洛杉矶乘车前往安大略省多伦多市的问题。具体来说，从洛杉矶的圣莫尼卡大道 1234 号到多伦多的 Yonge 街 4321 号，开车行驶的最短距离是多少？给定一张详细的北美路线图，上面标注了所有道路的行车距离，A* 实现可以计算出最优（最小距离）行车路线。考虑到路线图的庞大规模，这可能是一项昂贵的计算。 当然，人类旅行规划师绝不会在如此低的细节级别上工作。他们要解决三个问题： 从圣莫尼卡大道 1234 号前往通往洛杉矶以外的主要高速公路。 规划从洛杉矶到多伦多的路线。 从进入多伦多的高速公路行驶到 Yonge 街 4321 号。 第（1）步和第（3）步需要绘制每个城市的详细路线图。第（2）步可以使用高密度地图，用道路连接城市，抽象出城市内部的所有细节。实际上，人类旅行规划师使用抽象方法快速找到从洛杉矶到多伦多的路线。然而，由于将城市视为黑盒子，这种搜索并不能保证找到最短的路线。例如，虽然在高速公路上行驶可能更快，但对于一些高速公路绕城而过的城市来说，离开高速公路穿过城市可能是更短的路线。当然，这也可能不是更快的路线（城市的车速比高速公路慢），但在这个例子中，我们试图尽量缩短旅行距离。 可以将抽象化提升到更高水平：在州/省一级进行规划。一旦路径到达州界，就计算出州与州之间的最佳路线。知道各州的出入口后，再规划州际路线。同样，这样做也行得通，但可能会产生次优解决方案。 更进一步，抽象到国家层面：从美国到加拿大。显然，抽象到一定程度就会变得非常粗糙，以至于实际上毫无用处。 我们希望在计算机游戏路径搜索中采用类似的抽象策略。我们可以在一张完整的 1000 x 1000 地图上使用 A*，但这意味着一个巨大的搜索空间。将地图上的每个 10 x 10 个区块视为一个城市。现在，我们可以在 100 x 100 个城市的地图上进行搜索。对于每个城市，我们都知道城市的入口以及所有入口对的穿越成本。我们还知道如何在城市之间旅行。这样，问题就简化为三个步骤： 起始节点： 在包含起点节点的区块内，找出通往区块边界的最佳路径。 在区块级（100 x100 个区块）搜索从包含起点节点的区块到包含目标节点的区块的最佳路径。 目标节点： 在包含目标节点的区块内，找出从区块边界到目标的最佳路径。 其结果是，搜索速度大大加快，几乎可以得到最优解。此外，这种抽象与拓扑无关；设计人员无需手动将网格分解为高层次特征，也无需在网格上标注航点。 1.2 Contributions本文的贡献包括： HPA*，一种新的分层路径搜索算法（包括伪代码和源代码），该算法与领域无关，可很好地用于静态和动态地形拓扑。 对各种游戏迷宫（来自 BioWare’sB ALDUR’S GATE）进行分层搜索的实验结果表明，速度提高了 10 倍，而路径质量却下降了 1%。 一些游戏公司似乎正在使用分层搜索思想的变体，尽管它们的大多数算法细节并不公开。据我们所知，这是在商业电脑游戏领域使用分层 A* 的首次科学研究。 第 2 节简要概述了背景文献。第 3 节介绍了我们的分层 A* 新方法，第 4 节对其性能进行了评估。第 5 节是我们的结论和进一步研究的主题。附录 A 提供了我们算法的伪代码。 2 LiteratureRe view本节第一部分总结了商业游戏中用于路径定位的分层方法。第二部分回顾了更广泛背景下的相关工作，包括在机器人等其他网格领域的应用。 文献[5]描述了使用两级层次结构进行路径标定的方法。作者只提供了该方法的高分辨率演示。问题地图被抽象成一个个群组，如建筑物中的房间或场地上的方形块。一个抽象动作从入口中间穿过一个房间到达另一个房间。首先，这两种方法都将问题地图划分为方形块等群组。其次，抽象行动都是穿越街区（而不是从一个街区中心到另一个街区中心）。第三，两种技术都将区块入口抽象为一个过渡点（事实上，我们允许一个或两个过渡点）。这两种方法之间也存在显著差异。我们将层次结构扩展到多个抽象层，并以独立于领域的方式进行抽象。我们还预先计算并缓存了区块交叉的最佳距离，从而降低了在线计算的成本。 另一种重要的分层方法是利用可见度点（point of visibility）来进行商业游戏的路径定位[6]。对于每个节点，都会为从当前节点可以看到的所有节点添加边（即可以用直线连接的节点）。 当障碍物数量较少且形状为正多边形（如建筑物内部）时，这种方法尤其有用。当障碍物数量较多且/或其形状不是正多边形时，该方法的有效性就会降低。考虑一下包含森林的地图，森林是小尺寸障碍物的密集集合。用可见度点来模拟这种顶部结构，会产生一个具有短边的图形（就节点和边的数量而言）。因此，就无法有效利用在单步中进行长距离行进的关键想法。当问题地图包含凹形或曲面时，该方法要么性能不佳，要么需要复杂的工程设计才能有效地构建图形。相比之下，我们的方法适用于多种类型的地图，并且不需要复杂的领域分析来进行抽象。 导航网格（又名 NavMesh）是一种强大的抽象技术，适用于二维和三维地图。在二维环境中，这种方法用一组（最小的）凸多边形来覆盖地图的无遮挡区域。[11]中介绍了一种构建接近最优 NavMesh 的方法，这种方法放宽了最小多边形集的条件，构建地图覆盖范围的速度更快。 除了商业电脑游戏，路径标定还应用于许多研究领域。在机器人领域探索过的基于拓扑抽象的路径定位方法与本文描述的工作尤其相关。四叉树[8]已被提出作为进行分层地图分解的方法。这种方法将地图分割成不同大小的方形块，使每个块只包含可行走的单元格或只包含阻塞的单元格。问题地图最初被划分为 4 个块。如果块中同时包含障碍单元和可行走单元，则将其进一步分解为 4 个更小的块，依此类推。在这个抽象框架中，行动就是在两个相邻区块的中心点之间行走。由于智能体总是走在两个区块的中间，因此这种方法会产生次优解。 为了提高求解质量，可以将四叉树扩展为有框四叉树 [1,12]。在有框四叉树中，块的边界以最高分辨率的单元增强。一个动作在任意两个边界单元之间穿过一个块。另一方面，框架四叉树比四叉树占用更多内存。 与四叉树相比，框架四叉树与我们的工作更为相似，因为我们也将区块交叉作为抽象动作。不过，我们并不把区块边界上的所有单元格都视为入口点。通过将一个入口抽象为一个或两个入口点，我们减少了区块入口点的数量。此外，我们的方法允许区块包含障碍物。因此，我们必须计算位于同一区块边界上的入口点之间的最优路径。 在马尔可夫决策过程（MarkovDecision Process，MDP）框架下，多目标路径规划的性能已得到提升[4]。所提出的问题是针对所有地图位置对 (x;y) 有效地学习从 x 到 y 的近似最优策略 (x;y)。需要计算和存储的策略数量是地图单元数的二次方。问题地图上的所有位置都是机场，它们被分配到不同的层次结构中。从 x 到 y 的旅行策略与现实世界中的飞机旅行类似。首先，前往越来越大的机场，直到我们到达一个大到足以与目的地所在区域相连的机场。其次，依次前往更小的机场，直到到达目的地。这种方法与第 1.1 节中概述的策略非常相似。 文献[7]对各种框架中路径搜索的性质进行了分析。作者根据所寻求结果的类型、环境类型、可用信息量等对路径搜索问题进行了分类。文中还讨论了每种问题类型所面临的挑战以及解决策略，如重新规划和使用动态数据结构。 [9]分析了与HPA* 相 似 的最短路径算法的层次方法。该方法将初始问题图分解为片段子图集和连接片段子图的全局边界子图。计算并缓存最短路径供将来使用，这与 HPA* 对集群遍历路径执行的缓存类似。作者分析了应缓存哪些最短路径（即来自哪些子图），以及应保留哪些信息（即完整路径或仅成本），以便在内存有限的情况下获得最佳性能。 与 HPA* 相关的另一种技术是分层 A* [2]，它也使用空间的分层表示，目的是减少总体搜索工作量。不过，这两种技术使用层次化表示的方式有所不同。我们的方法使用抽象来构造和增强搜索空间的表示，而分层 A* 是一种自动生成与领域无关的启发式状态评估的方法。在单个代理搜索中，一个能评估从状态到目标之间距离的启发式函数被用来指导搜索过程。这种函数的质量在很大程度上影响着整个搜索算法的质量。从初始空间开始，分层 A* 建立抽象空间的分层，直到得到一个抽象的单状态空间。在建立下一个抽象空间时，当前空间中的几个状态会被组合成下一个空间中的一个抽象状态。在这种层次结构中，一个抽象空间用于计算前一个空间的启发式函数。 3 Hierarchical Path-Finding我们的分层方法实现了 1.1 节中描述的策略。在我们的分层框架中，搜索抽象解的过程分为三步，即在线搜索。其次，搜索从起始邻域边界到目标邻域边界的路径。这是在抽象层面上进行的，搜索更加简单快捷。第三，完成从目标邻域边界到目标位置的路径。 在线搜索的抽象图是利用从问题迷宫中提取的信息构建的。我们将更详细地讨论如何构建分层搜索框架（预处理）以及如何用于路径遴选（在线搜索）。起初，我们专注于构建两个层次的层次结构：一个低层次和一个抽象层次。本节末尾将讨论如何添加更多的层次。我们将在图 1(a) 所示的 40 40 小地图上演示我们的方法是如何工作的。 3.1 Pre-processing a Grid构建分层搜索框架的第一步是对迷宫进行顶层抽象。我们利用这种迷宫抽象来构建分层搜索的抽象图。 图 1(b)中的粗线表示用于拓扑抽象的抽象簇。在本例中，40 x 40 个网格被划分为 16 个大小为 10 x 10 的簇。请注意，这种抽象没有使用任何领域知识（除了调整簇的大小）。 对于两个相邻集群之间的每条边界线，我们都要确定一组（可能为空）连接它们的入口。==入口是沿两个相邻集群 c1 和 c2 的共同边界的最大无障碍线段，==其形式表示如下：考虑瓦片 l1 和 l2 的两条相邻线（每个集群一条），它们决定了 c1 和 c2 之间的边界边缘。 对于 $tile t \\in l1 \\cup l2$，我们将 symm(t)定义为 t 相对于 c1 和 c2 之间边界的对称瓦片。请注意，t 和 symm(t) 是相邻的，绝不属于同一个簇： 边界限制条件：$e\\in l1 \\cup l2$.该条件规定，入口沿相邻两个集群之间的边界分布，且不能超过这两个集群之间的边界。 对称条件：$\\forall t \\in l_1 \\cup l_2: t \\in e \\Leftrightarrow symm(t) \\in e $。 无障碍条件：入口处没有任何障碍物。 最大化条件：只要前面的条件保持不变，入口就会向两个方向延伸。 图 2 是样本地图左上角的缩放图片。图中显示了我们如何识别入口并利用它们构建抽象问题图的细节。在这个例子中，左侧的两个集群分别由宽度为 3 和 6 的两个入口连接。如果入口的宽度小于预设常数（在我们的例子中为 6），那么我们就在入口中间设置一个转换。否则，我们在入口两端各设置一个过渡段。 我们使用过渡来构建抽象问题图。对于抽象图中的每一个过渡，我们都会指定两个节点和一条连接它们的边。对于簇内的每对节点，我们都会找到一条连接它们的边，称为内边。我们通过搜索簇区域内的最优路径来计算内边的长度。 图 2 显示了所有节点（浅灰色方块）、所有边间（浅灰色线条）和部分边内（右上角集群）。图 3 显示了图 2 右上角集群的抽象内部拓扑细节。数据结构包含节点集以及节点之间的距离。直线转换时，距离为 1；对角线转换时，距离为 1:42。我们只缓存节点之间的距离，而舍弃与这些距离相对应的实际最优路径。如果需要，也可以存储路径，但代价是占用更多内存。详见第 3.2.2 节的讨论。 图 4(a) 显示了运行示例的抽象图。图中包括将起点节点 S 和目标节点 G 插入图中的结果（虚线），下一小节将对此进行描述。图中有 68 个节点，包括 S 和 G，每次搜索时它们都会发生变化。在此抽象层次上，有 16 个群组，其中 43 个相互连接，88 个内部连接。还有 2 条额外的边将 S 和 G 与图的其他部分连接起来。为了便于比较，低层次（非抽象）图包含 1; 463 个节点（每个未阻塞瓦片一个节点）和 2; 714 条边。 一旦构建了抽象图形并计算了边内距离，就可以在分层搜索中使用网格了。这些信息可以预先计算（在游戏启动前），存储在磁盘上，并在游戏运行时加载到内存中。这对于静态（不变化的）网格非常有用。对于动态变化的网格，必须在运行时修改预先计算的数据。当网格拓扑结构发生变化时（如桥被炸毁），受影响的本地群组的内边和间边需要重新计算。 3.2 On-line Search在线搜索的第一阶段是将起始位置 S 与包含 S 的簇边界连接起来，这一步是通过将 S 临时插入抽象图来完成的。同样，将目标位置 G 连接到其群集边界也是通过将 G 插入抽象图来完成的。 添加 S 和 G 后，我们使用 A* [10]在抽象图中搜索 S 和 G 之间的路径。这是在线搜索中最重要的部分。它提供了一条抽象路径、从 S 到 S 簇边界的实际移动、到 G 簇的抽象路径以及从 G 簇边界到 G 的实际移动。 在线搜索的最后两个步骤是可选的： 路径重整可用于将抽象路径转换为原始网格上的移动序列。 路径平滑可用于提高路径重整解决方案的质量。 抽象路径可在后续处理步骤中进行重整，以获得从 S 到 G 的详细路径。对于许多实时路径搜索应用来说，并不需要完整的路径，只需要前几段路径即可。这些信息可以让角色开始朝着目标的正确方向移动。相比之下，A* 必须完成搜索并生成从 S 到 G 的完整路径，然后才能确定角色的最初步骤。 ==考虑一个经常发生动态变化的领域（例如，有许多移动装置在周围穿梭）。在这种情况下，找到一条抽象路径后，我们可以在角色向目标导航的过程中逐步重新定义它。如果当前的抽象路径变得无效，智能体就会丢弃它，寻找另一条抽象路径。没有必要事先重新定义整条抽象路径。== 3.2.1 Searching for an Abstract Path要在抽象图中搜索路径，S 和 G 必须是图的一部分。我们将 S 连接到包含它的集群 c 的边界。我们将 S 添加到抽象图中，并在本地搜索 S 和 c 的每个抽象节点之间的最优路径。如果存在这样的路径，我们就在抽象图中添加一条边，并将其权重设置为路径的长度。在图 4 中，我们用虚线表示这些边。 在我们的实验中，我们假设每次新的搜索都会改变 S 和 G。因此，插入 S 和 G 的成本会被添加到找到解决方案的总成本中。找到路径后，我们会从图中移除 S 和 G。然而，在实际操作中，这种计算方法可以更加高效。在这种情况下，我们插入 G 一次，然后重复使用。插入 G 的成本会在多次搜索中摊销。一般来说，缓存可以用来存储热门起始节点和目标节点的连接信息。 插入 S 和 G 后，抽象图可用来搜索 S 和 G 之间的抽象路径。 3.2.2 Path Refinement路径重构将抽象路径转化为低级路径。抽象路径中的每个集群交叉都会被等效的低级移动序列所取代。 如果簇预处理缓存了这些附着在内侧边上的移动序列，那么重新定位就只需简单地查找即可。否则，我们将在每个簇内沿着抽象路径进行小规模搜索，以重新发现最优局部路径。有两个因素限制了重新定位搜索的复杂性。首先，只要在找到抽象路径后环境不发生变化，抽象解就能保证正确。这意味着我们永远不必为修正抽象解而回溯和重新规划。其次，初始搜索问题已被分解成几个非常小的搜索（抽象路径上的每个群组一个），搜索复杂度很低。 3.2.3 Path Smoothing拓扑抽象阶段每个入口只有一个转换点。虽然这样做很不科学，但却放弃了计算解决方案的最优性。解决方案在抽象图中是最优的，但在初始问题图中不一定。 为了提高解决方案的质量（即长度和美观度），我们进行了路径平滑的后处理阶段。我们的路径平滑技术很简单，但效果很好。其主要思路是用直线取代解的局部次优部分。从解法的一端开始。对于解中的每个节点，我们都要检查是否能以直线到达路径中的下一个节点。如果可以，那么这两个节点之间的直线路径就取代了这些节点之间的初始次优序列。 3.3 Experimental Results for Example表 1 的前两行总结了运行示例的实验结果。L-0 表示在低层图上运行 A*（我们称之为第 0 层），L-1 使用两个层次（即第 0 层和第 1 层），L-2 使用三个层次（即第 0 层、第 1 层和第 2 层）。最后一行 L-2 的含义将在第 3.5 节中说明。 使用曼哈顿距离作为启发式的低层（原始网格）搜索性能较差。我们选择这个例子是为了展示最糟糕的情况。在没有抽象的情况下，A* 将访问迷宫中所有未封锁的位置。搜索会扩展 1 462 个节点。限制搜索复杂度的唯一因素是迷宫的大小。具有相似拓扑结构的 Alar ger 地图对 A* 来说是一个难题。 使用分层搜索可以大大提高性能。将 S 插入抽象图时，它只能与起始簇边界上的一个节点相连。因此，我们添加了一个节点（对应 S）和一条边，将 S 与簇中唯一可访问的节点相连。将 G 插入图中是相同的。 在抽象图上使用 A* 搜索 S 和 G 之间的路径。在第 1 层搜索也会扩展抽象图的所有节点。不过，这次搜索的工作量大大减少。 主搜索扩展了 67 个节点。此外，插入 S 和 G 会扩展 16 个节点。找到一条抽象路径总共需要扩展 83 个节点。如果需要，抽象路径可以部分或全部重写，但需要额外费用。最糟糕的情况是，我们必须完全重写路径，而且没有缓存内边的实际路径。对于路径中的每一条内边（即簇交叉），我们都要执行一次搜索，以计算出相应的低水平作用序列。这样的小规模搜索共有 12 次，共扩展了 145 个节点。 3.4 Adding Levels of Hierarchy 添加层次结构级别层次结构可以扩展到多个层次，从而将抽象图转化为多层次图。在多层次图中，节点和边都有标签，显示其在抽象层次结构中的层级。层级结构中的附加层级可以减少搜索工作量，尤其是在大型迷宫中。有关在多线索图中进行高效搜索的详情，请参阅附录 A.2.2。为了构建多层迷宫图，我们将迷宫抽象为多个层次。层级越高，迷宫分解中的簇就越大。第 l 层的簇称为 l 簇。在现有结构的基础上建立每个新的层级。第 3.1 节介绍了第 1 个簇的构建。对于第 2 层，将 n x n 个相邻的（第 1 层）簇组合在一起就得到了第 l 层簇，其中 n 是参数。 位于新创建的 l 簇边界上的节点会将其等级更新为 l（我们称之为 l 节点）。在第 l 个簇之间进行转换的边际节点也会将其等级提升至第 l 级（我们称之为 l-边际节点）。 我们为位于同一 l 簇边界上的 l 个通信节点对添加了级别为 l 的内部边（即 l-intra-edges），该边的权重是仅使用（l 1）个节点和边连接簇内两个节点的最短路径的长度。更多细节见第 A.2.2 节。 将 S 插入图中会反复连接 S 和包含它的 l 簇边界上的节点，l从 1 到最大抽象层级递增。搜索 S 和 l 节点之间的路径仅限于 l 1 层和包含 S 的当前 l 簇的区域。 ==我们构建抽象图的方式确保了无论我们使用多少抽象层级，都能找到相同的解。==特别是，在图中添加新的第 l 2 层并不会降低解的质量。在此，我们将提供简要的直观解释，而不是形式上的证明。在第 l 层添加的新边对应于第 l 1 层的现有最短路径。在第 l 层搜索得到的解与在第 l 1 层搜索得到的解相同，只是速度更快。 在我们的示例中，增加一个 n =2 的额外层级会产生 4 个大的簇，地图的每个四分之一都有一个。图 2 中的整个图是一个 2 簇的例子。这个簇包含 2 个大小为 10 x 10 的 2-1 簇。除了 S，这个簇中唯一的 2 节点是左下角的那个。第 2 层是进行主要搜索的地方，共有 14 个节点（包括 S 和 G）。图 4(b) 显示了抽象图的第 2 层。图中虚线所示的边将 S 和 G 与第 2 层的图连接起来。 抽象层 2 很好地说明了预处理如何解决局部限制并降低抽象图的搜索复杂度。在第 2 层，我们避免在这个 “房间 “中进行任何无用的搜索，而是直接从 S 到左下角的出口。 插入 S 和 G 后，我们就可以搜索 S 和 G 之间的路径了。由于起点和目标的抽象层级最高，因此假设存在解决方案，我们将始终找到解决方案。搜索结果就是最高抽象层次的节点序列。如果需要，抽象路径可以反复重演，直到获得低层次的解决方案。 3.5 Experimental Results for Example with 3-LevelHierar chy表 1 的第三行列出了我们的运行示例的数字数据，该示例采用 3 级层次结构（即三个层次：L 0、L 1 和 L 2）。 如第 3.3 节所示，将 S 和 G 连接到它们的 1 簇边界共扩展了 16 个节点。同样，我们现在将 S 和 G 连接到它们的 2 簇边界。这些第 1 级搜索为 S 扩展了 3 个节点，为 G 扩展了 22 个节点。 第 2 层的主搜索只扩展了 7 个节点。除了抽象路径中的节点外，没有其他节点被扩展。如果我们考虑到在第 1 层图中的搜索扩展了图中的所有节点，那么这是一个重要的改进。在扩展层次中找到抽象解总共需要 48 个节点。 值得注意的是，在增加了一个新的抽象层后，插入 S 和 G 的成本就占了主搜索成本的绝大部分。这说明了该方法的一般特点，即插入 S 和 G 的成本随着层次数的增加而增加，而主搜索则变得更简单。 表 1 还显示了完整解决方案重构的成本。将解决方案从第 2 层重置到第 1 层会扩展 16 个节点，从第 1 层重置到第 0 层会扩展 145 个节点，总计 161 个节点。 3.6 Storage Analysis除了计算速度之外，分层方法用于路径标定的存储量也是另一个重要的性能指标。影响分层方法内存使用量的有两个因素：问题图的大小和 A* 使用的开放列表的大小。我们将在本节的其余部分详细讨论这两个因素。对于图的存储，我们既有经验分析，也有最坏情况的理论讨论。 3.6.1 Graph Storage Requirements表 2 显示了 BALDUR’S GATE 测试套件的问题图平均大小。有关该数据集和设置（如群组大小或原始问题图中的边定义）的详细信息，请参见第 4 节。我们将原始低级图与抽象图进行了比较，抽象图的抽象层级有一个、两个和三个（不包括第 0 层）。表中显示了节点数 N、边间数 E1 和边内数 E2。对于多层次图，我们同时显示了总数量和各层次的数量 $L_i, i \\in {1, 2, 3}$。 数据显示，与原始问题图的大小相比，抽象图的存储开销很小。添加新的图级别会更新一些现有节点和边间的级别，而不会创建任何这些类型的新对象。唯一的开销就是新增的内边。在我们的数据集中，我们在一个有 4469 个节点和 16420 条边的初始图中添加了至少 1846 条内边（当有三个抽象层时）。假设节点和边占用的内存量大致相同，我们得到的开销为 8.83%。 以内存字节数表示的开销很大程度上取决于实现、编译器优化或问题图大小等因素。例如，如果图的大小至少为 256 x 256，那么存储图节点的坐标就需要两个字节。更大的地图需要更多内存。 由于抽象节点和边是按级别标记的，因此在抽象图中存储元素所需的内存可能比在初始图中更大。由于大多数编译器会将对象的比特大小四舍五入为 8 的倍数，因此实际上可能不存在比特开销。 通过在内存（如缓存）中只保留当前搜索所需的图部分，可以优化存储利用率。在分层框架中，我们只需要与当前搜索所在层级和区域相对应的子图。例如，在进行主抽象搜索时，我们可以放弃低层次的问题图，从而大大减少该搜索的内存需求。 一个簇的最坏情况是边界上交替出现阻塞地砖和空闲地砖，并且任何两个边界节点都可以相互连接。假设问题迷宫的大小为 m x m，迷宫被分解为 c x c 个簇，一个簇的大小为 n x n。在最坏的情况下，我们得到每个簇有 4n=2=2 n 个节点。由于每对节点表示一条内边，因此一个簇的内边数量为 2n(2n 1)=2= n(2n 1)。迷宫边缘没有抽象节点，因此边缘集群的抽象节点数量较少。对于位于迷宫角落的簇，节点数为 n，边缘内的节点数为 n(n 1)=2. 对于位于迷宫边缘的簇，节点数为 1:5n，边缘内的节点数为 1:5n(1:5n 1)=2. 因此，抽象节点总数为 2m(c 1)。内边总数为 n(c 2)2(2n 1)+2( n 1)+3( c 2)(1:5n 1)。 3.6.2 Storage for the A* Open List由于分层路径搜索将问题分解为若干个小搜索，因此分层搜索中 A* 的平均打开长度比低层搜索小。表 3 比较了低层搜索和分层搜索中开放列表的平均长度。表 3 比较了低层搜索和分层搜索中开放列表的平均长度，该平均值是对第 4.1 节中描述的所有搜索的平均值，而不是在求解长度之后的结果。数据显示，在抽象框架中，低层搜索和主搜索的列表长度减少了三倍。 4 Experimental Results4.1 Experimental Setup实验对象是从 BioWare 的游戏《BALDUR’S GATE》中提取的 120 幅地图，地图大小从 50 x 50 到 320 x 320 不等。对于每幅地图，我们使用随机生成的 S 和 G 对进行了 100 次搜索，搜索结果显示这两个位置之间存在有效路径。 八边形是指在 4 个直线方向和 4 个对角线方向上具有邻接关系的图块。垂直和水平转换的成本均为 1，对角线转换的成本设定为 1:42。宽度小于 6 的入口只有一个过渡。对于较大的入口，我们会生成两个过渡。 代码使用阿尔伯塔大学路径定位代码库 (http://www.cs.ualberta.ca/ògames/pathfind) 实现。该库被用作搜索工具，可使用不同的网格表示快速实现不同的搜索算法。由于其通用性，使用该库会产生一些开销。本文中报告的所有时间应被视为自定义实现的宽松上限。 定时在 800 MHz 奔腾 III 处理器和 3GB 内存上进行。程序使用 gcc 2.96 版本编译，并在 Red Hat Linux 7.2 版本下运行。 4.2 分析图 5 比较了在最大层级设置为 1、2 和 3 的层次结构上进行低层 A* 抽象搜索的情况。对于分层搜索，我们显示的是总工作量，其中包括在图中插入 S 和 G、在最高层搜索以及重新生成路径。实际花费可能更少，因为插入 S 或 G 的成本可以在多次搜索中摊销，而且路径重定并非总是必要的。从图中可以看出，当需要进行完整处理时，第一抽象层对于我们在本实验中使用的地图大小来说已经足够好了。我们认为，对于更大的地图，更多层次的好处会更显著。复杂度的降低可能会大于增加层级的开销。正如我们接下来所展示的，当不需要路径重构，并且 S 或 G 可用于多次搜索时，更多层次也是有用的。 尽管报告的时间是针对通用实现的，但值得注意的是，对于任何长度的解决方案，适当的抽象层次都能在平均不到 10 毫秒的时间内提供答案。在长度为 400 的情况下，在 800 MHz 的机器上每次搜索的平均时间不到 5 毫秒。 当解题长度很小时，A* 略优于 HPA。解长小通常表示搜索问题简单，A 只需付出较少的努力就能解决。在这种情况下，HPA* 的开销（例如插入 S 和 G 的开销）大于算法可能节省的费用。在这种情况下，使用欧几里得距离作为启发式提供了完美的信息，而 A* 除了那些属于解决方案的节点外，不会扩展其他节点。 图 6 显示了分层搜索的总耗费是如何由抽象耗费、插入 S 和 G 的耗费以及解决方案再改进的耗费组成的。查找抽象路径的成本是主要成本与插入 S 和 G 的成本之和。当 S 或 G 在多次搜索中重复使用时，只有部分成本计入问题的抽象成本。考虑到这些因素，图中显示，在层级较多的层次结构中，寻找抽象路径变得更加容易。 图 7 显示了解决方案的质量。我们将分层路径平滑得到的解决方案与低层 A* 计算出的最优解决方案进行了比较。我们绘制了路径平滑前后的误差。误差用百分比来衡量开销，计算公式如下：$$e = \\frac{hl - ol}{ol} \\times 100$$ 其中，hl 是用 HPA* 求得的解的长度，ol 是用 A* 求得的最优解的长度。误差与层次数量无关。唯一导致次优的因素是没有考虑入口的所有可能转换。 聚类大小是一个可以调整的参数。我们在性能测试中使用了大小为 10 10 的 1 个集群。该图显示了抽象搜索的平均扩展节点数是如何随着簇大小的变化而变化的。虽然主搜索随着簇大小的增加而减少，但插入 S 和 G 的成本增加得更快。 对于更高层次，一个 l 簇包含 22( l 1)个簇。我们使用这个较小的值，是因为当使用较大的值时，插入 S 和 G 的成本增加速度要快于主搜索的减少速度。这种趋势在相对较小的地图上尤为明显，在这种地图上，较小的簇就能实现良好的性能，而使用较大簇所增加的成本可能无法摊销。插入 S 和 G 的开销来自于必须将 S 和 G 连接到位于簇边界上的节点，簇边界越长，需要连接的节点就越多。我们对随机生成的地图进行了类似测试。主要结论类似，但由于篇幅有限，本文不再讨论细节。 5 Conclusions and FutureWork尽管分层路径定位非常重要，也做了大量工作，但有关商业游戏中分层路径定位的详细出版物并不多。 在本文中，我们提出了一种高效近优路径定位的分层技术。我们的方法与领域无关，易于应用，并且适用于不同类型的地图拓扑结构。该方法能适应动态变化的环境。层次结构可以扩展到多个抽象层次，因此可以扩展到大型问题空间。我们使用从areal game中提取的地图测试了我们的程序，获得接近最优解的速度明显快于低层次的A*。 我们为分层路径搜索的未来工作提出了一些想法。我们计划优化将 S 和 G 插入抽象图的方式。如图 6 所示，增加新的抽象层后，这些成本会显著增加。提高性能的一种策略是只将 S 连接到边界上的稀疏节点子集，以保持抽象图的完整性。例如，如果抽象图中的每个 “未连接 “节点（即我们没有尝试连接 S 的边界上的节点）都可以从 “已连接 “节点（即我们连接了 S 的边界上的节点）到达，那么就可以保持抽象图的完整性。另一种方法是只考虑连接在 G 方向上的边界节点。然而，最后一种方法并不能保证完备性，而且很难事先评估其优点。如果由于图的不完整性导致搜索失败，我们就必须重新进行搜索，并逐渐扩大边界节点的子集。 我们目前使用的聚类方法很简单，效果也不错。不过，我们还想探索更复杂的聚类方法。一种与应用无关的策略是自动最小化一些聚类参数，如抽象聚类的数量、聚类相互作用和聚类复杂性（如内部障碍物的百分比）。","link":"/2024/02/29/Near-Optimal-Hierarchical-Path-Finding/"},{"title":"Using the Hierarchical Pathfinding A Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost","text":"Using the Hierarchical Pathfinding A* Algorithm in GIS to Find Paths through Rasters with Nonuniform Traversal Cost在地理信息系统中使用分层寻路 A* 算法查找具有非一致遍历成本的栅格路径","link":"/2024/02/29/Using-the-Hierarchical-Pathfinding-A-Algorithm-in-GIS-to-Find-Paths-through-Rasters-with-Nonuniform-Traversal-Cost/"},{"title":"Voronoi diagram","text":"Voronoi diagram（维诺图）当弗莱大楼被设计为数学学院的新校舍时，我们希望能在其中加入与我们学科相关的公共艺术。于是，我们决定为新的玻璃中庭设计一个特别设计的遮阳板（brise-soleil）。 早在 1644 年，哲学家勒内-笛卡尔（René Descartes）就考虑过沃罗诺伊图，并以俄罗斯数学家乔治-沃罗诺伊（Georgy Voronoi）的名字命名。 这种图通过在欧几里得平面上随机散布点来创建。然后，平面被分割成棋盘格多边形，即所谓的单元格，每个点周围有一个单元格，由平面上靠近该点的区域组成。事实上，我们的沃罗诺伊图案是由一组三维点构成的，将空间划分为多面体。如果将多面体切开，就会看到一个由多边形组成的二维图案，而正是这个图案被用来创建屏幕。 沃罗诺图在数学以及其他各种学科中都有大量应用，例如动物领地建模或晶体生长。在 1854 年伦敦霍乱疫情中，医生约翰-斯诺利用根据水泵位置绘制的 Voronoi 图，计算每个多边形中的死亡人数，从而确定某个水泵是传染源。 它们也被称为狄利克雷图案（Dirichlet patterns）或方格网，单元也被称为泰森多边形（Thiessen polygons）。 早在职业生涯早期，布里斯托尔大学的彼得-格林教授就设计出了一种高效计算沃罗诺伊图的算法，这种算法可以应用于非常大的点集。这篇论文已被空间数据分析、空间插值和平滑、图像注册、数字地形建模、流行病和生态建模、材料科学、地理信息系统以及许多其他科学和技术领域的研究人员引用了 1000 多次。您可以阅读他的论文，了解更多信息： 计算平面中的 Dirichlet 网格（与 R. Sibson 合著），《计算机杂志》，21，168-173（1978 年） 思想将一个有 n 个点的平面分割成凸多边形，使得每个多边形都包含一个生成点，并且给定多边形中的每个点都比其他点更靠近其生成点。Voronoi 图有时也称为 Dirichlet 细分图。这些单元被称为 Dirichlet 区域、Thiessen 多面体或 Voronoi 多边形。 早在 1644 年，勒内-笛卡尔（René Descartes）就考虑过沃罗诺伊图，迪里赫特（Dirichlet，1850 年）在研究正二次型时也使用过沃罗诺伊图。沃罗诺伊（Voronoi，1907 年）也对其进行了研究，并将沃罗诺伊图的研究扩展到了更高维度。它们广泛应用于计算机制图、流行病学、地球物理学和气象学等领域。约翰-斯诺（John Snow）医生在分析 1854 年伦敦霍乱疫情时发现，死亡人数与是否靠近布罗德街的一个特定（受感染）水泵密切相关（斯诺，1854 年；斯诺，1855 年）。在分析过程中，斯诺绘制了一张地图，并在地图上画了一条标有 “布罗德街水泵与其他水泵之间距离相等的边界 “的线。这条线基本上表示了布罗德街水泵的沃罗诺伊单元（奥斯汀，2006 年）。不过，关于这一民间传说史中有关斯诺和伦敦霍乱事件的描述中一些过度简化和错误归因的分析，请参见 Field (2020)。 在实数集中的 Delaunay 三角剖分和 Voronoi 图在图论意义上互为对偶。 定义在数学中，沃罗诺依图是将一个平面划分为与一组给定对象中的每个对象相近的区域。它也可以被归类为镶嵌图。在最简单的情况下，这些对象只是平面上的有限多个点（称为种子、点或生成器）。每个种子都有一个相应的区域，称为沃罗诺伊单元，由平面上所有比其他任何点都更靠近该种子的点组成。==一组点的沃罗诺伊图与该组点的 Delaunay 三角剖分图是对偶的。== Voronoi 图以数学家 Georgy Voronoy 的名字命名，也称为 Voronoi 细分图、Voronoi 分解图、Voronoi 分割图或 Dirichlet 细分图（以 Peter Gustav Lejeune Dirichlet 的名字命名）。Voronoi 单元也被称为 Thiessen 多边形，是以 Alfred H. Thiessen 命名的。[1][2][3] Voronoi 图在许多领域都有实际和理论应用，主要是在科学和技术领域，但在视觉艺术领域也有应用。","link":"/2024/02/24/Voronoi-diagram/"},{"title":"Visibility graph","text":"Visibility Graph定义在计算几何和机器人运动规划中$^{[1]}$，可见度图是一组相互可见的位置图，通常是欧几里得平面上一组点和障碍物的位置图。图中的每个节点代表一个点位置，每条边代表它们之间的可见连接。也就是说，如果连接两个位置的线段不经过任何障碍物，则在图中它们之间画一条边。当地点集位于一条线上时，这可以理解为一个有序序列。因此，可见度图被扩展到时间序列分析领域。 应用可见度图可用来寻找平面上一组多边形障碍物之间的欧氏最短路径：两个障碍物之间的最短路径除了在障碍物的顶点处可能转弯外，都是沿着直线段走的，因此欧氏最短路径就是以起点、终点和障碍物顶点为节点的可见度图中的最短路径$^{[2]}$。 因此，欧氏最短路径问题可分解为两个更简单的子问题：构建可见度图，以及对可见度图应用最短路径算法（如 Dijkstra 算法）。对于与障碍物相比体积不可忽略的机器人的运动规划，也可以采用类似的方法，在扩展障碍物以补偿机器人的体积后再进行规划$^{[2]}$。 Lozano-Pérez &amp; Wesley (1979) 将欧几里得最短路径的可见度图法归功于 1969 年 Nils Nilsson 对机器人 Shakey 运动规划的研究，并引用了 1973 年俄罗斯数学家 M. B. Ignat’yev、F. M. Kulakov 和 A. M. Pokrovskiy 对该方法的描述。 可视图还可用于计算无线电天线的位置，或通过可视图分析作为建筑和城市规划的工具。 位于一条直线上的一组位置的可视图可以解释为时间序列的图论表示[3]。这种特殊情况在时间序列、动力系统和图论之间架起了一座桥梁。 特点简单多边形的可见度图以多边形的顶点为点位置，多边形的外部是唯一的障碍物。简单多边形的可见性图必须是哈密顿图：多边形的边界在可见性图中形成一个哈密顿循环。众所周知，并非所有可见性图都能诱导出简单多边形。然而，简单多边形可见性图的高效算法特征描述仍然未知。这些图不属于许多已知的结构良好的图族：它们可能不是完美图、圆图或弦图$^{[4]}$。这种现象的一个例外是，简单多边形的可见性图是共赢图$^{[5]}$。 相关问题艺术画廊问题是指找到一小组点，使所有其他非障碍点都能从这组点上看到的问题。艺术画廊问题的某些形式可以解释为在可见度图中寻找支配集。 多边形或曲线系统的位切线是接触其中两条多边形或曲线而不穿透其接触点的直线。一组多边形的位切线构成可见度图的一个子集，可见度图以多边形的顶点为节点，以多边形本身为障碍物。由于欧氏最短路径只能沿着一条位切线进入或离开障碍物的边界，因此用可见度图法来解决欧氏最短路径问题，可以加快速度，因为可见度图是由位切线组成的，而不是使用所有可见度边$^{[6]}$。","link":"/2024/02/24/Visibility-graph/"},{"title":"Hierachical A: Searching Abstraction Hierarchies Efficiently","text":"Hierarchical A*： Searching Abstraction Hierarchies Efficiently Abstract在搜索、问题求解和规划中，抽象的作用是用另一个更容易搜索的状态空间（”抽象 “空间）来替代一个状态空间。抽象空间的搜索结果用于指导原始空间的搜索。例如，抽象解的长度可以作为 A* 在原始空间中搜索的启发式。然而，要有效地实现这一点有两个障碍。第一个障碍是一个定理（Valtorta，1984 年），该定理指出，对于一大类抽象，即 “嵌入抽象”，在用这种方法计算 A* 的启发式时，盲搜索扩展的每个状态也必须被 A* 扩展。第二个障碍产生的原因是，A* 在计算启发式时，需要反复对抽象空间进行全面搜索。本文介绍了一种新的由抽象引起的搜索技术–”分层 A* “，它能同时解决这两个难题：首先，它从不同的抽象类别–”同态抽象”–中汲取灵感；其次，它使用新颖的缓存技术，避免在抽象空间的连续搜索中重复扩展相同的状态。在所研究的所有搜索空间中，分层 A* 均优于盲搜索。 Introduction有几位研究者将抽象作为自动创建可接受的启发式A*搜索的一种手段进行了研究（Gaschnig, 1979; Pearl, 1984; Prieditis, 1993; Guida &amp; Somalvico, 1979）。总体思路是将状态空间 SS 中从状态 S 到目标 G 的距离估计值 h(S)，等同于另一个状态空间 SS’ 中从 SS’ 中对应于 S 的状态到对应于 6 的状态的精确距离，SS’是 SS 的 “抽象”。只要 SS 中每对状态之间的距离都大于或等于 SS’ 中相应状态之间的距离，以这种方式定义的 h(S) 就是一种可接受的启发式。普里迪蒂斯（Prieditis,1993）在 “抽象变换 “的定义中正式提出了这一观点，具体如下。 状态空间 “是一对 &lt;States,d&gt;，其中 States 是一组状态，d(S,,S,) 是两个状态之间的距离（最短路径的长度）（如果从 S, 到 S, 之间没有路径，则 d(S,,S,) = 00）；”问题 “是一对 &lt;Start,Goal&gt;，其中 Start 是一个状态，Goal 是一个（组）状态’。给定状态空间 SS = &lt;States&amp; 和 SS’= &lt;States’,d’&gt;, 一个映射 @： 如果 SS 中的每个距离都小于或等于 SS’ 中相应的（根据 @）距离，那么（SS 的）States + States’ 映射就是抽象变换。形式上：d’（#（S,）,#（S,）) I d(S,,S,) for all S,, S, E States. 给定 SS 的问题 &lt;Start,Goal&gt;，SS’的相应问题为 &lt;@tart),Goal’&gt;，其中 Goal’ 2 {H(g) I g E Goal}。通常我们会提及 @(SS)，而不指定 SS’。在这种情况下，SS’ 被隐含为 cimage#,d#&gt;，其中 image@= {K(s) I s E States} 和 d#(S;,S;) = min { d(s, ,s.J I #(st) = S; and @(sZ)= S;} 。 最早也是最常研究的抽象变换类型是 “嵌入”。非正式地讲，如果 @ 为 SS “添加了边”，那么它就是一种嵌入变换。例如，在状态空间定义中添加宏运算符或删除先决条件的技术就是嵌入。从形式上看，如果 SS’ 是 SS 的超图，即 States’ 2 States，且 g(s)= S 适用于所有 S E States，那么 @ 就是一种嵌入。因为 SS 中的所有状态和边（代价相同）都存在于 SS’ 中，所以 SS’ 中的距离不可能比 SS 中的相应距离长。因此，任何嵌入都是一种抽象变换。嵌入是（Gaschnig，1979；Pearl，1984；以及 Guida &amp; Somalvico，1979）中研究的一种转换类型。 抽象转换的另一种主要类型是 “同态”（”自然转换 “的同态）（Kibler，1982）。非正式地讲，同态 4 是将 SS 中的几个状态组合在一起，形成一个抽象状态。例如，从状态空间描述中完全删除谓词的技术（Knoblock, 1994）就是同构。从形式上看，如果 @ 是 SS 状态的多对一映射，那么如上定义的 $(SS) 就是 SS 的同构。 创建启发式的目的是加快搜索速度。如果没有启发式，A* 就会盲目地在原始空间中搜索。有了启发式，A* 的搜索就会更有针对性，在原始空间的搜索努力就会减少一些（”节省”）。使用通过抽象创建的启发式的主要风险在于，在搜索过程中计算 h(-) 的总成本可能会超过节省的成本。如果出现这种情况，启发式的使用就是有害的：计算启发式的成本超过了使用启发式的收益。 Valtorta, l984）中对通过嵌入变换自动生成的启发式方法进行了成本效益分析。 (Valtorta，l984）。结果证明，如果 SS 嵌入 SS’，而 h(-) 是通过在 SS’ 中盲目搜索计算出来的，那么使用 h(-) 的 A* 将扩展直接在 SS 中盲目搜索所扩展的每一个状态。换句话说，这种定义启发式的方法不可能加快搜索速度–使用启发式扩展的节点（状态）总数（包括在抽象空间中扩展的节点）必须等于或超过在原始空间中盲目搜索时扩展的节点（状态）总数。根据这一定理，我们将 “瓦尔托尔塔障碍 “定义为在空间中盲目搜索时扩展的节点数。瓦尔托尔塔定理指出，使用任何嵌入变换都无法 “打破 “这一障碍。 瓦尔托塔定理并不排除使用其他类型的变换来打破瓦尔托塔障碍的可能性。不过，迄今为止，瓦尔托塔障碍只被突破过两次。Absolver II（普里迪蒂斯，1993年）通过使用同态变换，为与 “傻瓜磁盘 “和 “瞬间精神错乱 “谜题相关的状态空间（和特定目标）创建了具有成本效益的启发式方法。在 Absolver II 应用的其他 11 个问题中，抽象本身无法创造出具有成本效益的启发式（其中 5 个问题的成本效益启发式是在抽象与其他类型的状态空间变换一起使用时创造出来的）。 在本文中，我们展示了利用通用同态抽象技术可以在多种搜索空间上打破 Valtorta 障碍。首先，我们提出了适用于所有类型抽象转换的 Valtorta 定理的广义版本。该定理提供了使用任何抽象变换必须扩展的节点数量的下限。对于同态变换，该界限低于在原始空间中盲目搜索所扩展的节点数。这表明，同态抽象至少在原则上有可能打破瓦尔托尔塔的障碍。不过，我们的初步实验结果表明，仅仅抽象是同态的这一事实，并不能保证能创造出具有成本效益的启发式方法。我们发现，使用同态抽象层次结构进行搜索所扩展的状态比盲目搜索多得多，在一个测试平台的搜索空间中，盲目搜索扩展的状态是盲目搜索的 17 倍。我们找出了造成这些负面结果的原因，并提出了两种缓解问题的互补方法。第一种是算法方法。对 A* 算法进行了定制，以便在抽象层级中进行搜索。定制版本称为分层 A，扩展的状态比原始 A 少大约 6 倍，并在大约一半的测试平台搜索空间中突破了 Valtorta 的障碍。第二种方法是创建精细度较低的抽象。这也打破了 Valtorta 在部分测试平台搜索空间的障碍。当两种方法结合使用时，所有测试平台搜索空间的瓦尔托塔障碍都会被打破。 Valtorta’s Theorem GeneralizedValtorta, l984）中的主要定理是针对嵌入的，但很容易推广到任何抽象变换。广义的定理是（正式的陈述和证明见 (Holte et al., 1995)）： 让 $\\phi$ 是状态空间 SS 到 SS’ 的任意抽象映射，$h_{\\phi}(S)$ 是 SS’ 中从 $\\phi(s)$到 $\\phi(goal)$ 的最短路径长度（通过在 SS’ 中盲查计算）。如果 S 是直接在状态空间 SS 中通过盲搜索求解给定问题时必然扩展的任何状态，那么在 SS 中使用带有 $h_{\\phi}(-)$ 的 A* 搜索求解问题时，要么 S 本身被扩展，要么 $\\phi(s)$ 被扩展。 当 $\\phi$ 是一个嵌入时，$\\phi(S)=S$，我们就得到了瓦尔托尔塔定理：盲搜索必然扩展的每个状态也必然被使用 h 的 A* 扩展，但如果 $\\phi$ 是一个同态，加速是可能的，因为抽象空间中一个状态的扩展等同于原始空间中许多状态的扩展。 一个简单的例子说明，基于同态抽象的启发式方法确实可以大大减少扩展节点的数量。假设状态空间 SS 是一个 n x n 网格，要解决的问题是从左下角 (1 ,l) 到右下角 (n,l)。要通过盲搜索解决这个问题，必须扩展距离 (n-l) 或更小的所有状态，因此要扩展 $O(n^2)$ 个状态。假设 $\\phi$ 是忽略第二个坐标的映射。那么，$\\phi(SS)$ 是一个线性空间，包含 (l)、(2)、……(n)个状态。 计算 $h_{\\phi}(Start)$ 需要在 $\\phi(SS)$ 中找到一条从（1）到（n）的路径。在这一搜索过程中会扩展 O(n) 个状态，但注意这一搜索会生成所有 S 的 $h_{\\phi}(s)$ 值，因此无需在抽象空间中做进一步搜索。此外，这个特定抽象定义的 $h_{\\phi}(-)$ 是一个完美的启发式，因此在 SS 中的搜索只会扩展解路径上的那些状态。因此，A* 使用 $h_{\\phi}(-)$ 扩展的节点总数为 O(n)，远远少于盲搜索扩展的 $O(n^2) $个节点。 Hierarchical Search using A*在当前的系统中，抽象状态是通过（Holte et al.，1996）中描述的 “最大度 “STAR 抽象技术创建的。这种技术非常简单：将度数最大的状态与一定距离（”抽象半径”）内的相邻状态组合在一起，形成一个抽象状态。如此反复，直到所有状态都被分配到某个抽象状态。这样就建立了一个抽象层级，这个过程不断重复，直到建立了一个只包含一个状态的层级。这就形成了一个抽象层级，其顶层就是三维搜索空间。层次结构的底层或 “基础 “层就是原始的搜索空间。这种创建抽象的方法最初是为被称为 “细化 “的搜索技术而设计的，并被证明是非常成功的（Holte 等，1996；Holte 等，1994）。在目前的工作开始时，还不完全清楚它是否能创建适合 A* 搜索的抽象层次。它当然不适合抽象出不同算子具有不同代价的搜索空间，但在本文的实验中并没有出现这种考虑。 A* 的实现是标准的，只是在估算从非目标状态 S 到目标的距离时，除了使用其他可能可用的启发式估算之外，还使用了适用于 S 的算子的最小成本。当有多个启发式信息来源时，会通过取最大值的方式将它们结合起来。如果单个启发式信息是可接受的，那么这种组合多个启发式信息的方法就保证是可接受的，但即使单个启发式信息是可接受的，这种方法也可能不是单调的（相反的例子见下一节）。然而，我们不难发现，如果每个算子都有相同代价的倒数，那么将最小算子代价与任何单调启发式相结合就会产生单调启发式，我们实验中的搜索空间就是这种情况。 当没有其他启发式估计时，”最廉价算子 “信息最为有用（盲探： 对于所有 S，A* 的 h(S)=0）。在这种情况下，使用 “最廉价算子 “可以大大减少扩展节点的数量。当有其他启发式估计时，”最廉价算子 “信息只对其他方法估计的非常接近目标的状态有用。 使用 A* 进行分层搜索非常简单。像往常一样，在 A* 搜索的每一步，一个状态都会从 OPEN 列表中移除，而它的每个后继状态都会被添加到 OPEN 列表中（如果它之前没有被打开过）。要将一个状态 S 加入 OPEN 列表，必须知道 h(S)。h(S) 的计算方法是在下一个更高的抽象层次进行搜索，使用与 S 对应的抽象状态 KS) 作为抽象起始状态，$\\phi(goal) $作为抽象目标。找到抽象解路径后，就知道了从 $g(s)$ 到 $\\phi(goal)$的确切抽象距离。如前文所述，这将与其他估计值（如适用于 S 的最便宜算子的成本）相结合，得出最终的 $h(S)$ 值。 当找到从 $\\phi(s) $到 $\\phi(goal)$ 的抽象路径时，这条路径上所有抽象状态的精确抽象距离到目标信息都是已知的。一般来说，每个抽象状态都对应着 “下一层”（包含 S 的状态空间）中的许多状态。因此，一次抽象搜索会对许多状态产生启发式估计。所有这些信息都被缓存起来。如果需要这些状态中任何一个状态的 h 值，只需简单查找即可，无需在抽象层进行任何搜索。尽管有这种缓存技术，但一般来说，要解决一个基础层问题，分层搜索技术需要解决许多抽象层问题。而这些抽象问题中的每一个都需要解决下一个抽象层次的许多问题，等等。解决单个基础层问题所扩展的节点数是在所有抽象层次（包括基础层本身）与该基础层问题相关的所有搜索过程中扩展的状态总数。 刚刚描述的分层搜索技术将被称为原始分层 A* (navie hierarchical A* )，以与下一节介绍的版本形成对比。我们在 8 个状态空间上对各种分层 A* 技术进行了经验评估（见 Holte 等人，1995 年）。所有算子都是可逆算子，应用所有算子的代价都是相同的 (1)。每个状态空间的测试问题都是随机选择 100 对状态生成的。每对状态 &lt;Sl,S2&gt; 都定义了两个要解决的问题： $&lt;start=S1,goal=S2&gt;$ 和 $&lt;start=S2,goal=Sl&gt;$。为了便于详细比较，每次实验都使用了相同的 200 个问题。显示的 “节点扩展 “结果是这 200 个问题的平均值。 在每个测试平台搜索空间中，天真分层 A* 扩展的状态都比盲法搜索多得多（见表 1）。要理解为什么会出现这种情况，关键在于天真分层 A* 扩展的状态比整个抽象分层中的状态多得多（表 1，第二列）。这意味着在解决单个基础层问题的过程中，某些状态被扩展了很多次。由于采用单调启发式的 A* 不会在一次搜索中重复扩展相同的状态，因此重复扩展一定是由于在与同一基础层搜索相关的多次不同搜索中扩展了相同的状态。下一节将介绍大大减少这种重复的方法。 分层 A* 在基础层中扩展的节点数是 A* 在给定抽象层级下所能达到的提速的基本限制。这个数字表示启发式的质量，即启发式能在多大程度上减少原始空间的搜索工作量。例如，在 Permute-6 搜索空间中，分层 A* 在基础层中扩展了 77 个状态，比盲目搜索扩展的数量减少了 75%。这只是微不足道的节省。但这是表 1 中最好的启发式方法。另一个极端是为 “传教士与食人族 “搜索空间创建的启发式（MC 60-40-7），它只节省了 25%。启发式搜索的质量是抽象技术的属性，只能通过使用不同的抽象技术来提高。除了改变抽象的粒度外，这一主题超出了本文的范围。 目前的抽象技术所产生的启发式搜索只能适度减少在基础层上扩展的节点数，这使得打破瓦尔塔障碍变得尤为困难。为了突破这一障碍，所有抽象搜索所扩展的节点总数必须少于启发式搜索所节省的数量。例如，考虑 5 字谜。通过抽象产生的启发式结果是 A* 在底层扩展了 224 个状态，比盲目搜索节省了 124 个状态。为了打破瓦尔托塔的障碍，为所有这 224 个状态（以及被打开但从未关闭的额外状态）计算启发式的成本（以在所有抽象层次扩展的节点计）不得超过 124。这并非不可能：如上例所示，在抽象层次扩展几个状态，就能为基础层的许多状态提供启发式值。 Customizing A* for Hierarchical Search在分层搜索中，一个基础层级的搜索可能会产生大量抽象层级的搜索。如前面的结果所示，这些搜索通常会扩展许多相同的状态。减少这种重复的关键在于观察到与同一基础层搜索相关的所有搜索都具有相同的目标。天真分层 A* 的简单缓存策略在很小程度上利用了这一观察结果，因为它在特定抽象层次的缓存直到该层次的目标发生变化时才会被清除。表 1 中的结果表明，如果要使分层 A* 有效，还需要更多利用这一观察结果的方法。 当抽象层次的搜索结束时，已知求解路径上每个抽象状态 S 到目标的确切距离 h* (S)。这一信息可以被缓存起来，并在后续相同目标的搜索中代替 h(S)。这样可以提高启发式在这一抽象层次的质量，从而减少后续搜索所扩展的节点数量。这种技术被称为 h* 缓存。从表 2（第 Vl 列）中可以看出，这大约将扩展节点的数量减少了一半。 由 h* 缓存产生的启发式并不是单调的。例如，假设所有算子的代价都是 1，并且所有非目标状态的 h(S)=1 。在解决了一个问题并缓存了 h*(-) 值后，求解路径上的状态可能会有相当大的 h(-) 值，而它们在求解路径之外的相邻状态仍会有 h(-)=1 值。因此，相邻 h(-) 值之差将大于 1，即两个状态之间的 “距离”。因此，新的 h(-) 函数不符合单调性的定义。 由于 h(-) 函数不是单调的，因此有可能过早地关闭一个状态，即在找到从起始状态到该状态的最短路径之前就关闭了。一般来说，使用非单调启发式算法时，为了保证找到最短路径，有必要重新打开此类状态。然而，对于 h* 缓存所产生的非单调启发式来说，这并不是必须的，事实上，我们的 A* 实现并没有重新打开封闭状态的规定。为了说明这一点，让 S 作为起始状态，P 作为过早关闭的状态。要使 P 提前关闭，必须是 h* (P)是未知的，而且从 S 到 P 的每条最短路径都要经过某个状态 X，而 h* (-)是已知的。如果在任何从 S 到目标的最短路径上都没有这样的 X，那么 P 也不存在，所以 P 的过早关闭就无关紧要了。另一方面，假设从 S 到目标的最短路径经过这样一个 X。h* (X) 已知这一事实意味着在之前的搜索中 X 在解路径上，因此之前发现了一条从 X 到目标的最短路径。这条路径上的每个状态 h*(-) 都是已知的。因此，在当前搜索中，这些状态都没有被扩展，所以从 S 到目标的这段最短路径将被找到，而无需重新打开任何封闭状态。 如前所述，对于已知 h*(X)的每个状态 X，从 X 到目标的最短路径也是已知的。如果除了 h* (X)之外还缓存了这条路径，就没有必要再扩展 X 了。这是因为知道了一条长度为 g(X)到 X 的路径，就等于知道了一条长度为 g(X)+h* (X) 到目标的路径。因此，我们可以将目标添加到 OPEN 列表中，而不是将 X 添加到 OPEN 列表中，然后像往常一样，当目标位于 OPEN 列表顶端时终止搜索。这种技术称为最优路径缓存。表 2 中第 V2 列显示了在天真分层 A* 中添加最优路径缓存时扩展的节点数。最优路径缓存比 h* 缓存节省了大约一倍的时间，并打破了 Valtorta 在 Permute-6 搜索空间中的障碍。 最后一项技术与搜索过程中打开（或关闭）但不在求解路径上的状态有关。对于每个这样的状态 S，我们都知道它与起点的距离 g(S)。如果求解路径的长度为 P，那么根据其最优性，必须是 P I g(S) + h* (S)。将其重排为 P-g(S) I h* (S)，我们可以看到 P-g(S)是一个可接受的启发式，我们称之为 P-g 启发式。当所有算子都有反函数时，可以证明（Holte 等人，1995 年）P-g 启发式与任何单调启发式结合都会产生一个单调启发式。P-g 缓存包含 h* 缓存，因为当 S 在求解路径上时，P-g(S) = h*(S)。最后，如果搜索终止时 S 是开放的，则无需计算 P-g(S)，因为在这种情况下 P 5 g(S)+h(S) 因此 P-g(S) I h(S)。 情况 P 5 g(S)+h(S)，因此 P-g(S) I h(S)。系统 V3 包括最优路径缓存和 P-g 缓存。在用于测试的 8 个搜索空间中，它有 5 个突破了 Valtorta 的障碍（表 2 中的粗体数字）。这表明，通过同态抽象，可以在实践中实现 Varying the Granularity of Abstraction我们的抽象技术允许我们通过设置抽象半径来控制所创建抽象的粒度。前面的结果是在抽象半径为 2 的情况下得出的，这意味着一个状态与其近邻状态分组。增加抽象半径对 “节点扩展 “的净影响并不明显，因为有两种相互对立的影响。一方面，半径越大，意味着抽象空间中包含的状态越少；另一方面，单次抽象搜索会产生更多状态的启发值。这些因素将减少分层 A* 扩展的抽象节点数量。另一方面，半径越大，启发式的区分度就越低：这往往会增加扩展节点的数量（如果启发式完全没有区分度，A* 就会退化为盲目搜索）。(Prieditis &amp; Davis, 1995）对 “抽象性”（即粒度）与启发式搜索结果的准确性之间的关系进行了初步的定量分析。 实验中，抽象半径设置为 2 到 5，某些搜索空间的抽象半径设置为更大。分层 A* 扩展的节点数随着半径的增大而减少，直到达到最小值；半径超过该值后，扩展的节点数会增加。表 3 显示了 V3 为每个搜索空间找到的最佳半径结果（天真分层 A* 的最佳半径有时更大）。现在，在每个搜索空间中，V3 在一半以上的问题上都突破了 Valtorta 的障碍（在其中两个搜索空间中，V3 在 95% 以上的问题上都突破了 Valtorta 的障碍）。 虽然最佳半径相当小，但在每种情况下，它们都占搜索空间直径的很大一部分。由此创建的抽象层次结构只有一个非三维抽象层，而且只包含少量状态。令人惊讶的是，如此粗略的启发式竟然能够减少扩展节点的数量。 只有一个小的非难抽象层次的后果是，上述算法改进的效果大打折扣：在几个空间中，天真的分层 A* 扩展的状态只比 V3 稍多一些。然而，算法改进之所以重要，是因为大多数创建抽象的技术都无法轻松控制所生成抽象的粒度。与天真层次 A* 不同的是，V3 具有很强的鲁棒性：它在任何粒度的抽象上都有很好的表现，因此是粒度无法控制时的首选搜索算法。 “节点扩展 “是一种方便的理论测量方法，但它并不能完全反映搜索系统所做的所有 “工作”，尤其是分层系统，因为它必须在抽象层级上反复初始化搜索，并将信息从一个层级传递到下一个层级。搜索系统的实际速度取决于所有这些操作。表 3 列出了盲搜索和 V3 解决所有 200 个问题所需的 CPU 时间。当然，在解释 CPU 时间结果时必须非常谨慎，因为它们可能会受到底层实现细节的严重影响。在目前的实现中，许多底层细节都相当笨拙，但 V3 所减少的节点扩展量似乎几乎完全抵消了分层搜索所带来的额外开销。 为了最大限度地减少分层搜索的开销，并在更大的状态空间和不同的同态抽象方法上评估分层 A* ，我们最近重新实施了分层搜索和缓存技术。该系统中的抽象是由用户提供的，而不是自动创建的，但到目前为止，我们还没有尝试对抽象进行优化，因为我们的目标是在 “典型 “抽象上评估 Hierarchical A* 。新实施的初步结果证实了表 3 所示的节点扩展结果的一般模式：在某些空间中，扩展的节点数量显著减少，而在其他空间（如河内塔）中，V3 扩展的节点数量则略有减少。不过，CPU 时间的结果却有很大改进。例如，在 &amp;puzzle 中，V3 将 CPU 时间减少了 10 倍（将扩展的节点数减少了 6.5 倍）。 Conclusion在本文中，我们证明了使用同态抽象自动创建的启发式 A* 搜索可以 “打破瓦尔托尔塔的障碍”，即在扩展节点数量方面优于盲搜索。这一点在实验中使用的所有状态空间中都得以实现。为了实现这一目标，有必要在 A* 中添加两种新的缓存技术，即最优路径缓存和 P-g 缓存，在某些情况下，还需要选择适当粒度的抽象。所扩展的节点数量减少不多，但这是由于抽象技术的限制，而不是由于算法开销过大。开发一种非常适合分层 A* 搜索的抽象技术是今后研究的一个重要课题。","link":"/2024/03/03/Hierachical-A-Searching-Abstraction-Hierarchies-Efficiently/"},{"title":"The Grid-Based Path Planning Competition 2014 Entries and Results","text":"The Grid-Based Path Planning Competition: 2014 Entries and Results Abstract基于网格的路径规划竞赛刚刚完成了第三次迭代。在此期间，竞赛中使用的参赛作品有了显著改进，改变了人们对网格寻路技术现状的看法。此外，大赛的参赛作品已经公开，提高了研究人员比较其工作的能力。本文总结了 2014 年竞赛的参赛作品，介绍了 2014 年的竞赛结果，并讨论了所学到的知识和有待改进的地方。 Introduction and Background基于网格的路径规划是一个被广泛研究的课题，在许多应用领域都有大量已发布的方法。多年来，该领域的工作缺乏广泛分布的标准基准问题来比较工作，也缺乏标准实现来比较工作质量。本文的第一作者致力于解决这两种情况：（1）引入各种标准基准问题，用于测试在基于网格的地图上运行的程序；（2）发起基于网格的路径规划竞赛（GPPC）。 引用次数表明，寻路基准已被广泛采用。(关于基准集中每张地图的来源，请参见（Sturtevant 2012）。GPPC 竞赛已举办过三次，分别在 2012 年、2013 年和 2014 年。在此期间，参赛作品的性能有了显著提高，对基于网格的地图结构的理解也有了改进。 本文详细介绍了竞赛采用的方法以及 2014 年竞赛的结果。随后，2014 年参赛作品的作者分别介绍了他们的参赛作品。论文最后讨论了竞赛和基于网格的寻路研究的未来方向。 Competition Setup竞赛的目的是对各种问题实例和各种地图大小进行实验。 GPPC 在一组 132 幅地图上运行，这些地图来自多个地图来源。表 1 列出了每组地图的来源以及每组地图的数量。竞赛中的地图样本如图 1 所示。 在 2012 年比赛之前，《龙腾世纪 2》中的地图尚未公开。这些地图已在 GPPC 竞赛中使用，但尚未作为通用在线寻路地图库的一部分发布，尽管今后有计划这样做。《星际争霸》和《龙腾世纪：起源》中的地图是寻路地图库的一部分；并使用了为这些地图创建的标准问题，尽管这些只是全部可用地图中的一小部分。随机地图、房间地图和迷宫地图都是人造的。这些地图的大小从 100 × 100 到 1550 × 1550 不等。随机地图中正好有 33% 的单元格被屏蔽，然后除了地图中最大的连接部分外，其他所有单元格都被移除，每张地图中大约又有 5% 的单元格被移除。房间地图包含的房间面积为地图面积的 10%。最初，所有房间都是封闭的，但房间之间的门会随机打开。当墙壁被打开时，墙壁中 1/8 的单元格会被随机解封。图 1 显示了 (a) 100 × 100 地图中的 10 × 10 房间和 (b) 400 × 400 地图中的 40 × 40 房间。迷宫地图的走廊尺寸是地图一维尺寸的 1%。因此，100 × 100 地图上的走廊尺寸为 1，800 × 800 地图上的走廊尺寸为 8。图 1 显示了（c）100 × 100 迷宫的一部分和（d）400 × 400 迷宫的一部分。 测试问题是随机选择的。问题按照最优解的长度除以 4 分成若干个桶。 因此，所有最优解长度为 [4, 8) 的问题都在同一个桶中。每个桶选出 10 个问题，每个地图的桶数由特定地图的路径长度决定。迷宫地图上的问题较多，因为迷宫中的路径非常长。《龙腾世纪 2》中的一些地图相对较小，因此即使地图数量较多，每张地图的问题数量也比其他地图少。 每个地图源的地图尺寸分布见图 2。从最大到最小，地图大小在 4 个数量级以上。较小的地图来自《龙腾世纪》游戏，而较大的地图则来自《星际争霸》和人造地图。 Experimental Setup为确保比赛结果不会受到 CPU 时序变化的过度影响，我们在每个参赛作品上运行问题集 5 次。参赛项目必须实现一个简单的接口，用于预计算地图数据、加载预计算数据以及在地图上进行路径计算。所有条目在运行前都要进行预计算。重复运行并不是连续的，因此前一次运行的数据不会在随后的运行中进入缓存。条目可以选择一步返回整个路径，也可以逐步返回，从而创建一个可以交错规划和移动的实时智能体。 在历年的比赛中，实验都是在同一台机器上进行的，这台服务器配备了双处理器四核至强 E5620，主频为 2.4Ghz，内存为 12GB。求解过程使用顺序 API，但预处理可以并行进行。 根据不同的领域，有大量有趣的指标可以确定最佳入口。我们并不设定特定的效用函数来确定最佳入口，而是寻找非优势入口的帕累托最优前沿。这样，实践者就可以自己分析数据，选择最适合自己应用的方法。 衡量标准包括： 总时间（秒）： 这是找到所有问题的解决方案所需的总时间。 平均时间（毫秒）： 这是查找单条路径的平均时间（毫秒）。 20 步（毫秒）： 这是找到路径前 20 步的平均时间（毫秒）。这可以衡量可跟踪路径的速度，在游戏或机器人等实时应用中非常重要。 最大线段（毫秒）： 这是生成路径中任何单独网段所需的最长时间的平均值。这衡量的是最差情况下的实时性能。 平均长度： 这是返回路径的平均长度。如果一个条目在长路径上是最优的，而在短路径上是次优的，那么它将接近平均长度，因为大部分长度来自最长的路径。 次优化： 这是每条路径的平均次优度。如果一个条目在长路径上是最优的，而在短路径上是高度次优的，那么由于大多数路径都是短路径，因此这个指标会很大。 解决数量： 这是 347，868 ∗ 5 = 1，739，340 个问题中已解决的问题总数。 无效： 这是返回的无效解决方案的数量，这些解决方案的路径并不完整（例如，返回路径中的相邻位置在地图上并不相邻）。 未解： 这是未解决、无解决方案的问题数量。 内存（之前）： 这是加载预计算数据后的内存使用量（以 MB 为单位）。 内存（后）： 这是运行全部问题集后的内存使用量（以 MB 为单位）。这包括用于存储结果的内存，因此所有条目的内存使用量都被人为夸大了。 存储空间： 这是用于所有预计算存储的磁盘空间。 预计算时间： 这是全部预计算所需的时间（分钟）。执行并行预计算的条目会在下一节的结果表中用 † 标记。 最初的 GPPC 竞赛限制了 RAM 和预计算时间，但后来取消了这些限制，使参赛作品更加多样化，但代价是在竞赛期间需要更多的计算。 2014 年共有 6 个团队的 14 个程序参赛1 。下文将对这些参赛项目进行详细介绍，但参赛项目有几个高层次的趋势。首先，我们看到新参赛者大量重复使用代码。这降低了参赛门槛，使参赛者可以从以前最好的作品开始。以往参赛作品的可用性也有助于在比赛之外进行实验比较。接下来，我们可以将参赛作品分为几种高级方法。这些方法包括 Faster A implementations。过去，这包括伪优先队列等工作。今年该类别有两个参赛作品，分别是 Relaxed A (RA ) 和桶式开放列表版 A* （ bucketed open list version of A*） 。 Grid Exploitation. 有几个项目专门致力于利用网格中存在的结构。其中包括基于跳点搜索（Harabor 和 Grastien，2011 年）和子目标图（Uras 和 Koenig，2014 年）的条目。这些技术密切相关，但全面描述它们之间的关系超出了本文的范围。 Compressed All Pairs Shortest Paths. 压缩路径数据库是压缩全对最短路径数据的第一种方法（Botea，2012 年）。今年有两个基于单行压缩（SRC）的新条目。 Other approaches。子目标方法包含了收缩层次法（Geisberger 等人，2008 年）的一些理念；今年我们也有一个收缩层次法参赛。在往年的比赛中，也出现了一些次优方法。 2014 Competition Results竞赛的全部结果见表 2。用粗体字标出的参赛作品是那些不被其他参赛作品所支配，形成帕累托最优边界的作品。也就是说，它们至少在一项指标上的表现优于所有其他参赛作品。这些条目的粗体指标是它们不占优势的指标。看完总体趋势后，我们再来研究被支配的条目。 我们注意到以下数据趋势： 很难设计出更好的开放式列表结构并保证其正确性。RA* 成功地做到了这一点。2012 年的伪优先队列（PPQ）方法无法解决的问题数量很少（23 个）。除此之外，它的速度明显快于 RA* ，次优性也较低。A* Bucket 作品也有类似的问题，但该作品是在较晚的时候才从组织者那里征集到的，因此参赛者在提交作品之前测试作品的时间相对较少。我们希望明年的参赛作品能有明显改善。 自 2012 年以来，子目标方法不断改进，使用的 RAM 相对较少。 在整个比赛期间，JPS 参赛作品的性能提高了 10 倍以上，如果考虑到算法的非预处理版本，提高的幅度甚至更大。 在道路网络中取得成功的收缩层次法（CH），现在在游戏地图上也有非常出色的表现。 预计算方向启发法（PDH）（Parra、de Reyna 和 Linares L ́ opez，2012 年）是之前少数几个利用增量计算的参赛项目之一。今年的单行压缩（SRC）参赛作品速度更快，性能更优，但占用内存更大。 查找完整路径最快的条目仍然是 Ken Anderson 在 2013 年发布的 “树缓存 “条目；新条目主要侧重于最优路径。 虽然严格来说 BLJPS 和 NSubgoal 条目使用的 RAM 最少，但许多条目使用的 RAM 量相差无几，因此在实际使用中这种差异并不一定有意义。 出于篇幅考虑，我们在此不对这些数据作进一步细分（如按地图类型或路径长度）。有兴趣的读者可以查阅完整数据。不过，我们在此从过去的条目开始，说明每个条目被支配或不被支配的原因。 过往作品 2012 年的 JPS 条目是非主导条目，因为没有其他最优条目不使用预计算。 2012 年的 “JPS+”项目被 2014 年的 “JPS+”项目弱支配。(这两个条目都是最优的，因此它们永远不会被完全支配）。 PPQ 条目（Guivant、Seton 和 Whitty，2012 年）将是非主导条目，但它并没有解决 23 个问题。 块 A* （Block）（Yap 等人，2011 年）除存储外，都被 BLJPS 所支配。但是，从 RAM 使用情况可以看出，Block A* 在运行时会计算一个 60MB 的表，而不会将其保存，因此我们仍然认为这个条目是被支配的。 2012 年和 2013 年的子目标条目被 2014 年的 NLevelSubgoal 条目所占据。 PDH 条目不占优势，因为只有一个条目的 20 步时间更快，但它使用的存储空间更大。 树 条目是非主导条目，因为没有任何条目能比该条目更快地找到完整路径。 2014 Entries 在所有不执行预计算的条目中，RA* 条目占用的内存最少，因此不占主导地位。 除了预计算存储空间外，BLJPS2 在 BLJPS2 中占主导地位。它是使用 20MB 或更少的存储空间速度最快的最佳条目。 JPS+ 以 BLJPS2 为主，尽管其差异在下文所述的 99% 置信度范围内。 BLJPS2 不占优势，因为它是使用 47MB 或更少的存储空间速度最快的最佳条目。 RA-Subgoal 不占优势，因为它是使用 264MB 或更少的存储空间的最快条目。 除预处理时间外，JPS+ Bucket 与 NSubgoal 相比优势微弱。但是，这些差异并不一定有意义。 除预处理时间外，BLJPS Sub 在 NSubgoal 中的优势较弱。但是，这些差异并不一定有意义。 NSubgoal 不占主导地位，因为它是使用 293MB 或更少的存储空间的最快最优算法。 CH 是非主导算法，因为它是使用 2.4GB 或更少的存储空间速度最快的最优算法。 由于 SRC-dfs-i 是最快的增量算法（20 步和最大分段时间），因此不占优势。 SRC-dfs 是非主导算法，因为它是返回完整最优路径的最快算法。 如果 A* Bucket 解决所有问题的次优性或速度都优于其他所有不进行预计算的参赛作品，那么它就不占优势。(由于是比赛组织者在最后一刻征集的作品，因此没有足够的时间进行测试）。 SRC-cut 条目由 SRC-dfs 条目主导。 这些结果表明，帕累托前沿有许多算法。 表 3 显示了 2014 年每个条目的时间的 95% 置信区间。这些值基于每个参赛作品在每个问题上运行 5 次这一事实。因此，我们使用 5 个样本的 t 检验来计算置信区间。虽然样本数很少，但置信区间也很小，因为我们在五个样本中的每个样本中都运行了如此多的问题（347 868 个）。所有条目都能以 95% 的置信度区分。最接近的结果是 JPS+ 和 BLJPS2 条目；这些条目无法以 99% 的置信度区分。 2014 Competition Entries在下面的文字中，每个条目的作者都详细介绍了自己的方法。各部分根据各部分内容的重叠程度排序。 subgoal graph 子目标图该词条的作者是来自南加州大学的 Tansel Uras 和 Sven Koenig。他们提交了表 2 中的条目 NSubgoal。 本节介绍子目标图的两种变体。简单子目标图是通过在障碍物的凸角处放置子目标并将它们连接起来而构建的网格。它们类似于连续地形的可见度图，但边缘较少，可用于快速查找网格上的最短路径。简单子目标图的顶点可以划分为不同的级别，从而创建 N 级子目标图（今年的参赛作品），通过忽略与搜索无关的子目标，可以更快地找到网格上的最短路径，从而显著减少搜索图的大小。 简单子目标图 (SSG）简单子目标图（Uras、Koenig 和 Hern ́ andez，2013 年）是通过在障碍物的凸角处放置子目标，并连接可直接到达的子目标对，从而从网格中构建出来的。定义 1 正式定义了这些概念。顶点位于无障碍单元的中心。边的长度等于它所连接的顶点之间的八分距离。图 3 显示了 SSG 的一个示例。请注意，子目标 C 和 E 是 h 可达的，但不是直接 h 可达的（由于子目标 D 的存在），因此没有连接它们的边。 定义 1. 一个单元格 s 是一个子目标，当且仅当 s 是无阻塞的，s 有一个阻塞的对角线邻居 t，并且 s 和 t 的两个邻居单元格都是无阻塞的。==当且仅当两个单元格 s 和 t 之间的最短网格路径长度等于它们之间的octile距离时，这两个单元格才是 h 可到达的。当且仅当两个单元格之间的最短路径都不经过子目标时，它们才是可直接到达的。== 使用 SSG 寻找最短网格路径时，需要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后用 A* 搜索此图，找到连接 s 和 g 的可直接到达子目标序列，即最短高层路径。例如，如果我们要使用图 3 中的 SSG 寻找 B1 和 H3 之间的最短网格路径，我们会将 B1 连接到子目标 A 和 B，将 H3 连接到子目标 F，然后搜索该图，找到最短高层路径 B1-D1-D3-F5-H5-H3。沿着网格上的这条高层路径，我们可以得到最短的网格路径 B1C1-D1-D2-D3-E4-F5-G5-H5-H4-H3。 通过使用预先计算出的间隙值的动态编程算法，可以高效地确定从给定单元可直接到达的子目标。使用这种算法，可以在几毫秒内构建 SSG，并在搜索前迅速将起始顶点和目标顶点连接到 SSG。 N-Level Subgoal Graphs N 层子目标图（Uras 和 Koenig，2014 年）是通过在 SSG 的顶点之间创建层次结构来构建的。这种层次结构与本文后面描述的收缩层次结构（Geisberger 等人，2008 年；Dibbelt、Strasser 和 Wagner，2014 年 a）非常相似，只是 N 层子目标图可以将多个顶点置于层次结构的同一层次，并且只在 h 个可达到的子目标之间添加新的边。构建过程中，每个子目标的级别都是 1，然后重复将最高级别的子目标划分为全局子目标和局部子目标，并将全局子目标的级别增加一级（任何在划分之初不在最高级别的子目标在划分过程中都会被忽略）。这个过程一直持续到最高级别的子目标无法再被分割，或者图中的级别数达到用户定义的限制为止。在将最高层子目标划分为全局和局部子目标时，划分必须满足以下属性： 如果从图中移除任何一个本地子目标子集，剩余的本地子目标和全局子目标之间的最短路径长度必须保持不变。图 4 显示了由图 3 中的 SSG 构建的两级子目标图（在子目标 D 和 F 之间添加了一条边）。 要使用 N 级子目标图查找最短路径，首先要将给定的起始顶点和目标顶点 s 和 g 与各自可直接到达的子目标连接起来，然后通过递增边（从子目标到更高级子目标的边，如果 s 和 g 不是子目标，则假定它们的级别为 0）确定所有可从 s 和 g 到达的子目标，并搜索由这些子目标和所有最高级子目标（以及它们之间的边）组成的图，从而在搜索过程中忽略其他子目标。例如，如果使用图 4 中的两级子目标图来查找 B2 和 H3 之间的路径，那么搜索到的图将包括子目标 A、B、D 和 F，但不包括 C 和 E。 在构建过程中考虑顶点的顺序决定了所得到的层次结构。正如收缩层次结构所显示的，良好的节点收缩排序可以大大加快路径规划的速度，这也是收缩层次结构方法经常花费大量预处理时间来寻找良好节点收缩排序的原因。未来的工作是在子目标层次结构的背景下考虑这种效果，因为子目标层次结构的 GPPC 条目使用任意节点排序。 Jump Point Search (JPS)由于多个条目都建立在跳点搜索（JPS）（Harabor 和 Grastien，2011 年；2014 年）的基础上，我们提供了算法的基本描述，作为这些条目的介绍。 JPS 利用网格结构避免通过交替/冗余路径到达许多状态。JPS 的核心理念是对路径进行排序，使所有对角线移动优先，然后是水平/垂直移动。这就为所有路径创建了一个规范排序，确保每个目标只有一条路径。然而，仅有这一想法是不够的，因为障碍物可能会阻挡通往特定目标的自然典型路径。因此，我们引入了跳跃点。跳转点是地图中部分重置典型排序的位置，以便让搜索绕过障碍物。我们在图 5 中对此进行了说明。在图 5（a）中，我们展示了根据从 S 开始的规范排序可到达的状态。在图 5（b）中，我们添加了一个标为 J 的跳转点，在这里规范排序被重置，允许搜索向下、向右进行，从而到达目标。J 的新邻居称为强制邻居。 跳跃点取决于地图上的障碍物，可以在运行时使用，也可以事先计算。JPS 的高效不仅在于它限制了对称路径的数量，==还在于它减少了开放列表中存储的节点数量。我们不需要把节点的每个后继节点都放在开放列表中，而只需要把跳转点放在开放列表中。==下面两个条目是在 JPS 的基础上改进其性能的。 BLJPS本条目作者是查尔斯特大学的杰森-特雷什（Jason Traish）和詹姆斯-图利普（James Tulip）。他们提交了表 2 中的参赛作品 BLJPS、BLJPS2 和 BLJPS Sub。 边界查找跳点搜索（BLJPS）是跳点搜索（JPS）的扩展。BLJPS 对地图上的边界进行预处理，以加快跳跃点检测速度。边界用于识别沿水平轴或垂直轴存在的跳转点，而无需反复检查大量单元格。 正常的 JPS 行为允许在相关主方向被阻挡时进行对角移动。但在本次比赛中，此类移动是被禁止的。在提交的代码中，这些行为之间的切换由标志变量 DIAG UNBLOCKED 控制。 下面的示例使用图 6 演示 JPS 如何从 P1 移动到 P4。每个基本方向的检查都以虚线显示。搜索从 P1 开始，检查所有 8 个方向（主方向和对角线方向）的跳转点。在本例中，只有东、北和东北三个方向可以访问。JPS 沿着一个基本方向遍历开放位置，直到到达一个受阻位置，然后终止搜索，不返回跳转点。在这种情况下，东面和北面都无法返回跳转点。然后，算法沿东北方向对角扩展到位置 (B8)。然后重复迭代检查相对于东北方向（北和东）的红心方向跳转点。同样，沿任一轴线都找不到跳转点，该过程重复进行，直到对角线扩展到达边界或在任一相对主轴方向上找到跳转点。在这种情况下，NE 扩展会继续到 P2 位置，此时东心轴方向检查会在 P3 位置返回一个潜在的跳转点，该跳转点由一个强制邻接点的存在而确定。然后，P2 就会被添加到开放列表（openlist）中，方向为 NE。无论是否发现东北方向的跳转点，都会终止从 P1 开始的搜索，因为只有北、东和东北方向可以访问。 然后弹出开放列表中的顶层节点，返回 P2。然后搜索 NE 扩展的自然邻接方向（N、E、NE）。在北向和东北向的搜索中没有发现其他跳转点，但在东向有 P3 作为潜在跳转点。P3 作为实际跳转点的评估方式与 P2 类似。然而，由于 P4 的强迫相邻点，东南方向也进行了搜索。在 SE 方向上的步进确定了目标 P4 已经到达。这就确认了 P3 为跳转点，并完成了路径（P1、P2、P3、P4）。 表 4 显示了与图 6 相对应的边界查找表。表 4 中的数值记录了从西部（或北部）边界开始，单元格在阻塞和开放状态之间切换的边界。第 1 行至第 5 行没有障碍物，因此水平边界查询记录的是地图宽度（N）。但第 6 行至第 9 行在 K 处有边界，因此将其记录为第一个条目。然后，边界在 L 单元重新打开，并再次被地图宽度（N）阻挡。 当 BLJPS 的边界在给定方向上比其上下两行的重开值更远时，BLJPS 就会识别出东/西方向的跳转点。例如，东面（A5）的边界为 N，小于其下面行（第 6 行）的重开值。第 6 行的边界为 K，向东重新打开的边界为 L，小于 N，因此跳转点为（L-1=K 第 5 行，K5）或 P3。如果从（M5）开始向西移动，边界会在-A 处离开地图。5 下方的第 6 行以 K 为西部边界，并在（K-1=L）上重新打开，该边界在西部方向上没有 -A 边界那么远。 BLJPS2 优化了这种方法，将四个主要方向的跳转点分别存储在不同的列表中。这样，每次检查轴的查表次数就从三次减少到一次。 BLJPS SubGoal 是一种介于 BLJPS 和 SubGoal 之间的混合方法。它使用与 SubGoal 相同的高层图剪枝方法，但用跳跃点代替低层子目标，以利用 JPS 的方向性。不过，将目标节点附加到低层 SubGoal 图上的计算成本很高，而且与基本的 SubGoal 算法相比没有任何改进。SubGoal 是从 2013 年基于网格的路径规划竞赛的参赛作品中提取的。 Optimized JPS+本条目作者是史蒂夫-拉宾。提交的作品包括 JPS+、JPS+Bucket 和 A* Bucket。 JPS+ 为每个节点（每条边一个）预先计算 8 个值，这有助于在运行时引导搜索到预先确定的跳转点节点。通过典型排序搜索和在前往关键跳转点节点的途中跳过节点的组合，实现了显著的节点剪枝。这样做的效果是，通过检查更少的节点来加快搜索速度，从而减少开放列表中的节点数量。 优化后的 JPS+ 在编程时采用了多种最佳实践，每种实践对整体速度的贡献都很小。搜索所需的节点数据预先分配在一个二维数组中，每个节点中存储的搜索迭代计数避免了在每次搜索前重置节点数据的需要。所有成本均使用定点数学计算，启发式则使用八分启发式计算：我们计算两点之间在每个基本方向上的最大和最小距离。八分位距即为（minDiff ∗ (√2 - 1.0) + maxDiff）。此外，如果某个节点已经在开放列表中，而其成本需要更新，则会提取启发式，从而避免重新计算。最后，开放列表使用了堆优先级队列和哈希表，以加快 A* 在搜索中找到通往现有节点的更短路径时进行的 DecreaseKey 操作。 经过优化的 JPS+ 的 “桶 “版本将堆优先级队列换成了使用桶实现的优先级队列，桶以成本为索引，每个桶内包含一个堆栈。所需的桶数是最大搜索成本的 10 倍，节点的桶索引等于最终成本的 10 倍，因此每个桶内的成本差异为 0.1。一个指针记录着最便宜的非空桶，并根据需要在添加和删除时进行更新。每个水桶内都使用了搜索迭代计数，以实现每次新搜索时的懒重置。 有两项重要的优化未能在比赛中及时实施，但已证明它们都能进一步加快 JPS+ 的搜索速度。使用快速堆栈优化非常有帮助，2013 年的参赛作品 Subgoal 就实现了这一点。如果节点的成本等于父节点的成本，该优化就会将节点放在堆栈中，而不是开放列表中。==然后，在检查开放列表之前，节点会从快速堆栈中移除。需要注意的是，这种优化方法只适用于使用 octile 启发式的网格搜索空间==。此外，基于墙模式和父节点方向的函数指针查找表已经证明可以通过消除条件来加快搜索速度（2,048 个条目指向 48 个独特的函数）。最后，作为一种内存优化方法，通过对所有搜索成本进行重定向，以起始节点的原始八叉启发式成本为基准，可以减少桶的数量。 为了便于比较，A* Bucket 是一个基于 A* 的条目，它采用与 JPS+ 类似的方式，为开放式名单设置分桶。 Relaxed A*本作品由 http://www.iroboapp.org/ 网站的一个研究小组撰写。由于非科学方面的原因，该作品的作者无法参与本论文；本说明由竞赛组织者撰写。 该小组的研究人员提交了表 2 中标有 RA* 和 RA-Subgoal 的条目。他们的条目在三个方面放宽了 A* 的行为。==首先，它不允许节点的 g-cost 在首次设定后被更改。==其次，由于节点的 g-cost 只更新一次，因此在使用 A* 打开节点时，无需明确检查打开列表中的成员。所有开放节点的 g-cost 都是无限的。最后，该条目不维护父节点指针，而是假设节点的父节点是 g 成本最低的节点。 这种方法首先应用于常规 A* 搜索，然后应用于作为子目标图一部分的 A* 搜索（Uras、Koenig 和 Hern ́ andez，2013 年）。子目标代码由 2013 年 GPPC 竞赛中的 SubgoalGraph-Fast 代码构建而成。 Contraction Hierarchies (CH)本条目的作者是卡尔斯鲁厄理工学院的 Ben Strasser，在表 2 中标注为 CH。 CH 是一种在一般加权图中计算最短路径的加速技术。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以利用辅助数据，运行速度应该非常快。该技术在（Geisberger 等人，2012 年）中提出，此后成为许多研究论文的焦点。在各种独立研究中，该技术在道路图上得到了广泛的评估。然而，人们一直在质疑该技术在源自游戏网格的图上是否可行，或者该技术是否需要调整。本论文的唯一目标就是确定这一点。我们没有针对游戏地图对提交的代码进行优化。事实上，我们的代码取自（Dibbelt、Strasser 和 Wagner，2014b）的实现，并进行了大部分封装。应该可以对代码进行调整。例如，预处理代码并没有利用游戏图是无向的这一特点。这样做应该很简单，并能将预处理运行时间缩短 2 倍。 算法的核心思想很简单，但需要一些符号。用 G 表示输入图，在本次竞赛中，输入图是无向的。辅助数据包括一个有向无循环搜索图 G′，其节点集与 G 相同，且满足覆盖属性： 对于每一对源节点 s 和目标节点 t，都存在一个节点 m，这样对于 G 中的每一条最短 st 路径 P，G′ 中都存在一条 sm 路径 P ′ u 和一条 tm 路径 P ′ d，使得 P 的长度与 P ′ u 和 P ′ d 的长度之和相同。我们把 P′ u 称为向上路径，把 P ′ d 称为向下路径。我们把 P ′ u 和 P ′ d 称为上下路径。 将顶部节点视为覆盖许多最短路径的重要节点。例如，道路图中的桥梁。底部节点则非常不重要。将它们视为死胡同。你可以把上-下路径看作是 G 中最短路径的粗略化版本。粗略化意味着两个顶部节点（即桥梁）之间的所有边都不见了。该算法的思路是搜索 P′ u 和 P ′ d，即一条向上向下的路径，而不是 P。 该算法使用两个在 G′ 上运行的 Dijkstra 算法实例。第一个实例从 s 开始搜索，第二个实例从 t 开始搜索。第一个实例找到 P ′ u，第二个实例找到 P ′ d，由此可以重建 G 中的路径。我们将节点 x 可到达的 G′ 子图称为 x 的搜索空间。 要构建 G′，我们需要（加权）节点收缩的概念。这就是为 CH 命名的操作。节点收缩包括从图 H 中移除节点 x，并在两个相邻节点 y 和 z 之间插入一条边，条件是 y→x→z 路径是唯一最短的 yz 路径。检验 y→x→z 是否具有这一特性的方法是在 H{x} 上运行迪克斯特拉算法，检查 H{x} 中最短的 yz 路径是否比 y→x→z 长。这一操作称为见证搜索。我们的想法是从 H 中删除 x，同时保持 H{x} 中所有最短路径的距离。G′ 是通过沿着收缩阶 o1 … on 迭代收缩不重要节点从 G 中构造出来的。用 Gi 表示前 i - 1 个节点收缩后剩下的图，即 G1 = G，Gi 是通过在 Gi-1 中收缩 oi-1 得到的。在枚举这些 Gi 的同时，算法按如下方式构建 G′： oi 的出弧指向 Gi 中 oi 的邻弧。正如（Geisberger 等人，2012 年）所述，这种构造符合覆盖属性。 剩下的关键问题是如何确定良好的节点收缩顺序。这是目前预处理中最慢的部分。文献中存在几种方法。最初的 CH 论文（Geisberger 等人，2012 年）采用了一种自下而上的方法，在 CH 收缩过程中贪婪地确定最不重要的节点。在（Abraham 等人，2012 年）中，引入了一种自上而下的方法。这种方法的理念是，最重要的节点是位于最多非覆盖最短路径上的节点。(自下而上的方法在类似道路的图中实际效果非常好，但却像烹饪食谱一样优雅： 你将各种启发式方法混合使用，最后问题就会迎刃而解。据我们所知，没有人真正知道为什么一种配方优于其他配方。自上而下的方法更为优雅，但其基本变体速度较慢。在（Delling 等人，2014 年）一书中，介绍了一种基于快速采样的自顶向下方法。自下而上和自上而下的方法计算的阶数都取决于 G 的边权重。在（Dibbelt、Strasser 和 Wagner，2014b；Bauer 等人，2013 年）中，引入了第三种基于平衡图分离器的与权重无关的构造，并证明其查询性能非常接近与权重有关的阶次。这种与权重无关的构造与树分解理论紧密结合在一起。 GPPC 提交的论文采用了一种相对缓慢但高质量的自下而上排序方法。其核心思想是将 G′的构建与收缩排序交织在一起。该算法为 Gi 中的每个节点 x 确定一个重要性值 Ii(x)。然后设置 oi = min arg Ii(x)。在下文中，我们将去掉 Ii 中的 i 索引和，以避免不必要的符号杂乱。为了避免在每次迭代中重新计算所有 I(x)，我们使用了一个优先级队列，按照节点当前的重要性对所有节点进行排序。收缩节点只会修改相邻节点的重要性。这些值在每次迭代中都会更新，然后算法会继续收缩 I(x) 最小的节点。I(x) 的定义就像一份烹饪食谱。我们首先定义所有配料。我们用 L(x) 表示近似顶点 x 在 G′ 中的水平值。最初所有 L(x) 都是 0。如果 x 是收缩的，那么对于每一条入射边 {x, y}，我们都要执行 (y) ← max{(y), `(x) + 1}。我们进一步为每条弧 a 存储一个跳长 h(a)。这是该快捷方式完全解包后所代表的弧的数量。用 D(x) 表示如果 x 被收缩则删除的弧集，用 A(x) 表示将插入的弧集。集合 A(x) 和 D(x) 是通过模拟节点收缩计算得出的。我们设定:$$I(x) = L(x) + \\frac{|A(x)|}{|D(x)|} + \\frac {\\sum_{a \\in A(x)} h(a)}{\\sum_{a \\in D(x)} h(a)}$$该公式源自（Abraham 等人，2012 年）。请注意，原始的 CH 变体（Geisberger 等人，2012 年）包含了更多旨在减少预处理时间的启发式。例如，如果 Dijkstra 算法运行时间过长，他们的变体就会中止见证搜索，而且不会更新所有 I(x)，而是使用一种称为 lazy-pop 的技术。而我们提交的 GPPC 没有做这些工作。 为了说明 CHs 的性能，我们在星际争霸 IceFloes 地图上进行了一次实验。该地图有 91,123 个单元，将其转化为一个有 91,123 个节点和 347,624 条边（权重为 1 或 √2）的图 G。确定顺序只需不到 2 分钟的时间。搜索图 G′包含 733 114 条弧。随机均匀节点的搜索空间平均包含 680 个节点和 6,677 条弧。搜索图 G′有 48 层。这个 CH 性能非常好。只有在极少数情况下，才能在保持合理搜索空间大小的同时，使每条输入边的搜索图弧少于两条。不过，我们相信，通过利用输入实例的映射结构，仍然可以取得显著的改进。例如，将输入图编码为二维位图的内存效率要远远高于任何等效的通用图表示法。利用这一观察结果可以大大降低内存占用。 Single Row Compression (SRC)本条目作者为 Ben Strasser、Adi Botea 和 Daniel Harabor，对应表 2 中的条目 SRC-dfs、SRCdfs-i、SRC-cut、SRC-cut-i。 SRC 是一种在有界度的一般加权图中计算最短路径的加速技术。该技术在（Strasser、Harabor 和 Botea，2014 年）中提出，其理论复杂性在（Botea、Strasser 和 Harabor，2015 年）中进行了研究。该技术分为两个阶段： 预处理阶段和查询阶段。预处理阶段速度较慢，使用辅助数据对图形进行扩充。所需路径的端点是查询阶段的输入。查询阶段可以使用辅助数据，运行速度必须非常快。 使用这种设置的一个非常基本的技术是计算一个大型的首步矩阵 A。从源节点 s 到目标节点 t 的第一次移动是从 s 到 t 的最短路径的第一条边。矩阵 A 的每个条目 aij 对应于从第 i 个节点到第 j 个节点的最短路径的第一条边。按照惯例，我们认为第 i 行包含了从第 i 节点到所有其他节点的所有首条路径。同样，第 j 列包含了所有向第 j 节点的第一次移动。这种设置的查询阶段速度极快，大部分时间只需一次随机存储器访问。这种方法的缺点是矩阵需要的空间是节点数的二次方，这对于大型图来说是无法承受的。 SRC 通过利用一个非常简单的观察结果来缓解这一空间问题： 一行中的所有边都必须是单个节点的出边。如果我们假设图的度数是有界的，那么许多边必须重复。SRC 利用这一事实，使用运行长度编码 (RLE) 对每一行进行单独压缩。如果处理得当，查询的运行时间可按压缩行长度的对数计算。遗憾的是，使用 RLE 可能无法很好地压缩行。因此，SRC 首先会对节点进行排列，使相似的首移在一行中倾向于出现在相邻位置。不幸的是，正如（Botea、Strasser 和 Harabor，2015 年）中所示，计算一个能使运行次数最小化的节点顺序是 NP 难的。幸运的是，启发式方法在实践中运行良好： Strasser、Harabor 和 Botea 2014）提出了 dfs 排序和 cut 排序。dfs-order 非常简单，只需从随机根节点开始使用深度优先预排序对节点重新排序。剪切阶更为复杂，对图形进行递归分割。在大多数测试过的图形上，剪切排序的效果略好于 dfs 排序。但在某些图上，由于不明原因，剪切阶数远不如 dfs 阶数。这导致了糟糕的压缩率。这就导致了整数溢出，这也解释了为什么剪切阶提交会在一些图形上失败。为了直观了解好的阶次是怎样的，请看美国道路图。考虑东南部某个节点的行 R。如果目的地在西北部，路径很可能总是从相同的第一步开始。成功的关键在于找到一种节点顺序，为西北部的所有节点分配连续的节点 ID。这样的顺序可以确保美国西北部的所有节点都在 R 中折叠成一个单一的运行。 SRC 的优势在于能快速计算先手。其主要缺点在于预处理时间，由于必须计算 A，预处理时间与节点数呈二次方关系。请注意，快速计算首步并不会自动转化为快速计算完整路径的最快算法。原因在于所有每次计算一条边的技术。这甚至包括基本的二次矩阵方法。这种算法需要对每条边进行一次随机内存访问。而将大部分路径预装在内存中的算法，只需对每个部分进行一次随机内存访问。由于缓存效应，速度会明显加快。(在当前的硬件上，顺序内存访问比随机内存访问快约 70 倍）。然而，在许多重要的应用场景中，对缓存更友好的路径计算最终并不会带来任何好处。考虑一个需要导航到某个位置的游戏单元。有两种不同的设置：(1) 在开始旅程时，单元会计算整个路径并将其存储在某处。每当单元到达一条边的终点时，它就会查找下一条边，即需要随机存取内存。(2) 每次单元到达一条边的终点时，它只计算下一条边。在实验室条件下，设置（1）可能比设置（2）更好，因为测得的运行时间通常只包括计算路径所需的时间。单元查找单条边所花费的时间往往被忽略。此外，(1) 方法需要在内存中存储长度可变的路径。这就增加了内存管理所需的时间，更重要的是，每个单元的内存消耗是不恒定的。考虑一种极端情况，即有ω(n) 个单元，其存储的路径有 Θ(n) 条边（n 为节点数）。这将导致 ω(n2) 的内存消耗。即使是采用二次矩阵方法的设置 2，在这种情况下也只需要 Θ(n2) 内存。 表 2 包含我们算法的 4 个变体。cut/dfs 部分指的是所使用的节点顺序。-i “表示是在一次函数调用中提取完整路径，还是逐边提取路径。理论上，这应该没有什么区别。但在实际操作中，它会影响时序代码的调用频率。如果路径是在一次函数调用中提取的，那么定时代码只会在每次路径查询前后运行。然而，如果路径是逐边提取的，则定时代码会在每条边上运行一次。这种略有不同的实验设置导致 “dfs-i “和 “dfs “的路径提取平均运行时间相差 0.044ms。 Looking Ahead and ConclusionsGPPC 涵盖各种基于网格的寻路问题。目前已开发出几种主要的竞争方法，它们利用网格结构的优势，显著提高了基本 A* 实现的性能。因此，该竞赛成功地记录了网格寻路的显著改进，并为实验和测试提供了高质量的寻路实现。 从作品的应用来看，比赛涵盖了游戏行业感兴趣的问题的一个子集，但并没有解决一些现实世界的问题，而这些问题有时是在使用网格时必须解决的。特别是，网格通常用于动态环境中，在这种环境中，世界和/或在世界中移动的成本会定期发生变化（Sturtevant，2013 年）。这是因为当世界发生变化时，网格表示法易于更新且成本低廉。 目前的竞赛不允许在地图或动态地图中使用动态权重，而旨在促进此类比较的新赛道没有收到任何参赛作品。从某种意义上说，这并不完全令人惊讶，因为网格方法的研究已经有很多年了，所以有大量的作品可以参赛。此外，测试动态地图的方法有很多种，对于类似机器人的环境和游戏环境，可能需要进行不同的测试。 但是，经过几年的竞赛，我们可以看到用于提高性能的主要核心思想，以及一系列内存和预计算要求。随着这些方法的不断改进，我们期待看到更多技术填补这些参赛项目之间的空白。特别是，实时和次优条目还有很大的创新空间。 展望未来，重要的是要解决如何挑战研究界的难题，使其超越统一成本网格寻路问题，进而解决更能代表实践者所面临的真实世界问题。例如，本文第一作者正在与游戏行业合作，以获得更多地图和地图类型，从而为研究人员提供有意义的研究数据。我们将认真考虑如何利用竞赛来鼓励对不同问题类型的研究，这些问题类型在更广泛的领域中有着更广泛的应用。","link":"/2024/03/01/The-Grid-Based-Path-Planning-Competition-2014-Entries-and-Results/"}],"tags":[{"name":"路径规划","slug":"路径规划","link":"/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"},{"name":"多智能体","slug":"多智能体","link":"/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"},{"name":"蚁群算法","slug":"蚁群算法","link":"/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"},{"name":"MAPF","slug":"MAPF","link":"/tags/MAPF/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"原创","slug":"原创","link":"/tags/%E5%8E%9F%E5%88%9B/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"CLion安装","slug":"CLion安装","link":"/tags/CLion%E5%AE%89%E8%A3%85/"},{"name":"GDAL","slug":"GDAL","link":"/tags/GDAL/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pandas","slug":"pandas","link":"/tags/pandas/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"XTDrone","slug":"XTDrone","link":"/tags/XTDrone/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论知识","slug":"图论知识","link":"/tags/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"原文翻译","slug":"原文翻译","link":"/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"环境配置","slug":"环境配置","link":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"C++学习","slug":"C-学习","link":"/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"启发式","slug":"启发式","link":"/tags/%E5%90%AF%E5%8F%91%E5%BC%8F/"},{"name":"综述","slug":"综述","link":"/tags/%E7%BB%BC%E8%BF%B0/"},{"name":"Q1","slug":"Q1","link":"/tags/Q1/"},{"name":"分层方法","slug":"分层方法","link":"/tags/%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95/"},{"name":"Hierachical","slug":"Hierachical","link":"/tags/Hierachical/"},{"name":"分层","slug":"分层","link":"/tags/%E5%88%86%E5%B1%82/"},{"name":"维诺图","slug":"维诺图","link":"/tags/%E7%BB%B4%E8%AF%BA%E5%9B%BE/"},{"name":"可视图","slug":"可视图","link":"/tags/%E5%8F%AF%E8%A7%86%E5%9B%BE/"}],"categories":[{"name":"MATLAB","slug":"MATLAB","link":"/categories/MATLAB/"},{"name":"路径规划","slug":"路径规划","link":"/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"原创","slug":"原创","link":"/categories/%E5%8E%9F%E5%88%9B/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"路径规划算法","slug":"路径规划算法","link":"/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"},{"name":"C++学习","slug":"C-学习","link":"/categories/C-%E5%AD%A6%E4%B9%A0/"},{"name":"excel操作","slug":"excel操作","link":"/categories/excel%E6%93%8D%E4%BD%9C/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"论文","slug":"论文","link":"/categories/%E8%AE%BA%E6%96%87/"},{"name":"路径规划启发式","slug":"路径规划启发式","link":"/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%90%AF%E5%8F%91%E5%BC%8F/"}],"pages":[]}